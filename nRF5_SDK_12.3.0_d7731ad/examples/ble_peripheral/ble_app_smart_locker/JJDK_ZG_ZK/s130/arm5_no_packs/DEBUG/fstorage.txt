; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\fstorage.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\fstorage.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\fstorage.crf ..\..\..\..\..\..\components\libraries\fstorage\fstorage.c]
                          THUMB

                          AREA ||i.check_config||, CODE, READONLY, ALIGN=2

                  check_config PROC
;;;86     // Checks that a configuration is non-NULL and within section variable bounds.
;;;87     static bool check_config(fs_config_t const * const config)
000000  4601              MOV      r1,r0
;;;88     {
;;;89     #ifndef DFU_SUPPORT_SIGNING
;;;90         if ((config != NULL) &&
000002  2900              CMP      r1,#0
000004  d007              BEQ      |L1.22|
;;;91             (FS_SECTION_VARS_START_ADDR <= (uint32_t)config) &&
000006  4805              LDR      r0,|L1.28|
000008  4288              CMP      r0,r1
00000a  d804              BHI      |L1.22|
;;;92             (FS_SECTION_VARS_END_ADDR   >  (uint32_t)config))
00000c  4804              LDR      r0,|L1.32|
00000e  4288              CMP      r0,r1
000010  d901              BLS      |L1.22|
;;;93         {
;;;94             return true;
000012  2001              MOVS     r0,#1
                  |L1.20|
;;;95         }
;;;96     
;;;97         return false;
;;;98     #else
;;;99         return true;
;;;100    #endif
;;;101    }
000014  4770              BX       lr
                  |L1.22|
000016  2000              MOVS     r0,#0                 ;97
000018  e7fc              B        |L1.20|
;;;102    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      ||fs_data$$Base||
                  |L1.32|
                          DCD      ||fs_data$$Limit||

                          AREA ||i.erase_execute||, CODE, READONLY, ALIGN=1

                  erase_execute PROC
;;;124    // Executes an erase operation.
;;;125    static uint32_t erase_execute(fs_op_t const * const p_op)
000000  b510              PUSH     {r4,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127        return sd_flash_page_erase(p_op->erase.page);
000004  89a0              LDRH     r0,[r4,#0xc]
000006  df28              SVC      #0x28
;;;128    }
000008  bd10              POP      {r4,pc}
;;;129    
                          ENDP


                          AREA ||i.fs_erase||, CODE, READONLY, ALIGN=2

                  fs_erase PROC
;;;444    
;;;445    fs_ret_t fs_erase(fs_config_t const * const p_config,
000000  b5f8              PUSH     {r3-r7,lr}
;;;446                      uint32_t    const * const p_page_addr,
;;;447                      uint16_t    const         num_pages,
;;;448                      void *                    p_context)
;;;449    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;450        fs_op_t * p_op;
;;;451    
;;;452        if (!(m_flags & FS_FLAG_INITIALIZED))
00000a  481f              LDR      r0,|L3.136|
00000c  7800              LDRB     r0,[r0,#0]  ; m_flags
00000e  07c0              LSLS     r0,r0,#31
000010  0fc0              LSRS     r0,r0,#31
000012  2800              CMP      r0,#0
000014  d101              BNE      |L3.26|
;;;453        {
;;;454            return FS_ERR_NOT_INITIALIZED;
000016  2001              MOVS     r0,#1
                  |L3.24|
;;;455        }
;;;456    
;;;457        if (!check_config(p_config))
;;;458        {
;;;459            return FS_ERR_INVALID_CFG;
;;;460        }
;;;461    
;;;462        if (p_page_addr == NULL)
;;;463        {
;;;464            return FS_ERR_NULL_ARG;
;;;465        }
;;;466    
;;;467        // Check that the page is aligned to a page boundary.
;;;468        if (((uint32_t)p_page_addr & (FS_PAGE_SIZE-1)) != 0)
;;;469        {
;;;470            return FS_ERR_UNALIGNED_ADDR;
;;;471        }
;;;472    
;;;473        // Check that the operation doesn't go outside the client's memory boundaries.
;;;474        if ((p_page_addr < p_config->p_start_addr) ||
;;;475            (p_page_addr + (FS_PAGE_SIZE_WORDS * num_pages) > p_config->p_end_addr))
;;;476        {
;;;477            return FS_ERR_INVALID_ADDR;
;;;478        }
;;;479    
;;;480        if (num_pages == 0)
;;;481        {
;;;482            return FS_ERR_INVALID_ARG;
;;;483        }
;;;484    
;;;485        if (!queue_get_next_free(&p_op))
;;;486        {
;;;487            return FS_ERR_QUEUE_FULL;
;;;488        }
;;;489    
;;;490        // Initialize the operation.
;;;491        p_op->p_context            = p_context;
;;;492        p_op->p_config             = p_config;
;;;493        p_op->op_code              = FS_OP_ERASE;
;;;494        p_op->erase.page           = ((uint32_t)p_page_addr / FS_PAGE_SIZE);
;;;495        p_op->erase.pages_to_erase = num_pages;
;;;496    
;;;497        queue_start();
;;;498    
;;;499        return FS_SUCCESS;
;;;500    }
000018  bdf8              POP      {r3-r7,pc}
                  |L3.26|
00001a  4628              MOV      r0,r5                 ;457
00001c  f7fffffe          BL       check_config
000020  2800              CMP      r0,#0                 ;457
000022  d101              BNE      |L3.40|
000024  2002              MOVS     r0,#2                 ;459
000026  e7f7              B        |L3.24|
                  |L3.40|
000028  2c00              CMP      r4,#0                 ;462
00002a  d101              BNE      |L3.48|
00002c  2003              MOVS     r0,#3                 ;464
00002e  e7f3              B        |L3.24|
                  |L3.48|
000030  05a0              LSLS     r0,r4,#22             ;468
000032  0d80              LSRS     r0,r0,#22             ;468
000034  2800              CMP      r0,#0                 ;468
000036  d001              BEQ      |L3.60|
000038  2006              MOVS     r0,#6                 ;470
00003a  e7ed              B        |L3.24|
                  |L3.60|
00003c  6828              LDR      r0,[r5,#0]            ;474
00003e  42a0              CMP      r0,r4                 ;474
000040  d804              BHI      |L3.76|
000042  02b0              LSLS     r0,r6,#10             ;475
000044  1900              ADDS     r0,r0,r4              ;475
000046  6869              LDR      r1,[r5,#4]            ;475
000048  4288              CMP      r0,r1                 ;475
00004a  d901              BLS      |L3.80|
                  |L3.76|
00004c  2005              MOVS     r0,#5                 ;477
00004e  e7e3              B        |L3.24|
                  |L3.80|
000050  2e00              CMP      r6,#0                 ;480
000052  d101              BNE      |L3.88|
000054  2004              MOVS     r0,#4                 ;482
000056  e7df              B        |L3.24|
                  |L3.88|
000058  4668              MOV      r0,sp                 ;485
00005a  f7fffffe          BL       queue_get_next_free
00005e  2800              CMP      r0,#0                 ;485
000060  d101              BNE      |L3.102|
000062  2007              MOVS     r0,#7                 ;487
000064  e7d8              B        |L3.24|
                  |L3.102|
000066  9800              LDR      r0,[sp,#0]            ;491
000068  6047              STR      r7,[r0,#4]            ;491
00006a  9800              LDR      r0,[sp,#0]            ;492
00006c  6005              STR      r5,[r0,#0]            ;492
00006e  2002              MOVS     r0,#2                 ;493
000070  9900              LDR      r1,[sp,#0]            ;493
000072  7208              STRB     r0,[r1,#8]            ;493
000074  01a0              LSLS     r0,r4,#6              ;494
000076  0c00              LSRS     r0,r0,#16             ;494
000078  9900              LDR      r1,[sp,#0]            ;494
00007a  8188              STRH     r0,[r1,#0xc]          ;494
00007c  9800              LDR      r0,[sp,#0]            ;495
00007e  8206              STRH     r6,[r0,#0x10]         ;495
000080  f7fffffe          BL       queue_start
000084  2000              MOVS     r0,#0                 ;499
000086  e7c7              B        |L3.24|
;;;501    
                          ENDP

                  |L3.136|
                          DCD      m_flags

                          AREA ||i.fs_fake_init||, CODE, READONLY, ALIGN=2

                  fs_fake_init PROC
;;;376    
;;;377    fs_ret_t fs_fake_init(void)
000000  4803              LDR      r0,|L4.16|
;;;378    {
;;;379        m_flags |= FS_FLAG_INITIALIZED;
000002  7800              LDRB     r0,[r0,#0]  ; m_flags
000004  2101              MOVS     r1,#1
000006  4308              ORRS     r0,r0,r1
000008  4901              LDR      r1,|L4.16|
00000a  7008              STRB     r0,[r1,#0]
;;;380        return FS_SUCCESS;
00000c  2000              MOVS     r0,#0
;;;381    }
00000e  4770              BX       lr
;;;382    
                          ENDP

                  |L4.16|
                          DCD      m_flags

                          AREA ||i.fs_flash_page_end_addr||, CODE, READONLY, ALIGN=2

                  fs_flash_page_end_addr PROC
;;;145    // Function to obtain the end of the flash space available to fstorage.
;;;146    static uint32_t const * fs_flash_page_end_addr()
000000  4805              LDR      r0,|L5.24|
;;;147    {
;;;148        uint32_t const bootloader_addr = NRF_UICR->NRFFW[0];
000002  6941              LDR      r1,[r0,#0x14]
;;;149    
;;;150        return  (uint32_t*)((bootloader_addr != FS_ERASED_WORD) ? bootloader_addr :
000004  1c48              ADDS     r0,r1,#1
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L5.14|
00000a  4608              MOV      r0,r1
                  |L5.12|
;;;151                                                                  NRF_FICR->CODESIZE * FS_PAGE_SIZE);
;;;152    }
00000c  4770              BX       lr
                  |L5.14|
00000e  2001              MOVS     r0,#1                 ;151
000010  0700              LSLS     r0,r0,#28             ;151
000012  6940              LDR      r0,[r0,#0x14]         ;151
000014  0280              LSLS     r0,r0,#10             ;151
000016  e7f9              B        |L5.12|
;;;153    
                          ENDP

                  |L5.24|
                          DCD      0x10001000

                          AREA ||i.fs_init||, CODE, READONLY, ALIGN=2

                  fs_init PROC
;;;293    
;;;294    fs_ret_t fs_init(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;295    {
;;;296        uint32_t const   total_users     = FS_SECTION_VARS_COUNT;
000002  482d              LDR      r0,|L6.184|
000004  492d              LDR      r1,|L6.188|
000006  1a40              SUBS     r0,r0,r1
000008  0904              LSRS     r4,r0,#4
;;;297        uint32_t         configs_to_init = FS_SECTION_VARS_COUNT;
00000a  482b              LDR      r0,|L6.184|
00000c  1a40              SUBS     r0,r0,r1
00000e  0905              LSRS     r5,r0,#4
;;;298        uint32_t const * p_current_end   = FS_PAGE_END_ADDR;
000010  f7fffffe          BL       fs_flash_page_end_addr
000014  9002              STR      r0,[sp,#8]
;;;299    
;;;300        if (m_flags & FS_FLAG_INITIALIZED)
000016  482a              LDR      r0,|L6.192|
000018  7800              LDRB     r0,[r0,#0]  ; m_flags
00001a  07c0              LSLS     r0,r0,#31
00001c  0fc0              LSRS     r0,r0,#31
00001e  2800              CMP      r0,#0
000020  d001              BEQ      |L6.38|
;;;301        {
;;;302            return FS_SUCCESS;
000022  2000              MOVS     r0,#0
                  |L6.36|
;;;303        }
;;;304    
;;;305        // Each fstorage user has registered one configuration.
;;;306        // The total number of users (and thus the total number of configurations) is
;;;307        // kept in total_users. Some of these users might have specified their flash
;;;308        // boundaries in their configurations. This function sets the flash boundaries
;;;309        // for the remaining user configurations without further user interaction.
;;;310    
;;;311        // First, determine how many user configurations this function has to initialize,
;;;312        // out of the total. This number will be kept in configs_to_init.
;;;313    
;;;314        for (uint32_t i = 0; i < total_users; i++)
;;;315        {
;;;316            fs_config_t const * const p_config = FS_SECTION_VARS_GET(i);
;;;317    
;;;318            if ((p_config->p_start_addr != NULL) &&
;;;319                (p_config->p_end_addr   != NULL))
;;;320            {
;;;321                configs_to_init--;
;;;322            }
;;;323        }
;;;324    
;;;325        // For each configuration to initialize, assign flash space based on the priority
;;;326        // specified. Higher priority means a higher memory address.
;;;327    
;;;328        for (uint32_t i = 0; i < configs_to_init; i++)
;;;329        {
;;;330            fs_config_t * p_config_i   = FS_SECTION_VARS_GET(i);
;;;331            uint8_t       max_priority = 0;
;;;332            uint8_t       max_index    = i;
;;;333    
;;;334            for (uint32_t j = 0; j < total_users; j++)
;;;335            {
;;;336                fs_config_t const * const p_config_j = FS_SECTION_VARS_GET(j);
;;;337    
;;;338                #if 0
;;;339                if (p_config_j->priority == p_config_i->priority)
;;;340                {
;;;341                    // Duplicated priorities are not allowed.
;;;342                    return FS_ERR_INVALID_CFG;
;;;343                }
;;;344                #endif
;;;345    
;;;346                if ((p_config_j->p_start_addr != NULL) &&
;;;347                    (p_config_j->p_end_addr   != NULL))
;;;348                {
;;;349                    // When calculating the configuration with the next highest priority
;;;350                    // skip configurations which were already set during a previous iteration.
;;;351                    // This check needs to be here to prevent re-using the configurations
;;;352                    // with higher priorities which we used in previous iterations.
;;;353                    continue;
;;;354                }
;;;355    
;;;356                if (p_config_j->priority > max_priority)
;;;357                {
;;;358                    max_priority = p_config_j->priority;
;;;359                    max_index    = j;
;;;360                }
;;;361            }
;;;362    
;;;363            p_config_i = FS_SECTION_VARS_GET(max_index);
;;;364    
;;;365            p_config_i->p_end_addr   = p_current_end;
;;;366            p_config_i->p_start_addr = p_current_end - (p_config_i->num_pages * FS_PAGE_SIZE_WORDS);
;;;367    
;;;368            p_current_end = p_config_i->p_start_addr;
;;;369        }
;;;370    
;;;371        m_flags |= FS_FLAG_INITIALIZED;
;;;372    
;;;373        return FS_SUCCESS;
;;;374    }
000024  bdfe              POP      {r1-r7,pc}
                  |L6.38|
000026  2000              MOVS     r0,#0                 ;314
000028  e00a              B        |L6.64|
                  |L6.42|
00002a  0102              LSLS     r2,r0,#4              ;316
00002c  4b23              LDR      r3,|L6.188|
00002e  18d1              ADDS     r1,r2,r3              ;316
000030  680a              LDR      r2,[r1,#0]            ;318
000032  2a00              CMP      r2,#0                 ;318
000034  d003              BEQ      |L6.62|
000036  684a              LDR      r2,[r1,#4]            ;319
000038  2a00              CMP      r2,#0                 ;319
00003a  d000              BEQ      |L6.62|
00003c  1e6d              SUBS     r5,r5,#1              ;321
                  |L6.62|
00003e  1c40              ADDS     r0,r0,#1              ;314
                  |L6.64|
000040  42a0              CMP      r0,r4                 ;314
000042  d3f2              BCC      |L6.42|
000044  2000              MOVS     r0,#0                 ;328
000046  e02c              B        |L6.162|
                  |L6.72|
000048  0102              LSLS     r2,r0,#4              ;330
00004a  4b1c              LDR      r3,|L6.188|
00004c  18d1              ADDS     r1,r2,r3              ;330
00004e  2200              MOVS     r2,#0                 ;331
000050  9201              STR      r2,[sp,#4]            ;331
000052  b2c2              UXTB     r2,r0                 ;332
000054  9200              STR      r2,[sp,#0]            ;332
000056  2200              MOVS     r2,#0                 ;334
000058  e013              B        |L6.130|
                  |L6.90|
00005a  0116              LSLS     r6,r2,#4              ;336
00005c  4f17              LDR      r7,|L6.188|
00005e  19f3              ADDS     r3,r6,r7              ;336
000060  681e              LDR      r6,[r3,#0]            ;346
000062  2e00              CMP      r6,#0                 ;346
000064  d003              BEQ      |L6.110|
000066  685e              LDR      r6,[r3,#4]            ;347
000068  2e00              CMP      r6,#0                 ;347
00006a  d000              BEQ      |L6.110|
00006c  e008              B        |L6.128|
                  |L6.110|
00006e  7b5f              LDRB     r7,[r3,#0xd]          ;356
000070  9e01              LDR      r6,[sp,#4]            ;356
000072  42b7              CMP      r7,r6                 ;356
000074  dd03              BLE      |L6.126|
000076  7b5e              LDRB     r6,[r3,#0xd]          ;358
000078  9601              STR      r6,[sp,#4]            ;358
00007a  b2d6              UXTB     r6,r2                 ;359
00007c  9600              STR      r6,[sp,#0]            ;359
                  |L6.126|
00007e  bf00              NOP                            ;353
                  |L6.128|
000080  1c52              ADDS     r2,r2,#1              ;334
                  |L6.130|
000082  42a2              CMP      r2,r4                 ;334
000084  d3e9              BCC      |L6.90|
000086  9a00              LDR      r2,[sp,#0]            ;363
000088  0112              LSLS     r2,r2,#4              ;363
00008a  4b0c              LDR      r3,|L6.188|
00008c  18d1              ADDS     r1,r2,r3              ;363
00008e  9a02              LDR      r2,[sp,#8]            ;365
000090  604a              STR      r2,[r1,#4]            ;365
000092  7b0a              LDRB     r2,[r1,#0xc]          ;366
000094  0293              LSLS     r3,r2,#10             ;366
000096  9a02              LDR      r2,[sp,#8]            ;366
000098  1ad2              SUBS     r2,r2,r3              ;366
00009a  600a              STR      r2,[r1,#0]            ;366
00009c  680a              LDR      r2,[r1,#0]            ;368
00009e  9202              STR      r2,[sp,#8]            ;368
0000a0  1c40              ADDS     r0,r0,#1              ;328
                  |L6.162|
0000a2  42a8              CMP      r0,r5                 ;328
0000a4  d3d0              BCC      |L6.72|
0000a6  4806              LDR      r0,|L6.192|
0000a8  7800              LDRB     r0,[r0,#0]            ;371  ; m_flags
0000aa  2101              MOVS     r1,#1                 ;371
0000ac  4308              ORRS     r0,r0,r1              ;371
0000ae  4904              LDR      r1,|L6.192|
0000b0  7008              STRB     r0,[r1,#0]            ;371
0000b2  2000              MOVS     r0,#0                 ;373
0000b4  e7b6              B        |L6.36|
;;;375    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L6.184|
                          DCD      ||fs_data$$Limit||
                  |L6.188|
                          DCD      ||fs_data$$Base||
                  |L6.192|
                          DCD      m_flags

                          AREA ||i.fs_queue_is_empty||, CODE, READONLY, ALIGN=2

                  fs_queue_is_empty PROC
;;;555    
;;;556    bool fs_queue_is_empty(void)
000000  4803              LDR      r0,|L7.16|
;;;557    {
;;;558        return (m_queue.count == 0);
000002  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000004  2800              CMP      r0,#0
000006  d101              BNE      |L7.12|
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;559    }
00000a  4770              BX       lr
                  |L7.12|
00000c  2000              MOVS     r0,#0                 ;558
00000e  e7fc              B        |L7.10|
;;;560    
                          ENDP

                  |L7.16|
                          DCD      m_queue

                          AREA ||i.fs_queue_is_full||, CODE, READONLY, ALIGN=2

                  fs_queue_is_full PROC
;;;550    
;;;551    bool fs_queue_is_full(void)
000000  4803              LDR      r0,|L8.16|
;;;552    {
;;;553        return (m_queue.count == FS_QUEUE_SIZE);
000002  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000004  2804              CMP      r0,#4
000006  d101              BNE      |L8.12|
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;554    }
00000a  4770              BX       lr
                  |L8.12|
00000c  2000              MOVS     r0,#0                 ;553
00000e  e7fc              B        |L8.10|
;;;555    
                          ENDP

                  |L8.16|
                          DCD      m_queue

                          AREA ||i.fs_queued_op_count_get||, CODE, READONLY, ALIGN=2

                  fs_queued_op_count_get PROC
;;;502    
;;;503    fs_ret_t fs_queued_op_count_get(uint32_t * const p_op_count)
000000  4601              MOV      r1,r0
;;;504    {
;;;505        if (p_op_count == NULL)
000002  2900              CMP      r1,#0
000004  d101              BNE      |L9.10|
;;;506        {
;;;507            return FS_ERR_NULL_ARG;
000006  2003              MOVS     r0,#3
                  |L9.8|
;;;508        }
;;;509    
;;;510        *p_op_count = m_queue.count;
;;;511    
;;;512        return FS_SUCCESS;
;;;513    }
000008  4770              BX       lr
                  |L9.10|
00000a  4802              LDR      r0,|L9.20|
00000c  6e40              LDR      r0,[r0,#0x64]         ;510  ; m_queue
00000e  6008              STR      r0,[r1,#0]            ;510
000010  2000              MOVS     r0,#0                 ;512
000012  e7f9              B        |L9.8|
;;;514    
                          ENDP

                  |L9.20|
                          DCD      m_queue

                          AREA ||i.fs_store||, CODE, READONLY, ALIGN=2

                  fs_store PROC
;;;383    
;;;384    fs_ret_t fs_store(fs_config_t const * const p_config,
000000  b5f8              PUSH     {r3-r7,lr}
;;;385                      uint32_t    const * const p_dest,
;;;386                      uint32_t    const * const p_src,
;;;387                      uint16_t    const         length_words,
;;;388                      void *                    p_context)
;;;389    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;390        fs_op_t * p_op;
;;;391    
;;;392        if (!(m_flags & FS_FLAG_INITIALIZED))
00000a  4823              LDR      r0,|L10.152|
00000c  7800              LDRB     r0,[r0,#0]  ; m_flags
00000e  07c0              LSLS     r0,r0,#31
000010  0fc0              LSRS     r0,r0,#31
000012  2800              CMP      r0,#0
000014  d101              BNE      |L10.26|
;;;393        {
;;;394            return FS_ERR_NOT_INITIALIZED;
000016  2001              MOVS     r0,#1
                  |L10.24|
;;;395        }
;;;396    
;;;397        if (!check_config(p_config))
;;;398        {
;;;399            return FS_ERR_INVALID_CFG;
;;;400        }
;;;401    
;;;402        if ((p_src == NULL) || (p_dest == NULL))
;;;403        {
;;;404            return FS_ERR_NULL_ARG;
;;;405        }
;;;406    
;;;407        // Check that both pointers are word aligned.
;;;408        if (((uint32_t)p_src  & 0x03) ||
;;;409            ((uint32_t)p_dest & 0x03))
;;;410        {
;;;411            return FS_ERR_UNALIGNED_ADDR;
;;;412        }
;;;413    
;;;414        // Check that the operation doesn't go outside the client's memory boundaries.
;;;415        if ((p_config->p_start_addr > p_dest) ||
;;;416            (p_config->p_end_addr   < (p_dest + length_words)))
;;;417        {
;;;418            return FS_ERR_INVALID_ADDR;
;;;419        }
;;;420    
;;;421        if (length_words == 0)
;;;422        {
;;;423            return FS_ERR_INVALID_ARG;
;;;424        }
;;;425    
;;;426        if (!queue_get_next_free(&p_op))
;;;427        {
;;;428            return FS_ERR_QUEUE_FULL;
;;;429        }
;;;430    
;;;431        // Initialize the operation.
;;;432        p_op->p_context          = p_context;
;;;433        p_op->p_config           = p_config;
;;;434        p_op->op_code            = FS_OP_STORE;
;;;435        p_op->store.p_src        = p_src;
;;;436        p_op->store.p_dest       = p_dest;
;;;437        p_op->store.length_words = length_words;
;;;438    
;;;439        queue_start();
;;;440    
;;;441        return FS_SUCCESS;
;;;442    }
000018  bdf8              POP      {r3-r7,pc}
                  |L10.26|
00001a  4628              MOV      r0,r5                 ;397
00001c  f7fffffe          BL       check_config
000020  2800              CMP      r0,#0                 ;397
000022  d101              BNE      |L10.40|
000024  2002              MOVS     r0,#2                 ;399
000026  e7f7              B        |L10.24|
                  |L10.40|
000028  2e00              CMP      r6,#0                 ;402
00002a  d001              BEQ      |L10.48|
00002c  2c00              CMP      r4,#0                 ;402
00002e  d101              BNE      |L10.52|
                  |L10.48|
000030  2003              MOVS     r0,#3                 ;404
000032  e7f1              B        |L10.24|
                  |L10.52|
000034  07b0              LSLS     r0,r6,#30             ;408
000036  0f80              LSRS     r0,r0,#30             ;408
000038  2800              CMP      r0,#0                 ;408
00003a  d103              BNE      |L10.68|
00003c  07a0              LSLS     r0,r4,#30             ;409
00003e  0f80              LSRS     r0,r0,#30             ;409
000040  2800              CMP      r0,#0                 ;409
000042  d001              BEQ      |L10.72|
                  |L10.68|
000044  2006              MOVS     r0,#6                 ;411
000046  e7e7              B        |L10.24|
                  |L10.72|
000048  6828              LDR      r0,[r5,#0]            ;415
00004a  42a0              CMP      r0,r4                 ;415
00004c  d804              BHI      |L10.88|
00004e  00b9              LSLS     r1,r7,#2              ;416
000050  1909              ADDS     r1,r1,r4              ;416
000052  6868              LDR      r0,[r5,#4]            ;416
000054  4288              CMP      r0,r1                 ;416
000056  d201              BCS      |L10.92|
                  |L10.88|
000058  2005              MOVS     r0,#5                 ;418
00005a  e7dd              B        |L10.24|
                  |L10.92|
00005c  2f00              CMP      r7,#0                 ;421
00005e  d101              BNE      |L10.100|
000060  2004              MOVS     r0,#4                 ;423
000062  e7d9              B        |L10.24|
                  |L10.100|
000064  4668              MOV      r0,sp                 ;426
000066  f7fffffe          BL       queue_get_next_free
00006a  2800              CMP      r0,#0                 ;426
00006c  d101              BNE      |L10.114|
00006e  2007              MOVS     r0,#7                 ;428
000070  e7d2              B        |L10.24|
                  |L10.114|
000072  9900              LDR      r1,[sp,#0]            ;432
000074  9806              LDR      r0,[sp,#0x18]         ;432
000076  6048              STR      r0,[r1,#4]            ;432
000078  9800              LDR      r0,[sp,#0]            ;433
00007a  6005              STR      r5,[r0,#0]            ;433
00007c  2001              MOVS     r0,#1                 ;434
00007e  9900              LDR      r1,[sp,#0]            ;434
000080  7208              STRB     r0,[r1,#8]            ;434
000082  9800              LDR      r0,[sp,#0]            ;435
000084  60c6              STR      r6,[r0,#0xc]          ;435
000086  9800              LDR      r0,[sp,#0]            ;436
000088  6104              STR      r4,[r0,#0x10]         ;436
00008a  9800              LDR      r0,[sp,#0]            ;437
00008c  8287              STRH     r7,[r0,#0x14]         ;437
00008e  f7fffffe          BL       queue_start
000092  2000              MOVS     r0,#0                 ;441
000094  e7c0              B        |L10.24|
;;;443    
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
                          DCD      m_flags

                          AREA ||i.fs_sys_event_handler||, CODE, READONLY, ALIGN=2

                  fs_sys_event_handler PROC
;;;515    
;;;516    void fs_sys_event_handler(uint32_t sys_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;517    {
000002  4604              MOV      r4,r0
;;;518        fs_op_t * const p_op = &m_queue.op[m_queue.rp];
000004  4818              LDR      r0,|L11.104|
000006  6e00              LDR      r0,[r0,#0x60]  ; m_queue
000008  2118              MOVS     r1,#0x18
00000a  4348              MULS     r0,r1,r0
00000c  4916              LDR      r1,|L11.104|
00000e  1845              ADDS     r5,r0,r1
;;;519    
;;;520        if (m_flags & FS_FLAG_PROCESSING)
000010  4816              LDR      r0,|L11.108|
000012  7800              LDRB     r0,[r0,#0]  ; m_flags
000014  2102              MOVS     r1,#2
000016  4008              ANDS     r0,r0,r1
000018  2800              CMP      r0,#0
00001a  d00d              BEQ      |L11.56|
;;;521        {
;;;522            // A flash operation was initiated by this module. Handle the result.
;;;523            switch (sys_evt)
00001c  2c02              CMP      r4,#2
00001e  d002              BEQ      |L11.38|
000020  2c03              CMP      r4,#3
000022  d108              BNE      |L11.54|
000024  e003              B        |L11.46|
                  |L11.38|
;;;524            {
;;;525                case NRF_EVT_FLASH_OPERATION_SUCCESS:
;;;526                    on_operation_success(p_op);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       on_operation_success
;;;527                    break;
00002c  e003              B        |L11.54|
                  |L11.46|
;;;528    
;;;529                case NRF_EVT_FLASH_OPERATION_ERROR:
;;;530                    on_operation_failure(p_op);
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       on_operation_failure
;;;531                    break;
000034  bf00              NOP      
                  |L11.54|
000036  e014              B        |L11.98|
                  |L11.56|
;;;532            }
;;;533        }
;;;534        else if ((m_flags & FS_FLAG_FLASH_REQ_PENDING))
000038  480c              LDR      r0,|L11.108|
00003a  7800              LDRB     r0,[r0,#0]  ; m_flags
00003c  2104              MOVS     r1,#4
00003e  4008              ANDS     r0,r0,r1
000040  2800              CMP      r0,#0
000042  d00e              BEQ      |L11.98|
;;;535        {
;;;536            // A flash operation was initiated outside this module.
;;;537            // A callback which indicates that it has finished was received.
;;;538            m_flags &= ~FS_FLAG_FLASH_REQ_PENDING;
000044  4809              LDR      r0,|L11.108|
000046  7800              LDRB     r0,[r0,#0]  ; m_flags
000048  4388              BICS     r0,r0,r1
00004a  4908              LDR      r1,|L11.108|
00004c  7008              STRB     r0,[r1,#0]
;;;539    
;;;540            // If there are any elements left in the queue, set FS_FLAG_PROCESSING.
;;;541            if (m_queue.count > 0)
00004e  4806              LDR      r0,|L11.104|
000050  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000052  2800              CMP      r0,#0
000054  d005              BEQ      |L11.98|
;;;542            {
;;;543               m_flags |= FS_FLAG_PROCESSING;
000056  4608              MOV      r0,r1
000058  7800              LDRB     r0,[r0,#0]  ; m_flags
00005a  2102              MOVS     r1,#2
00005c  4308              ORRS     r0,r0,r1
00005e  4903              LDR      r1,|L11.108|
000060  7008              STRB     r0,[r1,#0]
                  |L11.98|
;;;544            }
;;;545        }
;;;546    
;;;547        // Resume processing the queue, if necessary.
;;;548        queue_process();
000062  f7fffffe          BL       queue_process
;;;549    }
000066  bd70              POP      {r4-r6,pc}
;;;550    
                          ENDP

                  |L11.104|
                          DCD      m_queue
                  |L11.108|
                          DCD      m_flags

                          AREA ||i.on_operation_failure||, CODE, READONLY, ALIGN=2

                  on_operation_failure PROC
;;;256    // been reached, notifies the application and advances the queue.
;;;257    static void on_operation_failure(fs_op_t const * const p_op)
000000  b510              PUSH     {r4,lr}
;;;258    {
000002  4604              MOV      r4,r0
;;;259        if (++m_retry_count > FS_OP_MAX_RETRIES)
000004  4808              LDR      r0,|L12.40|
000006  7800              LDRB     r0,[r0,#0]  ; m_retry_count
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0
00000c  4906              LDR      r1,|L12.40|
00000e  7008              STRB     r0,[r1,#0]
000010  2803              CMP      r0,#3
000012  dd07              BLE      |L12.36|
;;;260        {
;;;261            m_retry_count = 0;
000014  2000              MOVS     r0,#0
000016  7008              STRB     r0,[r1,#0]
;;;262    
;;;263            send_event(p_op, FS_ERR_OPERATION_TIMEOUT);
000018  2108              MOVS     r1,#8
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       send_event
;;;264            queue_advance();
000020  f7fffffe          BL       queue_advance
                  |L12.36|
;;;265        }
;;;266    }
000024  bd10              POP      {r4,pc}
;;;267    
                          ENDP

000026  0000              DCW      0x0000
                  |L12.40|
                          DCD      m_retry_count

                          AREA ||i.on_operation_success||, CODE, READONLY, ALIGN=2

                  on_operation_success PROC
;;;204    // If it has finished, advances the queue and notifies the application.
;;;205    static void on_operation_success(fs_op_t * const p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;206    {
000002  4604              MOV      r4,r0
;;;207        m_retry_count = 0;
000004  2000              MOVS     r0,#0
000006  491b              LDR      r1,|L13.116|
000008  7008              STRB     r0,[r1,#0]
;;;208    
;;;209        switch (p_op->op_code)
00000a  7a20              LDRB     r0,[r4,#8]
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L13.22|
000010  2802              CMP      r0,#2
000012  d12b              BNE      |L13.108|
000014  e019              B        |L13.74|
                  |L13.22|
;;;210        {
;;;211            case FS_OP_STORE:
;;;212            {
;;;213                uint16_t chunk_len;
;;;214    
;;;215                if ((p_op->store.length_words - p_op->store.offset) < FS_MAX_WRITE_SIZE_WORDS)
000016  8aa1              LDRH     r1,[r4,#0x14]
000018  8ae0              LDRH     r0,[r4,#0x16]
00001a  1a08              SUBS     r0,r1,r0
00001c  28ff              CMP      r0,#0xff
00001e  dc04              BGT      |L13.42|
;;;216                {
;;;217                    chunk_len = p_op->store.length_words - p_op->store.offset;
000020  8aa1              LDRH     r1,[r4,#0x14]
000022  8ae0              LDRH     r0,[r4,#0x16]
000024  1a08              SUBS     r0,r1,r0
000026  b285              UXTH     r5,r0
000028  e001              B        |L13.46|
                  |L13.42|
;;;218                }
;;;219                else
;;;220                {
;;;221                    chunk_len = FS_MAX_WRITE_SIZE_WORDS;
00002a  25ff              MOVS     r5,#0xff
00002c  3501              ADDS     r5,#1
                  |L13.46|
;;;222                }
;;;223    
;;;224                p_op->store.offset += chunk_len;
00002e  8ae0              LDRH     r0,[r4,#0x16]
000030  1940              ADDS     r0,r0,r5
000032  82e0              STRH     r0,[r4,#0x16]
;;;225    
;;;226                if (p_op->store.offset == p_op->store.length_words)
000034  8ae1              LDRH     r1,[r4,#0x16]
000036  8aa0              LDRH     r0,[r4,#0x14]
000038  4281              CMP      r1,r0
00003a  d105              BNE      |L13.72|
;;;227                {
;;;228                    // The operation has finished.
;;;229                    send_event(p_op, FS_SUCCESS);
00003c  2100              MOVS     r1,#0
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       send_event
;;;230                    queue_advance();
000044  f7fffffe          BL       queue_advance
                  |L13.72|
;;;231                }
;;;232            }
;;;233            break;
000048  e011              B        |L13.110|
                  |L13.74|
;;;234    
;;;235            case FS_OP_ERASE:
;;;236            {
;;;237                p_op->erase.page++;
00004a  89a0              LDRH     r0,[r4,#0xc]
00004c  1c40              ADDS     r0,r0,#1
00004e  81a0              STRH     r0,[r4,#0xc]
;;;238                p_op->erase.pages_erased++;
000050  89e0              LDRH     r0,[r4,#0xe]
000052  1c40              ADDS     r0,r0,#1
000054  81e0              STRH     r0,[r4,#0xe]
;;;239    
;;;240                if (p_op->erase.pages_erased == p_op->erase.pages_to_erase)
000056  89e1              LDRH     r1,[r4,#0xe]
000058  8a20              LDRH     r0,[r4,#0x10]
00005a  4281              CMP      r1,r0
00005c  d105              BNE      |L13.106|
;;;241                {
;;;242                    send_event(p_op, FS_SUCCESS);
00005e  2100              MOVS     r1,#0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       send_event
;;;243                    queue_advance();
000066  f7fffffe          BL       queue_advance
                  |L13.106|
;;;244                }
;;;245            }
;;;246            break;
00006a  e000              B        |L13.110|
                  |L13.108|
;;;247    
;;;248            default:
;;;249                // Should not happen.
;;;250                break;
00006c  bf00              NOP      
                  |L13.110|
00006e  bf00              NOP                            ;233
;;;251        }
;;;252    }
000070  bd70              POP      {r4-r6,pc}
;;;253    
                          ENDP

000072  0000              DCW      0x0000
                  |L13.116|
                          DCD      m_retry_count

                          AREA ||i.queue_advance||, CODE, READONLY, ALIGN=2

                  queue_advance PROC
;;;132    // If no elements are left in the queue, clears the FS_FLAG_PROCESSING flag.
;;;133    static void queue_advance(void)
000000  480b              LDR      r0,|L14.48|
;;;134    {
;;;135        if (--m_queue.count == 0)
000002  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000004  1e40              SUBS     r0,r0,#1
000006  490a              LDR      r1,|L14.48|
000008  6648              STR      r0,[r1,#0x64]  ; m_queue
00000a  2800              CMP      r0,#0
00000c  d105              BNE      |L14.26|
;;;136        {
;;;137            m_flags &= ~FS_FLAG_PROCESSING;
00000e  4809              LDR      r0,|L14.52|
000010  7800              LDRB     r0,[r0,#0]  ; m_flags
000012  2102              MOVS     r1,#2
000014  4388              BICS     r0,r0,r1
000016  4907              LDR      r1,|L14.52|
000018  7008              STRB     r0,[r1,#0]
                  |L14.26|
;;;138        }
;;;139    
;;;140        if (++m_queue.rp == FS_QUEUE_SIZE)
00001a  4805              LDR      r0,|L14.48|
00001c  6e00              LDR      r0,[r0,#0x60]  ; m_queue
00001e  1c40              ADDS     r0,r0,#1
000020  4903              LDR      r1,|L14.48|
000022  6608              STR      r0,[r1,#0x60]  ; m_queue
000024  2804              CMP      r0,#4
000026  d101              BNE      |L14.44|
;;;141        {
;;;142            m_queue.rp = 0;
000028  2000              MOVS     r0,#0
00002a  6608              STR      r0,[r1,#0x60]  ; m_queue
                  |L14.44|
;;;143        }
;;;144    }
00002c  4770              BX       lr
;;;145    
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      m_queue
                  |L14.52|
                          DCD      m_flags

                          AREA ||i.queue_get_next_free||, CODE, READONLY, ALIGN=2

                  queue_get_next_free PROC
;;;270    // Additionally, increases the number of elements stored in the queue.
;;;271    static bool queue_get_next_free(fs_op_t ** p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;272    {
000002  4604              MOV      r4,r0
;;;273        uint32_t idx;
;;;274    
;;;275        if (m_queue.count == FS_QUEUE_SIZE)
000004  4816              LDR      r0,|L15.96|
000006  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000008  2804              CMP      r0,#4
00000a  d101              BNE      |L15.16|
;;;276        {
;;;277            return false;
00000c  2000              MOVS     r0,#0
                  |L15.14|
;;;278        }
;;;279    
;;;280        idx = ((m_queue.rp + m_queue.count) < FS_QUEUE_SIZE) ?
;;;281               (m_queue.rp + m_queue.count) : ((m_queue.rp + m_queue.count)-FS_QUEUE_SIZE);
;;;282    
;;;283        m_queue.count++;
;;;284    
;;;285        // Zero the element so that unassigned fields will be zero.
;;;286        memset(&m_queue.op[idx], 0x00, sizeof(fs_op_t));
;;;287    
;;;288        *p_op = &m_queue.op[idx];
;;;289    
;;;290        return true;
;;;291    }
00000e  bd70              POP      {r4-r6,pc}
                  |L15.16|
000010  4813              LDR      r0,|L15.96|
000012  6e00              LDR      r0,[r0,#0x60]         ;280  ; m_queue
000014  4912              LDR      r1,|L15.96|
000016  6e49              LDR      r1,[r1,#0x64]         ;280  ; m_queue
000018  1840              ADDS     r0,r0,r1              ;280
00001a  2804              CMP      r0,#4                 ;280
00001c  d205              BCS      |L15.42|
00001e  4810              LDR      r0,|L15.96|
000020  6e00              LDR      r0,[r0,#0x60]         ;281  ; m_queue
000022  490f              LDR      r1,|L15.96|
000024  6e49              LDR      r1,[r1,#0x64]         ;281  ; m_queue
000026  1840              ADDS     r0,r0,r1              ;281
000028  e005              B        |L15.54|
                  |L15.42|
00002a  480d              LDR      r0,|L15.96|
00002c  6e00              LDR      r0,[r0,#0x60]         ;281  ; m_queue
00002e  490c              LDR      r1,|L15.96|
000030  6e49              LDR      r1,[r1,#0x64]         ;281  ; m_queue
000032  1840              ADDS     r0,r0,r1              ;281
000034  1f00              SUBS     r0,r0,#4              ;281
                  |L15.54|
000036  4605              MOV      r5,r0                 ;281
000038  4809              LDR      r0,|L15.96|
00003a  6e40              LDR      r0,[r0,#0x64]         ;283  ; m_queue
00003c  1c40              ADDS     r0,r0,#1              ;283
00003e  4908              LDR      r1,|L15.96|
000040  6648              STR      r0,[r1,#0x64]         ;283  ; m_queue
000042  2118              MOVS     r1,#0x18              ;286
000044  4369              MULS     r1,r5,r1              ;286
000046  4a06              LDR      r2,|L15.96|
000048  1888              ADDS     r0,r1,r2              ;286
00004a  2118              MOVS     r1,#0x18              ;286
00004c  f7fffffe          BL       __aeabi_memclr4
000050  2018              MOVS     r0,#0x18              ;288
000052  4368              MULS     r0,r5,r0              ;288
000054  4902              LDR      r1,|L15.96|
000056  1840              ADDS     r0,r0,r1              ;288
000058  6020              STR      r0,[r4,#0]            ;288
00005a  2001              MOVS     r0,#1                 ;290
00005c  e7d7              B        |L15.14|
;;;292    
                          ENDP

00005e  0000              DCW      0x0000
                  |L15.96|
                          DCD      m_queue

                          AREA ||i.queue_process||, CODE, READONLY, ALIGN=2

                  queue_process PROC
;;;147    // Processes the current element in the queue. If the queue is empty, does nothing.
;;;148    static void queue_process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;149    {
;;;150        uint32_t         ret;
;;;151        fs_op_t  * const p_op = &m_queue.op[m_queue.rp];
000002  4819              LDR      r0,|L16.104|
000004  6e00              LDR      r0,[r0,#0x60]  ; m_queue
000006  2118              MOVS     r1,#0x18
000008  4348              MULS     r0,r1,r0
00000a  4917              LDR      r1,|L16.104|
00000c  1845              ADDS     r5,r0,r1
;;;152    
;;;153        if (m_queue.count > 0)
00000e  4608              MOV      r0,r1
000010  6e40              LDR      r0,[r0,#0x64]  ; m_queue
000012  2800              CMP      r0,#0
000014  d027              BEQ      |L16.102|
;;;154        {
;;;155            switch (p_op->op_code)
000016  7a28              LDRB     r0,[r5,#8]
000018  2801              CMP      r0,#1
00001a  d002              BEQ      |L16.34|
00001c  2802              CMP      r0,#2
00001e  d10a              BNE      |L16.54|
000020  e004              B        |L16.44|
                  |L16.34|
;;;156            {
;;;157                case FS_OP_STORE:
;;;158                    ret = store_execute(p_op);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       store_execute
000028  4604              MOV      r4,r0
;;;159                    break;
00002a  e006              B        |L16.58|
                  |L16.44|
;;;160    
;;;161                case FS_OP_ERASE:
;;;162                    ret = erase_execute(p_op);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       erase_execute
000032  4604              MOV      r4,r0
;;;163                    break;
000034  e001              B        |L16.58|
                  |L16.54|
;;;164    
;;;165                 default:
;;;166                    ret = FS_ERR_INTERNAL;
000036  2409              MOVS     r4,#9
;;;167                    break;
000038  bf00              NOP      
                  |L16.58|
00003a  bf00              NOP                            ;159
;;;168            }
;;;169    
;;;170            // There is a pending flash operation which was not initiated by this module.
;;;171            // Stop processing the queue and wait for a system event.
;;;172            if (ret == NRF_ERROR_BUSY)
00003c  2c11              CMP      r4,#0x11
00003e  d10c              BNE      |L16.90|
;;;173            {
;;;174                m_flags &= ~FS_FLAG_PROCESSING;
000040  480a              LDR      r0,|L16.108|
000042  7800              LDRB     r0,[r0,#0]  ; m_flags
000044  2102              MOVS     r1,#2
000046  4388              BICS     r0,r0,r1
000048  4908              LDR      r1,|L16.108|
00004a  7008              STRB     r0,[r1,#0]
;;;175                m_flags |= FS_FLAG_FLASH_REQ_PENDING;
00004c  4608              MOV      r0,r1
00004e  7800              LDRB     r0,[r0,#0]  ; m_flags
000050  2104              MOVS     r1,#4
000052  4308              ORRS     r0,r0,r1
000054  4905              LDR      r1,|L16.108|
000056  7008              STRB     r0,[r1,#0]
000058  e005              B        |L16.102|
                  |L16.90|
;;;176            }
;;;177            else if (ret != NRF_SUCCESS)
00005a  2c00              CMP      r4,#0
00005c  d003              BEQ      |L16.102|
;;;178            {
;;;179                // An error has occurred.
;;;180                send_event(p_op, FS_ERR_INTERNAL);
00005e  2109              MOVS     r1,#9
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       send_event
                  |L16.102|
;;;181            }
;;;182            else
;;;183            {
;;;184                // Operation is executing.
;;;185            }
;;;186        }
;;;187    }
000066  bd70              POP      {r4-r6,pc}
;;;188    
                          ENDP

                  |L16.104|
                          DCD      m_queue
                  |L16.108|
                          DCD      m_flags

                          AREA ||i.queue_start||, CODE, READONLY, ALIGN=2

                  queue_start PROC
;;;191    // outside this module. Returns immediately otherwise.
;;;192    static void queue_start(void)
000000  b510              PUSH     {r4,lr}
;;;193    {
;;;194        if (!(m_flags & FS_FLAG_PROCESSING) &&
000002  480a              LDR      r0,|L17.44|
000004  7800              LDRB     r0,[r0,#0]  ; m_flags
000006  2102              MOVS     r1,#2
000008  4008              ANDS     r0,r0,r1
00000a  2800              CMP      r0,#0
00000c  d10d              BNE      |L17.42|
;;;195            !(m_flags & FS_FLAG_FLASH_REQ_PENDING))
00000e  4807              LDR      r0,|L17.44|
000010  7800              LDRB     r0,[r0,#0]  ; m_flags
000012  2104              MOVS     r1,#4
000014  4008              ANDS     r0,r0,r1
000016  2800              CMP      r0,#0
000018  d107              BNE      |L17.42|
;;;196        {
;;;197            m_flags |= FS_FLAG_PROCESSING;
00001a  4804              LDR      r0,|L17.44|
00001c  7800              LDRB     r0,[r0,#0]  ; m_flags
00001e  2102              MOVS     r1,#2
000020  4308              ORRS     r0,r0,r1
000022  4902              LDR      r1,|L17.44|
000024  7008              STRB     r0,[r1,#0]
;;;198            queue_process();
000026  f7fffffe          BL       queue_process
                  |L17.42|
;;;199        }
;;;200    }
00002a  bd10              POP      {r4,pc}
;;;201    
                          ENDP

                  |L17.44|
                          DCD      m_flags

                          AREA ||i.send_event||, CODE, READONLY, ALIGN=1

                  send_event PROC
;;;56     // Sends events to the application.
;;;57     static void send_event(fs_op_t const * const p_op, fs_ret_t result)
000000  b57f              PUSH     {r0-r6,lr}
;;;58     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;59         fs_evt_t evt;
;;;60         memset(&evt, 0x00, sizeof(fs_evt_t));
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  9001              STR      r0,[sp,#4]
00000c  9002              STR      r0,[sp,#8]
00000e  9003              STR      r0,[sp,#0xc]
;;;61     
;;;62         switch (p_op->op_code)
000010  7a20              LDRB     r0,[r4,#8]
000012  2801              CMP      r0,#1
000014  d002              BEQ      |L18.28|
000016  2802              CMP      r0,#2
000018  d115              BNE      |L18.70|
00001a  e008              B        |L18.46|
                  |L18.28|
;;;63         {
;;;64             case FS_OP_STORE:
;;;65                 evt.id                 = FS_EVT_STORE;
00001c  2000              MOVS     r0,#0
00001e  4669              MOV      r1,sp
000020  7008              STRB     r0,[r1,#0]
;;;66                 evt.store.p_data       = p_op->store.p_dest;
000022  6920              LDR      r0,[r4,#0x10]
000024  9002              STR      r0,[sp,#8]
;;;67                 evt.store.length_words = p_op->store.length_words;
000026  8aa1              LDRH     r1,[r4,#0x14]
000028  4668              MOV      r0,sp
00002a  8181              STRH     r1,[r0,#0xc]
;;;68                 break;
00002c  e00c              B        |L18.72|
                  |L18.46|
;;;69     
;;;70             case FS_OP_ERASE:
;;;71                 evt.id               = FS_EVT_ERASE;
00002e  2101              MOVS     r1,#1
000030  4668              MOV      r0,sp
000032  7001              STRB     r1,[r0,#0]
;;;72                 evt.erase.first_page = p_op->erase.page - p_op->erase.pages_erased;
000034  89a1              LDRH     r1,[r4,#0xc]
000036  89e0              LDRH     r0,[r4,#0xe]
000038  1a08              SUBS     r0,r1,r0
00003a  b281              UXTH     r1,r0
00003c  4668              MOV      r0,sp
00003e  8101              STRH     r1,[r0,#8]
;;;73                 evt.erase.last_page  = p_op->erase.page;
000040  89a1              LDRH     r1,[r4,#0xc]
000042  8141              STRH     r1,[r0,#0xa]
;;;74                 break;
000044  e000              B        |L18.72|
                  |L18.70|
;;;75     
;;;76             default:
;;;77                 // Should not happen.
;;;78                 break;
000046  bf00              NOP      
                  |L18.72|
000048  bf00              NOP                            ;68
;;;79         }
;;;80         evt.p_context = p_op->p_context;
00004a  6860              LDR      r0,[r4,#4]
00004c  9001              STR      r0,[sp,#4]
;;;81     
;;;82         p_op->p_config->callback(&evt, result);
00004e  6820              LDR      r0,[r4,#0]
000050  4629              MOV      r1,r5
000052  6882              LDR      r2,[r0,#8]
000054  4668              MOV      r0,sp
000056  4790              BLX      r2
;;;83     }
000058  bd7f              POP      {r0-r6,pc}
;;;84     
                          ENDP


                          AREA ||i.store_execute||, CODE, READONLY, ALIGN=1

                  store_execute PROC
;;;104    // Executes a store operation.
;;;105    static uint32_t store_execute(fs_op_t const * const p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;106    {
000002  4604              MOV      r4,r0
;;;107        uint16_t chunk_len;
;;;108    
;;;109        if ((p_op->store.length_words - p_op->store.offset) < FS_MAX_WRITE_SIZE_WORDS)
000004  8aa1              LDRH     r1,[r4,#0x14]
000006  8ae0              LDRH     r0,[r4,#0x16]
000008  1a08              SUBS     r0,r1,r0
00000a  28ff              CMP      r0,#0xff
00000c  dc04              BGT      |L19.24|
;;;110        {
;;;111            chunk_len = p_op->store.length_words - p_op->store.offset;
00000e  8aa1              LDRH     r1,[r4,#0x14]
000010  8ae0              LDRH     r0,[r4,#0x16]
000012  1a08              SUBS     r0,r1,r0
000014  b285              UXTH     r5,r0
000016  e001              B        |L19.28|
                  |L19.24|
;;;112        }
;;;113        else
;;;114        {
;;;115            chunk_len = FS_MAX_WRITE_SIZE_WORDS;
000018  25ff              MOVS     r5,#0xff
00001a  3501              ADDS     r5,#1
                  |L19.28|
;;;116        }
;;;117    
;;;118        return sd_flash_write((uint32_t*)p_op->store.p_dest + p_op->store.offset,
00001c  8ae2              LDRH     r2,[r4,#0x16]
00001e  0092              LSLS     r2,r2,#2
000020  68e3              LDR      r3,[r4,#0xc]
000022  1899              ADDS     r1,r3,r2
000024  8ae2              LDRH     r2,[r4,#0x16]
000026  0092              LSLS     r2,r2,#2
000028  6923              LDR      r3,[r4,#0x10]
00002a  1898              ADDS     r0,r3,r2
00002c  462a              MOV      r2,r5
00002e  df29              SVC      #0x29
;;;119                              (uint32_t*)p_op->store.p_src  + p_op->store.offset,
;;;120                              chunk_len);
;;;121    }
000030  bd70              POP      {r4-r6,pc}
;;;122    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_queue
                          %        104

                          AREA ||.data||, DATA, ALIGN=0

                  m_flags
000000  00                DCB      0x00
                  m_retry_count
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\fstorage\\fstorage.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_fstorage_c_fs_init____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_fstorage_c_fs_init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_fstorage_c_fs_init____REVSH|
#line 144
|__asm___10_fstorage_c_fs_init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
