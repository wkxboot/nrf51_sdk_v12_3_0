; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\nrf_drv_gpiote.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\nrf_drv_gpiote.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\nrf_drv_gpiote.crf ..\..\..\..\..\..\components\drivers_nrf\gpiote\nrf_drv_gpiote.c]
                          THUMB

                          AREA ||i.GPIOTE_IRQHandler||, CODE, READONLY, ALIGN=2

                  GPIOTE_IRQHandler PROC
;;;646    
;;;647    void GPIOTE_IRQHandler(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;648    {
000002  b08f              SUB      sp,sp,#0x3c
;;;649        uint32_t status            = 0;
000004  2000              MOVS     r0,#0
000006  900e              STR      r0,[sp,#0x38]
;;;650        uint32_t input[GPIO_COUNT] = {0};
000008  900d              STR      r0,[sp,#0x34]
;;;651    
;;;652        /* collect status of all GPIOTE pin events. Processing is done once all are collected and cleared.*/
;;;653        uint32_t            i;
;;;654        nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_IN_0;
00000a  20ff              MOVS     r0,#0xff
00000c  3001              ADDS     r0,#1
00000e  900c              STR      r0,[sp,#0x30]
;;;655        uint32_t            mask  = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
000010  2601              MOVS     r6,#1
;;;656    
;;;657        for (i = 0; i < GPIOTE_CH_NUM; i++)
000012  2400              MOVS     r4,#0
000014  e016              B        |L1.68|
                  |L1.22|
;;;658        {
;;;659            if (nrf_gpiote_event_is_set(event) && nrf_gpiote_int_is_enabled(mask))
000016  980c              LDR      r0,[sp,#0x30]
000018  f7fffffe          BL       nrf_gpiote_event_is_set
00001c  2800              CMP      r0,#0
00001e  d00b              BEQ      |L1.56|
000020  bf00              NOP      
000022  4892              LDR      r0,|L1.620|
000024  6840              LDR      r0,[r0,#4]
000026  4030              ANDS     r0,r0,r6
000028  2800              CMP      r0,#0
00002a  d005              BEQ      |L1.56|
;;;660            {
;;;661                nrf_gpiote_event_clear(event);
00002c  980c              LDR      r0,[sp,#0x30]
00002e  f7fffffe          BL       nrf_gpiote_event_clear
;;;662                status |= mask;
000032  980e              LDR      r0,[sp,#0x38]
000034  4330              ORRS     r0,r0,r6
000036  900e              STR      r0,[sp,#0x38]
                  |L1.56|
;;;663            }
;;;664            mask <<= 1;
000038  0076              LSLS     r6,r6,#1
;;;665            /* Incrementing to next event, utilizing the fact that events are grouped together
;;;666             * in ascending order. */
;;;667            event = (nrf_gpiote_events_t)((uint32_t)event + sizeof(uint32_t));
00003a  980c              LDR      r0,[sp,#0x30]
00003c  1d00              ADDS     r0,r0,#4
00003e  b280              UXTH     r0,r0
000040  900c              STR      r0,[sp,#0x30]
000042  1c64              ADDS     r4,r4,#1              ;657
                  |L1.68|
000044  2c04              CMP      r4,#4                 ;657
000046  d3e6              BCC      |L1.22|
;;;668        }
;;;669    
;;;670        /* collect PORT status event, if event is set read pins state. Processing is postponed to the
;;;671         * end of interrupt. */
;;;672        if (nrf_gpiote_event_is_set(NRF_GPIOTE_EVENTS_PORT))
000048  20ff              MOVS     r0,#0xff
00004a  307d              ADDS     r0,r0,#0x7d
00004c  f7fffffe          BL       nrf_gpiote_event_is_set
000050  2800              CMP      r0,#0
000052  d00d              BEQ      |L1.112|
;;;673        {
;;;674            nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
000054  20ff              MOVS     r0,#0xff
000056  307d              ADDS     r0,r0,#0x7d
000058  f7fffffe          BL       nrf_gpiote_event_clear
;;;675            status |= (uint32_t)NRF_GPIOTE_INT_PORT_MASK;
00005c  2101              MOVS     r1,#1
00005e  07c9              LSLS     r1,r1,#31
000060  980e              LDR      r0,[sp,#0x38]
000062  4308              ORRS     r0,r0,r1
000064  900e              STR      r0,[sp,#0x38]
;;;676            nrf_gpio_ports_read(0, GPIO_COUNT, input);
000066  aa0d              ADD      r2,sp,#0x34
000068  2101              MOVS     r1,#1
00006a  2000              MOVS     r0,#0
00006c  f7fffffe          BL       nrf_gpio_ports_read
                  |L1.112|
;;;677        }
;;;678    
;;;679        /* Process pin events. */
;;;680        if (status & NRF_GPIOTE_INT_IN_MASK)
000070  980e              LDR      r0,[sp,#0x38]
000072  0700              LSLS     r0,r0,#28
000074  0f00              LSRS     r0,r0,#28
000076  2800              CMP      r0,#0
000078  d02c              BEQ      |L1.212|
;;;681        {
;;;682            mask = (uint32_t)NRF_GPIOTE_INT_IN0_MASK;
00007a  2601              MOVS     r6,#1
;;;683    
;;;684            for (i = 0; i < GPIOTE_CH_NUM; i++)
00007c  2400              MOVS     r4,#0
00007e  e027              B        |L1.208|
                  |L1.128|
;;;685            {
;;;686                if (mask & status)
000080  980e              LDR      r0,[sp,#0x38]
000082  4030              ANDS     r0,r0,r6
000084  2800              CMP      r0,#0
000086  d021              BEQ      |L1.204|
;;;687                {
;;;688                    nrf_drv_gpiote_pin_t pin = nrf_gpiote_event_pin_get(i);
000088  bf00              NOP      
00008a  4879              LDR      r0,|L1.624|
00008c  2151              MOVS     r1,#0x51
00008e  0109              LSLS     r1,r1,#4
000090  1840              ADDS     r0,r0,r1
000092  00a1              LSLS     r1,r4,#2
000094  5840              LDR      r0,[r0,r1]
000096  211f              MOVS     r1,#0x1f
000098  0209              LSLS     r1,r1,#8
00009a  4008              ANDS     r0,r0,r1
00009c  0a00              LSRS     r0,r0,#8
00009e  4607              MOV      r7,r0
;;;689                    NRF_LOG_DEBUG("Event in number: %d.\r\n", i);
;;;690                    nrf_gpiote_polarity_t        polarity = nrf_gpiote_event_polarity_get(i);
0000a0  bf00              NOP      
0000a2  4873              LDR      r0,|L1.624|
0000a4  2151              MOVS     r1,#0x51
0000a6  0109              LSLS     r1,r1,#4
0000a8  1840              ADDS     r0,r0,r1
0000aa  00a1              LSLS     r1,r4,#2
0000ac  5840              LDR      r0,[r0,r1]
0000ae  2103              MOVS     r1,#3
0000b0  0409              LSLS     r1,r1,#16
0000b2  4008              ANDS     r0,r0,r1
0000b4  0c00              LSRS     r0,r0,#16
0000b6  900b              STR      r0,[sp,#0x2c]
;;;691                    nrf_drv_gpiote_evt_handler_t handler  = channel_handler_get(i);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       channel_handler_get
0000be  4605              MOV      r5,r0
;;;692                    NRF_LOG_DEBUG("Pin: %d, polarity: %d.\r\n", pin, polarity);
;;;693                    if (handler)
0000c0  2d00              CMP      r5,#0
0000c2  d002              BEQ      |L1.202|
;;;694                    {
;;;695                        handler(pin, polarity);
0000c4  4638              MOV      r0,r7
0000c6  990b              LDR      r1,[sp,#0x2c]
0000c8  47a8              BLX      r5
                  |L1.202|
;;;696                    }
;;;697                }
0000ca  bf00              NOP      
                  |L1.204|
;;;698                mask <<= 1;
0000cc  0076              LSLS     r6,r6,#1
0000ce  1c64              ADDS     r4,r4,#1              ;684
                  |L1.208|
0000d0  2c04              CMP      r4,#4                 ;684
0000d2  d3d5              BCC      |L1.128|
                  |L1.212|
;;;699            }
;;;700        }
;;;701    
;;;702        if (status & (uint32_t)NRF_GPIOTE_INT_PORT_MASK)
0000d4  980e              LDR      r0,[sp,#0x38]
0000d6  0fc0              LSRS     r0,r0,#31
0000d8  07c0              LSLS     r0,r0,#31
0000da  2800              CMP      r0,#0
0000dc  d076              BEQ      |L1.460|
;;;703        {
;;;704            /* Process port event. */
;;;705            uint32_t port_idx;
;;;706            uint8_t  repeat                  = 0;
0000de  2000              MOVS     r0,#0
0000e0  900b              STR      r0,[sp,#0x2c]
;;;707            uint32_t toggle_mask[GPIO_COUNT] = {0};
0000e2  900a              STR      r0,[sp,#0x28]
;;;708            uint32_t pins_to_check[GPIO_COUNT];
;;;709    
;;;710            // Faster way of doing memset because in interrupt context.
;;;711            for (port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
0000e4  2500              MOVS     r5,#0
0000e6  e005              B        |L1.244|
                  |L1.232|
;;;712            {
;;;713                pins_to_check[port_idx] = 0xFFFFFFFF;
0000e8  2000              MOVS     r0,#0
0000ea  43c0              MVNS     r0,r0
0000ec  00a9              LSLS     r1,r5,#2
0000ee  aa09              ADD      r2,sp,#0x24
0000f0  5050              STR      r0,[r2,r1]
0000f2  1c6d              ADDS     r5,r5,#1              ;711
                  |L1.244|
0000f4  2d00              CMP      r5,#0                 ;711
0000f6  d0f7              BEQ      |L1.232|
;;;714            }
;;;715    
;;;716            do
0000f8  bf00              NOP      
                  |L1.250|
;;;717            {
;;;718                repeat = 0;
0000fa  2000              MOVS     r0,#0
0000fc  900b              STR      r0,[sp,#0x2c]
;;;719    
;;;720                for (i = 0; i < GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS; i++)
0000fe  2400              MOVS     r4,#0
000100  e07a              B        |L1.504|
                  |L1.258|
;;;721                {
;;;722                    uint8_t              pin_and_sense = m_cb.port_handlers_pins[i];
000102  485c              LDR      r0,|L1.628|
000104  5d00              LDRB     r0,[r0,r4]
000106  9008              STR      r0,[sp,#0x20]
;;;723                    nrf_drv_gpiote_pin_t pin           = (pin_and_sense & ~SENSE_FIELD_MASK);
000108  21c0              MOVS     r1,#0xc0
00010a  9808              LDR      r0,[sp,#0x20]
00010c  4388              BICS     r0,r0,r1
00010e  4607              MOV      r7,r0
;;;724    
;;;725                    if ((m_cb.port_handlers_pins[i] != PIN_NOT_USED)
000110  4858              LDR      r0,|L1.628|
000112  5700              LDRSB    r0,[r0,r4]
000114  1c40              ADDS     r0,r0,#1
000116  2800              CMP      r0,#0
000118  d06d              BEQ      |L1.502|
;;;726                        && nrf_bitmask_bit_is_set(pin, pins_to_check))
00011a  a909              ADD      r1,sp,#0x24
00011c  4638              MOV      r0,r7
00011e  f7fffffe          BL       nrf_bitmask_bit_is_set
000122  2800              CMP      r0,#0
000124  d067              BEQ      |L1.502|
;;;727                    {
;;;728                        nrf_gpiote_polarity_t polarity =
000126  21c0              MOVS     r1,#0xc0
000128  9808              LDR      r0,[sp,#0x20]
00012a  4008              ANDS     r0,r0,r1
00012c  1180              ASRS     r0,r0,#6
00012e  9007              STR      r0,[sp,#0x1c]
;;;729                            (nrf_gpiote_polarity_t)((pin_and_sense &
;;;730                                                     SENSE_FIELD_MASK) >> SENSE_FIELD_POS);
;;;731                        nrf_drv_gpiote_evt_handler_t handler =
000130  4638              MOV      r0,r7
000132  f7fffffe          BL       channel_port_get
000136  9005              STR      r0,[sp,#0x14]
000138  f7fffffe          BL       channel_handler_get
00013c  9006              STR      r0,[sp,#0x18]
;;;732                            channel_handler_get(channel_port_get(pin));
;;;733                        if (handler || (polarity == NRF_GPIOTE_POLARITY_TOGGLE))
00013e  9806              LDR      r0,[sp,#0x18]
000140  2800              CMP      r0,#0
000142  d102              BNE      |L1.330|
000144  9807              LDR      r0,[sp,#0x1c]
000146  2803              CMP      r0,#3
000148  d154              BNE      |L1.500|
                  |L1.330|
;;;734                        {
;;;735                            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
00014a  9807              LDR      r0,[sp,#0x1c]
00014c  2803              CMP      r0,#3
00014e  d115              BNE      |L1.380|
;;;736                            {
;;;737                                nrf_bitmask_bit_set(pin, toggle_mask);
000150  a80a              ADD      r0,sp,#0x28
000152  9703              STR      r7,[sp,#0xc]
000154  9002              STR      r0,[sp,#8]
000156  9f03              LDR      r7,[sp,#0xc]
000158  08f9              LSRS     r1,r7,#3
00015a  9101              STR      r1,[sp,#4]
00015c  9f03              LDR      r7,[sp,#0xc]
00015e  0779              LSLS     r1,r7,#29
000160  0f49              LSRS     r1,r1,#29
000162  9103              STR      r1,[sp,#0xc]
000164  9901              LDR      r1,[sp,#4]
000166  9802              LDR      r0,[sp,#8]
000168  5c41              LDRB     r1,[r0,r1]
00016a  2301              MOVS     r3,#1
00016c  9a03              LDR      r2,[sp,#0xc]
00016e  4093              LSLS     r3,r3,r2
000170  4319              ORRS     r1,r1,r3
000172  b2ca              UXTB     r2,r1
000174  9901              LDR      r1,[sp,#4]
000176  5442              STRB     r2,[r0,r1]
000178  bf00              NOP      
00017a  bf00              NOP      
                  |L1.380|
;;;738                            }
;;;739                            nrf_gpio_pin_sense_t sense     = nrf_gpio_pin_sense_get(pin);
00017c  bf00              NOP      
00017e  bf00              NOP      
000180  2105              MOVS     r1,#5
000182  0709              LSLS     r1,r1,#28
000184  4608              MOV      r0,r1
000186  00b9              LSLS     r1,r7,#2
000188  2207              MOVS     r2,#7
00018a  0212              LSLS     r2,r2,#8
00018c  1882              ADDS     r2,r0,r2
00018e  5851              LDR      r1,[r2,r1]
000190  2203              MOVS     r2,#3
000192  0412              LSLS     r2,r2,#16
000194  4011              ANDS     r1,r1,r2
000196  0c09              LSRS     r1,r1,#16
000198  9105              STR      r1,[sp,#0x14]
;;;740                            uint32_t             pin_state = nrf_bitmask_bit_is_set(pin, input);
00019a  a90d              ADD      r1,sp,#0x34
00019c  4638              MOV      r0,r7
00019e  f7fffffe          BL       nrf_bitmask_bit_is_set
0001a2  9004              STR      r0,[sp,#0x10]
;;;741                            if ((pin_state && (sense == NRF_GPIO_PIN_SENSE_HIGH)) ||
0001a4  9804              LDR      r0,[sp,#0x10]
0001a6  2800              CMP      r0,#0
0001a8  d002              BEQ      |L1.432|
0001aa  9805              LDR      r0,[sp,#0x14]
0001ac  2802              CMP      r0,#2
0001ae  d005              BEQ      |L1.444|
                  |L1.432|
;;;742                                (!pin_state && (sense == NRF_GPIO_PIN_SENSE_LOW))  )
0001b0  9804              LDR      r0,[sp,#0x10]
0001b2  2800              CMP      r0,#0
0001b4  d11d              BNE      |L1.498|
0001b6  9805              LDR      r0,[sp,#0x14]
0001b8  2803              CMP      r0,#3
0001ba  d11a              BNE      |L1.498|
                  |L1.444|
;;;743                            {
;;;744                                NRF_LOG_DEBUG("PORT event for pin: %d, polarity: %d.\r\n", pin,
;;;745                                              polarity);
;;;746                                if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
0001bc  9807              LDR      r0,[sp,#0x1c]
0001be  2803              CMP      r0,#3
0001c0  d110              BNE      |L1.484|
;;;747                                {
;;;748                                    nrf_gpio_pin_sense_t next_sense =
0001c2  9805              LDR      r0,[sp,#0x14]
0001c4  2802              CMP      r0,#2
0001c6  d102              BNE      |L1.462|
;;;749                                        (sense == NRF_GPIO_PIN_SENSE_HIGH) ?
;;;750                                        NRF_GPIO_PIN_SENSE_LOW :
0001c8  2003              MOVS     r0,#3
0001ca  e001              B        |L1.464|
                  |L1.460|
0001cc  e04b              B        |L1.614|
                  |L1.462|
;;;751                                        NRF_GPIO_PIN_SENSE_HIGH;
0001ce  2002              MOVS     r0,#2
                  |L1.464|
0001d0  9003              STR      r0,[sp,#0xc]
;;;752                                    nrf_gpio_cfg_sense_set(pin, next_sense);
0001d2  4638              MOV      r0,r7
0001d4  9903              LDR      r1,[sp,#0xc]
0001d6  f7fffffe          BL       nrf_gpio_cfg_sense_set
;;;753                                    ++repeat;
0001da  980b              LDR      r0,[sp,#0x2c]
0001dc  1c40              ADDS     r0,r0,#1
0001de  b2c0              UXTB     r0,r0
0001e0  900b              STR      r0,[sp,#0x2c]
;;;754    
;;;755                                }
0001e2  bf00              NOP      
                  |L1.484|
;;;756                                if (handler)
0001e4  9806              LDR      r0,[sp,#0x18]
0001e6  2800              CMP      r0,#0
0001e8  d003              BEQ      |L1.498|
;;;757                                {
;;;758                                    handler(pin, polarity);
0001ea  4638              MOV      r0,r7
0001ec  9a06              LDR      r2,[sp,#0x18]
0001ee  9907              LDR      r1,[sp,#0x1c]
0001f0  4790              BLX      r2
                  |L1.498|
;;;759                                }
;;;760                            }
;;;761                        }
0001f2  bf00              NOP      
                  |L1.500|
;;;762                    }
0001f4  bf00              NOP      
                  |L1.502|
0001f6  1c64              ADDS     r4,r4,#1              ;720
                  |L1.504|
0001f8  2c04              CMP      r4,#4                 ;720
0001fa  d382              BCC      |L1.258|
;;;763                }
;;;764    
;;;765                if (repeat)
0001fc  980b              LDR      r0,[sp,#0x2c]
0001fe  2800              CMP      r0,#0
000200  d02c              BEQ      |L1.604|
;;;766                {
;;;767                    // When one of the pins in low-accuracy and toggle mode becomes active,
;;;768                    // it's sense mode is inverted to clear the internal SENSE signal.
;;;769                    // State of any other enabled low-accuracy input in toggle mode must be checked
;;;770                    // explicitly, because it does not trigger the interrput when SENSE signal is active.
;;;771                    // For more information about SENSE functionality, refer to Product Specification.
;;;772    
;;;773                    uint32_t new_input[GPIO_COUNT];
;;;774                    bool     input_unchanged = true;
000202  2701              MOVS     r7,#1
;;;775                    nrf_gpio_ports_read(0, GPIO_COUNT, new_input);
000204  aa08              ADD      r2,sp,#0x20
000206  2101              MOVS     r1,#1
000208  2000              MOVS     r0,#0
00020a  f7fffffe          BL       nrf_gpio_ports_read
;;;776    
;;;777                    // Faster way of doing memcmp because in interrupt context.
;;;778                    for (port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
00020e  2500              MOVS     r5,#0
000210  e00a              B        |L1.552|
                  |L1.530|
;;;779                    {
;;;780                        if (new_input[port_idx] != input[port_idx])
000212  00a8              LSLS     r0,r5,#2
000214  a908              ADD      r1,sp,#0x20
000216  5808              LDR      r0,[r1,r0]
000218  00a9              LSLS     r1,r5,#2
00021a  aa0d              ADD      r2,sp,#0x34
00021c  5851              LDR      r1,[r2,r1]
00021e  4288              CMP      r0,r1
000220  d001              BEQ      |L1.550|
;;;781                        {
;;;782                            input_unchanged = false;
000222  2700              MOVS     r7,#0
;;;783                            break;
000224  e002              B        |L1.556|
                  |L1.550|
000226  1c6d              ADDS     r5,r5,#1              ;778
                  |L1.552|
000228  2d00              CMP      r5,#0                 ;778
00022a  d0f2              BEQ      |L1.530|
                  |L1.556|
00022c  bf00              NOP      
;;;784                        }
;;;785                    }
;;;786    
;;;787                    if (input_unchanged)
00022e  2f00              CMP      r7,#0
000230  d002              BEQ      |L1.568|
;;;788                    {
;;;789                        // No change.
;;;790                        repeat = 0;
000232  2000              MOVS     r0,#0
000234  900b              STR      r0,[sp,#0x2c]
000236  e010              B        |L1.602|
                  |L1.568|
;;;791                    }
;;;792                    else
;;;793                    {
;;;794                        // Faster way of doing memcpy because in interrupt context.
;;;795                        for (port_idx = 0; port_idx < GPIO_COUNT; port_idx++)
000238  2500              MOVS     r5,#0
00023a  e00c              B        |L1.598|
                  |L1.572|
;;;796                        {
;;;797                            input[port_idx]         = new_input[port_idx];
00023c  00a8              LSLS     r0,r5,#2
00023e  a908              ADD      r1,sp,#0x20
000240  5808              LDR      r0,[r1,r0]
000242  00a9              LSLS     r1,r5,#2
000244  aa0d              ADD      r2,sp,#0x34
000246  5050              STR      r0,[r2,r1]
;;;798                            pins_to_check[port_idx] = toggle_mask[port_idx];
000248  00a8              LSLS     r0,r5,#2
00024a  a90a              ADD      r1,sp,#0x28
00024c  5808              LDR      r0,[r1,r0]
00024e  00a9              LSLS     r1,r5,#2
000250  aa09              ADD      r2,sp,#0x24
000252  5050              STR      r0,[r2,r1]
000254  1c6d              ADDS     r5,r5,#1              ;795
                  |L1.598|
000256  2d00              CMP      r5,#0                 ;795
000258  d0f0              BEQ      |L1.572|
                  |L1.602|
;;;799                        }
;;;800                    }
;;;801                }
00025a  bf00              NOP      
                  |L1.604|
;;;802            }
;;;803            while (repeat);
00025c  980b              LDR      r0,[sp,#0x2c]
00025e  2800              CMP      r0,#0
000260  d000              BEQ      |L1.612|
000262  e74a              B        |L1.250|
                  |L1.612|
;;;804        }
000264  bf00              NOP      
                  |L1.614|
;;;805    }
000266  b00f              ADD      sp,sp,#0x3c
000268  bdf0              POP      {r4-r7,pc}
;;;806    
                          ENDP

00026a  0000              DCW      0x0000
                  |L1.620|
                          DCD      0x40006300
                  |L1.624|
                          DCD      0x40006000
                  |L1.628|
                          DCD      m_cb+0x40

                          AREA ||i.channel_free||, CODE, READONLY, ALIGN=2

                  channel_free PROC
;;;214    
;;;215    static void channel_free(uint8_t channel_id)
000000  2100              MOVS     r1,#0
;;;216    {
;;;217        m_cb.handlers[channel_id] = FORBIDDEN_HANDLER_ADDRESS;
000002  43c9              MVNS     r1,r1
000004  0082              LSLS     r2,r0,#2
000006  4b05              LDR      r3,|L2.28|
000008  5099              STR      r1,[r3,r2]
;;;218        if (channel_id >= GPIOTE_CH_NUM)
00000a  2804              CMP      r0,#4
00000c  db04              BLT      |L2.24|
;;;219        {
;;;220            m_cb.port_handlers_pins[channel_id - GPIOTE_CH_NUM] = (int8_t)PIN_NOT_USED;
00000e  460b              MOV      r3,r1
000010  1f01              SUBS     r1,r0,#4
000012  4a02              LDR      r2,|L2.28|
000014  3240              ADDS     r2,r2,#0x40
000016  5453              STRB     r3,[r2,r1]
                  |L2.24|
;;;221        }
;;;222    }
000018  4770              BX       lr
;;;223    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      m_cb

                          AREA ||i.channel_handler_get||, CODE, READONLY, ALIGN=2

                  channel_handler_get PROC
;;;183    
;;;184    __STATIC_INLINE nrf_drv_gpiote_evt_handler_t channel_handler_get(uint32_t channel)
000000  4601              MOV      r1,r0
;;;185    {
;;;186        return m_cb.handlers[channel];
000002  0088              LSLS     r0,r1,#2
000004  4a01              LDR      r2,|L3.12|
000006  5810              LDR      r0,[r2,r0]
;;;187    }
000008  4770              BX       lr
;;;188    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      m_cb

                          AREA ||i.channel_port_alloc||, CODE, READONLY, ALIGN=2

                  channel_port_alloc PROC
;;;189    
;;;190    static int8_t channel_port_alloc(uint32_t pin, nrf_drv_gpiote_evt_handler_t handler, bool channel)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;191    {
000002  b085              SUB      sp,sp,#0x14
000004  460b              MOV      r3,r1
;;;192        int8_t   channel_id = NO_CHANNELS;
000006  2000              MOVS     r0,#0
000008  43c0              MVNS     r0,r0
00000a  9004              STR      r0,[sp,#0x10]
;;;193        uint32_t i;
;;;194    
;;;195        uint32_t start_idx = channel ? 0 : GPIOTE_CH_NUM;
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L4.20|
000010  2000              MOVS     r0,#0
000012  e000              B        |L4.22|
                  |L4.20|
000014  2004              MOVS     r0,#4
                  |L4.22|
000016  9003              STR      r0,[sp,#0xc]
;;;196        uint32_t end_idx   =
000018  2a00              CMP      r2,#0
00001a  d001              BEQ      |L4.32|
;;;197            channel ? GPIOTE_CH_NUM : (GPIOTE_CH_NUM + GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS);
00001c  2004              MOVS     r0,#4
00001e  e000              B        |L4.34|
                  |L4.32|
000020  2008              MOVS     r0,#8
                  |L4.34|
000022  9002              STR      r0,[sp,#8]
;;;198    
;;;199        // critical section
;;;200    
;;;201        for (i = start_idx; i < end_idx; i++)
000024  9903              LDR      r1,[sp,#0xc]
000026  e01e              B        |L4.102|
                  |L4.40|
;;;202        {
;;;203            if (m_cb.handlers[i] == FORBIDDEN_HANDLER_ADDRESS)
000028  0088              LSLS     r0,r1,#2
00002a  4c12              LDR      r4,|L4.116|
00002c  5820              LDR      r0,[r4,r0]
00002e  1c40              ADDS     r0,r0,#1
000030  2800              CMP      r0,#0
000032  d117              BNE      |L4.100|
;;;204            {
;;;205                pin_in_use_by_te_set(pin, i, handler, channel);
000034  4608              MOV      r0,r1
000036  9c05              LDR      r4,[sp,#0x14]
000038  9300              STR      r3,[sp,#0]
00003a  9201              STR      r2,[sp,#4]
00003c  b246              SXTB     r6,r0
00003e  4d0d              LDR      r5,|L4.116|
000040  3520              ADDS     r5,r5,#0x20
000042  552e              STRB     r6,[r5,r4]
000044  0085              LSLS     r5,r0,#2
000046  4e0b              LDR      r6,|L4.116|
000048  9b00              LDR      r3,[sp,#0]
00004a  5173              STR      r3,[r6,r5]
00004c  9a01              LDR      r2,[sp,#4]
00004e  2a00              CMP      r2,#0
000050  d104              BNE      |L4.92|
000052  b266              SXTB     r6,r4
000054  1f05              SUBS     r5,r0,#4
000056  4f07              LDR      r7,|L4.116|
000058  3740              ADDS     r7,r7,#0x40
00005a  557e              STRB     r6,[r7,r5]
                  |L4.92|
00005c  bf00              NOP      
;;;206                channel_id = i;
00005e  b248              SXTB     r0,r1
000060  9004              STR      r0,[sp,#0x10]
;;;207                break;
000062  e003              B        |L4.108|
                  |L4.100|
000064  1c49              ADDS     r1,r1,#1              ;201
                  |L4.102|
000066  9802              LDR      r0,[sp,#8]            ;201
000068  4281              CMP      r1,r0                 ;201
00006a  d3dd              BCC      |L4.40|
                  |L4.108|
00006c  bf00              NOP      
;;;208            }
;;;209        }
;;;210        // critical section
;;;211        return channel_id;
00006e  9804              LDR      r0,[sp,#0x10]
;;;212    }
000070  b008              ADD      sp,sp,#0x20
000072  bdf0              POP      {r4-r7,pc}
;;;213    
                          ENDP

                  |L4.116|
                          DCD      m_cb

                          AREA ||i.channel_port_get||, CODE, READONLY, ALIGN=2

                  channel_port_get PROC
;;;177    
;;;178    __STATIC_INLINE int8_t channel_port_get(uint32_t pin)
000000  4601              MOV      r1,r0
;;;179    {
;;;180        return m_cb.pin_assignments[pin];
000002  4801              LDR      r0,|L5.8|
000004  5640              LDRSB    r0,[r0,r1]
;;;181    }
000006  4770              BX       lr
;;;182    
                          ENDP

                  |L5.8|
                          DCD      m_cb+0x20

                          AREA ||i.nrf_bitmask_bit_is_set||, CODE, READONLY, ALIGN=1

                  nrf_bitmask_bit_is_set PROC
;;;62      */
;;;63     __STATIC_INLINE uint32_t nrf_bitmask_bit_is_set(uint32_t bit, void const * p_mask)
000000  b530              PUSH     {r4,r5,lr}
;;;64     {
000002  4602              MOV      r2,r0
;;;65         uint8_t const * p_mask8 = (uint8_t const *)p_mask;
000004  460b              MOV      r3,r1
;;;66         uint32_t byte_idx = BITMASK_BYTE_GET(bit);
000006  08d4              LSRS     r4,r2,#3
;;;67         bit = BITMASK_RELBIT_GET(bit);
000008  0752              LSLS     r2,r2,#29
00000a  0f52              LSRS     r2,r2,#29
;;;68         return (1 << bit) & p_mask8[byte_idx];
00000c  2001              MOVS     r0,#1
00000e  4090              LSLS     r0,r0,r2
000010  5d1d              LDRB     r5,[r3,r4]
000012  4028              ANDS     r0,r0,r5
;;;69     }
000014  bd30              POP      {r4,r5,pc}
;;;70     
                          ENDP


                          AREA ||i.nrf_drv_gpiote_in_event_addr_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_event_addr_get PROC
;;;631    
;;;632    uint32_t nrf_drv_gpiote_in_event_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;633    {
000002  4604              MOV      r4,r0
;;;634        ASSERT(pin < NUMBER_OF_PINS);
;;;635        ASSERT(pin_in_use_by_port(pin) || pin_in_use_by_te(pin));
;;;636    
;;;637        nrf_gpiote_events_t event = NRF_GPIOTE_EVENTS_PORT;
000004  25ff              MOVS     r5,#0xff
000006  357d              ADDS     r5,r5,#0x7d
;;;638    
;;;639        if (pin_in_use_by_te(pin))
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       pin_in_use_by_te
00000e  2800              CMP      r0,#0
000010  d006              BEQ      |L7.32|
;;;640        {
;;;641            event = TE_IDX_TO_EVENT_ADDR(channel_port_get(pin));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       channel_port_get
000018  0080              LSLS     r0,r0,#2
00001a  30ff              ADDS     r0,r0,#0xff
00001c  3001              ADDS     r0,#1
00001e  b285              UXTH     r5,r0
                  |L7.32|
;;;642        }
;;;643        return nrf_gpiote_event_addr_get(event);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       nrf_gpiote_event_addr_get
;;;644    }
000026  bd70              POP      {r4-r6,pc}
;;;645    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_in_event_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_event_disable PROC
;;;592    
;;;593    void nrf_drv_gpiote_in_event_disable(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;594    {
000002  4605              MOV      r5,r0
;;;595        ASSERT(pin < NUMBER_OF_PINS);
;;;596        ASSERT(pin_in_use_by_gpiote(pin));
;;;597        if (pin_in_use_by_port(pin))
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       pin_in_use_by_port
00000a  2800              CMP      r0,#0
00000c  d004              BEQ      |L8.24|
;;;598        {
;;;599            nrf_gpio_cfg_sense_set(pin, NRF_GPIO_PIN_NOSENSE);
00000e  2100              MOVS     r1,#0
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       nrf_gpio_cfg_sense_set
000016  e01e              B        |L8.86|
                  |L8.24|
;;;600        }
;;;601        else if (pin_in_use_by_te(pin))
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       pin_in_use_by_te
00001e  2800              CMP      r0,#0
000020  d019              BEQ      |L8.86|
;;;602        {
;;;603            int32_t channel = (int32_t)channel_port_get(pin);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       channel_port_get
000028  4604              MOV      r4,r0
;;;604            nrf_gpiote_event_disable(channel);
00002a  4620              MOV      r0,r4
00002c  490a              LDR      r1,|L8.88|
00002e  2251              MOVS     r2,#0x51
000030  0112              LSLS     r2,r2,#4
000032  1889              ADDS     r1,r1,r2
000034  0082              LSLS     r2,r0,#2
000036  5889              LDR      r1,[r1,r2]
000038  0849              LSRS     r1,r1,#1
00003a  0049              LSLS     r1,r1,#1
00003c  4a06              LDR      r2,|L8.88|
00003e  2351              MOVS     r3,#0x51
000040  011b              LSLS     r3,r3,#4
000042  18d2              ADDS     r2,r2,r3
000044  0083              LSLS     r3,r0,#2
000046  50d1              STR      r1,[r2,r3]
000048  bf00              NOP      
;;;605            nrf_gpiote_int_disable(1 << channel);
00004a  2001              MOVS     r0,#1
00004c  40a0              LSLS     r0,r0,r4
00004e  4903              LDR      r1,|L8.92|
000050  6088              STR      r0,[r1,#8]
000052  bf00              NOP      
;;;606        }
000054  bf00              NOP      
                  |L8.86|
;;;607    }
000056  bd70              POP      {r4-r6,pc}
;;;608    
                          ENDP

                  |L8.88|
                          DCD      0x40006000
                  |L8.92|
                          DCD      0x40006300

                          AREA ||i.nrf_drv_gpiote_in_event_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_event_enable PROC
;;;547    
;;;548    void nrf_drv_gpiote_in_event_enable(nrf_drv_gpiote_pin_t pin, bool int_enable)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;549    {
000002  b081              SUB      sp,sp,#4
000004  460d              MOV      r5,r1
;;;550        ASSERT(pin < NUMBER_OF_PINS);
;;;551        ASSERT(pin_in_use_by_gpiote(pin));
;;;552        if (pin_in_use_by_port(pin))
000006  9801              LDR      r0,[sp,#4]
000008  f7fffffe          BL       pin_in_use_by_port
00000c  2800              CMP      r0,#0
00000e  d01d              BEQ      |L9.76|
;;;553        {
;;;554            uint8_t pin_and_sense =
000010  9801              LDR      r0,[sp,#4]
000012  f7fffffe          BL       channel_port_get
000016  1f00              SUBS     r0,r0,#4
000018  4926              LDR      r1,|L9.180|
00001a  5c0e              LDRB     r6,[r1,r0]
;;;555                m_cb.port_handlers_pins[channel_port_get(pin) - GPIOTE_CH_NUM];
;;;556            nrf_gpiote_polarity_t polarity =
00001c  11b4              ASRS     r4,r6,#6
;;;557                (nrf_gpiote_polarity_t)(pin_and_sense >> SENSE_FIELD_POS);
;;;558            nrf_gpio_pin_sense_t sense;
;;;559            if (polarity == NRF_GPIOTE_POLARITY_TOGGLE)
00001e  2c03              CMP      r4,#3
000020  d109              BNE      |L9.54|
;;;560            {
;;;561                /* read current pin state and set for next sense to oposit */
;;;562                sense = (nrf_gpio_pin_read(pin)) ?
000022  9801              LDR      r0,[sp,#4]
000024  f7fffffe          BL       nrf_gpio_pin_read
000028  2800              CMP      r0,#0
00002a  d001              BEQ      |L9.48|
;;;563                        NRF_GPIO_PIN_SENSE_LOW : NRF_GPIO_PIN_SENSE_HIGH;
00002c  2003              MOVS     r0,#3
00002e  e000              B        |L9.50|
                  |L9.48|
000030  2002              MOVS     r0,#2
                  |L9.50|
000032  4607              MOV      r7,r0
000034  e005              B        |L9.66|
                  |L9.54|
;;;564            }
;;;565            else
;;;566            {
;;;567                sense = (polarity == NRF_GPIOTE_POLARITY_LOTOHI) ?
000036  2c01              CMP      r4,#1
000038  d101              BNE      |L9.62|
;;;568                        NRF_GPIO_PIN_SENSE_HIGH : NRF_GPIO_PIN_SENSE_LOW;
00003a  2002              MOVS     r0,#2
00003c  e000              B        |L9.64|
                  |L9.62|
00003e  2003              MOVS     r0,#3
                  |L9.64|
000040  4607              MOV      r7,r0
                  |L9.66|
;;;569            }
;;;570            nrf_gpio_cfg_sense_set(pin, sense);
000042  4639              MOV      r1,r7
000044  9801              LDR      r0,[sp,#4]
000046  f7fffffe          BL       nrf_gpio_cfg_sense_set
;;;571        }
00004a  e031              B        |L9.176|
                  |L9.76|
;;;572        else if (pin_in_use_by_te(pin))
00004c  9801              LDR      r0,[sp,#4]
00004e  f7fffffe          BL       pin_in_use_by_te
000052  2800              CMP      r0,#0
000054  d02c              BEQ      |L9.176|
;;;573        {
;;;574            int32_t             channel = (int32_t)channel_port_get(pin);
000056  9801              LDR      r0,[sp,#4]
000058  f7fffffe          BL       channel_port_get
00005c  4604              MOV      r4,r0
;;;575            nrf_gpiote_events_t event   = TE_IDX_TO_EVENT_ADDR(channel);
00005e  00a0              LSLS     r0,r4,#2
000060  30ff              ADDS     r0,r0,#0xff
000062  3001              ADDS     r0,#1
000064  b286              UXTH     r6,r0
;;;576    
;;;577            nrf_gpiote_event_enable(channel);
000066  4620              MOV      r0,r4
000068  4913              LDR      r1,|L9.184|
00006a  2251              MOVS     r2,#0x51
00006c  0112              LSLS     r2,r2,#4
00006e  1889              ADDS     r1,r1,r2
000070  0082              LSLS     r2,r0,#2
000072  5889              LDR      r1,[r1,r2]
000074  2201              MOVS     r2,#1
000076  4311              ORRS     r1,r1,r2
000078  4a0f              LDR      r2,|L9.184|
00007a  2351              MOVS     r3,#0x51
00007c  011b              LSLS     r3,r3,#4
00007e  18d2              ADDS     r2,r2,r3
000080  0083              LSLS     r3,r0,#2
000082  50d1              STR      r1,[r2,r3]
000084  bf00              NOP      
;;;578    
;;;579            nrf_gpiote_event_clear(event);
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       nrf_gpiote_event_clear
;;;580            if (int_enable)
00008c  2d00              CMP      r5,#0
00008e  d00e              BEQ      |L9.174|
;;;581            {
;;;582                nrf_drv_gpiote_evt_handler_t handler = channel_handler_get(channel_port_get(pin));
000090  9801              LDR      r0,[sp,#4]
000092  f7fffffe          BL       channel_port_get
000096  9000              STR      r0,[sp,#0]
000098  f7fffffe          BL       channel_handler_get
00009c  4607              MOV      r7,r0
;;;583                // Enable the interrupt only if event handler was provided.
;;;584                if (handler)
00009e  2f00              CMP      r7,#0
0000a0  d004              BEQ      |L9.172|
;;;585                {
;;;586                    nrf_gpiote_int_enable(1 << channel);
0000a2  2101              MOVS     r1,#1
0000a4  40a1              LSLS     r1,r1,r4
0000a6  4608              MOV      r0,r1
0000a8  f7fffffe          BL       nrf_gpiote_int_enable
                  |L9.172|
;;;587                }
;;;588            }
0000ac  bf00              NOP      
                  |L9.174|
;;;589        }
0000ae  bf00              NOP      
                  |L9.176|
;;;590    }
0000b0  bdfe              POP      {r1-r7,pc}
;;;591    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L9.180|
                          DCD      m_cb+0x40
                  |L9.184|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_in_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_in_init PROC
;;;499    
;;;500    ret_code_t nrf_drv_gpiote_in_init(nrf_drv_gpiote_pin_t               pin,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;501                                      nrf_drv_gpiote_in_config_t const * p_config,
;;;502                                      nrf_drv_gpiote_evt_handler_t       evt_handler)
;;;503    {
000002  b084              SUB      sp,sp,#0x10
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;504        ASSERT(pin < NUMBER_OF_PINS);
;;;505        ret_code_t err_code = NRF_SUCCESS;
000008  2000              MOVS     r0,#0
00000a  9003              STR      r0,[sp,#0xc]
;;;506    
;;;507        /* Only one GPIOTE channel can be assigned to one physical pin. */
;;;508        if (pin_in_use_by_gpiote(pin))
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       pin_in_use_by_gpiote
000012  2800              CMP      r0,#0
000014  d002              BEQ      |L10.28|
;;;509        {
;;;510            err_code = NRF_ERROR_INVALID_STATE;
000016  2008              MOVS     r0,#8
000018  9003              STR      r0,[sp,#0xc]
00001a  e063              B        |L10.228|
                  |L10.28|
;;;511        }
;;;512        else
;;;513        {
;;;514            int8_t channel = channel_port_alloc(pin, evt_handler, p_config->hi_accuracy);
00001c  78f2              LDRB     r2,[r6,#3]
00001e  4620              MOV      r0,r4
000020  9906              LDR      r1,[sp,#0x18]
000022  f7fffffe          BL       channel_port_alloc
000026  4605              MOV      r5,r0
;;;515            if (channel != NO_CHANNELS)
000028  1c68              ADDS     r0,r5,#1
00002a  2800              CMP      r0,#0
00002c  d057              BEQ      |L10.222|
;;;516            {
;;;517                if (p_config->is_watcher)
00002e  78b0              LDRB     r0,[r6,#2]
000030  2800              CMP      r0,#0
000032  d013              BEQ      |L10.92|
;;;518                {
;;;519                    nrf_gpio_cfg_watcher(pin);
000034  bf00              NOP      
000036  bf00              NOP      
000038  2205              MOVS     r2,#5
00003a  0712              LSLS     r2,r2,#28
00003c  4610              MOV      r0,r2
00003e  00a2              LSLS     r2,r4,#2
000040  2307              MOVS     r3,#7
000042  021b              LSLS     r3,r3,#8
000044  18c3              ADDS     r3,r0,r3
000046  589a              LDR      r2,[r3,r2]
000048  2302              MOVS     r3,#2
00004a  439a              BICS     r2,r2,r3
00004c  4611              MOV      r1,r2
00004e  00a2              LSLS     r2,r4,#2
000050  2307              MOVS     r3,#7
000052  021b              LSLS     r3,r3,#8
000054  18c3              ADDS     r3,r0,r3
000056  5099              STR      r1,[r3,r2]
000058  bf00              NOP      
00005a  e00b              B        |L10.116|
                  |L10.92|
;;;520                }
;;;521                else
;;;522                {
;;;523                    nrf_gpio_cfg_input(pin, p_config->pull);
00005c  7877              LDRB     r7,[r6,#1]
00005e  2000              MOVS     r0,#0
000060  9000              STR      r0,[sp,#0]
000062  463b              MOV      r3,r7
000064  4602              MOV      r2,r0
000066  4601              MOV      r1,r0
000068  9001              STR      r0,[sp,#4]
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       nrf_gpio_cfg
000070  bf00              NOP      
000072  bf00              NOP      
                  |L10.116|
;;;524                }
;;;525    
;;;526                if (p_config->hi_accuracy)
000074  78f0              LDRB     r0,[r6,#3]
000076  2800              CMP      r0,#0
000078  d026              BEQ      |L10.200|
;;;527                {
;;;528                    nrf_gpiote_event_configure(channel, pin, p_config->sense);
00007a  7837              LDRB     r7,[r6,#0]
00007c  481b              LDR      r0,|L10.236|
00007e  2151              MOVS     r1,#0x51
000080  0109              LSLS     r1,r1,#4
000082  1840              ADDS     r0,r0,r1
000084  00a9              LSLS     r1,r5,#2
000086  5840              LDR      r0,[r0,r1]
000088  4919              LDR      r1,|L10.240|
00008a  4008              ANDS     r0,r0,r1
00008c  4917              LDR      r1,|L10.236|
00008e  2251              MOVS     r2,#0x51
000090  0112              LSLS     r2,r2,#4
000092  1889              ADDS     r1,r1,r2
000094  00aa              LSLS     r2,r5,#2
000096  5088              STR      r0,[r1,r2]
000098  4814              LDR      r0,|L10.236|
00009a  2151              MOVS     r1,#0x51
00009c  0109              LSLS     r1,r1,#4
00009e  1840              ADDS     r0,r0,r1
0000a0  00a9              LSLS     r1,r5,#2
0000a2  5841              LDR      r1,[r0,r1]
0000a4  0220              LSLS     r0,r4,#8
0000a6  221f              MOVS     r2,#0x1f
0000a8  0212              LSLS     r2,r2,#8
0000aa  4010              ANDS     r0,r0,r2
0000ac  043a              LSLS     r2,r7,#16
0000ae  2303              MOVS     r3,#3
0000b0  041b              LSLS     r3,r3,#16
0000b2  401a              ANDS     r2,r2,r3
0000b4  4310              ORRS     r0,r0,r2
0000b6  4301              ORRS     r1,r1,r0
0000b8  480c              LDR      r0,|L10.236|
0000ba  2251              MOVS     r2,#0x51
0000bc  0112              LSLS     r2,r2,#4
0000be  1880              ADDS     r0,r0,r2
0000c0  00aa              LSLS     r2,r5,#2
0000c2  5081              STR      r1,[r0,r2]
0000c4  bf00              NOP      
0000c6  e00c              B        |L10.226|
                  |L10.200|
;;;529                }
;;;530                else
;;;531                {
;;;532                    m_cb.port_handlers_pins[channel -
0000c8  1f28              SUBS     r0,r5,#4
0000ca  490a              LDR      r1,|L10.244|
0000cc  5c08              LDRB     r0,[r1,r0]
0000ce  7831              LDRB     r1,[r6,#0]
0000d0  0189              LSLS     r1,r1,#6
0000d2  4308              ORRS     r0,r0,r1
0000d4  b242              SXTB     r2,r0
0000d6  1f28              SUBS     r0,r5,#4
0000d8  4906              LDR      r1,|L10.244|
0000da  540a              STRB     r2,[r1,r0]
0000dc  e001              B        |L10.226|
                  |L10.222|
;;;533                                            GPIOTE_CH_NUM] |= (p_config->sense) << SENSE_FIELD_POS;
;;;534                }
;;;535            }
;;;536            else
;;;537            {
;;;538                err_code = NRF_ERROR_NO_MEM;
0000de  2004              MOVS     r0,#4
0000e0  9003              STR      r0,[sp,#0xc]
                  |L10.226|
;;;539            }
;;;540        }
0000e2  bf00              NOP      
                  |L10.228|
;;;541    
;;;542        NRF_LOG_INFO("Function: %s, error code: %s.\r\n", (uint32_t)__func__,
;;;543                     (uint32_t)ERR_TO_STR(err_code));
;;;544        return err_code;
0000e4  9803              LDR      r0,[sp,#0xc]
;;;545    }
0000e6  b007              ADD      sp,sp,#0x1c
0000e8  bdf0              POP      {r4-r7,pc}
;;;546    
                          ENDP

0000ea  0000              DCW      0x0000
                  |L10.236|
                          DCD      0x40006000
                  |L10.240|
                          DCD      0xfffce0ff
                  |L10.244|
                          DCD      m_cb+0x40

                          AREA ||i.nrf_drv_gpiote_in_is_set||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_is_set PROC
;;;624    
;;;625    bool nrf_drv_gpiote_in_is_set(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;626    {
000002  4604              MOV      r4,r0
;;;627        ASSERT(pin < NUMBER_OF_PINS);
;;;628        return nrf_gpio_pin_read(pin) ? true : false;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_read
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L11.18|
00000e  2001              MOVS     r0,#1
                  |L11.16|
;;;629    }
000010  bd10              POP      {r4,pc}
                  |L11.18|
000012  2000              MOVS     r0,#0                 ;628
000014  e7fc              B        |L11.16|
;;;630    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_in_uninit||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_in_uninit PROC
;;;609    
;;;610    void nrf_drv_gpiote_in_uninit(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;611    {
000002  4604              MOV      r4,r0
;;;612        ASSERT(pin < NUMBER_OF_PINS);
;;;613        ASSERT(pin_in_use_by_gpiote(pin));
;;;614        nrf_drv_gpiote_in_event_disable(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_drv_gpiote_in_event_disable
;;;615        if (pin_in_use_by_te(pin))
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       pin_in_use_by_te
000010  2800              CMP      r0,#0
000012  d005              BEQ      |L12.32|
;;;616        {
;;;617            nrf_gpiote_te_default(channel_port_get(pin));
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       channel_port_get
00001a  4605              MOV      r5,r0
00001c  f7fffffe          BL       nrf_gpiote_te_default
                  |L12.32|
;;;618        }
;;;619        nrf_gpio_cfg_default(pin);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       nrf_gpio_cfg_default
;;;620        channel_free((uint8_t)channel_port_get(pin));
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       channel_port_get
00002c  b2c5              UXTB     r5,r0
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       channel_free
;;;621        pin_in_use_clear(pin);
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       pin_in_use_clear
;;;622    }
00003a  bd70              POP      {r4-r6,pc}
;;;623    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_init PROC
;;;224    
;;;225    ret_code_t nrf_drv_gpiote_init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;226    {
;;;227        ret_code_t err_code;
;;;228    
;;;229        if (m_cb.state != NRF_DRV_STATE_UNINITIALIZED)
000002  4815              LDR      r0,|L13.88|
000004  7900              LDRB     r0,[r0,#4]  ; m_cb
000006  2800              CMP      r0,#0
000008  d002              BEQ      |L13.16|
;;;230        {
;;;231            err_code = NRF_ERROR_INVALID_STATE;
00000a  2508              MOVS     r5,#8
;;;232            NRF_LOG_WARNING("Function: %s, error code: %s.\r\n",
;;;233                            (uint32_t)__func__,
;;;234                            (uint32_t)ERR_TO_STR(err_code));
;;;235            return err_code;
00000c  4628              MOV      r0,r5
                  |L13.14|
;;;236        }
;;;237    
;;;238        uint8_t i;
;;;239    
;;;240        for (i = 0; i < NUMBER_OF_PINS; i++)
;;;241        {
;;;242            pin_in_use_clear(i);
;;;243        }
;;;244    
;;;245        for (i = 0; i < (GPIOTE_CH_NUM + GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS); i++)
;;;246        {
;;;247            channel_free(i);
;;;248        }
;;;249    
;;;250        nrf_drv_common_irq_enable(GPIOTE_IRQn, GPIOTE_CONFIG_IRQ_PRIORITY);
;;;251        nrf_gpiote_event_clear(NRF_GPIOTE_EVENTS_PORT);
;;;252        nrf_gpiote_int_enable(GPIOTE_INTENSET_PORT_Msk);
;;;253        m_cb.state = NRF_DRV_STATE_INITIALIZED;
;;;254    
;;;255        err_code = NRF_SUCCESS;
;;;256        NRF_LOG_INFO("Function: %s, error code: %s.\r\n", (uint32_t)__func__,
;;;257                     (uint32_t)ERR_TO_STR(err_code));
;;;258        return err_code;
;;;259    }
00000e  bd70              POP      {r4-r6,pc}
                  |L13.16|
000010  2400              MOVS     r4,#0                 ;240
000012  e004              B        |L13.30|
                  |L13.20|
000014  4620              MOV      r0,r4                 ;242
000016  f7fffffe          BL       pin_in_use_clear
00001a  1c60              ADDS     r0,r4,#1              ;240
00001c  b2c4              UXTB     r4,r0                 ;240
                  |L13.30|
00001e  2c20              CMP      r4,#0x20              ;240
000020  dbf8              BLT      |L13.20|
000022  2400              MOVS     r4,#0                 ;245
000024  e004              B        |L13.48|
                  |L13.38|
000026  4620              MOV      r0,r4                 ;247
000028  f7fffffe          BL       channel_free
00002c  1c60              ADDS     r0,r4,#1              ;245
00002e  b2c4              UXTB     r4,r0                 ;245
                  |L13.48|
000030  2c08              CMP      r4,#8                 ;245
000032  dbf8              BLT      |L13.38|
000034  2103              MOVS     r1,#3                 ;250
000036  2006              MOVS     r0,#6                 ;250
000038  f7fffffe          BL       nrf_drv_common_irq_enable
00003c  20ff              MOVS     r0,#0xff              ;251
00003e  307d              ADDS     r0,r0,#0x7d           ;251
000040  f7fffffe          BL       nrf_gpiote_event_clear
000044  2001              MOVS     r0,#1                 ;252
000046  07c0              LSLS     r0,r0,#31             ;252
000048  f7fffffe          BL       nrf_gpiote_int_enable
00004c  2101              MOVS     r1,#1                 ;253
00004e  4802              LDR      r0,|L13.88|
000050  7101              STRB     r1,[r0,#4]            ;253
000052  2500              MOVS     r5,#0                 ;255
000054  4628              MOV      r0,r5                 ;258
000056  e7da              B        |L13.14|
;;;260    
                          ENDP

                  |L13.88|
                          DCD      m_cb+0x40

                          AREA ||i.nrf_drv_gpiote_is_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_is_init PROC
;;;261    
;;;262    bool nrf_drv_gpiote_is_init(void)
000000  4803              LDR      r0,|L14.16|
;;;263    {
;;;264        return (m_cb.state != NRF_DRV_STATE_UNINITIALIZED) ? true : false;
000002  7900              LDRB     r0,[r0,#4]  ; m_cb
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L14.12|
000008  2001              MOVS     r0,#1
                  |L14.10|
;;;265    }
00000a  4770              BX       lr
                  |L14.12|
00000c  2000              MOVS     r0,#0                 ;264
00000e  e7fc              B        |L14.10|
;;;266    
                          ENDP

                  |L14.16|
                          DCD      m_cb+0x40

                          AREA ||i.nrf_drv_gpiote_out_clear||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_clear PROC
;;;372    
;;;373    void nrf_drv_gpiote_out_clear(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;374    {
000002  4604              MOV      r4,r0
;;;375        ASSERT(pin < NUMBER_OF_PINS);
;;;376        ASSERT(pin_in_use(pin));
;;;377        ASSERT(!pin_in_use_by_te(pin))
;;;378    
;;;379        nrf_gpio_pin_clear(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_clear
;;;380    }
00000a  bd10              POP      {r4,pc}
;;;381    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_init PROC
;;;292    
;;;293    ret_code_t nrf_drv_gpiote_out_init(nrf_drv_gpiote_pin_t                pin,
000000  b5fe              PUSH     {r1-r7,lr}
;;;294                                       nrf_drv_gpiote_out_config_t const * p_config)
;;;295    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;296        ASSERT(pin < NUMBER_OF_PINS);
;;;297        ASSERT(m_cb.state == NRF_DRV_STATE_INITIALIZED);
;;;298        ASSERT(p_config);
;;;299    
;;;300        ret_code_t err_code = NRF_SUCCESS;
000006  2000              MOVS     r0,#0
000008  9002              STR      r0,[sp,#8]
;;;301    
;;;302        if (pin_in_use(pin))
00000a  4620              MOV      r0,r4
00000c  4936              LDR      r1,|L16.232|
00000e  5609              LDRSB    r1,[r1,r0]
000010  1c49              ADDS     r1,r1,#1
000012  2900              CMP      r1,#0
000014  d001              BEQ      |L16.26|
000016  2101              MOVS     r1,#1
000018  e000              B        |L16.28|
                  |L16.26|
00001a  2100              MOVS     r1,#0
                  |L16.28|
00001c  2900              CMP      r1,#0
00001e  d002              BEQ      |L16.38|
;;;303        {
;;;304            err_code = NRF_ERROR_INVALID_STATE;
000020  2008              MOVS     r0,#8
000022  9002              STR      r0,[sp,#8]
000024  e05d              B        |L16.226|
                  |L16.38|
;;;305        }
;;;306        else
;;;307        {
;;;308            if (p_config->task_pin)
000026  78b0              LDRB     r0,[r6,#2]
000028  2800              CMP      r0,#0
00002a  d03a              BEQ      |L16.162|
;;;309            {
;;;310                int8_t channel = channel_port_alloc(pin, NULL, true);
00002c  2201              MOVS     r2,#1
00002e  2100              MOVS     r1,#0
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       channel_port_alloc
000036  4605              MOV      r5,r0
;;;311    
;;;312                if (channel != NO_CHANNELS)
000038  1c68              ADDS     r0,r5,#1
00003a  2800              CMP      r0,#0
00003c  d02e              BEQ      |L16.156|
;;;313                {
;;;314                    nrf_gpiote_task_configure(channel, pin, p_config->action, p_config->init_state);
00003e  7837              LDRB     r7,[r6,#0]
000040  7872              LDRB     r2,[r6,#1]
000042  9201              STR      r2,[sp,#4]
000044  4829              LDR      r0,|L16.236|
000046  2151              MOVS     r1,#0x51
000048  0109              LSLS     r1,r1,#4
00004a  1840              ADDS     r0,r0,r1
00004c  00a9              LSLS     r1,r5,#2
00004e  5840              LDR      r0,[r0,r1]
000050  4927              LDR      r1,|L16.240|
000052  4008              ANDS     r0,r0,r1
000054  4925              LDR      r1,|L16.236|
000056  2251              MOVS     r2,#0x51
000058  0112              LSLS     r2,r2,#4
00005a  1889              ADDS     r1,r1,r2
00005c  00aa              LSLS     r2,r5,#2
00005e  5088              STR      r0,[r1,r2]
000060  4822              LDR      r0,|L16.236|
000062  2151              MOVS     r1,#0x51
000064  0109              LSLS     r1,r1,#4
000066  1840              ADDS     r0,r0,r1
000068  00a9              LSLS     r1,r5,#2
00006a  5841              LDR      r1,[r0,r1]
00006c  0220              LSLS     r0,r4,#8
00006e  221f              MOVS     r2,#0x1f
000070  0212              LSLS     r2,r2,#8
000072  4010              ANDS     r0,r0,r2
000074  043a              LSLS     r2,r7,#16
000076  2303              MOVS     r3,#3
000078  041b              LSLS     r3,r3,#16
00007a  401a              ANDS     r2,r2,r3
00007c  4310              ORRS     r0,r0,r2
00007e  9a01              LDR      r2,[sp,#4]
000080  0512              LSLS     r2,r2,#20
000082  2301              MOVS     r3,#1
000084  051b              LSLS     r3,r3,#20
000086  401a              ANDS     r2,r2,r3
000088  4310              ORRS     r0,r0,r2
00008a  4301              ORRS     r1,r1,r0
00008c  4817              LDR      r0,|L16.236|
00008e  2251              MOVS     r2,#0x51
000090  0112              LSLS     r2,r2,#4
000092  1880              ADDS     r0,r0,r2
000094  00aa              LSLS     r2,r5,#2
000096  5081              STR      r1,[r0,r2]
000098  bf00              NOP      
00009a  e001              B        |L16.160|
                  |L16.156|
;;;315                }
;;;316                else
;;;317                {
;;;318                    err_code = NRF_ERROR_NO_MEM;
00009c  2004              MOVS     r0,#4
00009e  9002              STR      r0,[sp,#8]
                  |L16.160|
;;;319                }
;;;320            }
0000a0  e006              B        |L16.176|
                  |L16.162|
;;;321            else
;;;322            {
;;;323                pin_in_use_set(pin);
0000a2  bf00              NOP      
0000a4  2101              MOVS     r1,#1
0000a6  43c9              MVNS     r1,r1
0000a8  480f              LDR      r0,|L16.232|
0000aa  5501              STRB     r1,[r0,r4]
0000ac  bf00              NOP      
0000ae  bf00              NOP      
                  |L16.176|
;;;324            }
;;;325    
;;;326            if (err_code == NRF_SUCCESS)
0000b0  9802              LDR      r0,[sp,#8]
0000b2  2800              CMP      r0,#0
0000b4  d115              BNE      |L16.226|
;;;327            {
;;;328                if (p_config->init_state == NRF_GPIOTE_INITIAL_VALUE_HIGH)
0000b6  7870              LDRB     r0,[r6,#1]
0000b8  2801              CMP      r0,#1
0000ba  d103              BNE      |L16.196|
;;;329                {
;;;330                    nrf_gpio_pin_set(pin);
0000bc  4620              MOV      r0,r4
0000be  f7fffffe          BL       nrf_gpio_pin_set
0000c2  e002              B        |L16.202|
                  |L16.196|
;;;331                }
;;;332                else
;;;333                {
;;;334                    nrf_gpio_pin_clear(pin);
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       nrf_gpio_pin_clear
                  |L16.202|
;;;335                }
;;;336    
;;;337                nrf_gpio_cfg_output(pin);
0000ca  bf00              NOP      
0000cc  2000              MOVS     r0,#0
0000ce  9000              STR      r0,[sp,#0]
0000d0  4603              MOV      r3,r0
0000d2  2201              MOVS     r2,#1
0000d4  4611              MOV      r1,r2
0000d6  9001              STR      r0,[sp,#4]
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       nrf_gpio_cfg
0000de  bf00              NOP      
0000e0  bf00              NOP      
                  |L16.226|
;;;338            }
;;;339        }
;;;340    
;;;341        NRF_LOG_INFO("Function: %s, error code: %s.\r\n", (uint32_t)__func__,
;;;342                     (uint32_t)ERR_TO_STR(err_code));
;;;343        return err_code;
0000e2  9802              LDR      r0,[sp,#8]
;;;344    }
0000e4  bdfe              POP      {r1-r7,pc}
;;;345    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L16.232|
                          DCD      m_cb+0x20
                  |L16.236|
                          DCD      0x40006000
                  |L16.240|
                          DCD      0xffece0ff

                          AREA ||i.nrf_drv_gpiote_out_set||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_set PROC
;;;362    
;;;363    void nrf_drv_gpiote_out_set(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;364    {
000002  4604              MOV      r4,r0
;;;365        ASSERT(pin < NUMBER_OF_PINS);
;;;366        ASSERT(pin_in_use(pin));
;;;367        ASSERT(!pin_in_use_by_te(pin))
;;;368    
;;;369        nrf_gpio_pin_set(pin);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpio_pin_set
;;;370    }
00000a  bd10              POP      {r4,pc}
;;;371    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_task_addr_get||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_addr_get PROC
;;;412    
;;;413    uint32_t nrf_drv_gpiote_out_task_addr_get(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;414    {
000002  4605              MOV      r5,r0
;;;415        ASSERT(pin < NUMBER_OF_PINS);
;;;416        ASSERT(pin_in_use_by_te(pin));
;;;417    
;;;418        nrf_gpiote_tasks_t task = TE_OUT_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       channel_port_get
00000a  0680              LSLS     r0,r0,#26
00000c  0e04              LSRS     r4,r0,#24
;;;419        return nrf_gpiote_task_addr_get(task);
00000e  4620              MOV      r0,r4
000010  4901              LDR      r1,|L18.24|
000012  1841              ADDS     r1,r0,r1
000014  4608              MOV      r0,r1
;;;420    }
000016  bd70              POP      {r4-r6,pc}
;;;421    
                          ENDP

                  |L18.24|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_out_task_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_disable PROC
;;;402    
;;;403    void nrf_drv_gpiote_out_task_disable(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;404    {
000002  4601              MOV      r1,r0
;;;405        ASSERT(pin < NUMBER_OF_PINS);
;;;406        ASSERT(pin_in_use(pin));
;;;407        ASSERT(pin_in_use_by_te(pin))
;;;408    
;;;409        nrf_gpiote_task_disable(m_cb.pin_assignments[pin]);
000004  4a08              LDR      r2,|L19.40|
000006  5650              LDRSB    r0,[r2,r1]
000008  4a08              LDR      r2,|L19.44|
00000a  2351              MOVS     r3,#0x51
00000c  011b              LSLS     r3,r3,#4
00000e  18d2              ADDS     r2,r2,r3
000010  0083              LSLS     r3,r0,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0892              LSRS     r2,r2,#2
000016  0092              LSLS     r2,r2,#2
000018  4b04              LDR      r3,|L19.44|
00001a  2451              MOVS     r4,#0x51
00001c  0124              LSLS     r4,r4,#4
00001e  191b              ADDS     r3,r3,r4
000020  0084              LSLS     r4,r0,#2
000022  511a              STR      r2,[r3,r4]
000024  bf00              NOP      
;;;410    }
000026  bd10              POP      {r4,pc}
;;;411    
                          ENDP

                  |L19.40|
                          DCD      m_cb+0x20
                  |L19.44|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_out_task_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_enable PROC
;;;392    
;;;393    void nrf_drv_gpiote_out_task_enable(nrf_drv_gpiote_pin_t pin)
000000  b530              PUSH     {r4,r5,lr}
;;;394    {
000002  4601              MOV      r1,r0
;;;395        ASSERT(pin < NUMBER_OF_PINS);
;;;396        ASSERT(pin_in_use(pin));
;;;397        ASSERT(pin_in_use_by_te(pin))
;;;398    
;;;399        nrf_gpiote_task_enable(m_cb.pin_assignments[pin]);
000004  4a0e              LDR      r2,|L20.64|
000006  5650              LDRSB    r0,[r2,r1]
000008  0083              LSLS     r3,r0,#2
00000a  4c0e              LDR      r4,|L20.68|
00000c  191b              ADDS     r3,r3,r4
00000e  691b              LDR      r3,[r3,#0x10]
000010  2403              MOVS     r4,#3
000012  4323              ORRS     r3,r3,r4
000014  461a              MOV      r2,r3
000016  231f              MOVS     r3,#0x1f
000018  021b              LSLS     r3,r3,#8
00001a  4313              ORRS     r3,r3,r2
00001c  4c0a              LDR      r4,|L20.72|
00001e  2551              MOVS     r5,#0x51
000020  012d              LSLS     r5,r5,#4
000022  1964              ADDS     r4,r4,r5
000024  0085              LSLS     r5,r0,#2
000026  5163              STR      r3,[r4,r5]
000028  bf00              NOP      
00002a  bf00              NOP      
00002c  bf00              NOP      
00002e  4b06              LDR      r3,|L20.72|
000030  2451              MOVS     r4,#0x51
000032  0124              LSLS     r4,r4,#4
000034  191b              ADDS     r3,r3,r4
000036  0084              LSLS     r4,r0,#2
000038  511a              STR      r2,[r3,r4]
00003a  bf00              NOP      
;;;400    }
00003c  bd30              POP      {r4,r5,pc}
;;;401    
                          ENDP

00003e  0000              DCW      0x0000
                  |L20.64|
                          DCD      m_cb+0x20
                  |L20.68|
                          DCD      0x40006500
                  |L20.72|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_out_task_force||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_force PROC
;;;448    
;;;449    void nrf_drv_gpiote_out_task_force(nrf_drv_gpiote_pin_t pin, uint8_t state)
000000  b570              PUSH     {r4-r6,lr}
;;;450    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;451        ASSERT(pin < NUMBER_OF_PINS);
;;;452        ASSERT(pin_in_use(pin));
;;;453        ASSERT(pin_in_use_by_te(pin));
;;;454    
;;;455        nrf_gpiote_outinit_t init_val =
000006  2b00              CMP      r3,#0
000008  d001              BEQ      |L21.14|
;;;456            state ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW;
00000a  2101              MOVS     r1,#1
00000c  e000              B        |L21.16|
                  |L21.14|
00000e  2100              MOVS     r1,#0
                  |L21.16|
000010  4608              MOV      r0,r1
;;;457        nrf_gpiote_task_force(m_cb.pin_assignments[pin], init_val);
000012  4c0c              LDR      r4,|L21.68|
000014  56a1              LDRSB    r1,[r4,r2]
000016  4c0c              LDR      r4,|L21.72|
000018  2551              MOVS     r5,#0x51
00001a  012d              LSLS     r5,r5,#4
00001c  1964              ADDS     r4,r4,r5
00001e  008d              LSLS     r5,r1,#2
000020  5964              LDR      r4,[r4,r5]
000022  2501              MOVS     r5,#1
000024  052d              LSLS     r5,r5,#20
000026  43ac              BICS     r4,r4,r5
000028  0505              LSLS     r5,r0,#20
00002a  2601              MOVS     r6,#1
00002c  0536              LSLS     r6,r6,#20
00002e  4035              ANDS     r5,r5,r6
000030  432c              ORRS     r4,r4,r5
000032  4d05              LDR      r5,|L21.72|
000034  2651              MOVS     r6,#0x51
000036  0136              LSLS     r6,r6,#4
000038  19ad              ADDS     r5,r5,r6
00003a  008e              LSLS     r6,r1,#2
00003c  51ac              STR      r4,[r5,r6]
00003e  bf00              NOP      
;;;458    }
000040  bd70              POP      {r4-r6,pc}
;;;459    
                          ENDP

000042  0000              DCW      0x0000
                  |L21.68|
                          DCD      m_cb+0x20
                  |L21.72|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_out_task_trigger||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_out_task_trigger PROC
;;;460    
;;;461    void nrf_drv_gpiote_out_task_trigger(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;462    {
000002  4604              MOV      r4,r0
;;;463        ASSERT(pin < NUMBER_OF_PINS);
;;;464        ASSERT(pin_in_use(pin));
;;;465        ASSERT(pin_in_use_by_te(pin));
;;;466    
;;;467        nrf_gpiote_tasks_t task = TE_OUT_IDX_TO_TASK_ADDR(channel_port_get(pin));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       channel_port_get
00000a  0680              LSLS     r0,r0,#26
00000c  0e05              LSRS     r5,r0,#24
;;;468        nrf_gpiote_task_set(task);
00000e  bf00              NOP      
000010  2001              MOVS     r0,#1
000012  4902              LDR      r1,|L22.28|
000014  1869              ADDS     r1,r5,r1
000016  6008              STR      r0,[r1,#0]
000018  bf00              NOP      
;;;469    }
00001a  bd70              POP      {r4-r6,pc}
;;;470    
                          ENDP

                  |L22.28|
                          DCD      0x40006000

                          AREA ||i.nrf_drv_gpiote_out_toggle||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_toggle PROC
;;;382    
;;;383    void nrf_drv_gpiote_out_toggle(nrf_drv_gpiote_pin_t pin)
000000  b510              PUSH     {r4,lr}
;;;384    {
;;;385        ASSERT(pin < NUMBER_OF_PINS);
;;;386        ASSERT(pin_in_use(pin));
;;;387        ASSERT(!pin_in_use_by_te(pin))
;;;388    
;;;389        nrf_gpio_pin_toggle(pin);
000002  bf00              NOP      
000004  bf00              NOP      
000006  2305              MOVS     r3,#5
000008  071b              LSLS     r3,r3,#28
00000a  4619              MOV      r1,r3
00000c  151b              ASRS     r3,r3,#20
00000e  18cb              ADDS     r3,r1,r3
000010  685a              LDR      r2,[r3,#4]
000012  2301              MOVS     r3,#1
000014  4083              LSLS     r3,r3,r0
000016  4393              BICS     r3,r3,r2
000018  2405              MOVS     r4,#5
00001a  0224              LSLS     r4,r4,#8
00001c  190c              ADDS     r4,r1,r4
00001e  60a3              STR      r3,[r4,#8]
000020  2301              MOVS     r3,#1
000022  4083              LSLS     r3,r3,r0
000024  4013              ANDS     r3,r3,r2
000026  2405              MOVS     r4,#5
000028  0224              LSLS     r4,r4,#8
00002a  190c              ADDS     r4,r1,r4
00002c  60e3              STR      r3,[r4,#0xc]
00002e  bf00              NOP      
;;;390    }
000030  bd10              POP      {r4,pc}
;;;391    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_out_uninit||, CODE, READONLY, ALIGN=1

                  nrf_drv_gpiote_out_uninit PROC
;;;346    
;;;347    void nrf_drv_gpiote_out_uninit(nrf_drv_gpiote_pin_t pin)
000000  b570              PUSH     {r4-r6,lr}
;;;348    {
000002  4604              MOV      r4,r0
;;;349        ASSERT(pin < NUMBER_OF_PINS);
;;;350        ASSERT(pin_in_use(pin));
;;;351    
;;;352        if (pin_in_use_by_te(pin))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       pin_in_use_by_te
00000a  2800              CMP      r0,#0
00000c  d00c              BEQ      |L24.40|
;;;353        {
;;;354            channel_free((uint8_t)channel_port_get(pin));
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       channel_port_get
000014  b2c5              UXTB     r5,r0
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       channel_free
;;;355            nrf_gpiote_te_default(channel_port_get(pin));
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       channel_port_get
000022  4605              MOV      r5,r0
000024  f7fffffe          BL       nrf_gpiote_te_default
                  |L24.40|
;;;356        }
;;;357        pin_in_use_clear(pin);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       pin_in_use_clear
;;;358    
;;;359        nrf_gpio_cfg_default(pin);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       nrf_gpio_cfg_default
;;;360    }
000034  bd70              POP      {r4-r6,pc}
;;;361    
                          ENDP


                          AREA ||i.nrf_drv_gpiote_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_gpiote_uninit PROC
;;;267    
;;;268    void nrf_drv_gpiote_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;269    {
;;;270        ASSERT(m_cb.state != NRF_DRV_STATE_UNINITIALIZED);
;;;271    
;;;272        uint32_t i;
;;;273    
;;;274        for (i = 0; i < NUMBER_OF_PINS; i++)
000002  2400              MOVS     r4,#0
000004  e017              B        |L25.54|
                  |L25.6|
;;;275        {
;;;276            if (pin_in_use_as_non_task_out(i))
000006  4620              MOV      r0,r4
000008  490e              LDR      r1,|L25.68|
00000a  5609              LDRSB    r1,[r1,r0]
00000c  1c89              ADDS     r1,r1,#2
00000e  2900              CMP      r1,#0
000010  d101              BNE      |L25.22|
000012  2101              MOVS     r1,#1
000014  e000              B        |L25.24|
                  |L25.22|
000016  2100              MOVS     r1,#0
                  |L25.24|
000018  2900              CMP      r1,#0
00001a  d003              BEQ      |L25.36|
;;;277            {
;;;278                nrf_drv_gpiote_out_uninit(i);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       nrf_drv_gpiote_out_uninit
000022  e007              B        |L25.52|
                  |L25.36|
;;;279            }
;;;280            else if ( pin_in_use_by_gpiote(i))
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       pin_in_use_by_gpiote
00002a  2800              CMP      r0,#0
00002c  d002              BEQ      |L25.52|
;;;281            {
;;;282                /* Disable gpiote_in is having the same effect on out pin as gpiote_out_uninit on
;;;283                 * so it can be called on all pins used by GPIOTE.
;;;284                 */
;;;285                nrf_drv_gpiote_in_uninit(i);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       nrf_drv_gpiote_in_uninit
                  |L25.52|
000034  1c64              ADDS     r4,r4,#1              ;274
                  |L25.54|
000036  2c20              CMP      r4,#0x20              ;274
000038  d3e5              BCC      |L25.6|
;;;286            }
;;;287        }
;;;288        m_cb.state = NRF_DRV_STATE_UNINITIALIZED;
00003a  2100              MOVS     r1,#0
00003c  4801              LDR      r0,|L25.68|
00003e  3020              ADDS     r0,r0,#0x20
000040  7101              STRB     r1,[r0,#4]
;;;289        NRF_LOG_INFO("Uninitialized.\r\n");
;;;290    }
000042  bd10              POP      {r4,pc}
;;;291    
                          ENDP

                  |L25.68|
                          DCD      m_cb+0x20

                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg PROC
;;;503    
;;;504    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;505        uint32_t             pin_number,
;;;506        nrf_gpio_pin_dir_t   dir,
;;;507        nrf_gpio_pin_input_t input,
;;;508        nrf_gpio_pin_pull_t  pull,
;;;509        nrf_gpio_pin_drive_t drive,
;;;510        nrf_gpio_pin_sense_t sense)
;;;511    {
;;;512        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000002  bf00              NOP      
000004  2505              MOVS     r5,#5
000006  072d              LSLS     r5,r5,#28
000008  462c              MOV      r4,r5
;;;513    
;;;514        reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
00000a  0055              LSLS     r5,r2,#1
00000c  430d              ORRS     r5,r5,r1
00000e  009e              LSLS     r6,r3,#2
000010  4335              ORRS     r5,r5,r6
000012  9e05              LDR      r6,[sp,#0x14]
000014  0236              LSLS     r6,r6,#8
000016  4335              ORRS     r5,r5,r6
000018  9e06              LDR      r6,[sp,#0x18]
00001a  0436              LSLS     r6,r6,#16
00001c  4335              ORRS     r5,r5,r6
00001e  0086              LSLS     r6,r0,#2
000020  2707              MOVS     r7,#7
000022  023f              LSLS     r7,r7,#8
000024  19e7              ADDS     r7,r4,r7
000026  51bd              STR      r5,[r7,r6]
;;;515                                   | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;516                                   | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
;;;517                                   | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;518                                   | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;519    }
000028  bdf0              POP      {r4-r7,pc}
;;;520    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_default||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_default PROC
;;;545    
;;;546    __STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;547    {
000002  4604              MOV      r4,r0
;;;548        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4601              MOV      r1,r0
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;549            pin_number,
;;;550            NRF_GPIO_PIN_DIR_INPUT,
;;;551            NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;552            NRF_GPIO_PIN_NOPULL,
;;;553            NRF_GPIO_PIN_S0S1,
;;;554            NRF_GPIO_PIN_NOSENSE);
;;;555    }
000016  bd1c              POP      {r2-r4,pc}
;;;556    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_sense_set||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_sense_set PROC
;;;591    
;;;592    __STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
000000  b530              PUSH     {r4,r5,lr}
;;;593    {
000002  460a              MOV      r2,r1
;;;594        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000004  bf00              NOP      
000006  2305              MOVS     r3,#5
000008  071b              LSLS     r3,r3,#28
00000a  4619              MOV      r1,r3
;;;595    
;;;596        /*lint -e{845} // A zero has been given as right argument to operator '|'" */
;;;597        reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
00000c  0083              LSLS     r3,r0,#2
00000e  2407              MOVS     r4,#7
000010  0224              LSLS     r4,r4,#8
000012  190c              ADDS     r4,r1,r4
000014  58e3              LDR      r3,[r4,r3]
000016  2403              MOVS     r4,#3
000018  0424              LSLS     r4,r4,#16
00001a  43a3              BICS     r3,r3,r4
00001c  0084              LSLS     r4,r0,#2
00001e  2507              MOVS     r5,#7
000020  022d              LSLS     r5,r5,#8
000022  194d              ADDS     r5,r1,r5
000024  512b              STR      r3,[r5,r4]
;;;598        reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
000026  0083              LSLS     r3,r0,#2
000028  2407              MOVS     r4,#7
00002a  0224              LSLS     r4,r4,#8
00002c  190c              ADDS     r4,r1,r4
00002e  58e3              LDR      r3,[r4,r3]
000030  0414              LSLS     r4,r2,#16
000032  4323              ORRS     r3,r3,r4
000034  0084              LSLS     r4,r0,#2
000036  2507              MOVS     r5,#7
000038  022d              LSLS     r5,r5,#8
00003a  194d              ADDS     r5,r1,r5
00003c  512b              STR      r3,[r5,r4]
;;;599    }
00003e  bd30              POP      {r4,r5,pc}
;;;600    
                          ENDP


                          AREA ||i.nrf_gpio_pin_clear||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_clear PROC
;;;629    
;;;630    __STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
000000  bf00              NOP      
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
;;;631    {
;;;632        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  460a              MOV      r2,r1
;;;633    
;;;634        nrf_gpio_port_out_clear(reg, 1UL << pin_number);
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
00000c  2305              MOVS     r3,#5
00000e  021b              LSLS     r3,r3,#8
000010  18d3              ADDS     r3,r2,r3
000012  60d9              STR      r1,[r3,#0xc]
000014  bf00              NOP      
;;;635    }
000016  4770              BX       lr
;;;636    
                          ENDP


                          AREA ||i.nrf_gpio_pin_read||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_read PROC
;;;660    
;;;661    __STATIC_INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number)
000000  4601              MOV      r1,r0
;;;662    {
;;;663        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000002  bf00              NOP      
000004  2005              MOVS     r0,#5
000006  0700              LSLS     r0,r0,#28
000008  4602              MOV      r2,r0
;;;664    
;;;665        return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
00000a  bf00              NOP      
00000c  1500              ASRS     r0,r0,#20
00000e  1810              ADDS     r0,r2,r0
000010  6900              LDR      r0,[r0,#0x10]
000012  40c8              LSRS     r0,r0,r1
000014  07c0              LSLS     r0,r0,#31
000016  0fc0              LSRS     r0,r0,#31
;;;666    }
000018  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.nrf_gpio_pin_set||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_set PROC
;;;621    
;;;622    __STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
000000  bf00              NOP      
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
;;;623    {
;;;624        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  460a              MOV      r2,r1
;;;625    
;;;626        nrf_gpio_port_out_set(reg, 1UL << pin_number);
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
00000c  2305              MOVS     r3,#5
00000e  021b              LSLS     r3,r3,#8
000010  18d3              ADDS     r3,r2,r3
000012  6099              STR      r1,[r3,#8]
000014  bf00              NOP      
;;;627    }
000016  4770              BX       lr
;;;628    
                          ENDP


                          AREA ||i.nrf_gpio_ports_read||, CODE, READONLY, ALIGN=2

                  nrf_gpio_ports_read PROC
;;;739    
;;;740    __STATIC_INLINE void nrf_gpio_ports_read(uint32_t start_port, uint32_t length, uint32_t * p_masks)
000000  b578              PUSH     {r3-r6,lr}
;;;741    {
000002  460b              MOV      r3,r1
;;;742        NRF_GPIO_Type * gpio_regs[GPIO_COUNT] = GPIO_REG_LIST;
000004  4c09              LDR      r4,|L32.44|
000006  6824              LDR      r4,[r4,#0]  ; <Data1>
000008  9400              STR      r4,[sp,#0]
;;;743    
;;;744        ASSERT(start_port + length <= GPIO_COUNT);
;;;745        uint32_t i;
;;;746    
;;;747        for (i = start_port; i < (start_port + length); i++)
00000a  4601              MOV      r1,r0
00000c  e009              B        |L32.34|
                  |L32.14|
;;;748        {
;;;749            *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
00000e  008d              LSLS     r5,r1,#2
000010  466e              MOV      r6,sp
000012  5974              LDR      r4,[r6,r5]
000014  2505              MOVS     r5,#5
000016  022d              LSLS     r5,r5,#8
000018  1965              ADDS     r5,r4,r5
00001a  692d              LDR      r5,[r5,#0x10]
00001c  6015              STR      r5,[r2,#0]
;;;750            p_masks++;
00001e  1d12              ADDS     r2,r2,#4
000020  1c49              ADDS     r1,r1,#1              ;747
                  |L32.34|
000022  18c4              ADDS     r4,r0,r3              ;747
000024  428c              CMP      r4,r1                 ;747
000026  d8f2              BHI      |L32.14|
;;;751        }
;;;752    }
000028  bd78              POP      {r3-r6,pc}
;;;753    
                          ENDP

00002a  0000              DCW      0x0000
                  |L32.44|
                          DCD      ||.constdata||

                          AREA ||i.nrf_gpiote_event_addr_get||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_event_addr_get PROC
;;;330    
;;;331    __STATIC_INLINE uint32_t nrf_gpiote_event_addr_get(nrf_gpiote_events_t event)
000000  4601              MOV      r1,r0
;;;332    {
;;;333        return ((uint32_t)NRF_GPIOTE + event);
000002  4801              LDR      r0,|L33.8|
000004  1808              ADDS     r0,r1,r0
;;;334    }
000006  4770              BX       lr
;;;335    
                          ENDP

                  |L33.8|
                          DCD      0x40006000

                          AREA ||i.nrf_gpiote_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_gpiote_event_clear PROC
;;;321    
;;;322    __STATIC_INLINE void nrf_gpiote_event_clear(nrf_gpiote_events_t event)
000000  b510              PUSH     {r4,lr}
;;;323    {
000002  4604              MOV      r4,r0
;;;324        *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpiote_event_addr_get
00000a  2100              MOVS     r1,#0
00000c  6001              STR      r1,[r0,#0]
;;;325    #if __CORTEX_M == 0x04
;;;326        volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
;;;327        (void)dummy;
;;;328    #endif
;;;329    }
00000e  bd10              POP      {r4,pc}
;;;330    
                          ENDP


                          AREA ||i.nrf_gpiote_event_is_set||, CODE, READONLY, ALIGN=1

                  nrf_gpiote_event_is_set PROC
;;;316    
;;;317    __STATIC_INLINE bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event)
000000  b510              PUSH     {r4,lr}
;;;318    {
000002  4604              MOV      r4,r0
;;;319        return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       nrf_gpiote_event_addr_get
00000a  6800              LDR      r0,[r0,#0]
00000c  2801              CMP      r0,#1
00000e  d100              BNE      |L35.18|
                  |L35.16|
;;;320    }
000010  bd10              POP      {r4,pc}
                  |L35.18|
000012  2000              MOVS     r0,#0                 ;319
000014  e7fc              B        |L35.16|
;;;321    
                          ENDP


                          AREA ||i.nrf_gpiote_int_enable||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_int_enable PROC
;;;335    
;;;336    __STATIC_INLINE void nrf_gpiote_int_enable(uint32_t mask)
000000  4901              LDR      r1,|L36.8|
;;;337    {
;;;338        NRF_GPIOTE->INTENSET = mask;
000002  6048              STR      r0,[r1,#4]
;;;339    }
000004  4770              BX       lr
;;;340    
                          ENDP

000006  0000              DCW      0x0000
                  |L36.8|
                          DCD      0x40006300

                          AREA ||i.nrf_gpiote_te_default||, CODE, READONLY, ALIGN=2

                  nrf_gpiote_te_default PROC
;;;417    
;;;418    __STATIC_INLINE void nrf_gpiote_te_default(uint32_t idx)
000000  2100              MOVS     r1,#0
;;;419    {
;;;420        NRF_GPIOTE->CONFIG[idx] = 0;
000002  4a03              LDR      r2,|L37.16|
000004  2351              MOVS     r3,#0x51
000006  011b              LSLS     r3,r3,#4
000008  18d2              ADDS     r2,r2,r3
00000a  0083              LSLS     r3,r0,#2
00000c  50d1              STR      r1,[r2,r3]
;;;421    }
00000e  4770              BX       lr
;;;422    #endif //SUPPRESS_INLINE_IMPLEMENTATION
                          ENDP

                  |L37.16|
                          DCD      0x40006000

                          AREA ||i.pin_in_use_by_gpiote||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_gpiote PROC
;;;145    
;;;146    __STATIC_INLINE bool pin_in_use_by_gpiote(uint32_t pin)
000000  4601              MOV      r1,r0
;;;147    {
;;;148        return (m_cb.pin_assignments[pin] >= 0);
000002  4805              LDR      r0,|L38.24|
000004  5640              LDRSB    r0,[r0,r1]
000006  17c0              ASRS     r0,r0,#31
000008  1c40              ADDS     r0,r0,#1
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L38.18|
00000e  2001              MOVS     r0,#1
                  |L38.16|
;;;149    }
000010  4770              BX       lr
                  |L38.18|
000012  2000              MOVS     r0,#0                 ;148
000014  e7fc              B        |L38.16|
;;;150    
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      m_cb+0x20

                          AREA ||i.pin_in_use_by_port||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_port PROC
;;;139    
;;;140    __STATIC_INLINE bool pin_in_use_by_port(uint32_t pin)
000000  4601              MOV      r1,r0
;;;141    {
;;;142        return (m_cb.pin_assignments[pin] >= GPIOTE_CH_NUM);
000002  4804              LDR      r0,|L39.20|
000004  5640              LDRSB    r0,[r0,r1]
000006  2804              CMP      r0,#4
000008  db01              BLT      |L39.14|
00000a  2001              MOVS     r0,#1
                  |L39.12|
;;;143    }
00000c  4770              BX       lr
                  |L39.14|
00000e  2000              MOVS     r0,#0                 ;142
000010  e7fc              B        |L39.12|
;;;144    
                          ENDP

000012  0000              DCW      0x0000
                  |L39.20|
                          DCD      m_cb+0x20

                          AREA ||i.pin_in_use_by_te||, CODE, READONLY, ALIGN=2

                  pin_in_use_by_te PROC
;;;132    
;;;133    __STATIC_INLINE bool pin_in_use_by_te(uint32_t pin)
000000  4601              MOV      r1,r0
;;;134    {
;;;135        return (m_cb.pin_assignments[pin] >= 0 && m_cb.pin_assignments[pin] <
000002  4806              LDR      r0,|L40.28|
000004  5640              LDRSB    r0,[r0,r1]
000006  2800              CMP      r0,#0
000008  db05              BLT      |L40.22|
00000a  4804              LDR      r0,|L40.28|
00000c  5640              LDRSB    r0,[r0,r1]
00000e  2804              CMP      r0,#4
000010  da01              BGE      |L40.22|
;;;136                GPIOTE_CH_NUM) ? true : false;
000012  2001              MOVS     r0,#1
                  |L40.20|
;;;137    }
000014  4770              BX       lr
                  |L40.22|
000016  2000              MOVS     r0,#0                 ;136
000018  e7fc              B        |L40.20|
;;;138    
                          ENDP

00001a  0000              DCW      0x0000
                  |L40.28|
                          DCD      m_cb+0x20

                          AREA ||i.pin_in_use_clear||, CODE, READONLY, ALIGN=2

                  pin_in_use_clear PROC
;;;171    
;;;172    __STATIC_INLINE void pin_in_use_clear(uint32_t pin)
000000  2200              MOVS     r2,#0
;;;173    {
;;;174        m_cb.pin_assignments[pin] = PIN_NOT_USED;
000002  43d2              MVNS     r2,r2
000004  4901              LDR      r1,|L41.12|
000006  540a              STRB     r2,[r1,r0]
;;;175    }
000008  4770              BX       lr
;;;176    
                          ENDP

00000a  0000              DCW      0x0000
                  |L41.12|
                          DCD      m_cb+0x20

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb
                          %        72

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x50000000
                  __func__
000004  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000008  6472765f          DCB      0x64,0x72,0x76,0x5f
00000c  6770696f          DCB      0x67,0x70,0x69,0x6f
000010  74655f69          DCB      0x74,0x65,0x5f,0x69
000014  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.114|
000018  6e72665f          DCB      0x6e,0x72,0x66,0x5f
00001c  6472765f          DCB      0x64,0x72,0x76,0x5f
000020  6770696f          DCB      0x67,0x70,0x69,0x6f
000024  74655f6f          DCB      0x74,0x65,0x5f,0x6f
000028  75745f69          DCB      0x75,0x74,0x5f,0x69
00002c  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.115|
000030  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000034  6472765f          DCB      0x64,0x72,0x76,0x5f
000038  6770696f          DCB      0x67,0x70,0x69,0x6f
00003c  74655f69          DCB      0x74,0x65,0x5f,0x69
000040  6e5f696e          DCB      0x6e,0x5f,0x69,0x6e
000044  697400            DCB      0x69,0x74,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\gpiote\\nrf_drv_gpiote.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_875a4e72____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_nrf_drv_gpiote_c_875a4e72____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_nrf_drv_gpiote_c_875a4e72____REVSH|
#line 144
|__asm___16_nrf_drv_gpiote_c_875a4e72____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
