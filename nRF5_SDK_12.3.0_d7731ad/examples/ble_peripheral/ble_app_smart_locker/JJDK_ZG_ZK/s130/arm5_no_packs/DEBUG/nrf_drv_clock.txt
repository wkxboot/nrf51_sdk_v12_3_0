; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\nrf_drv_clock.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\nrf_drv_clock.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\nrf_drv_clock.crf ..\..\..\..\..\..\components\drivers_nrf\clock\nrf_drv_clock.c]
                          THUMB

                          AREA ||i.POWER_CLOCK_IRQHandler||, CODE, READONLY, ALIGN=2

                  POWER_CLOCK_IRQHandler PROC
;;;513    #else
;;;514    void POWER_CLOCK_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;515    #endif
;;;516    {
;;;517        if (nrf_clock_event_check(NRF_CLOCK_EVENT_HFCLKSTARTED))
000002  20ff              MOVS     r0,#0xff
000004  3001              ADDS     r0,#1
000006  f7fffffe          BL       nrf_clock_event_check
00000a  2800              CMP      r0,#0
00000c  d00c              BEQ      |L1.40|
;;;518        {
;;;519            nrf_clock_event_clear(NRF_CLOCK_EVENT_HFCLKSTARTED);
00000e  20ff              MOVS     r0,#0xff
000010  3001              ADDS     r0,#1
000012  f7fffffe          BL       nrf_clock_event_clear
;;;520            NRF_LOG_DEBUG("Event: %s.\r\n", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_HFCLKSTARTED));
;;;521            nrf_clock_int_disable(NRF_CLOCK_INT_HF_STARTED_MASK);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       nrf_clock_int_disable
;;;522            m_clock_cb.hfclk_on = true;
00001c  2001              MOVS     r0,#1
00001e  490c              LDR      r1,|L1.80|
000020  7048              STRB     r0,[r1,#1]
;;;523            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       clock_clk_started_notify
                  |L1.40|
;;;524        }
;;;525        if (nrf_clock_event_check(NRF_CLOCK_EVENT_LFCLKSTARTED))
000028  20ff              MOVS     r0,#0xff
00002a  3005              ADDS     r0,#5
00002c  f7fffffe          BL       nrf_clock_event_check
000030  2800              CMP      r0,#0
000032  d00b              BEQ      |L1.76|
;;;526        {
;;;527            nrf_clock_event_clear(NRF_CLOCK_EVENT_LFCLKSTARTED);
000034  20ff              MOVS     r0,#0xff
000036  3005              ADDS     r0,#5
000038  f7fffffe          BL       nrf_clock_event_clear
;;;528            NRF_LOG_DEBUG("Event: %s.\r\n", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_LFCLKSTARTED));
;;;529            nrf_clock_int_disable(NRF_CLOCK_INT_LF_STARTED_MASK);
00003c  2002              MOVS     r0,#2
00003e  f7fffffe          BL       nrf_clock_int_disable
;;;530            m_clock_cb.lfclk_on = true;
000042  2001              MOVS     r0,#1
000044  4902              LDR      r1,|L1.80|
000046  7088              STRB     r0,[r1,#2]
;;;531            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_LFCLK_STARTED);
000048  f7fffffe          BL       clock_clk_started_notify
                  |L1.76|
;;;532        }
;;;533    #if CALIBRATION_SUPPORT
;;;534        if (nrf_clock_event_check(NRF_CLOCK_EVENT_CTTO))
;;;535        {
;;;536            nrf_clock_event_clear(NRF_CLOCK_EVENT_CTTO);
;;;537            NRF_LOG_DEBUG("Event: %s.\r\n", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_CTTO));
;;;538            nrf_clock_int_disable(NRF_CLOCK_INT_CTTO_MASK);
;;;539            nrf_drv_clock_hfclk_request(&m_clock_cb.cal_hfclk_started_handler_item);
;;;540        }
;;;541    
;;;542        if (nrf_clock_event_check(NRF_CLOCK_EVENT_DONE))
;;;543        {
;;;544            nrf_clock_event_clear(NRF_CLOCK_EVENT_DONE);
;;;545            NRF_LOG_DEBUG("Event: %s.\r\n", (uint32_t)EVT_TO_STR(NRF_CLOCK_EVENT_DONE));
;;;546            nrf_clock_int_disable(NRF_CLOCK_INT_DONE_MASK);
;;;547            nrf_drv_clock_hfclk_release();
;;;548            bool aborted = (m_clock_cb.cal_state == CAL_STATE_ABORT);
;;;549            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;550            if (m_clock_cb.cal_done_handler)
;;;551            {
;;;552                m_clock_cb.cal_done_handler(aborted ?
;;;553                    NRF_DRV_CLOCK_EVT_CAL_ABORTED : NRF_DRV_CLOCK_EVT_CAL_DONE);
;;;554            }
;;;555        }
;;;556    #endif // CALIBRATION_SUPPORT
;;;557    }
00004c  bd10              POP      {r4,pc}
;;;558    
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      m_clock_cb

                          AREA ||i.clock_clk_started_notify||, CODE, READONLY, ALIGN=2

                  clock_clk_started_notify PROC
;;;486    
;;;487    __STATIC_INLINE void clock_clk_started_notify(nrf_drv_clock_evt_type_t evt_type)
000000  b570              PUSH     {r4-r6,lr}
;;;488    {
000002  4605              MOV      r5,r0
;;;489        nrf_drv_clock_handler_item_t **p_head;
;;;490        if (evt_type == NRF_DRV_CLOCK_EVT_HFCLK_STARTED)
000004  2d00              CMP      r5,#0
000006  d101              BNE      |L2.12|
;;;491        {
;;;492            p_head = (nrf_drv_clock_handler_item_t **)&m_clock_cb.p_hf_head;
000008  4c09              LDR      r4,|L2.48|
00000a  e001              B        |L2.16|
                  |L2.12|
;;;493        }
;;;494        else
;;;495        {
;;;496            p_head = (nrf_drv_clock_handler_item_t **)&m_clock_cb.p_lf_head;
00000c  4c08              LDR      r4,|L2.48|
00000e  3408              ADDS     r4,r4,#8
                  |L2.16|
;;;497        }
;;;498    
;;;499        while (1)
000010  e00a              B        |L2.40|
                  |L2.18|
;;;500        {
;;;501            nrf_drv_clock_handler_item_t * p_item = item_dequeue(p_head);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       item_dequeue
000018  4606              MOV      r6,r0
;;;502            if (!p_item)
00001a  2e00              CMP      r6,#0
00001c  d100              BNE      |L2.32|
;;;503            {
;;;504                break;
00001e  e004              B        |L2.42|
                  |L2.32|
;;;505            }
;;;506    
;;;507            p_item->event_handler(evt_type);
000020  4628              MOV      r0,r5
000022  6871              LDR      r1,[r6,#4]
000024  4788              BLX      r1
;;;508        }
000026  bf00              NOP      
                  |L2.40|
000028  e7f3              B        |L2.18|
                  |L2.42|
00002a  bf00              NOP                            ;504
;;;509    }
00002c  bd70              POP      {r4-r6,pc}
;;;510    
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      m_clock_cb+0x8

                          AREA ||i.hfclk_start||, CODE, READONLY, ALIGN=1

                  hfclk_start PROC
;;;142    
;;;143    static void hfclk_start(void)
000000  b510              PUSH     {r4,lr}
;;;144    {
;;;145    #ifdef SOFTDEVICE_PRESENT
;;;146        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L3.14|
;;;147        {
;;;148            (void)sd_clock_hfclk_request();
00000a  df49              SVC      #0x49
                  |L3.12|
;;;149            return;
;;;150        }
;;;151    #endif // SOFTDEVICE_PRESENT
;;;152    
;;;153        nrf_clock_event_clear(NRF_CLOCK_EVENT_HFCLKSTARTED);
;;;154        nrf_clock_int_enable(NRF_CLOCK_INT_HF_STARTED_MASK);
;;;155        nrf_clock_task_trigger(NRF_CLOCK_TASK_HFCLKSTART);
;;;156    }
00000c  bd10              POP      {r4,pc}
                  |L3.14|
00000e  20ff              MOVS     r0,#0xff              ;153
000010  3001              ADDS     r0,#1                 ;153
000012  f7fffffe          BL       nrf_clock_event_clear
000016  2001              MOVS     r0,#1                 ;154
000018  f7fffffe          BL       nrf_clock_int_enable
00001c  2000              MOVS     r0,#0                 ;155
00001e  f7fffffe          BL       nrf_clock_task_trigger
000022  bf00              NOP      
000024  e7f2              B        |L3.12|
;;;157    
                          ENDP


                          AREA ||i.hfclk_stop||, CODE, READONLY, ALIGN=2

                  hfclk_stop PROC
;;;157    
;;;158    static void hfclk_stop(void)
000000  b510              PUSH     {r4,lr}
;;;159    {
;;;160    #ifdef SOFTDEVICE_PRESENT
;;;161        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L4.14|
;;;162        {
;;;163            (void)sd_clock_hfclk_release();
00000a  df4a              SVC      #0x4a
                  |L4.12|
;;;164            return;
;;;165        }
;;;166    #endif // SOFTDEVICE_PRESENT
;;;167    
;;;168        nrf_clock_task_trigger(NRF_CLOCK_TASK_HFCLKSTOP);
;;;169        while (nrf_clock_hf_is_running(NRF_CLOCK_HFCLK_HIGH_ACCURACY))
;;;170        {}
;;;171        m_clock_cb.hfclk_on = false;
;;;172    }
00000c  bd10              POP      {r4,pc}
                  |L4.14|
00000e  2004              MOVS     r0,#4                 ;168
000010  f7fffffe          BL       nrf_clock_task_trigger
000014  bf00              NOP                            ;169
                  |L4.22|
000016  2001              MOVS     r0,#1                 ;169
000018  f7fffffe          BL       nrf_clock_hf_is_running
00001c  2800              CMP      r0,#0                 ;169
00001e  d1fa              BNE      |L4.22|
000020  4901              LDR      r1,|L4.40|
000022  7048              STRB     r0,[r1,#1]            ;171
000024  bf00              NOP      
000026  e7f1              B        |L4.12|
;;;173    
                          ENDP

                  |L4.40|
                          DCD      m_clock_cb

                          AREA ||i.item_dequeue||, CODE, READONLY, ALIGN=1

                  item_dequeue PROC
;;;240    
;;;241    static nrf_drv_clock_handler_item_t * item_dequeue(nrf_drv_clock_handler_item_t ** p_head)
000000  4601              MOV      r1,r0
;;;242    {
;;;243        nrf_drv_clock_handler_item_t * p_item = *p_head;
000002  6808              LDR      r0,[r1,#0]
;;;244        if (p_item)
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L5.12|
;;;245        {
;;;246            *p_head = p_item->p_next;
000008  6802              LDR      r2,[r0,#0]
00000a  600a              STR      r2,[r1,#0]
                  |L5.12|
;;;247        }
;;;248        return p_item;
;;;249    }
00000c  4770              BX       lr
;;;250    
                          ENDP


                          AREA ||i.item_enqueue||, CODE, READONLY, ALIGN=1

                  item_enqueue PROC
;;;223    
;;;224    static void item_enqueue(nrf_drv_clock_handler_item_t ** p_head,
000000  6802              LDR      r2,[r0,#0]
;;;225                             nrf_drv_clock_handler_item_t * p_item)
;;;226    {
;;;227        nrf_drv_clock_handler_item_t * p_next = *p_head;
;;;228        while(p_next)
000002  e003              B        |L6.12|
                  |L6.4|
;;;229        {
;;;230            if(p_next == p_item)
000004  428a              CMP      r2,r1
000006  d100              BNE      |L6.10|
                  |L6.8|
;;;231            {
;;;232                return;
;;;233            }
;;;234            p_next = p_next->p_next;
;;;235        }
;;;236    
;;;237        p_item->p_next = (*p_head ? *p_head : NULL);
;;;238        *p_head = p_item;
;;;239    }
000008  4770              BX       lr
                  |L6.10|
00000a  6812              LDR      r2,[r2,#0]            ;234
                  |L6.12|
00000c  2a00              CMP      r2,#0                 ;228
00000e  d1f9              BNE      |L6.4|
000010  6803              LDR      r3,[r0,#0]            ;237
000012  2b00              CMP      r3,#0                 ;237
000014  d001              BEQ      |L6.26|
000016  6803              LDR      r3,[r0,#0]            ;237
000018  e000              B        |L6.28|
                  |L6.26|
00001a  2300              MOVS     r3,#0                 ;237
                  |L6.28|
00001c  600b              STR      r3,[r1,#0]            ;237
00001e  6001              STR      r1,[r0,#0]            ;238
000020  bf00              NOP      
000022  e7f1              B        |L6.8|
;;;240    
                          ENDP


                          AREA ||i.lfclk_start||, CODE, READONLY, ALIGN=1

                  lfclk_start PROC
;;;114     */
;;;115    static void lfclk_start(void)
000000  b510              PUSH     {r4,lr}
;;;116    {
;;;117        nrf_clock_event_clear(NRF_CLOCK_EVENT_LFCLKSTARTED);
000002  20ff              MOVS     r0,#0xff
000004  3005              ADDS     r0,#5
000006  f7fffffe          BL       nrf_clock_event_clear
;;;118        nrf_clock_int_enable(NRF_CLOCK_INT_LF_STARTED_MASK);
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       nrf_clock_int_enable
;;;119        nrf_clock_task_trigger(NRF_CLOCK_TASK_LFCLKSTART);
000010  2008              MOVS     r0,#8
000012  f7fffffe          BL       nrf_clock_task_trigger
;;;120    }
000016  bd10              POP      {r4,pc}
;;;121    
                          ENDP


                          AREA ||i.lfclk_stop||, CODE, READONLY, ALIGN=2

                  lfclk_stop PROC
;;;123     */
;;;124    static void lfclk_stop(void)
000000  b510              PUSH     {r4,lr}
;;;125    {
;;;126    #if CALIBRATION_SUPPORT
;;;127        (void)nrf_drv_clock_calibration_abort();
;;;128    #endif
;;;129    
;;;130    #ifdef SOFTDEVICE_PRESENT
;;;131        // If LFCLK is requested to stop while SD is still enabled,
;;;132        // it indicates an error in the application.
;;;133        // Enabling SD should increment the LFCLK request.
;;;134        ASSERT(!softdevice_handler_is_enabled());
;;;135    #endif // SOFTDEVICE_PRESENT
;;;136    
;;;137        nrf_clock_task_trigger(NRF_CLOCK_TASK_LFCLKSTOP);
000002  200c              MOVS     r0,#0xc
000004  f7fffffe          BL       nrf_clock_task_trigger
;;;138        while (nrf_clock_lf_is_running())
000008  bf00              NOP      
                  |L8.10|
00000a  f7fffffe          BL       nrf_clock_lf_is_running
00000e  2800              CMP      r0,#0
000010  d1fb              BNE      |L8.10|
;;;139        {}
;;;140        m_clock_cb.lfclk_on = false;
000012  4901              LDR      r1,|L8.24|
000014  7088              STRB     r0,[r1,#2]
;;;141    }
000016  bd10              POP      {r4,pc}
;;;142    
                          ENDP

                  |L8.24|
                          DCD      m_clock_cb

                          AREA ||i.nrf_clock_event_check||, CODE, READONLY, ALIGN=1

                  nrf_clock_event_check PROC
;;;325    
;;;326    __STATIC_INLINE bool nrf_clock_event_check(nrf_clock_event_t event)
000000  4601              MOV      r1,r0
;;;327    {
;;;328        return (bool)*((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
000002  2001              MOVS     r0,#1
000004  0780              LSLS     r0,r0,#30
000006  1808              ADDS     r0,r1,r0
000008  6800              LDR      r0,[r0,#0]
00000a  2800              CMP      r0,#0
00000c  d001              BEQ      |L9.18|
00000e  2001              MOVS     r0,#1
                  |L9.16|
;;;329    }
000010  4770              BX       lr
                  |L9.18|
000012  2000              MOVS     r0,#0                 ;328
000014  e7fc              B        |L9.16|
;;;330    
                          ENDP


                          AREA ||i.nrf_clock_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_clock_event_clear PROC
;;;316    
;;;317    __STATIC_INLINE void nrf_clock_event_clear(nrf_clock_event_t event)
000000  2100              MOVS     r1,#0
;;;318    {
;;;319        *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event)) = NRF_CLOCK_EVENT_CLEAR;
000002  2201              MOVS     r2,#1
000004  0792              LSLS     r2,r2,#30
000006  1882              ADDS     r2,r0,r2
000008  6011              STR      r1,[r2,#0]
;;;320    #if __CORTEX_M == 0x04
;;;321        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + event));
;;;322        (void)dummy;
;;;323    #endif
;;;324    }
00000a  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.nrf_clock_hf_is_running||, CODE, READONLY, ALIGN=2

                  nrf_clock_hf_is_running PROC
;;;373    
;;;374    __STATIC_INLINE bool nrf_clock_hf_is_running(nrf_clock_hfclk_t clk_src)
000000  4601              MOV      r1,r0
;;;375    {
;;;376        return (NRF_CLOCK->HFCLKSTAT & (CLOCK_HFCLKSTAT_STATE_Msk | CLOCK_HFCLKSTAT_SRC_Msk)) ==
000002  4806              LDR      r0,|L11.28|
000004  68c0              LDR      r0,[r0,#0xc]
000006  4a06              LDR      r2,|L11.32|
000008  4010              ANDS     r0,r0,r2
00000a  0412              LSLS     r2,r2,#16
00000c  430a              ORRS     r2,r2,r1
00000e  4290              CMP      r0,r2
000010  d101              BNE      |L11.22|
000012  2001              MOVS     r0,#1
                  |L11.20|
;;;377                (CLOCK_HFCLKSTAT_STATE_Msk | (clk_src << CLOCK_HFCLKSTAT_SRC_Pos));
;;;378    }
000014  4770              BX       lr
                  |L11.22|
000016  2000              MOVS     r0,#0                 ;376
000018  e7fc              B        |L11.20|
;;;379    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40000400
                  |L11.32|
                          DCD      0x00010001

                          AREA ||i.nrf_clock_int_disable||, CODE, READONLY, ALIGN=2

                  nrf_clock_int_disable PROC
;;;291    
;;;292    __STATIC_INLINE void nrf_clock_int_disable(uint32_t int_mask)
000000  4901              LDR      r1,|L12.8|
;;;293    {
;;;294        NRF_CLOCK->INTENCLR = int_mask;
000002  6088              STR      r0,[r1,#8]
;;;295    }
000004  4770              BX       lr
;;;296    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40000300

                          AREA ||i.nrf_clock_int_enable||, CODE, READONLY, ALIGN=2

                  nrf_clock_int_enable PROC
;;;286    
;;;287    __STATIC_INLINE void nrf_clock_int_enable(uint32_t int_mask)
000000  4901              LDR      r1,|L13.8|
;;;288    {
;;;289        NRF_CLOCK->INTENSET = int_mask;
000002  6048              STR      r0,[r1,#4]
;;;290    }
000004  4770              BX       lr
;;;291    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40000300

                          AREA ||i.nrf_clock_lf_is_running||, CODE, READONLY, ALIGN=2

                  nrf_clock_lf_is_running PROC
;;;354    
;;;355    __STATIC_INLINE bool nrf_clock_lf_is_running(void)
000000  4803              LDR      r0,|L14.16|
;;;356    {
;;;357        return ((NRF_CLOCK->LFCLKSTAT &
000002  6980              LDR      r0,[r0,#0x18]
000004  2101              MOVS     r1,#1
000006  0409              LSLS     r1,r1,#16
000008  4008              ANDS     r0,r0,r1
00000a  0c00              LSRS     r0,r0,#16
;;;358                 CLOCK_LFCLKSTAT_STATE_Msk) >> CLOCK_LFCLKSTAT_STATE_Pos);
;;;359    }
00000c  4770              BX       lr
;;;360    
                          ENDP

00000e  0000              DCW      0x0000
                  |L14.16|
                          DCD      0x40000400

                          AREA ||i.nrf_clock_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_clock_task_trigger PROC
;;;306    
;;;307    __STATIC_INLINE void nrf_clock_task_trigger(nrf_clock_task_t task)
000000  2101              MOVS     r1,#1
;;;308    {
;;;309        *((volatile uint32_t *)((uint8_t *)NRF_CLOCK + task)) = NRF_CLOCK_TASK_TRIGGER;
000002  078a              LSLS     r2,r1,#30
000004  1882              ADDS     r2,r0,r2
000006  6011              STR      r1,[r2,#0]
;;;310    }
000008  4770              BX       lr
;;;311    
                          ENDP


                          AREA ||i.nrf_drv_clock_calibration_abort||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_calibration_abort PROC
;;;436    
;;;437    ret_code_t nrf_drv_clock_calibration_abort(void)
000000  2000              MOVS     r0,#0
;;;438    {
;;;439        ret_code_t err_code = NRF_SUCCESS;
;;;440    #if CALIBRATION_SUPPORT
;;;441        CRITICAL_REGION_ENTER();
;;;442        switch (m_clock_cb.cal_state)
;;;443        {
;;;444        case CAL_STATE_CT:
;;;445            nrf_clock_int_disable(NRF_CLOCK_INT_CTTO_MASK);
;;;446            nrf_clock_task_trigger(NRF_CLOCK_TASK_CTSTOP);
;;;447            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;448            if (m_clock_cb.cal_done_handler)
;;;449            {
;;;450                m_clock_cb.cal_done_handler(NRF_DRV_CLOCK_EVT_CAL_ABORTED);
;;;451            }
;;;452            break;
;;;453        case CAL_STATE_HFCLK_REQ:
;;;454            /* fall through. */
;;;455        case CAL_STATE_CAL:
;;;456            m_clock_cb.cal_state = CAL_STATE_ABORT;
;;;457            break;
;;;458        default:
;;;459            break;
;;;460        }
;;;461        CRITICAL_REGION_EXIT();
;;;462        
;;;463        NRF_LOG_INFO("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;464        return err_code;
;;;465    #else
;;;466        err_code = NRF_ERROR_FORBIDDEN;
000002  200f              MOVS     r0,#0xf
;;;467        NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;468        return err_code;
;;;469    #endif // CALIBRATION_SUPPORT
;;;470    }
000004  4770              BX       lr
;;;471    
                          ENDP


                          AREA ||i.nrf_drv_clock_calibration_start||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_calibration_start PROC
;;;396    
;;;397    ret_code_t nrf_drv_clock_calibration_start(uint8_t interval, nrf_drv_clock_event_handler_t handler)
000000  4602              MOV      r2,r0
;;;398    {
;;;399        ret_code_t err_code = NRF_SUCCESS;
000002  2000              MOVS     r0,#0
;;;400    #if CALIBRATION_SUPPORT
;;;401        ASSERT(m_clock_cb.cal_state == CAL_STATE_IDLE);
;;;402        if (m_clock_cb.lfclk_on == false)
;;;403        {
;;;404            err_code = NRF_ERROR_INVALID_STATE;
;;;405        }
;;;406        else if (m_clock_cb.cal_state == CAL_STATE_IDLE)
;;;407        {
;;;408            m_clock_cb.cal_done_handler = handler;
;;;409            m_clock_cb.cal_hfclk_started_handler_item.event_handler = clock_calibration_hf_started;
;;;410            if (interval == 0)
;;;411            {
;;;412                m_clock_cb.cal_state = CAL_STATE_HFCLK_REQ;
;;;413                nrf_drv_clock_hfclk_request(&m_clock_cb.cal_hfclk_started_handler_item);
;;;414            }
;;;415            else
;;;416            {
;;;417                m_clock_cb.cal_state = CAL_STATE_CT;
;;;418                nrf_clock_cal_timer_timeout_set(interval);
;;;419                nrf_clock_event_clear(NRF_CLOCK_EVENT_CTTO);
;;;420                nrf_clock_int_enable(NRF_CLOCK_INT_CTTO_MASK);
;;;421                nrf_clock_task_trigger(NRF_CLOCK_TASK_CTSTART);
;;;422            }
;;;423        }
;;;424        else
;;;425        {
;;;426            err_code = NRF_ERROR_BUSY;
;;;427        }
;;;428        NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;429        return err_code;
;;;430    #else
;;;431        err_code = NRF_ERROR_FORBIDDEN;
000004  200f              MOVS     r0,#0xf
;;;432        NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;433        return err_code;
;;;434    #endif // CALIBRATION_SUPPORT
;;;435    }
000006  4770              BX       lr
;;;436    
                          ENDP


                          AREA ||i.nrf_drv_clock_hfclk_is_running||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_hfclk_is_running PROC
;;;358    
;;;359    bool nrf_drv_clock_hfclk_is_running(void)
000000  b508              PUSH     {r3,lr}
;;;360    {
;;;361        ASSERT(m_clock_cb.module_initialized);
;;;362    
;;;363    #ifdef SOFTDEVICE_PRESENT
;;;364        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  2800              CMP      r0,#0
000008  d008              BEQ      |L18.28|
;;;365        {
;;;366            uint32_t is_running;
;;;367            UNUSED_VARIABLE(sd_clock_hfclk_is_running(&is_running));
00000a  4668              MOV      r0,sp
00000c  df4b              SVC      #0x4b
;;;368            return (is_running ? true : false);
00000e  9800              LDR      r0,[sp,#0]
000010  2800              CMP      r0,#0
000012  d001              BEQ      |L18.24|
000014  2001              MOVS     r0,#1
                  |L18.22|
;;;369        }
;;;370    #endif // SOFTDEVICE_PRESENT
;;;371    
;;;372        return nrf_clock_hf_is_running(NRF_CLOCK_HFCLK_HIGH_ACCURACY);
;;;373    }
000016  bd08              POP      {r3,pc}
                  |L18.24|
000018  2000              MOVS     r0,#0                 ;368
00001a  e7fc              B        |L18.22|
                  |L18.28|
00001c  2001              MOVS     r0,#1                 ;372
00001e  f7fffffe          BL       nrf_clock_hf_is_running
000022  e7f8              B        |L18.22|
;;;374    
                          ENDP


                          AREA ||i.nrf_drv_clock_hfclk_release||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_hfclk_release PROC
;;;344    
;;;345    void nrf_drv_clock_hfclk_release(void)
000000  b508              PUSH     {r3,lr}
;;;346    {
;;;347        ASSERT(m_clock_cb.module_initialized);
;;;348        ASSERT(m_clock_cb.hfclk_requests > 0);
;;;349    
;;;350        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;351        --(m_clock_cb.hfclk_requests);
00000c  4807              LDR      r0,|L19.44|
00000e  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000010  1e40              SUBS     r0,r0,#1
000012  4906              LDR      r1,|L19.44|
000014  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;352        if (m_clock_cb.hfclk_requests == 0)
000016  4608              MOV      r0,r1
000018  6840              LDR      r0,[r0,#4]  ; m_clock_cb
00001a  2800              CMP      r0,#0
00001c  d101              BNE      |L19.34|
;;;353        {
;;;354            hfclk_stop();
00001e  f7fffffe          BL       hfclk_stop
                  |L19.34|
;;;355        }
;;;356        CRITICAL_REGION_EXIT();
000022  4668              MOV      r0,sp
000024  7800              LDRB     r0,[r0,#0]
000026  f7fffffe          BL       app_util_critical_region_exit
;;;357    }
00002a  bd08              POP      {r3,pc}
;;;358    
                          ENDP

                  |L19.44|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_hfclk_request||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_hfclk_request PROC
;;;311    
;;;312    void nrf_drv_clock_hfclk_request(nrf_drv_clock_handler_item_t * p_handler_item)
000000  b538              PUSH     {r3-r5,lr}
;;;313    {
000002  4604              MOV      r4,r0
;;;314        ASSERT(m_clock_cb.module_initialized);
;;;315    
;;;316        if (m_clock_cb.hfclk_on)
000004  481a              LDR      r0,|L20.112|
000006  7840              LDRB     r0,[r0,#1]  ; m_clock_cb
000008  2800              CMP      r0,#0
00000a  d013              BEQ      |L20.52|
;;;317        {
;;;318            if (p_handler_item)
00000c  2c00              CMP      r4,#0
00000e  d002              BEQ      |L20.22|
;;;319            {
;;;320                p_handler_item->event_handler(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
000010  2000              MOVS     r0,#0
000012  6861              LDR      r1,[r4,#4]
000014  4788              BLX      r1
                  |L20.22|
;;;321            }
;;;322            CRITICAL_REGION_ENTER();
000016  2100              MOVS     r1,#0
000018  9100              STR      r1,[sp,#0]
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       app_util_critical_region_enter
;;;323            ++(m_clock_cb.hfclk_requests);
000020  4813              LDR      r0,|L20.112|
000022  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000024  1c40              ADDS     r0,r0,#1
000026  4912              LDR      r1,|L20.112|
000028  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;324            CRITICAL_REGION_EXIT();
00002a  4668              MOV      r0,sp
00002c  7800              LDRB     r0,[r0,#0]
00002e  f7fffffe          BL       app_util_critical_region_exit
000032  e01b              B        |L20.108|
                  |L20.52|
;;;325        }
;;;326        else
;;;327        {
;;;328            CRITICAL_REGION_ENTER();
000034  2000              MOVS     r0,#0
000036  9000              STR      r0,[sp,#0]
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       app_util_critical_region_enter
;;;329            if (p_handler_item)
00003e  2c00              CMP      r4,#0
000040  d004              BEQ      |L20.76|
;;;330            {
;;;331                item_enqueue((nrf_drv_clock_handler_item_t **)&m_clock_cb.p_hf_head,
000042  4621              MOV      r1,r4
000044  480a              LDR      r0,|L20.112|
000046  3008              ADDS     r0,r0,#8
000048  f7fffffe          BL       item_enqueue
                  |L20.76|
;;;332                    p_handler_item);
;;;333            }
;;;334            if (m_clock_cb.hfclk_requests == 0)
00004c  4808              LDR      r0,|L20.112|
00004e  6840              LDR      r0,[r0,#4]  ; m_clock_cb
000050  2800              CMP      r0,#0
000052  d101              BNE      |L20.88|
;;;335            {
;;;336                hfclk_start();
000054  f7fffffe          BL       hfclk_start
                  |L20.88|
;;;337            }
;;;338            ++(m_clock_cb.hfclk_requests);
000058  4805              LDR      r0,|L20.112|
00005a  6840              LDR      r0,[r0,#4]  ; m_clock_cb
00005c  1c40              ADDS     r0,r0,#1
00005e  4904              LDR      r1,|L20.112|
000060  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;339            CRITICAL_REGION_EXIT();
000062  4668              MOV      r0,sp
000064  7800              LDRB     r0,[r0,#0]
000066  f7fffffe          BL       app_util_critical_region_exit
00006a  bf00              NOP      
                  |L20.108|
;;;340        }
;;;341    
;;;342        ASSERT(m_clock_cb.hfclk_requests > 0);
;;;343    }
00006c  bd38              POP      {r3-r5,pc}
;;;344    
                          ENDP

00006e  0000              DCW      0x0000
                  |L20.112|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_init PROC
;;;178    
;;;179    ret_code_t nrf_drv_clock_init(void)
000000  b510              PUSH     {r4,lr}
;;;180    {
;;;181        ret_code_t err_code = NRF_SUCCESS;
000002  2400              MOVS     r4,#0
;;;182        if (m_clock_cb.module_initialized)
000004  4817              LDR      r0,|L21.100|
000006  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L21.16|
;;;183        {
;;;184            err_code = NRF_ERROR_MODULE_ALREADY_INITIALIZED;
00000c  2485              MOVS     r4,#0x85
00000e  e027              B        |L21.96|
                  |L21.16|
;;;185        }
;;;186        else
;;;187        {
;;;188            m_clock_cb.p_hf_head      = NULL;
000010  2000              MOVS     r0,#0
000012  4914              LDR      r1,|L21.100|
000014  6088              STR      r0,[r1,#8]  ; m_clock_cb
;;;189            m_clock_cb.hfclk_requests = 0;
000016  6048              STR      r0,[r1,#4]  ; m_clock_cb
;;;190            m_clock_cb.p_lf_head      = NULL;
000018  6108              STR      r0,[r1,#0x10]  ; m_clock_cb
;;;191            m_clock_cb.lfclk_requests = 0;
00001a  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;192            nrf_drv_common_power_clock_irq_init();
00001c  bf00              NOP      
00001e  bf00              NOP      
000020  0941              LSRS     r1,r0,#5
000022  0089              LSLS     r1,r1,#2
000024  4a10              LDR      r2,|L21.104|
000026  1889              ADDS     r1,r1,r2
000028  6809              LDR      r1,[r1,#0]
00002a  2201              MOVS     r2,#1
00002c  4082              LSLS     r2,r2,r0
00002e  4011              ANDS     r1,r1,r2
000030  2900              CMP      r1,#0
000032  d001              BEQ      |L21.56|
000034  2101              MOVS     r1,#1
000036  e000              B        |L21.58|
                  |L21.56|
000038  2100              MOVS     r1,#0
                  |L21.58|
00003a  2900              CMP      r1,#0
00003c  d103              BNE      |L21.70|
00003e  2103              MOVS     r1,#3
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       nrf_drv_common_irq_enable
                  |L21.70|
000046  bf00              NOP      
;;;193    #ifdef SOFTDEVICE_PRESENT
;;;194            if (!softdevice_handler_is_enabled())
000048  f7fffffe          BL       softdevice_handler_is_enabled
00004c  2800              CMP      r0,#0
00004e  d104              BNE      |L21.90|
;;;195    #endif
;;;196            {
;;;197                nrf_clock_lf_src_set((nrf_clock_lfclk_t)CLOCK_CONFIG_LF_SRC);
000050  2001              MOVS     r0,#1
000052  4906              LDR      r1,|L21.108|
000054  6188              STR      r0,[r1,#0x18]
000056  bf00              NOP      
000058  bf00              NOP      
                  |L21.90|
;;;198            }
;;;199    
;;;200    #if CALIBRATION_SUPPORT
;;;201            m_clock_cb.cal_state = CAL_STATE_IDLE;
;;;202    #endif
;;;203    
;;;204            m_clock_cb.module_initialized = true;
00005a  2001              MOVS     r0,#1
00005c  4901              LDR      r1,|L21.100|
00005e  7008              STRB     r0,[r1,#0]
                  |L21.96|
;;;205        }
;;;206    
;;;207        NRF_LOG_INFO("Function: %s, error code: %s.\r\n",
;;;208            (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;209        return err_code;
000060  4620              MOV      r0,r4
;;;210    }
000062  bd10              POP      {r4,pc}
;;;211    
                          ENDP

                  |L21.100|
                          DCD      m_clock_cb
                  |L21.104|
                          DCD      0xe000e100
                  |L21.108|
                          DCD      0x40000500

                          AREA ||i.nrf_drv_clock_init_check||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_init_check PROC
;;;173    
;;;174    bool nrf_drv_clock_init_check(void)
000000  4801              LDR      r0,|L22.8|
;;;175    {
;;;176        return m_clock_cb.module_initialized;
000002  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
;;;177    }
000004  4770              BX       lr
;;;178    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_is_calibrating||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_is_calibrating PROC
;;;471    
;;;472    ret_code_t nrf_drv_clock_is_calibrating(bool * p_is_calibrating)
000000  4601              MOV      r1,r0
;;;473    {
;;;474        ret_code_t err_code = NRF_SUCCESS;
000002  2000              MOVS     r0,#0
;;;475    #if CALIBRATION_SUPPORT
;;;476        ASSERT(m_clock_cb.module_initialized);
;;;477        *p_is_calibrating = (m_clock_cb.cal_state != CAL_STATE_IDLE);
;;;478        NRF_LOG_INFO("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;479        return err_code;
;;;480    #else
;;;481        err_code = NRF_ERROR_FORBIDDEN;
000004  200f              MOVS     r0,#0xf
;;;482        NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;483        return err_code;
;;;484    #endif // CALIBRATION_SUPPORT
;;;485    }
000006  4770              BX       lr
;;;486    
                          ENDP


                          AREA ||i.nrf_drv_clock_lfclk_is_running||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_lfclk_is_running PROC
;;;297    
;;;298    bool nrf_drv_clock_lfclk_is_running(void)
000000  b510              PUSH     {r4,lr}
;;;299    {
;;;300        ASSERT(m_clock_cb.module_initialized);
;;;301    
;;;302    #ifdef SOFTDEVICE_PRESENT
;;;303        if (softdevice_handler_is_enabled())
000002  f7fffffe          BL       softdevice_handler_is_enabled
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L24.14|
;;;304        {
;;;305            return true;
00000a  2001              MOVS     r0,#1
                  |L24.12|
;;;306        }
;;;307    #endif // SOFTDEVICE_PRESENT
;;;308    
;;;309        return nrf_clock_lf_is_running();
;;;310    }
00000c  bd10              POP      {r4,pc}
                  |L24.14|
00000e  f7fffffe          BL       nrf_clock_lf_is_running
000012  e7fb              B        |L24.12|
;;;311    
                          ENDP


                          AREA ||i.nrf_drv_clock_lfclk_release||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_lfclk_release PROC
;;;283    
;;;284    void nrf_drv_clock_lfclk_release(void)
000000  b508              PUSH     {r3,lr}
;;;285    {
;;;286        ASSERT(m_clock_cb.module_initialized);
;;;287        ASSERT(m_clock_cb.lfclk_requests > 0);
;;;288    
;;;289        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;290        --(m_clock_cb.lfclk_requests);
00000c  4807              LDR      r0,|L25.44|
00000e  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000010  1e40              SUBS     r0,r0,#1
000012  4906              LDR      r1,|L25.44|
000014  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;291        if (m_clock_cb.lfclk_requests == 0)
000016  4608              MOV      r0,r1
000018  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00001a  2800              CMP      r0,#0
00001c  d101              BNE      |L25.34|
;;;292        {
;;;293            lfclk_stop();
00001e  f7fffffe          BL       lfclk_stop
                  |L25.34|
;;;294        }
;;;295        CRITICAL_REGION_EXIT();
000022  4668              MOV      r0,sp
000024  7800              LDRB     r0,[r0,#0]
000026  f7fffffe          BL       app_util_critical_region_exit
;;;296    }
00002a  bd08              POP      {r3,pc}
;;;297    
                          ENDP

                  |L25.44|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_lfclk_request||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_lfclk_request PROC
;;;250    
;;;251    void nrf_drv_clock_lfclk_request(nrf_drv_clock_handler_item_t * p_handler_item)
000000  b538              PUSH     {r3-r5,lr}
;;;252    {
000002  4604              MOV      r4,r0
;;;253        ASSERT(m_clock_cb.module_initialized);
;;;254    
;;;255        if (m_clock_cb.lfclk_on)
000004  481a              LDR      r0,|L26.112|
000006  7880              LDRB     r0,[r0,#2]  ; m_clock_cb
000008  2800              CMP      r0,#0
00000a  d013              BEQ      |L26.52|
;;;256        {
;;;257            if (p_handler_item)
00000c  2c00              CMP      r4,#0
00000e  d002              BEQ      |L26.22|
;;;258            {
;;;259                p_handler_item->event_handler(NRF_DRV_CLOCK_EVT_LFCLK_STARTED);
000010  2001              MOVS     r0,#1
000012  6861              LDR      r1,[r4,#4]
000014  4788              BLX      r1
                  |L26.22|
;;;260            }
;;;261            CRITICAL_REGION_ENTER();
000016  2100              MOVS     r1,#0
000018  9100              STR      r1,[sp,#0]
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       app_util_critical_region_enter
;;;262            ++(m_clock_cb.lfclk_requests);
000020  4813              LDR      r0,|L26.112|
000022  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000024  1c40              ADDS     r0,r0,#1
000026  4912              LDR      r1,|L26.112|
000028  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;263            CRITICAL_REGION_EXIT();
00002a  4668              MOV      r0,sp
00002c  7800              LDRB     r0,[r0,#0]
00002e  f7fffffe          BL       app_util_critical_region_exit
000032  e01b              B        |L26.108|
                  |L26.52|
;;;264        }
;;;265        else
;;;266        {
;;;267            CRITICAL_REGION_ENTER();
000034  2000              MOVS     r0,#0
000036  9000              STR      r0,[sp,#0]
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       app_util_critical_region_enter
;;;268            if (p_handler_item)
00003e  2c00              CMP      r4,#0
000040  d004              BEQ      |L26.76|
;;;269            {
;;;270                item_enqueue((nrf_drv_clock_handler_item_t **)&m_clock_cb.p_lf_head,
000042  4621              MOV      r1,r4
000044  480a              LDR      r0,|L26.112|
000046  3010              ADDS     r0,r0,#0x10
000048  f7fffffe          BL       item_enqueue
                  |L26.76|
;;;271                    p_handler_item);
;;;272            }
;;;273            if (m_clock_cb.lfclk_requests == 0)
00004c  4808              LDR      r0,|L26.112|
00004e  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
000050  2800              CMP      r0,#0
000052  d101              BNE      |L26.88|
;;;274            {
;;;275                lfclk_start();
000054  f7fffffe          BL       lfclk_start
                  |L26.88|
;;;276            }
;;;277            ++(m_clock_cb.lfclk_requests);
000058  4805              LDR      r0,|L26.112|
00005a  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00005c  1c40              ADDS     r0,r0,#1
00005e  4904              LDR      r1,|L26.112|
000060  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;278            CRITICAL_REGION_EXIT();
000062  4668              MOV      r0,sp
000064  7800              LDRB     r0,[r0,#0]
000066  f7fffffe          BL       app_util_critical_region_exit
00006a  bf00              NOP      
                  |L26.108|
;;;279        }
;;;280    
;;;281        ASSERT(m_clock_cb.lfclk_requests > 0);
;;;282    }
00006c  bd38              POP      {r3-r5,pc}
;;;283    
                          ENDP

00006e  0000              DCW      0x0000
                  |L26.112|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_on_sd_disable||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_on_sd_disable PROC
;;;582    
;;;583    void nrf_drv_clock_on_sd_disable(void)
000000  b510              PUSH     {r4,lr}
;;;584    {
;;;585        /* Reinit interrupts */
;;;586        ASSERT(m_clock_cb.module_initialized);
;;;587        nrf_drv_common_irq_enable(POWER_CLOCK_IRQn, CLOCK_CONFIG_IRQ_PRIORITY);
000002  2103              MOVS     r1,#3
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       nrf_drv_common_irq_enable
;;;588    
;;;589        /* SD leaves LFCLK enabled - disable it if it is no longer required. */
;;;590        nrf_drv_clock_lfclk_release();
00000a  f7fffffe          BL       nrf_drv_clock_lfclk_release
;;;591    }
00000e  bd10              POP      {r4,pc}
;;;592    
                          ENDP


                          AREA ||i.nrf_drv_clock_on_sd_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_on_sd_enable PROC
;;;568    
;;;569    void nrf_drv_clock_on_sd_enable(void)
000000  b508              PUSH     {r3,lr}
;;;570    {
;;;571        CRITICAL_REGION_ENTER();
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       app_util_critical_region_enter
;;;572        /* Make sure that nrf_drv_clock module is initialized */
;;;573        if (!m_clock_cb.module_initialized)
00000c  4808              LDR      r0,|L28.48|
00000e  7800              LDRB     r0,[r0,#0]  ; m_clock_cb
000010  2800              CMP      r0,#0
000012  d101              BNE      |L28.24|
;;;574        {
;;;575            (void)nrf_drv_clock_init();
000014  f7fffffe          BL       nrf_drv_clock_init
                  |L28.24|
;;;576        }
;;;577        /* SD is one of the LFCLK requesters, but it will enable it by itself. */
;;;578        ++(m_clock_cb.lfclk_requests);
000018  4805              LDR      r0,|L28.48|
00001a  68c0              LDR      r0,[r0,#0xc]  ; m_clock_cb
00001c  1c40              ADDS     r0,r0,#1
00001e  4904              LDR      r1,|L28.48|
000020  60c8              STR      r0,[r1,#0xc]  ; m_clock_cb
;;;579        m_clock_cb.lfclk_on = true;
000022  2001              MOVS     r0,#1
000024  7088              STRB     r0,[r1,#2]
;;;580        CRITICAL_REGION_EXIT();
000026  4668              MOV      r0,sp
000028  7800              LDRB     r0,[r0,#0]
00002a  f7fffffe          BL       app_util_critical_region_exit
;;;581    }
00002e  bd08              POP      {r3,pc}
;;;582    
                          ENDP

                  |L28.48|
                          DCD      m_clock_cb

                          AREA ||i.nrf_drv_clock_on_soc_event||, CODE, READONLY, ALIGN=1

                  nrf_drv_clock_on_soc_event PROC
;;;560    
;;;561    void nrf_drv_clock_on_soc_event(uint32_t evt_id)
000000  b510              PUSH     {r4,lr}
;;;562    {
000002  4604              MOV      r4,r0
;;;563        if (evt_id == NRF_EVT_HFCLKSTARTED)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L29.12|
;;;564        {
;;;565            clock_clk_started_notify(NRF_DRV_CLOCK_EVT_HFCLK_STARTED);
000008  f7fffffe          BL       clock_clk_started_notify
                  |L29.12|
;;;566        }
;;;567    }
00000c  bd10              POP      {r4,pc}
;;;568    
                          ENDP


                          AREA ||i.nrf_drv_clock_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_clock_uninit PROC
;;;211    
;;;212    void nrf_drv_clock_uninit(void)
000000  b510              PUSH     {r4,lr}
;;;213    {
;;;214        ASSERT(m_clock_cb.module_initialized);
;;;215        nrf_drv_common_clock_irq_disable();
000002  f7fffffe          BL       nrf_drv_common_clock_irq_disable
;;;216        nrf_clock_int_disable(0xFFFFFFFF);
000006  2000              MOVS     r0,#0
000008  43c0              MVNS     r0,r0
00000a  f7fffffe          BL       nrf_clock_int_disable
;;;217    
;;;218        lfclk_stop();
00000e  f7fffffe          BL       lfclk_stop
;;;219        hfclk_stop();
000012  f7fffffe          BL       hfclk_stop
;;;220        m_clock_cb.module_initialized = false;
000016  2000              MOVS     r0,#0
000018  4901              LDR      r1,|L30.32|
00001a  7008              STRB     r0,[r1,#0]
;;;221        NRF_LOG_INFO("Uninitialized.\r\n");
;;;222    }
00001c  bd10              POP      {r4,pc}
;;;223    
                          ENDP

00001e  0000              DCW      0x0000
                  |L30.32|
                          DCD      m_clock_cb

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_clock_cb
                          %        20

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __func__
000000  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000004  6472765f          DCB      0x64,0x72,0x76,0x5f
000008  636c6f63          DCB      0x63,0x6c,0x6f,0x63
00000c  6b5f696e          DCB      0x6b,0x5f,0x69,0x6e
000010  697400            DCB      0x69,0x74,0x00
                  |symbol_number.83|
000013  6e                DCB      0x6e
000014  72665f64          DCB      0x72,0x66,0x5f,0x64
000018  72765f63          DCB      0x72,0x76,0x5f,0x63
00001c  6c6f636b          DCB      0x6c,0x6f,0x63,0x6b
000020  5f63616c          DCB      0x5f,0x63,0x61,0x6c
000024  69627261          DCB      0x69,0x62,0x72,0x61
000028  74696f6e          DCB      0x74,0x69,0x6f,0x6e
00002c  5f737461          DCB      0x5f,0x73,0x74,0x61
000030  727400            DCB      0x72,0x74,0x00
                  |symbol_number.84|
000033  6e                DCB      0x6e
000034  72665f64          DCB      0x72,0x66,0x5f,0x64
000038  72765f63          DCB      0x72,0x76,0x5f,0x63
00003c  6c6f636b          DCB      0x6c,0x6f,0x63,0x6b
000040  5f63616c          DCB      0x5f,0x63,0x61,0x6c
000044  69627261          DCB      0x69,0x62,0x72,0x61
000048  74696f6e          DCB      0x74,0x69,0x6f,0x6e
00004c  5f61626f          DCB      0x5f,0x61,0x62,0x6f
000050  727400            DCB      0x72,0x74,0x00
                  |symbol_number.85|
000053  6e                DCB      0x6e
000054  72665f64          DCB      0x72,0x66,0x5f,0x64
000058  72765f63          DCB      0x72,0x76,0x5f,0x63
00005c  6c6f636b          DCB      0x6c,0x6f,0x63,0x6b
000060  5f69735f          DCB      0x5f,0x69,0x73,0x5f
000064  63616c69          DCB      0x63,0x61,0x6c,0x69
000068  62726174          DCB      0x62,0x72,0x61,0x74
00006c  696e6700          DCB      0x69,0x6e,0x67,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\clock\\nrf_drv_clock.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_b202e278____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_nrf_drv_clock_c_b202e278____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_nrf_drv_clock_c_b202e278____REVSH|
#line 144
|__asm___15_nrf_drv_clock_c_b202e278____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
