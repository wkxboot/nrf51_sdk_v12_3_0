L 1 "..\..\..\..\..\..\components\libraries\button\app_button.c"
N/**
N * Copyright (c) 2012 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N#include "sdk_common.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 1
N/**
N * Copyright (c) 2013 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @cond */
N/**@file
N *
N * @ingroup experimental_api
N * @defgroup sdk_common SDK Common Header
N * @brief All common headers needed for SDK examples will be included here so that application
N *       developer does not have to include headers on him/herself.
N * @{
N */
N
N#ifndef SDK_COMMON_H__
N#define SDK_COMMON_H__
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050041
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 55 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5050041
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 56 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5050041
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 57 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "sdk_config.h"
L 1 "..\config\sdk_config.h" 1
N
N
N#ifndef SDK_CONFIG_H
N#define SDK_CONFIG_H
N// <<< Use Configuration Wizard in Context Menu >>>\n
N#ifdef USE_APP_CONFIG
S#include "app_config.h"
N#endif
N// <h> nRF_BLE 
N
N//==========================================================
N// <q> BLE_ADVERTISING_ENABLED  - ble_advertising - Advertising module
N 
N
N#ifndef BLE_ADVERTISING_ENABLED
N#define BLE_ADVERTISING_ENABLED 1
N#endif
N
N// <q> BLE_DTM_ENABLED  - ble_dtm - Module for testing RF/PHY using DTM commands
N 
N
N#ifndef BLE_DTM_ENABLED
N#define BLE_DTM_ENABLED 0
N#endif
N
N// <q> BLE_RACP_ENABLED  - ble_racp - Record Access Control Point library
N 
N
N#ifndef BLE_RACP_ENABLED
N#define BLE_RACP_ENABLED 0
N#endif
N
N// <q> NRF_BLE_QWR_ENABLED  - nrf_ble_qwr - Queued writes support module (prepare/execute write)
N 
N
N#ifndef NRF_BLE_QWR_ENABLED
N#define NRF_BLE_QWR_ENABLED 0
N#endif
N
N// <q> PEER_MANAGER_ENABLED  - peer_manager - Peer Manager
N 
N
N#ifndef PEER_MANAGER_ENABLED
N#define PEER_MANAGER_ENABLED 1
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_BLE_Services 
N
N//==========================================================
N// <q> BLE_ANCS_C_ENABLED  - ble_ancs_c - Apple Notification Service Client
N 
N
N#ifndef BLE_ANCS_C_ENABLED
N#define BLE_ANCS_C_ENABLED 0
N#endif
N
N// <q> BLE_ANS_C_ENABLED  - ble_ans_c - Alert Notification Service Client
N 
N
N#ifndef BLE_ANS_C_ENABLED
N#define BLE_ANS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_C_ENABLED  - ble_bas_c - Battery Service Client
N 
N
N#ifndef BLE_BAS_C_ENABLED
N#define BLE_BAS_C_ENABLED 0
N#endif
N
N// <q> BLE_BAS_ENABLED  - ble_bas - Battery Service
N 
N
N#ifndef BLE_BAS_ENABLED
N#define BLE_BAS_ENABLED 0
N#endif
N
N// <q> BLE_CSCS_ENABLED  - ble_cscs - Cycling Speed and Cadence Service
N 
N
N#ifndef BLE_CSCS_ENABLED
N#define BLE_CSCS_ENABLED 0
N#endif
N
N// <q> BLE_CTS_C_ENABLED  - ble_cts_c - Current Time Service Client
N 
N
N#ifndef BLE_CTS_C_ENABLED
N#define BLE_CTS_C_ENABLED 0
N#endif
N
N// <q> BLE_DIS_ENABLED  - ble_dis - Device Information Service
N 
N
N#ifndef BLE_DIS_ENABLED
N#define BLE_DIS_ENABLED 0
N#endif
N
N// <q> BLE_GLS_ENABLED  - ble_gls - Glucose Service
N 
N
N#ifndef BLE_GLS_ENABLED
N#define BLE_GLS_ENABLED 0
N#endif
N
N// <q> BLE_HIDS_ENABLED  - ble_hids - Human Interface Device Service
N 
N
N#ifndef BLE_HIDS_ENABLED
N#define BLE_HIDS_ENABLED 0
N#endif
N
N// <e> BLE_HRS_C_ENABLED - ble_hrs_c - Heart Rate Service Client
N//==========================================================
N#ifndef BLE_HRS_C_ENABLED
N#define BLE_HRS_C_ENABLED 0
N#endif
N#if  BLE_HRS_C_ENABLED
X#if  0
S// <o> BLE_HRS_C_RR_INTERVALS_MAX_CNT - Maximum number of RR_INTERVALS per notification to be decoded 
S#ifndef BLE_HRS_C_RR_INTERVALS_MAX_CNT
S#define BLE_HRS_C_RR_INTERVALS_MAX_CNT 30
S#endif
S
N#endif //BLE_HRS_C_ENABLED
N// </e>
N
N// <q> BLE_HRS_ENABLED  - ble_hrs - Heart Rate Service
N 
N
N#ifndef BLE_HRS_ENABLED
N#define BLE_HRS_ENABLED 0
N#endif
N
N// <q> BLE_HTS_ENABLED  - ble_hts - Health Thermometer Service
N 
N
N#ifndef BLE_HTS_ENABLED
N#define BLE_HTS_ENABLED 0
N#endif
N
N// <q> BLE_IAS_C_ENABLED  - ble_ias_c - Immediate Alert Service Client
N 
N
N#ifndef BLE_IAS_C_ENABLED
N#define BLE_IAS_C_ENABLED 0
N#endif
N
N// <q> BLE_IAS_ENABLED  - ble_ias - Immediate Alert Service
N 
N
N#ifndef BLE_IAS_ENABLED
N#define BLE_IAS_ENABLED 0
N#endif
N
N// <q> BLE_LBS_C_ENABLED  - ble_lbs_c - Nordic LED Button Service Client
N 
N
N#ifndef BLE_LBS_C_ENABLED
N#define BLE_LBS_C_ENABLED 0
N#endif
N
N// <q> BLE_LBS_ENABLED  - ble_lbs - LED Button Service
N 
N
N#ifndef BLE_LBS_ENABLED
N#define BLE_LBS_ENABLED 0
N#endif
N
N// <q> BLE_LLS_ENABLED  - ble_lls - Link Loss Service
N 
N
N#ifndef BLE_LLS_ENABLED
N#define BLE_LLS_ENABLED 0
N#endif
N
N// <q> BLE_NUS_C_ENABLED  - ble_nus_c - Nordic UART Central Service
N 
N
N#ifndef BLE_NUS_C_ENABLED
N#define BLE_NUS_C_ENABLED 0
N#endif
N
N// <q> BLE_NUS_ENABLED  - ble_nus - Nordic UART Service
N 
N
N#ifndef BLE_NUS_ENABLED
N#define BLE_NUS_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_C_ENABLED  - ble_rscs_c - Running Speed and Cadence Client
N 
N
N#ifndef BLE_RSCS_C_ENABLED
N#define BLE_RSCS_C_ENABLED 0
N#endif
N
N// <q> BLE_RSCS_ENABLED  - ble_rscs - Running Speed and Cadence Service
N 
N
N#ifndef BLE_RSCS_ENABLED
N#define BLE_RSCS_ENABLED 0
N#endif
N
N// <q> BLE_TPS_ENABLED  - ble_tps - TX Power Service
N 
N
N#ifndef BLE_TPS_ENABLED
N#define BLE_TPS_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Drivers 
N
N//==========================================================
N// <e> ADC_ENABLED - nrf_drv_adc - Driver for ADC peripheral (nRF51)
N//==========================================================
N#ifndef ADC_ENABLED
N#define ADC_ENABLED 0
N#endif
N#if  ADC_ENABLED
X#if  0
S// <o> ADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef ADC_CONFIG_IRQ_PRIORITY
S#define ADC_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> ADC_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef ADC_CONFIG_LOG_ENABLED
S#define ADC_CONFIG_LOG_ENABLED 0
S#endif
S#if  ADC_CONFIG_LOG_ENABLED
S// <o> ADC_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef ADC_CONFIG_LOG_LEVEL
S#define ADC_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> ADC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef ADC_CONFIG_INFO_COLOR
S#define ADC_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> ADC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef ADC_CONFIG_DEBUG_COLOR
S#define ADC_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //ADC_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //ADC_ENABLED
N// </e>
N
N// <e> APP_USBD_ENABLED - app_usbd - USB Device library
N//==========================================================
N#ifndef APP_USBD_ENABLED
N#define APP_USBD_ENABLED 0
N#endif
N#if  APP_USBD_ENABLED
X#if  0
S// <o> APP_USBD_VID - Vendor ID  <0x0000-0xFFFF> 
S
S
S// <i> Vendor ID ordered from USB IF: http://www.usb.org/developers/vendor/
S
S#ifndef APP_USBD_VID
S#define APP_USBD_VID 0
S#endif
S
S// <o> APP_USBD_PID - Product ID  <0x0000-0xFFFF> 
S
S
S// <i> Selected Product ID
S
S#ifndef APP_USBD_PID
S#define APP_USBD_PID 0
S#endif
S
S// <o> APP_USBD_DEVICE_VER_MAJOR - Device version, major part  <0-99> 
S
S
S// <i> Device version, will be converted automatically to BCD notation. Use just decimal values.
S
S#ifndef APP_USBD_DEVICE_VER_MAJOR
S#define APP_USBD_DEVICE_VER_MAJOR 1
S#endif
S
S// <o> APP_USBD_DEVICE_VER_MINOR - Device version, minor part  <0-99> 
S
S
S// <i> Device version, will be converted automatically to BCD notation. Use just decimal values.
S
S#ifndef APP_USBD_DEVICE_VER_MINOR
S#define APP_USBD_DEVICE_VER_MINOR 0
S#endif
S
N#endif //APP_USBD_ENABLED
N// </e>
N
N// <e> CLOCK_ENABLED - nrf_drv_clock - CLOCK peripheral driver
N//==========================================================
N#ifndef CLOCK_ENABLED
N#define CLOCK_ENABLED 1
N#endif
N#if  CLOCK_ENABLED
X#if  1
N// <o> CLOCK_CONFIG_XTAL_FREQ  - HF XTAL Frequency
N 
N// <0=> Default (64 MHz) 
N// <255=> Default (16 MHz) 
N// <0=> 32 MHz 
N
N#ifndef CLOCK_CONFIG_XTAL_FREQ
N#define CLOCK_CONFIG_XTAL_FREQ 255
N#endif
N
N// <o> CLOCK_CONFIG_LF_SRC  - LF Clock Source
N 
N// <0=> RC 
N// <1=> XTAL 
N// <2=> Synth 
N
N#ifndef CLOCK_CONFIG_LF_SRC
N#define CLOCK_CONFIG_LF_SRC 1
N#endif
N
N// <o> CLOCK_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N
N#ifndef CLOCK_CONFIG_IRQ_PRIORITY
N#define CLOCK_CONFIG_IRQ_PRIORITY 3
N#endif
N
N// <e> CLOCK_CONFIG_LOG_ENABLED - Enables logging in the module.
N//==========================================================
N#ifndef CLOCK_CONFIG_LOG_ENABLED
N#define CLOCK_CONFIG_LOG_ENABLED 0
N#endif
N#if  CLOCK_CONFIG_LOG_ENABLED
X#if  0
S// <o> CLOCK_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef CLOCK_CONFIG_LOG_LEVEL
S#define CLOCK_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> CLOCK_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef CLOCK_CONFIG_INFO_COLOR
S#define CLOCK_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> CLOCK_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef CLOCK_CONFIG_DEBUG_COLOR
S#define CLOCK_CONFIG_DEBUG_COLOR 0
S#endif
S
N#endif //CLOCK_CONFIG_LOG_ENABLED
N// </e>
N
N#endif //CLOCK_ENABLED
N// </e>
N
N// <e> COMP_ENABLED - nrf_drv_comp - COMP peripheral driver
N//==========================================================
N#ifndef COMP_ENABLED
N#define COMP_ENABLED 0
N#endif
N#if  COMP_ENABLED
X#if  0
S// <o> COMP_CONFIG_REF  - Reference voltage
S 
S// <0=> Internal 1.2V 
S// <1=> Internal 1.8V 
S// <2=> Internal 2.4V 
S// <4=> VDD 
S// <7=> ARef 
S
S#ifndef COMP_CONFIG_REF
S#define COMP_CONFIG_REF 1
S#endif
S
S// <o> COMP_CONFIG_MAIN_MODE  - Main mode
S 
S// <0=> Single ended 
S// <1=> Differential 
S
S#ifndef COMP_CONFIG_MAIN_MODE
S#define COMP_CONFIG_MAIN_MODE 0
S#endif
S
S// <o> COMP_CONFIG_SPEED_MODE  - Speed mode
S 
S// <0=> Low power 
S// <1=> Normal 
S// <2=> High speed 
S
S#ifndef COMP_CONFIG_SPEED_MODE
S#define COMP_CONFIG_SPEED_MODE 2
S#endif
S
S// <o> COMP_CONFIG_HYST  - Hystheresis
S 
S// <0=> No 
S// <1=> 50mV 
S
S#ifndef COMP_CONFIG_HYST
S#define COMP_CONFIG_HYST 0
S#endif
S
S// <o> COMP_CONFIG_ISOURCE  - Current Source
S 
S// <0=> Off 
S// <1=> 2.5 uA 
S// <2=> 5 uA 
S// <3=> 10 uA 
S
S#ifndef COMP_CONFIG_ISOURCE
S#define COMP_CONFIG_ISOURCE 0
S#endif
S
S// <o> COMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef COMP_CONFIG_INPUT
S#define COMP_CONFIG_INPUT 0
S#endif
S
S// <o> COMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef COMP_CONFIG_IRQ_PRIORITY
S#define COMP_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> COMP_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef COMP_CONFIG_LOG_ENABLED
S#define COMP_CONFIG_LOG_ENABLED 0
S#endif
S#if  COMP_CONFIG_LOG_ENABLED
S// <o> COMP_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef COMP_CONFIG_LOG_LEVEL
S#define COMP_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> COMP_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef COMP_CONFIG_INFO_COLOR
S#define COMP_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> COMP_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef COMP_CONFIG_DEBUG_COLOR
S#define COMP_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //COMP_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //COMP_ENABLED
N// </e>
N
N// <e> EGU_ENABLED - nrf_drv_swi - SWI(EGU) peripheral driver
N//==========================================================
N#ifndef EGU_ENABLED
N#define EGU_ENABLED 0
N#endif
N#if  EGU_ENABLED
X#if  0
S// <e> SWI_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef SWI_CONFIG_LOG_ENABLED
S#define SWI_CONFIG_LOG_ENABLED 0
S#endif
S#if  SWI_CONFIG_LOG_ENABLED
S// <o> SWI_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef SWI_CONFIG_LOG_LEVEL
S#define SWI_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> SWI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SWI_CONFIG_INFO_COLOR
S#define SWI_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> SWI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SWI_CONFIG_DEBUG_COLOR
S#define SWI_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //SWI_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //EGU_ENABLED
N// </e>
N
N// <e> GPIOTE_ENABLED - nrf_drv_gpiote - GPIOTE peripheral driver
N//==========================================================
N#ifndef GPIOTE_ENABLED
N#define GPIOTE_ENABLED 1
N#endif
N#if  GPIOTE_ENABLED
X#if  1
N// <o> GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS - Number of lower power input pins 
N#ifndef GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS
N#define GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS 4
N#endif
N
N// <o> GPIOTE_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N
N#ifndef GPIOTE_CONFIG_IRQ_PRIORITY
N#define GPIOTE_CONFIG_IRQ_PRIORITY 3
N#endif
N
N// <e> GPIOTE_CONFIG_LOG_ENABLED - Enables logging in the module.
N//==========================================================
N#ifndef GPIOTE_CONFIG_LOG_ENABLED
N#define GPIOTE_CONFIG_LOG_ENABLED 0
N#endif
N#if  GPIOTE_CONFIG_LOG_ENABLED
X#if  0
S// <o> GPIOTE_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef GPIOTE_CONFIG_LOG_LEVEL
S#define GPIOTE_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> GPIOTE_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef GPIOTE_CONFIG_INFO_COLOR
S#define GPIOTE_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> GPIOTE_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef GPIOTE_CONFIG_DEBUG_COLOR
S#define GPIOTE_CONFIG_DEBUG_COLOR 0
S#endif
S
N#endif //GPIOTE_CONFIG_LOG_ENABLED
N// </e>
N
N#endif //GPIOTE_ENABLED
N// </e>
N
N// <e> I2S_ENABLED - nrf_drv_i2s - I2S peripheral driver
N//==========================================================
N#ifndef I2S_ENABLED
N#define I2S_ENABLED 0
N#endif
N#if  I2S_ENABLED
X#if  0
S// <o> I2S_CONFIG_SCK_PIN - SCK pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SCK_PIN
S#define I2S_CONFIG_SCK_PIN 31
S#endif
S
S// <o> I2S_CONFIG_LRCK_PIN - LRCK pin  <1-31> 
S
S
S#ifndef I2S_CONFIG_LRCK_PIN
S#define I2S_CONFIG_LRCK_PIN 30
S#endif
S
S// <o> I2S_CONFIG_MCK_PIN - MCK pin 
S#ifndef I2S_CONFIG_MCK_PIN
S#define I2S_CONFIG_MCK_PIN 255
S#endif
S
S// <o> I2S_CONFIG_SDOUT_PIN - SDOUT pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDOUT_PIN
S#define I2S_CONFIG_SDOUT_PIN 29
S#endif
S
S// <o> I2S_CONFIG_SDIN_PIN - SDIN pin  <0-31> 
S
S
S#ifndef I2S_CONFIG_SDIN_PIN
S#define I2S_CONFIG_SDIN_PIN 28
S#endif
S
S// <o> I2S_CONFIG_MASTER  - Mode
S 
S// <0=> Master 
S// <1=> Slave 
S
S#ifndef I2S_CONFIG_MASTER
S#define I2S_CONFIG_MASTER 0
S#endif
S
S// <o> I2S_CONFIG_FORMAT  - Format
S 
S// <0=> I2S 
S// <1=> Aligned 
S
S#ifndef I2S_CONFIG_FORMAT
S#define I2S_CONFIG_FORMAT 0
S#endif
S
S// <o> I2S_CONFIG_ALIGN  - Alignment
S 
S// <0=> Left 
S// <1=> Right 
S
S#ifndef I2S_CONFIG_ALIGN
S#define I2S_CONFIG_ALIGN 0
S#endif
S
S// <o> I2S_CONFIG_SWIDTH  - Sample width (bits)
S 
S// <0=> 8 
S// <1=> 16 
S// <2=> 24 
S
S#ifndef I2S_CONFIG_SWIDTH
S#define I2S_CONFIG_SWIDTH 1
S#endif
S
S// <o> I2S_CONFIG_CHANNELS  - Channels
S 
S// <0=> Stereo 
S// <1=> Left 
S// <2=> Right 
S
S#ifndef I2S_CONFIG_CHANNELS
S#define I2S_CONFIG_CHANNELS 1
S#endif
S
S// <o> I2S_CONFIG_MCK_SETUP  - MCK behavior
S 
S// <0=> Disabled 
S// <2147483648=> 32MHz/2 
S// <1342177280=> 32MHz/3 
S// <1073741824=> 32MHz/4 
S// <805306368=> 32MHz/5 
S// <671088640=> 32MHz/6 
S// <536870912=> 32MHz/8 
S// <402653184=> 32MHz/10 
S// <369098752=> 32MHz/11 
S// <285212672=> 32MHz/15 
S// <268435456=> 32MHz/16 
S// <201326592=> 32MHz/21 
S// <184549376=> 32MHz/23 
S// <142606336=> 32MHz/30 
S// <138412032=> 32MHz/31 
S// <134217728=> 32MHz/32 
S// <100663296=> 32MHz/42 
S// <68157440=> 32MHz/63 
S// <34340864=> 32MHz/125 
S
S#ifndef I2S_CONFIG_MCK_SETUP
S#define I2S_CONFIG_MCK_SETUP 536870912
S#endif
S
S// <o> I2S_CONFIG_RATIO  - MCK/LRCK ratio
S 
S// <0=> 32x 
S// <1=> 48x 
S// <2=> 64x 
S// <3=> 96x 
S// <4=> 128x 
S// <5=> 192x 
S// <6=> 256x 
S// <7=> 384x 
S// <8=> 512x 
S
S#ifndef I2S_CONFIG_RATIO
S#define I2S_CONFIG_RATIO 2000
S#endif
S
S// <o> I2S_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef I2S_CONFIG_IRQ_PRIORITY
S#define I2S_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> I2S_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef I2S_CONFIG_LOG_ENABLED
S#define I2S_CONFIG_LOG_ENABLED 0
S#endif
S#if  I2S_CONFIG_LOG_ENABLED
S// <o> I2S_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef I2S_CONFIG_LOG_LEVEL
S#define I2S_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> I2S_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef I2S_CONFIG_INFO_COLOR
S#define I2S_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> I2S_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef I2S_CONFIG_DEBUG_COLOR
S#define I2S_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //I2S_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //I2S_ENABLED
N// </e>
N
N// <e> LPCOMP_ENABLED - nrf_drv_lpcomp - LPCOMP peripheral driver
N//==========================================================
N#ifndef LPCOMP_ENABLED
N#define LPCOMP_ENABLED 0
N#endif
N#if  LPCOMP_ENABLED
X#if  0
S// <o> LPCOMP_CONFIG_REFERENCE  - Reference voltage
S 
S// <0=> Supply 1/8 
S// <1=> Supply 2/8 
S// <2=> Supply 3/8 
S// <3=> Supply 4/8 
S// <4=> Supply 5/8 
S// <5=> Supply 6/8 
S// <6=> Supply 7/8 
S// <8=> Supply 1/16 (nRF52) 
S// <9=> Supply 3/16 (nRF52) 
S// <10=> Supply 5/16 (nRF52) 
S// <11=> Supply 7/16 (nRF52) 
S// <12=> Supply 9/16 (nRF52) 
S// <13=> Supply 11/16 (nRF52) 
S// <14=> Supply 13/16 (nRF52) 
S// <15=> Supply 15/16 (nRF52) 
S// <7=> External Ref 0 
S// <65543=> External Ref 1 
S
S#ifndef LPCOMP_CONFIG_REFERENCE
S#define LPCOMP_CONFIG_REFERENCE 3
S#endif
S
S// <o> LPCOMP_CONFIG_DETECTION  - Detection
S 
S// <0=> Crossing 
S// <1=> Up 
S// <2=> Down 
S
S#ifndef LPCOMP_CONFIG_DETECTION
S#define LPCOMP_CONFIG_DETECTION 2
S#endif
S
S// <o> LPCOMP_CONFIG_INPUT  - Analog input
S 
S// <0=> 0 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef LPCOMP_CONFIG_INPUT
S#define LPCOMP_CONFIG_INPUT 0
S#endif
S
S// <q> LPCOMP_CONFIG_HYST  - Hysteresis
S 
S
S#ifndef LPCOMP_CONFIG_HYST
S#define LPCOMP_CONFIG_HYST 0
S#endif
S
S// <o> LPCOMP_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef LPCOMP_CONFIG_IRQ_PRIORITY
S#define LPCOMP_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> LPCOMP_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef LPCOMP_CONFIG_LOG_ENABLED
S#define LPCOMP_CONFIG_LOG_ENABLED 0
S#endif
S#if  LPCOMP_CONFIG_LOG_ENABLED
S// <o> LPCOMP_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef LPCOMP_CONFIG_LOG_LEVEL
S#define LPCOMP_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> LPCOMP_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef LPCOMP_CONFIG_INFO_COLOR
S#define LPCOMP_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> LPCOMP_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef LPCOMP_CONFIG_DEBUG_COLOR
S#define LPCOMP_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //LPCOMP_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //LPCOMP_ENABLED
N// </e>
N
N// <e> PDM_ENABLED - nrf_drv_pdm - PDM peripheral driver
N//==========================================================
N#ifndef PDM_ENABLED
N#define PDM_ENABLED 0
N#endif
N#if  PDM_ENABLED
X#if  0
S// <o> PDM_CONFIG_MODE  - Mode
S 
S// <0=> Stereo 
S// <1=> Mono 
S
S#ifndef PDM_CONFIG_MODE
S#define PDM_CONFIG_MODE 1
S#endif
S
S// <o> PDM_CONFIG_EDGE  - Edge
S 
S// <0=> Left falling 
S// <1=> Left rising 
S
S#ifndef PDM_CONFIG_EDGE
S#define PDM_CONFIG_EDGE 0
S#endif
S
S// <o> PDM_CONFIG_CLOCK_FREQ  - Clock frequency
S 
S// <134217728=> 1000k 
S// <138412032=> 1032k (default) 
S// <142606336=> 1067k 
S
S#ifndef PDM_CONFIG_CLOCK_FREQ
S#define PDM_CONFIG_CLOCK_FREQ 138412032
S#endif
S
S// <o> PDM_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef PDM_CONFIG_IRQ_PRIORITY
S#define PDM_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> PDM_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef PDM_CONFIG_LOG_ENABLED
S#define PDM_CONFIG_LOG_ENABLED 0
S#endif
S#if  PDM_CONFIG_LOG_ENABLED
S// <o> PDM_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef PDM_CONFIG_LOG_LEVEL
S#define PDM_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> PDM_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef PDM_CONFIG_INFO_COLOR
S#define PDM_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> PDM_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef PDM_CONFIG_DEBUG_COLOR
S#define PDM_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //PDM_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //PDM_ENABLED
N// </e>
N
N// <e> PERIPHERAL_RESOURCE_SHARING_ENABLED - nrf_drv_common - Peripheral drivers common module
N//==========================================================
N#ifndef PERIPHERAL_RESOURCE_SHARING_ENABLED
N#define PERIPHERAL_RESOURCE_SHARING_ENABLED 0
N#endif
N#if  PERIPHERAL_RESOURCE_SHARING_ENABLED
X#if  0
S// <e> COMMON_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef COMMON_CONFIG_LOG_ENABLED
S#define COMMON_CONFIG_LOG_ENABLED 0
S#endif
S#if  COMMON_CONFIG_LOG_ENABLED
S// <o> COMMON_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef COMMON_CONFIG_LOG_LEVEL
S#define COMMON_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> COMMON_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef COMMON_CONFIG_INFO_COLOR
S#define COMMON_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> COMMON_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef COMMON_CONFIG_DEBUG_COLOR
S#define COMMON_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //COMMON_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //PERIPHERAL_RESOURCE_SHARING_ENABLED
N// </e>
N
N// <e> POWER_ENABLED - nrf_drv_power - POWER peripheral driver
N//==========================================================
N#ifndef POWER_ENABLED
N#define POWER_ENABLED 0
N#endif
N#if  POWER_ENABLED
X#if  0
S// <o> POWER_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef POWER_CONFIG_IRQ_PRIORITY
S#define POWER_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <q> POWER_CONFIG_DEFAULT_DCDCEN  - The default configuration of main DCDC regulator
S 
S
S// <i> This settings means only that components for DCDC regulator are installed and it can be enabled.
S
S#ifndef POWER_CONFIG_DEFAULT_DCDCEN
S#define POWER_CONFIG_DEFAULT_DCDCEN 0
S#endif
S
S// <q> POWER_CONFIG_DEFAULT_DCDCENHV  - The default configuration of High Voltage DCDC regulator
S 
S
S// <i> This settings means only that components for DCDC regulator are installed and it can be enabled.
S
S#ifndef POWER_CONFIG_DEFAULT_DCDCENHV
S#define POWER_CONFIG_DEFAULT_DCDCENHV 0
S#endif
S
N#endif //POWER_ENABLED
N// </e>
N
N// <e> PPI_ENABLED - nrf_drv_ppi - PPI peripheral driver
N//==========================================================
N#ifndef PPI_ENABLED
N#define PPI_ENABLED 0
N#endif
N#if  PPI_ENABLED
X#if  0
S// <e> PPI_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef PPI_CONFIG_LOG_ENABLED
S#define PPI_CONFIG_LOG_ENABLED 0
S#endif
S#if  PPI_CONFIG_LOG_ENABLED
S// <o> PPI_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef PPI_CONFIG_LOG_LEVEL
S#define PPI_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> PPI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef PPI_CONFIG_INFO_COLOR
S#define PPI_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> PPI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef PPI_CONFIG_DEBUG_COLOR
S#define PPI_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //PPI_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //PPI_ENABLED
N// </e>
N
N// <e> PWM_ENABLED - nrf_drv_pwm - PWM peripheral driver
N//==========================================================
N#ifndef PWM_ENABLED
N#define PWM_ENABLED 0
N#endif
N#if  PWM_ENABLED
X#if  0
S// <o> PWM_DEFAULT_CONFIG_OUT0_PIN - Out0 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT0_PIN
S#define PWM_DEFAULT_CONFIG_OUT0_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT1_PIN - Out1 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT1_PIN
S#define PWM_DEFAULT_CONFIG_OUT1_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT2_PIN - Out2 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT2_PIN
S#define PWM_DEFAULT_CONFIG_OUT2_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_OUT3_PIN - Out3 pin  <0-31> 
S
S
S#ifndef PWM_DEFAULT_CONFIG_OUT3_PIN
S#define PWM_DEFAULT_CONFIG_OUT3_PIN 31
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_BASE_CLOCK  - Base clock
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 MHz 
S
S#ifndef PWM_DEFAULT_CONFIG_BASE_CLOCK
S#define PWM_DEFAULT_CONFIG_BASE_CLOCK 4
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_COUNT_MODE  - Count mode
S 
S// <0=> Up 
S// <1=> Up and Down 
S
S#ifndef PWM_DEFAULT_CONFIG_COUNT_MODE
S#define PWM_DEFAULT_CONFIG_COUNT_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_TOP_VALUE - Top value 
S#ifndef PWM_DEFAULT_CONFIG_TOP_VALUE
S#define PWM_DEFAULT_CONFIG_TOP_VALUE 1000
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_LOAD_MODE  - Load mode
S 
S// <0=> Common 
S// <1=> Grouped 
S// <2=> Individual 
S// <3=> Waveform 
S
S#ifndef PWM_DEFAULT_CONFIG_LOAD_MODE
S#define PWM_DEFAULT_CONFIG_LOAD_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_STEP_MODE  - Step mode
S 
S// <0=> Auto 
S// <1=> Triggered 
S
S#ifndef PWM_DEFAULT_CONFIG_STEP_MODE
S#define PWM_DEFAULT_CONFIG_STEP_MODE 0
S#endif
S
S// <o> PWM_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S// <4=> 4 
S// <5=> 5 
S// <6=> 6 
S// <7=> 7 
S
S#ifndef PWM_DEFAULT_CONFIG_IRQ_PRIORITY
S#define PWM_DEFAULT_CONFIG_IRQ_PRIORITY 7
S#endif
S
S// <q> PWM0_ENABLED  - Enable PWM0 instance
S 
S
S#ifndef PWM0_ENABLED
S#define PWM0_ENABLED 0
S#endif
S
S// <q> PWM1_ENABLED  - Enable PWM1 instance
S 
S
S#ifndef PWM1_ENABLED
S#define PWM1_ENABLED 0
S#endif
S
S// <q> PWM2_ENABLED  - Enable PWM2 instance
S 
S
S#ifndef PWM2_ENABLED
S#define PWM2_ENABLED 0
S#endif
S
S// <e> PWM_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef PWM_CONFIG_LOG_ENABLED
S#define PWM_CONFIG_LOG_ENABLED 0
S#endif
S#if  PWM_CONFIG_LOG_ENABLED
S// <o> PWM_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef PWM_CONFIG_LOG_LEVEL
S#define PWM_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> PWM_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef PWM_CONFIG_INFO_COLOR
S#define PWM_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> PWM_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef PWM_CONFIG_DEBUG_COLOR
S#define PWM_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //PWM_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //PWM_ENABLED
N// </e>
N
N// <e> QDEC_ENABLED - nrf_drv_qdec - QDEC peripheral driver
N//==========================================================
N#ifndef QDEC_ENABLED
N#define QDEC_ENABLED 0
N#endif
N#if  QDEC_ENABLED
X#if  0
S// <o> QDEC_CONFIG_REPORTPER  - Report period
S 
S// <0=> 10 Samples 
S// <1=> 40 Samples 
S// <2=> 80 Samples 
S// <3=> 120 Samples 
S// <4=> 160 Samples 
S// <5=> 200 Samples 
S// <6=> 240 Samples 
S// <7=> 280 Samples 
S
S#ifndef QDEC_CONFIG_REPORTPER
S#define QDEC_CONFIG_REPORTPER 0
S#endif
S
S// <o> QDEC_CONFIG_SAMPLEPER  - Sample period
S 
S// <0=> 128 us 
S// <1=> 256 us 
S// <2=> 512 us 
S// <3=> 1024 us 
S// <4=> 2048 us 
S// <5=> 4096 us 
S// <6=> 8192 us 
S// <7=> 16384 us 
S
S#ifndef QDEC_CONFIG_SAMPLEPER
S#define QDEC_CONFIG_SAMPLEPER 7
S#endif
S
S// <o> QDEC_CONFIG_PIO_A - A pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_A
S#define QDEC_CONFIG_PIO_A 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_B - B pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_B
S#define QDEC_CONFIG_PIO_B 31
S#endif
S
S// <o> QDEC_CONFIG_PIO_LED - LED pin  <0-31> 
S
S
S#ifndef QDEC_CONFIG_PIO_LED
S#define QDEC_CONFIG_PIO_LED 31
S#endif
S
S// <o> QDEC_CONFIG_LEDPRE - LED pre 
S#ifndef QDEC_CONFIG_LEDPRE
S#define QDEC_CONFIG_LEDPRE 511
S#endif
S
S// <o> QDEC_CONFIG_LEDPOL  - LED polarity
S 
S// <0=> Active low 
S// <1=> Active high 
S
S#ifndef QDEC_CONFIG_LEDPOL
S#define QDEC_CONFIG_LEDPOL 1
S#endif
S
S// <q> QDEC_CONFIG_DBFEN  - Debouncing enable
S 
S
S#ifndef QDEC_CONFIG_DBFEN
S#define QDEC_CONFIG_DBFEN 0
S#endif
S
S// <q> QDEC_CONFIG_SAMPLE_INTEN  - Sample ready interrupt enable
S 
S
S#ifndef QDEC_CONFIG_SAMPLE_INTEN
S#define QDEC_CONFIG_SAMPLE_INTEN 0
S#endif
S
S// <o> QDEC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef QDEC_CONFIG_IRQ_PRIORITY
S#define QDEC_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> QDEC_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef QDEC_CONFIG_LOG_ENABLED
S#define QDEC_CONFIG_LOG_ENABLED 0
S#endif
S#if  QDEC_CONFIG_LOG_ENABLED
S// <o> QDEC_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef QDEC_CONFIG_LOG_LEVEL
S#define QDEC_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> QDEC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef QDEC_CONFIG_INFO_COLOR
S#define QDEC_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> QDEC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef QDEC_CONFIG_DEBUG_COLOR
S#define QDEC_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //QDEC_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //QDEC_ENABLED
N// </e>
N
N// <e> RNG_ENABLED - nrf_drv_rng - RNG peripheral driver
N//==========================================================
N#ifndef RNG_ENABLED
N#define RNG_ENABLED 0
N#endif
N#if  RNG_ENABLED
X#if  0
S// <q> RNG_CONFIG_ERROR_CORRECTION  - Error correction
S 
S
S#ifndef RNG_CONFIG_ERROR_CORRECTION
S#define RNG_CONFIG_ERROR_CORRECTION 0
S#endif
S
S// <o> RNG_CONFIG_POOL_SIZE - Pool size 
S#ifndef RNG_CONFIG_POOL_SIZE
S#define RNG_CONFIG_POOL_SIZE 32
S#endif
S
S// <o> RNG_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef RNG_CONFIG_IRQ_PRIORITY
S#define RNG_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> RNG_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef RNG_CONFIG_LOG_ENABLED
S#define RNG_CONFIG_LOG_ENABLED 0
S#endif
S#if  RNG_CONFIG_LOG_ENABLED
S// <o> RNG_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef RNG_CONFIG_LOG_LEVEL
S#define RNG_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> RNG_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef RNG_CONFIG_INFO_COLOR
S#define RNG_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> RNG_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef RNG_CONFIG_DEBUG_COLOR
S#define RNG_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //RNG_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //RNG_ENABLED
N// </e>
N
N// <e> RTC_ENABLED - nrf_drv_rtc - RTC peripheral driver
N//==========================================================
N#ifndef RTC_ENABLED
N#define RTC_ENABLED 0
N#endif
N#if  RTC_ENABLED
X#if  0
S// <o> RTC_DEFAULT_CONFIG_FREQUENCY - Frequency  <16-32768> 
S
S
S#ifndef RTC_DEFAULT_CONFIG_FREQUENCY
S#define RTC_DEFAULT_CONFIG_FREQUENCY 32768
S#endif
S
S// <q> RTC_DEFAULT_CONFIG_RELIABLE  - Ensures safe compare event triggering
S 
S
S#ifndef RTC_DEFAULT_CONFIG_RELIABLE
S#define RTC_DEFAULT_CONFIG_RELIABLE 0
S#endif
S
S// <o> RTC_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef RTC_DEFAULT_CONFIG_IRQ_PRIORITY
S#define RTC_DEFAULT_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <q> RTC0_ENABLED  - Enable RTC0 instance
S 
S
S#ifndef RTC0_ENABLED
S#define RTC0_ENABLED 0
S#endif
S
S// <q> RTC1_ENABLED  - Enable RTC1 instance
S 
S
S#ifndef RTC1_ENABLED
S#define RTC1_ENABLED 0
S#endif
S
S// <q> RTC2_ENABLED  - Enable RTC2 instance
S 
S
S#ifndef RTC2_ENABLED
S#define RTC2_ENABLED 0
S#endif
S
S// <o> NRF_MAXIMUM_LATENCY_US - Maximum possible time[us] in highest priority interrupt 
S#ifndef NRF_MAXIMUM_LATENCY_US
S#define NRF_MAXIMUM_LATENCY_US 2000
S#endif
S
S// <e> RTC_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef RTC_CONFIG_LOG_ENABLED
S#define RTC_CONFIG_LOG_ENABLED 0
S#endif
S#if  RTC_CONFIG_LOG_ENABLED
S// <o> RTC_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef RTC_CONFIG_LOG_LEVEL
S#define RTC_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> RTC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef RTC_CONFIG_INFO_COLOR
S#define RTC_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> RTC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef RTC_CONFIG_DEBUG_COLOR
S#define RTC_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //RTC_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //RTC_ENABLED
N// </e>
N
N// <e> SAADC_ENABLED - nrf_drv_saadc - SAADC peripheral driver
N//==========================================================
N#ifndef SAADC_ENABLED
N#define SAADC_ENABLED 0
N#endif
N#if  SAADC_ENABLED
X#if  0
S// <o> SAADC_CONFIG_RESOLUTION  - Resolution
S 
S// <0=> 8 bit 
S// <1=> 10 bit 
S// <2=> 12 bit 
S// <3=> 14 bit 
S
S#ifndef SAADC_CONFIG_RESOLUTION
S#define SAADC_CONFIG_RESOLUTION 1
S#endif
S
S// <o> SAADC_CONFIG_OVERSAMPLE  - Sample period
S 
S// <0=> Disabled 
S// <1=> 2x 
S// <2=> 4x 
S// <3=> 8x 
S// <4=> 16x 
S// <5=> 32x 
S// <6=> 64x 
S// <7=> 128x 
S// <8=> 256x 
S
S#ifndef SAADC_CONFIG_OVERSAMPLE
S#define SAADC_CONFIG_OVERSAMPLE 0
S#endif
S
S// <q> SAADC_CONFIG_LP_MODE  - Enabling low power mode
S 
S
S#ifndef SAADC_CONFIG_LP_MODE
S#define SAADC_CONFIG_LP_MODE 0
S#endif
S
S// <o> SAADC_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef SAADC_CONFIG_IRQ_PRIORITY
S#define SAADC_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> SAADC_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef SAADC_CONFIG_LOG_ENABLED
S#define SAADC_CONFIG_LOG_ENABLED 0
S#endif
S#if  SAADC_CONFIG_LOG_ENABLED
S// <o> SAADC_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef SAADC_CONFIG_LOG_LEVEL
S#define SAADC_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> SAADC_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SAADC_CONFIG_INFO_COLOR
S#define SAADC_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> SAADC_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SAADC_CONFIG_DEBUG_COLOR
S#define SAADC_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //SAADC_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //SAADC_ENABLED
N// </e>
N
N// <e> SPIS_ENABLED - nrf_drv_spis - SPI Slave driver
N//==========================================================
N#ifndef SPIS_ENABLED
N#define SPIS_ENABLED 0
N#endif
N#if  SPIS_ENABLED
X#if  0
S// <o> SPIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef SPIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define SPIS_DEFAULT_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <o> SPIS_DEFAULT_MODE  - Mode
S 
S// <0=> MODE_0 
S// <1=> MODE_1 
S// <2=> MODE_2 
S// <3=> MODE_3 
S
S#ifndef SPIS_DEFAULT_MODE
S#define SPIS_DEFAULT_MODE 0
S#endif
S
S// <o> SPIS_DEFAULT_BIT_ORDER  - SPIS default bit order
S 
S// <0=> MSB first 
S// <1=> LSB first 
S
S#ifndef SPIS_DEFAULT_BIT_ORDER
S#define SPIS_DEFAULT_BIT_ORDER 0
S#endif
S
S// <o> SPIS_DEFAULT_DEF - SPIS default DEF character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_DEF
S#define SPIS_DEFAULT_DEF 255
S#endif
S
S// <o> SPIS_DEFAULT_ORC - SPIS default ORC character  <0-255> 
S
S
S#ifndef SPIS_DEFAULT_ORC
S#define SPIS_DEFAULT_ORC 255
S#endif
S
S// <q> SPIS0_ENABLED  - Enable SPIS0 instance
S 
S
S#ifndef SPIS0_ENABLED
S#define SPIS0_ENABLED 0
S#endif
S
S// <q> SPIS1_ENABLED  - Enable SPIS1 instance
S 
S
S#ifndef SPIS1_ENABLED
S#define SPIS1_ENABLED 0
S#endif
S
S// <q> SPIS2_ENABLED  - Enable SPIS2 instance
S 
S
S#ifndef SPIS2_ENABLED
S#define SPIS2_ENABLED 0
S#endif
S
S// <e> SPIS_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef SPIS_CONFIG_LOG_ENABLED
S#define SPIS_CONFIG_LOG_ENABLED 0
S#endif
S#if  SPIS_CONFIG_LOG_ENABLED
S// <o> SPIS_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef SPIS_CONFIG_LOG_LEVEL
S#define SPIS_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> SPIS_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPIS_CONFIG_INFO_COLOR
S#define SPIS_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> SPIS_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPIS_CONFIG_DEBUG_COLOR
S#define SPIS_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //SPIS_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //SPIS_ENABLED
N// </e>
N
N// <e> SPI_ENABLED - nrf_drv_spi - SPI/SPIM peripheral driver
N//==========================================================
N#ifndef SPI_ENABLED
N#define SPI_ENABLED 0
N#endif
N#if  SPI_ENABLED
X#if  0
S// <o> SPI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef SPI_DEFAULT_CONFIG_IRQ_PRIORITY
S#define SPI_DEFAULT_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> SPI0_ENABLED - Enable SPI0 instance
S//==========================================================
S#ifndef SPI0_ENABLED
S#define SPI0_ENABLED 0
S#endif
S#if  SPI0_ENABLED
S// <q> SPI0_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI0_USE_EASY_DMA
S#define SPI0_USE_EASY_DMA 0
S#endif
S
S// <o> SPI0_DEFAULT_FREQUENCY  - SPI frequency
S 
S// <33554432=> 125 kHz 
S// <67108864=> 250 kHz 
S// <134217728=> 500 kHz 
S// <268435456=> 1 MHz 
S// <536870912=> 2 MHz 
S// <1073741824=> 4 MHz 
S// <2147483648=> 8 MHz 
S
S#ifndef SPI0_DEFAULT_FREQUENCY
S#define SPI0_DEFAULT_FREQUENCY 1073741824
S#endif
S
S#endif //SPI0_ENABLED
S// </e>
S
S// <e> SPI1_ENABLED - Enable SPI1 instance
S//==========================================================
S#ifndef SPI1_ENABLED
S#define SPI1_ENABLED 0
S#endif
S#if  SPI1_ENABLED
S// <q> SPI1_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI1_USE_EASY_DMA
S#define SPI1_USE_EASY_DMA 0
S#endif
S
S// <o> SPI1_DEFAULT_FREQUENCY  - SPI frequency
S 
S// <33554432=> 125 kHz 
S// <67108864=> 250 kHz 
S// <134217728=> 500 kHz 
S// <268435456=> 1 MHz 
S// <536870912=> 2 MHz 
S// <1073741824=> 4 MHz 
S// <2147483648=> 8 MHz 
S
S#ifndef SPI1_DEFAULT_FREQUENCY
S#define SPI1_DEFAULT_FREQUENCY 1073741824
S#endif
S
S#endif //SPI1_ENABLED
S// </e>
S
S// <e> SPI2_ENABLED - Enable SPI2 instance
S//==========================================================
S#ifndef SPI2_ENABLED
S#define SPI2_ENABLED 0
S#endif
S#if  SPI2_ENABLED
S// <q> SPI2_USE_EASY_DMA  - Use EasyDMA
S 
S
S#ifndef SPI2_USE_EASY_DMA
S#define SPI2_USE_EASY_DMA 0
S#endif
S
S// <q> SPI2_DEFAULT_FREQUENCY  - Use EasyDMA
S 
S
S#ifndef SPI2_DEFAULT_FREQUENCY
S#define SPI2_DEFAULT_FREQUENCY 0
S#endif
S
S#endif //SPI2_ENABLED
S// </e>
S
S// <e> SPI_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef SPI_CONFIG_LOG_ENABLED
S#define SPI_CONFIG_LOG_ENABLED 0
S#endif
S#if  SPI_CONFIG_LOG_ENABLED
S// <o> SPI_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef SPI_CONFIG_LOG_LEVEL
S#define SPI_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> SPI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_INFO_COLOR
S#define SPI_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> SPI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef SPI_CONFIG_DEBUG_COLOR
S#define SPI_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //SPI_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //SPI_ENABLED
N// </e>
N
N// <e> TIMER_ENABLED - nrf_drv_timer - TIMER periperal driver
N//==========================================================
N#ifndef TIMER_ENABLED
N#define TIMER_ENABLED 0
N#endif
N#if  TIMER_ENABLED
X#if  0
S// <o> TIMER_DEFAULT_CONFIG_FREQUENCY  - Timer frequency if in Timer mode
S 
S// <0=> 16 MHz 
S// <1=> 8 MHz 
S// <2=> 4 MHz 
S// <3=> 2 MHz 
S// <4=> 1 MHz 
S// <5=> 500 kHz 
S// <6=> 250 kHz 
S// <7=> 125 kHz 
S// <8=> 62.5 kHz 
S// <9=> 31.25 kHz 
S
S#ifndef TIMER_DEFAULT_CONFIG_FREQUENCY
S#define TIMER_DEFAULT_CONFIG_FREQUENCY 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_MODE  - Timer mode or operation
S 
S// <0=> Timer 
S// <1=> Counter 
S
S#ifndef TIMER_DEFAULT_CONFIG_MODE
S#define TIMER_DEFAULT_CONFIG_MODE 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_BIT_WIDTH  - Timer counter bit width
S 
S// <0=> 16 bit 
S// <1=> 8 bit 
S// <2=> 24 bit 
S// <3=> 32 bit 
S
S#ifndef TIMER_DEFAULT_CONFIG_BIT_WIDTH
S#define TIMER_DEFAULT_CONFIG_BIT_WIDTH 0
S#endif
S
S// <o> TIMER_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef TIMER_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TIMER_DEFAULT_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <q> TIMER0_ENABLED  - Enable TIMER0 instance
S 
S
S#ifndef TIMER0_ENABLED
S#define TIMER0_ENABLED 0
S#endif
S
S// <q> TIMER1_ENABLED  - Enable TIMER1 instance
S 
S
S#ifndef TIMER1_ENABLED
S#define TIMER1_ENABLED 0
S#endif
S
S// <q> TIMER2_ENABLED  - Enable TIMER2 instance
S 
S
S#ifndef TIMER2_ENABLED
S#define TIMER2_ENABLED 0
S#endif
S
S// <q> TIMER3_ENABLED  - Enable TIMER3 instance
S 
S
S#ifndef TIMER3_ENABLED
S#define TIMER3_ENABLED 0
S#endif
S
S// <q> TIMER4_ENABLED  - Enable TIMER4 instance
S 
S
S#ifndef TIMER4_ENABLED
S#define TIMER4_ENABLED 0
S#endif
S
S// <e> TIMER_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef TIMER_CONFIG_LOG_ENABLED
S#define TIMER_CONFIG_LOG_ENABLED 0
S#endif
S#if  TIMER_CONFIG_LOG_ENABLED
S// <o> TIMER_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef TIMER_CONFIG_LOG_LEVEL
S#define TIMER_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> TIMER_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef TIMER_CONFIG_INFO_COLOR
S#define TIMER_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> TIMER_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef TIMER_CONFIG_DEBUG_COLOR
S#define TIMER_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //TIMER_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //TIMER_ENABLED
N// </e>
N
N// <e> TWIS_ENABLED - nrf_drv_twis - TWIS peripheral driver
N//==========================================================
N#ifndef TWIS_ENABLED
N#define TWIS_ENABLED 0
N#endif
N#if  TWIS_ENABLED
X#if  0
S// <o> TWIS_DEFAULT_CONFIG_ADDR0 - Address0 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR0
S#define TWIS_DEFAULT_CONFIG_ADDR0 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_ADDR1 - Address1 
S#ifndef TWIS_DEFAULT_CONFIG_ADDR1
S#define TWIS_DEFAULT_CONFIG_ADDR1 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SCL_PULL  - SCL pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SCL_PULL
S#define TWIS_DEFAULT_CONFIG_SCL_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_SDA_PULL  - SDA pin pull configuration
S 
S// <0=> Disabled 
S// <1=> Pull down 
S// <3=> Pull up 
S
S#ifndef TWIS_DEFAULT_CONFIG_SDA_PULL
S#define TWIS_DEFAULT_CONFIG_SDA_PULL 0
S#endif
S
S// <o> TWIS_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef TWIS_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWIS_DEFAULT_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <q> TWIS0_ENABLED  - Enable TWIS0 instance
S 
S
S#ifndef TWIS0_ENABLED
S#define TWIS0_ENABLED 0
S#endif
S
S// <q> TWIS1_ENABLED  - Enable TWIS1 instance
S 
S
S#ifndef TWIS1_ENABLED
S#define TWIS1_ENABLED 0
S#endif
S
S// <q> TWIS_ASSUME_INIT_AFTER_RESET_ONLY  - Assume that any instance would be initialized only once
S 
S
S// <i> Optimization flag. Registers used by TWIS are shared by other peripherals. Normally, during initialization driver tries to clear all registers to known state before doing the initialization itself. This gives initialization safe procedure, no matter when it would be called. If you activate TWIS only once and do never uninitialize it - set this flag to 1 what gives more optimal code.
S
S#ifndef TWIS_ASSUME_INIT_AFTER_RESET_ONLY
S#define TWIS_ASSUME_INIT_AFTER_RESET_ONLY 0
S#endif
S
S// <q> TWIS_NO_SYNC_MODE  - Remove support for synchronous mode
S 
S
S// <i> Synchronous mode would be used in specific situations. And it uses some additional code and data memory to safely process state machine by polling it in status functions. If this functionality is not required it may be disabled to free some resources.
S
S#ifndef TWIS_NO_SYNC_MODE
S#define TWIS_NO_SYNC_MODE 0
S#endif
S
S// <e> TWIS_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef TWIS_CONFIG_LOG_ENABLED
S#define TWIS_CONFIG_LOG_ENABLED 0
S#endif
S#if  TWIS_CONFIG_LOG_ENABLED
S// <o> TWIS_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef TWIS_CONFIG_LOG_LEVEL
S#define TWIS_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> TWIS_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef TWIS_CONFIG_INFO_COLOR
S#define TWIS_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> TWIS_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef TWIS_CONFIG_DEBUG_COLOR
S#define TWIS_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //TWIS_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //TWIS_ENABLED
N// </e>
N
N// <e> TWI_ENABLED - nrf_drv_twi - TWI/TWIM peripheral driver
N//==========================================================
N#ifndef TWI_ENABLED
N#define TWI_ENABLED 0
N#endif
N#if  TWI_ENABLED
X#if  0
S// <o> TWI_DEFAULT_CONFIG_FREQUENCY  - Frequency
S 
S// <26738688=> 100k 
S// <67108864=> 250k 
S// <104857600=> 400k 
S
S#ifndef TWI_DEFAULT_CONFIG_FREQUENCY
S#define TWI_DEFAULT_CONFIG_FREQUENCY 26738688
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_CLR_BUS_INIT  - Enables bus clearing procedure during init
S 
S
S#ifndef TWI_DEFAULT_CONFIG_CLR_BUS_INIT
S#define TWI_DEFAULT_CONFIG_CLR_BUS_INIT 0
S#endif
S
S// <q> TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT  - Enables bus holding after uninit
S 
S
S#ifndef TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT
S#define TWI_DEFAULT_CONFIG_HOLD_BUS_UNINIT 0
S#endif
S
S// <o> TWI_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef TWI_DEFAULT_CONFIG_IRQ_PRIORITY
S#define TWI_DEFAULT_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> TWI0_ENABLED - Enable TWI0 instance
S//==========================================================
S#ifndef TWI0_ENABLED
S#define TWI0_ENABLED 0
S#endif
S#if  TWI0_ENABLED
S// <q> TWI0_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI0_USE_EASY_DMA
S#define TWI0_USE_EASY_DMA 0
S#endif
S
S#endif //TWI0_ENABLED
S// </e>
S
S// <e> TWI1_ENABLED - Enable TWI1 instance
S//==========================================================
S#ifndef TWI1_ENABLED
S#define TWI1_ENABLED 0
S#endif
S#if  TWI1_ENABLED
S// <q> TWI1_USE_EASY_DMA  - Use EasyDMA (if present)
S 
S
S#ifndef TWI1_USE_EASY_DMA
S#define TWI1_USE_EASY_DMA 0
S#endif
S
S#endif //TWI1_ENABLED
S// </e>
S
S// <e> TWI_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef TWI_CONFIG_LOG_ENABLED
S#define TWI_CONFIG_LOG_ENABLED 0
S#endif
S#if  TWI_CONFIG_LOG_ENABLED
S// <o> TWI_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef TWI_CONFIG_LOG_LEVEL
S#define TWI_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> TWI_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef TWI_CONFIG_INFO_COLOR
S#define TWI_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> TWI_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef TWI_CONFIG_DEBUG_COLOR
S#define TWI_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //TWI_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //TWI_ENABLED
N// </e>
N
N// <e> UART_ENABLED - nrf_drv_uart - UART/UARTE peripheral driver
N//==========================================================
N#ifndef UART_ENABLED
N#define UART_ENABLED            1
N#endif
N#if  UART_ENABLED
X#if  1
N// <o> UART_DEFAULT_CONFIG_HWFC  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef UART_DEFAULT_CONFIG_HWFC
N#define UART_DEFAULT_CONFIG_HWFC 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_PARITY  - Parity
N 
N// <0=> Excluded 
N// <14=> Included 
N
N#ifndef UART_DEFAULT_CONFIG_PARITY
N#define UART_DEFAULT_CONFIG_PARITY 0
N#endif
N
N// <o> UART_DEFAULT_CONFIG_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30924800=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef UART_DEFAULT_CONFIG_BAUDRATE
N#define UART_DEFAULT_CONFIG_BAUDRATE 30924800
N#endif
N
N// <o> UART_DEFAULT_CONFIG_IRQ_PRIORITY  - Interrupt priority
N 
N
N// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
N// <0=> 0 (highest) 
N// <1=> 1 
N// <2=> 2 
N// <3=> 3 
N
N#ifndef UART_DEFAULT_CONFIG_IRQ_PRIORITY
N#define UART_DEFAULT_CONFIG_IRQ_PRIORITY 3
N#endif
N
N// <q> UART_EASY_DMA_SUPPORT  - Driver supporting EasyDMA
N 
N
N#ifndef UART_EASY_DMA_SUPPORT
N#define UART_EASY_DMA_SUPPORT 1
N#endif
N
N// <q> UART_LEGACY_SUPPORT  - Driver supporting Legacy mode
N 
N
N#ifndef UART_LEGACY_SUPPORT
N#define UART_LEGACY_SUPPORT 1
N#endif
N
N// <e> UART0_ENABLED - Enable UART0 instance
N//==========================================================
N#ifndef UART0_ENABLED
N#define UART0_ENABLED   1
N#endif
N#if  UART0_ENABLED
X#if  1
N// <q> UART0_CONFIG_USE_EASY_DMA  - Default setting for using EasyDMA
N 
N
N#ifndef UART0_CONFIG_USE_EASY_DMA
N#define UART0_CONFIG_USE_EASY_DMA 1
N#endif
N
N#endif //UART0_ENABLED
N// </e>
N
N// <e> UART_CONFIG_LOG_ENABLED - Enables logging in the module.
N//==========================================================
N#ifndef UART_CONFIG_LOG_ENABLED
N#define UART_CONFIG_LOG_ENABLED 0
N#endif
N#if  UART_CONFIG_LOG_ENABLED
X#if  0
S// <o> UART_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef UART_CONFIG_LOG_LEVEL
S#define UART_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> UART_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef UART_CONFIG_INFO_COLOR
S#define UART_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> UART_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef UART_CONFIG_DEBUG_COLOR
S#define UART_CONFIG_DEBUG_COLOR 0
S#endif
S
N#endif //UART_CONFIG_LOG_ENABLED
N// </e>
N
N#endif //UART_ENABLED
N// </e>
N
N// <e> USBD_ENABLED - nrf_drv_usbd - USB driver
N//==========================================================
N#ifndef USBD_ENABLED
N#define USBD_ENABLED 0
N#endif
N#if  USBD_ENABLED
X#if  0
S// <o> NRF_DRV_USBD_DMASCHEDULER_MODE  - USBD SMA scheduler working scheme
S 
S// <0=> Prioritized access 
S// <1=> Round Robin 
S
S#ifndef NRF_DRV_USBD_DMASCHEDULER_MODE
S#define NRF_DRV_USBD_DMASCHEDULER_MODE 0
S#endif
S
S// <q> NRF_USBD_DRV_LOG_ENABLED  - Enable logging.
S 
S
S#ifndef NRF_USBD_DRV_LOG_ENABLED
S#define NRF_USBD_DRV_LOG_ENABLED 0
S#endif
S
N#endif //USBD_ENABLED
N// </e>
N
N// <e> WDT_ENABLED - nrf_drv_wdt - WDT peripheral driver
N//==========================================================
N#ifndef WDT_ENABLED
N#define WDT_ENABLED 0
N#endif
N#if  WDT_ENABLED
X#if  0
S// <o> WDT_CONFIG_BEHAVIOUR  - WDT behavior in CPU SLEEP or HALT mode
S 
S// <1=> Run in SLEEP, Pause in HALT 
S// <8=> Pause in SLEEP, Run in HALT 
S// <9=> Run in SLEEP and HALT 
S// <0=> Pause in SLEEP and HALT 
S
S#ifndef WDT_CONFIG_BEHAVIOUR
S#define WDT_CONFIG_BEHAVIOUR 1
S#endif
S
S// <o> WDT_CONFIG_RELOAD_VALUE - Reload value  <15-4294967295> 
S
S
S#ifndef WDT_CONFIG_RELOAD_VALUE
S#define WDT_CONFIG_RELOAD_VALUE 2000
S#endif
S
S// <o> WDT_CONFIG_IRQ_PRIORITY  - Interrupt priority
S 
S
S// <i> Priorities 0,2 (nRF51) and 0,1,4,5 (nRF52) are reserved for SoftDevice
S// <0=> 0 (highest) 
S// <1=> 1 
S// <2=> 2 
S// <3=> 3 
S
S#ifndef WDT_CONFIG_IRQ_PRIORITY
S#define WDT_CONFIG_IRQ_PRIORITY 3
S#endif
S
S// <e> WDT_CONFIG_LOG_ENABLED - Enables logging in the module.
S//==========================================================
S#ifndef WDT_CONFIG_LOG_ENABLED
S#define WDT_CONFIG_LOG_ENABLED 0
S#endif
S#if  WDT_CONFIG_LOG_ENABLED
S// <o> WDT_CONFIG_LOG_LEVEL  - Default Severity level
S 
S// <0=> Off 
S// <1=> Error 
S// <2=> Warning 
S// <3=> Info 
S// <4=> Debug 
S
S#ifndef WDT_CONFIG_LOG_LEVEL
S#define WDT_CONFIG_LOG_LEVEL 3
S#endif
S
S// <o> WDT_CONFIG_INFO_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef WDT_CONFIG_INFO_COLOR
S#define WDT_CONFIG_INFO_COLOR 0
S#endif
S
S// <o> WDT_CONFIG_DEBUG_COLOR  - ANSI escape code prefix.
S 
S// <0=> Default 
S// <1=> Black 
S// <2=> Red 
S// <3=> Green 
S// <4=> Yellow 
S// <5=> Blue 
S// <6=> Magenta 
S// <7=> Cyan 
S// <8=> White 
S
S#ifndef WDT_CONFIG_DEBUG_COLOR
S#define WDT_CONFIG_DEBUG_COLOR 0
S#endif
S
S#endif //WDT_CONFIG_LOG_ENABLED
S// </e>
S
N#endif //WDT_ENABLED
N// </e>
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Libraries 
N
N//==========================================================
N// <q> APP_GPIOTE_ENABLED  - app_gpiote - GPIOTE events dispatcher
N 
N
N#ifndef APP_GPIOTE_ENABLED
N#define APP_GPIOTE_ENABLED 0
N#endif
N
N// <q> APP_PWM_ENABLED  - app_pwm - PWM functionality
N 
N
N#ifndef APP_PWM_ENABLED
N#define APP_PWM_ENABLED 0
N#endif
N
N// <e> APP_SCHEDULER_ENABLED - app_scheduler - Events scheduler
N//==========================================================
N#ifndef APP_SCHEDULER_ENABLED
N#define APP_SCHEDULER_ENABLED 0
N#endif
N#if  APP_SCHEDULER_ENABLED
X#if  0
S// <q> APP_SCHEDULER_WITH_PAUSE  - Enabling pause feature
S 
S
S#ifndef APP_SCHEDULER_WITH_PAUSE
S#define APP_SCHEDULER_WITH_PAUSE 0
S#endif
S
S// <q> APP_SCHEDULER_WITH_PROFILER  - Enabling scheduler profiling
S 
S
S#ifndef APP_SCHEDULER_WITH_PROFILER
S#define APP_SCHEDULER_WITH_PROFILER 0
S#endif
S
N#endif //APP_SCHEDULER_ENABLED
N// </e>
N
N// <e> APP_TIMER_ENABLED - app_timer - Application timer functionality
N//==========================================================
N#ifndef APP_TIMER_ENABLED
N#define APP_TIMER_ENABLED 1
N#endif
N#if  APP_TIMER_ENABLED
X#if  1
N// <q> APP_TIMER_WITH_PROFILER  - Enable app_timer profiling
N 
N
N#ifndef APP_TIMER_WITH_PROFILER
N#define APP_TIMER_WITH_PROFILER 0
N#endif
N
N// <q> APP_TIMER_KEEPS_RTC_ACTIVE  - Enable RTC always on
N 
N
N// <i> If option is enabled RTC is kept running even if there is no active timers.
N// <i> This option can be used when app_timer is used for timestamping.
N
N#ifndef APP_TIMER_KEEPS_RTC_ACTIVE
N#define APP_TIMER_KEEPS_RTC_ACTIVE 0
N#endif
N
N#endif //APP_TIMER_ENABLED
N// </e>
N
N// <q> APP_TWI_ENABLED  - app_twi - TWI transaction manager
N 
N
N#ifndef APP_TWI_ENABLED
N#define APP_TWI_ENABLED 0
N#endif
N
N// <e> APP_UART_ENABLED - app_uart - UART driver
N//==========================================================
N#ifndef APP_UART_ENABLED
N#define APP_UART_ENABLED 0
N#endif
N#if  APP_UART_ENABLED
X#if  0
S// <o> APP_UART_DRIVER_INSTANCE  - UART instance used
S 
S// <0=> 0 
S
S#ifndef APP_UART_DRIVER_INSTANCE
S#define APP_UART_DRIVER_INSTANCE 0
S#endif
S
N#endif //APP_UART_ENABLED
N// </e>
N
N// <q> APP_USBD_CLASS_AUDIO_ENABLED  - app_usbd_audio - USB AUDIO class
N 
N
N#ifndef APP_USBD_CLASS_AUDIO_ENABLED
N#define APP_USBD_CLASS_AUDIO_ENABLED 0
N#endif
N
N// <q> APP_USBD_CLASS_HID_ENABLED  - app_usbd_hid - USB HID class
N 
N
N#ifndef APP_USBD_CLASS_HID_ENABLED
N#define APP_USBD_CLASS_HID_ENABLED 0
N#endif
N
N// <q> APP_USBD_HID_GENERIC_ENABLED  - app_usbd_hid_generic - USB HID generic
N 
N
N#ifndef APP_USBD_HID_GENERIC_ENABLED
N#define APP_USBD_HID_GENERIC_ENABLED 0
N#endif
N
N// <q> APP_USBD_HID_KBD_ENABLED  - app_usbd_hid_kbd - USB HID keyboard
N 
N
N#ifndef APP_USBD_HID_KBD_ENABLED
N#define APP_USBD_HID_KBD_ENABLED 0
N#endif
N
N// <q> APP_USBD_HID_MOUSE_ENABLED  - app_usbd_hid_mouse - USB HID mouse
N 
N
N#ifndef APP_USBD_HID_MOUSE_ENABLED
N#define APP_USBD_HID_MOUSE_ENABLED 0
N#endif
N
N// <q> BUTTON_ENABLED  - app_button - buttons handling module
N 
N
N#ifndef BUTTON_ENABLED
N#define BUTTON_ENABLED 1
N#endif
N
N// <q> CRC16_ENABLED  - crc16 - CRC16 calculation routines
N 
N
N#ifndef CRC16_ENABLED
N#define CRC16_ENABLED 1
N#endif
N
N// <q> CRC32_ENABLED  - crc32 - CRC32 calculation routines
N 
N
N#ifndef CRC32_ENABLED
N#define CRC32_ENABLED 0
N#endif
N
N// <q> ECC_ENABLED  - ecc - Elliptic Curve Cryptography Library
N 
N
N#ifndef ECC_ENABLED
N#define ECC_ENABLED 0
N#endif
N
N// <e> FDS_ENABLED - fds - Flash data storage module
N//==========================================================
N#ifndef FDS_ENABLED
N#define FDS_ENABLED 1
N#endif
N#if  FDS_ENABLED
X#if  1
N// <o> FDS_OP_QUEUE_SIZE - Size of the internal queue. 
N#ifndef FDS_OP_QUEUE_SIZE
N#define FDS_OP_QUEUE_SIZE 4
N#endif
N
N// <o> FDS_CHUNK_QUEUE_SIZE - Determines how many @ref fds_record_chunk_t structures can be buffered at any time. 
N#ifndef FDS_CHUNK_QUEUE_SIZE
N#define FDS_CHUNK_QUEUE_SIZE 8
N#endif
N
N// <o> FDS_MAX_USERS - Maximum number of callbacks that can be registered. 
N#ifndef FDS_MAX_USERS
N#define FDS_MAX_USERS 8
N#endif
N
N// <o> FDS_VIRTUAL_PAGES - Number of virtual flash pages to use. 
N// <i> One of the virtual pages is reserved by the system for garbage collection.
N// <i> Therefore, the minimum is two virtual pages: one page to store data and
N// <i> one page to be used by the system for garbage collection. The total amount
N// <i> of flash memory that is used by FDS amounts to @ref FDS_VIRTUAL_PAGES
N// <i> @ref FDS_VIRTUAL_PAGE_SIZE * 4 bytes.
N
N#ifndef FDS_VIRTUAL_PAGES
N#define FDS_VIRTUAL_PAGES 3
N#endif
N
N// <o> FDS_VIRTUAL_PAGE_SIZE  - The size of a virtual page of flash memory, expressed in number of 4-byte words.
N 
N
N// <i> By default, a virtual page is the same size as a physical page.
N// <i> The size of a virtual page must be a multiple of the size of a physical page.
N// <256=> 256 
N// <512=> 512 
N// <1024=> 1024 
N
N#ifndef FDS_VIRTUAL_PAGE_SIZE
N#define FDS_VIRTUAL_PAGE_SIZE 256
N#endif
N
N#endif //FDS_ENABLED
N// </e>
N
N// <e> FSTORAGE_ENABLED - fstorage - Flash storage module
N//==========================================================
N#ifndef FSTORAGE_ENABLED
N#define FSTORAGE_ENABLED 1
N#endif
N#if  FSTORAGE_ENABLED
X#if  1
N// <o> FS_QUEUE_SIZE - Configures the size of the internal queue. 
N// <i> Increase this if there are many users, or if it is likely that many
N// <i> operation will be queued at once without waiting for the previous operations
N// <i> to complete. In general, increase the queue size if you frequently receive
N// <i> @ref FS_ERR_QUEUE_FULL errors when calling @ref fs_store or @ref fs_erase.
N
N#ifndef FS_QUEUE_SIZE
N#define FS_QUEUE_SIZE 4
N#endif
N
N// <o> FS_OP_MAX_RETRIES - Number attempts to execute an operation if the SoftDevice fails. 
N// <i> Increase this value if events return the @ref FS_ERR_OPERATION_TIMEOUT
N// <i> error often. The SoftDevice may fail to schedule flash access due to high BLE activity.
N
N#ifndef FS_OP_MAX_RETRIES
N#define FS_OP_MAX_RETRIES 3
N#endif
N
N// <o> FS_MAX_WRITE_SIZE_WORDS - Maximum number of words to be written to flash in a single operation. 
N// <i> Tweaking this value can increase the chances of the SoftDevice being
N// <i> able to fit flash operations in between radio activity. This value is bound by the
N// <i> maximum number of words which the SoftDevice can write to flash in a single call to
N// <i> @ref sd_flash_write, which is 256 words for nRF51 ICs and 1024 words for nRF52 ICs.
N
N#ifndef FS_MAX_WRITE_SIZE_WORDS
N#define FS_MAX_WRITE_SIZE_WORDS 256
N#endif
N
N#endif //FSTORAGE_ENABLED
N// </e>
N
N// <q> HARDFAULT_HANDLER_ENABLED  - hardfault_default - HardFault default handler for debugging and release
N 
N
N#ifndef HARDFAULT_HANDLER_ENABLED
N#define HARDFAULT_HANDLER_ENABLED 0
N#endif
N
N// <e> HCI_MEM_POOL_ENABLED - hci_mem_pool - memory pool implementation used by HCI
N//==========================================================
N#ifndef HCI_MEM_POOL_ENABLED
N#define HCI_MEM_POOL_ENABLED 0
N#endif
N#if  HCI_MEM_POOL_ENABLED
X#if  0
S// <o> HCI_TX_BUF_SIZE - TX buffer size in bytes. 
S#ifndef HCI_TX_BUF_SIZE
S#define HCI_TX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_SIZE - RX buffer size in bytes. 
S#ifndef HCI_RX_BUF_SIZE
S#define HCI_RX_BUF_SIZE 600
S#endif
S
S// <o> HCI_RX_BUF_QUEUE_SIZE - RX buffer queue size. 
S#ifndef HCI_RX_BUF_QUEUE_SIZE
S#define HCI_RX_BUF_QUEUE_SIZE 4
S#endif
S
N#endif //HCI_MEM_POOL_ENABLED
N// </e>
N
N// <e> HCI_SLIP_ENABLED - hci_slip - SLIP protocol implementation used by HCI
N//==========================================================
N#ifndef HCI_SLIP_ENABLED
N#define HCI_SLIP_ENABLED 0
N#endif
N#if  HCI_SLIP_ENABLED
X#if  0
S// <o> HCI_UART_BAUDRATE  - Default Baudrate
S 
S// <323584=> 1200 baud 
S// <643072=> 2400 baud 
S// <1290240=> 4800 baud 
S// <2576384=> 9600 baud 
S// <3862528=> 14400 baud 
S// <5152768=> 19200 baud 
S// <7716864=> 28800 baud 
S// <10289152=> 38400 baud 
S// <15400960=> 57600 baud 
S// <20615168=> 76800 baud 
S// <30924800=> 115200 baud 
S// <61865984=> 230400 baud 
S// <67108864=> 250000 baud 
S// <121634816=> 460800 baud 
S// <251658240=> 921600 baud 
S// <268435456=> 57600 baud 
S
S#ifndef HCI_UART_BAUDRATE
S#define HCI_UART_BAUDRATE 30924800
S#endif
S
S// <o> HCI_UART_FLOW_CONTROL  - Hardware Flow Control
S 
S// <0=> Disabled 
S// <1=> Enabled 
S
S#ifndef HCI_UART_FLOW_CONTROL
S#define HCI_UART_FLOW_CONTROL 0
S#endif
S
S// <o> HCI_UART_RX_PIN - UART RX pin 
S#ifndef HCI_UART_RX_PIN
S#define HCI_UART_RX_PIN 11
S#endif
S
S// <o> HCI_UART_TX_PIN - UART TX pin 
S#ifndef HCI_UART_TX_PIN
S#define HCI_UART_TX_PIN 9
S#endif
S
S// <o> HCI_UART_RTS_PIN - UART RTS pin 
S#ifndef HCI_UART_RTS_PIN
S#define HCI_UART_RTS_PIN 8
S#endif
S
S// <o> HCI_UART_CTS_PIN - UART CTS pin 
S#ifndef HCI_UART_CTS_PIN
S#define HCI_UART_CTS_PIN 10
S#endif
S
N#endif //HCI_SLIP_ENABLED
N// </e>
N
N// <e> HCI_TRANSPORT_ENABLED - hci_transport - HCI transport
N//==========================================================
N#ifndef HCI_TRANSPORT_ENABLED
N#define HCI_TRANSPORT_ENABLED 0
N#endif
N#if  HCI_TRANSPORT_ENABLED
X#if  0
S// <o> HCI_MAX_PACKET_SIZE_IN_BITS - Maximum size of a single application packet in bits. 
S#ifndef HCI_MAX_PACKET_SIZE_IN_BITS
S#define HCI_MAX_PACKET_SIZE_IN_BITS 8000
S#endif
S
N#endif //HCI_TRANSPORT_ENABLED
N// </e>
N
N// <q> LED_SOFTBLINK_ENABLED  - led_softblink - led_softblink module
N 
N
N#ifndef LED_SOFTBLINK_ENABLED
N#define LED_SOFTBLINK_ENABLED 0
N#endif
N
N// <q> LOW_POWER_PWM_ENABLED  - low_power_pwm - low_power_pwm module
N 
N
N#ifndef LOW_POWER_PWM_ENABLED
N#define LOW_POWER_PWM_ENABLED 0
N#endif
N
N// <e> MEM_MANAGER_ENABLED - mem_manager - Dynamic memory allocator
N//==========================================================
N#ifndef MEM_MANAGER_ENABLED
N#define MEM_MANAGER_ENABLED 0
N#endif
N#if  MEM_MANAGER_ENABLED
X#if  0
S// <o> MEMORY_MANAGER_SMALL_BLOCK_COUNT - Size of each memory blocks identified as 'small' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_COUNT
S#define MEMORY_MANAGER_SMALL_BLOCK_COUNT 1
S#endif
S
S// <o> MEMORY_MANAGER_SMALL_BLOCK_SIZE -  Size of each memory blocks identified as 'small' block. 
S// <i>  Size of each memory blocks identified as 'small' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_SMALL_BLOCK_SIZE
S#define MEMORY_MANAGER_SMALL_BLOCK_SIZE 32
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_COUNT - Size of each memory blocks identified as 'medium' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_COUNT
S#define MEMORY_MANAGER_MEDIUM_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_MEDIUM_BLOCK_SIZE -  Size of each memory blocks identified as 'medium' block. 
S// <i>  Size of each memory blocks identified as 'medium' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_MEDIUM_BLOCK_SIZE
S#define MEMORY_MANAGER_MEDIUM_BLOCK_SIZE 256
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_COUNT - Size of each memory blocks identified as 'large' block.  <0-255> 
S
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_COUNT
S#define MEMORY_MANAGER_LARGE_BLOCK_COUNT 0
S#endif
S
S// <o> MEMORY_MANAGER_LARGE_BLOCK_SIZE -  Size of each memory blocks identified as 'large' block. 
S// <i>  Size of each memory blocks identified as 'large' block. Memory block are recommended to be word-sized.
S
S#ifndef MEMORY_MANAGER_LARGE_BLOCK_SIZE
S#define MEMORY_MANAGER_LARGE_BLOCK_SIZE 256
S#endif
S
S// <q> MEM_MANAGER_ENABLE_LOGS  - Enable debug trace in the module.
S 
S
S#ifndef MEM_MANAGER_ENABLE_LOGS
S#define MEM_MANAGER_ENABLE_LOGS 0
S#endif
S
S// <q> MEM_MANAGER_DISABLE_API_PARAM_CHECK  - Disable API parameter checks in the module.
S 
S
S#ifndef MEM_MANAGER_DISABLE_API_PARAM_CHECK
S#define MEM_MANAGER_DISABLE_API_PARAM_CHECK 0
S#endif
S
N#endif //MEM_MANAGER_ENABLED
N// </e>
N
N// <e> NRF_CSENSE_ENABLED - nrf_csense - nrf_csense module
N//==========================================================
N#ifndef NRF_CSENSE_ENABLED
N#define NRF_CSENSE_ENABLED 0
N#endif
N#if  NRF_CSENSE_ENABLED
X#if  0
S// <o> NRF_CSENSE_PAD_HYSTERESIS - Minimal value of change to decide that pad was touched. 
S#ifndef NRF_CSENSE_PAD_HYSTERESIS
S#define NRF_CSENSE_PAD_HYSTERESIS 15
S#endif
S
S// <o> NRF_CSENSE_PAD_DEVIATION - Minimal value measured on pad to take its value while calculating step. 
S#ifndef NRF_CSENSE_PAD_DEVIATION
S#define NRF_CSENSE_PAD_DEVIATION 70
S#endif
S
S// <o> NRF_CSENSE_MIN_PAD_VALUE - Minimum normalized value on pad to take its value into account. 
S#ifndef NRF_CSENSE_MIN_PAD_VALUE
S#define NRF_CSENSE_MIN_PAD_VALUE 20
S#endif
S
S// <o> NRF_CSENSE_MAX_PADS_NUMBER - Maximum number of pads used for one instance. 
S#ifndef NRF_CSENSE_MAX_PADS_NUMBER
S#define NRF_CSENSE_MAX_PADS_NUMBER 20
S#endif
S
S// <o> NRF_CSENSE_MAX_VALUE - Maximum normalized value got from measurement. 
S#ifndef NRF_CSENSE_MAX_VALUE
S#define NRF_CSENSE_MAX_VALUE 1000
S#endif
S
S// <o> NRF_CSENSE_OUTPUT_PIN - Output pin used by lower module. 
S// <i> This is only used when running on NRF51.
S
S#ifndef NRF_CSENSE_OUTPUT_PIN
S#define NRF_CSENSE_OUTPUT_PIN 30
S#endif
S
N#endif //NRF_CSENSE_ENABLED
N// </e>
N
N// <e> NRF_DRV_CSENSE_ENABLED - nrf_drv_csense - Capacitive sensor module
N//==========================================================
N#ifndef NRF_DRV_CSENSE_ENABLED
N#define NRF_DRV_CSENSE_ENABLED 0
N#endif
N#if  NRF_DRV_CSENSE_ENABLED
X#if  0
S// <o> TIMER0_FOR_CSENSE - First TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER0_FOR_CSENSE
S#define TIMER0_FOR_CSENSE 1
S#endif
S
S// <o> TIMER1_FOR_CSENSE - Second TIMER instance used by the driver (except nRF51) 
S#ifndef TIMER1_FOR_CSENSE
S#define TIMER1_FOR_CSENSE 2
S#endif
S
S// <o> MEASUREMENT_PERIOD - Single measurement period. 
S// <i> Time of single measurement can be calculated as T = (1/2)*MEASUREMENT_PERIOD*(1/f_OSC) where f_OSC = I_SOURCE / (2C*(VUP-VDOWN) ). I_SOURCE, VUP and VDOWN are values used to initialize COMP and C is capacitance of used pad.
S
S#ifndef MEASUREMENT_PERIOD
S#define MEASUREMENT_PERIOD 20
S#endif
S
N#endif //NRF_DRV_CSENSE_ENABLED
N// </e>
N
N// <q> NRF_QUEUE_ENABLED  - nrf_queue - Queue module
N 
N
N#ifndef NRF_QUEUE_ENABLED
N#define NRF_QUEUE_ENABLED 0
N#endif
N
N// <q> SLIP_ENABLED  - slip - SLIP encoding decoding
N 
N
N#ifndef SLIP_ENABLED
N#define SLIP_ENABLED 0
N#endif
N
N// <h> app_usbd_cdc_acm - USB CDC ACM class
N
N//==========================================================
N// <q> APP_USBD_CLASS_CDC_ACM_ENABLED  - Enabling USBD CDC ACM Class library
N 
N
N#ifndef APP_USBD_CLASS_CDC_ACM_ENABLED
N#define APP_USBD_CLASS_CDC_ACM_ENABLED 0
N#endif
N
N// <q> APP_USBD_CDC_ACM_LOG_ENABLED  - Enables logging in the module.
N 
N
N#ifndef APP_USBD_CDC_ACM_LOG_ENABLED
N#define APP_USBD_CDC_ACM_LOG_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// <h> app_usbd_msc - USB MSC class
N
N//==========================================================
N// <q> APP_USBD_CLASS_MSC_ENABLED  - Enabling USBD MSC Class library
N 
N
N#ifndef APP_USBD_CLASS_MSC_ENABLED
N#define APP_USBD_CLASS_MSC_ENABLED 0
N#endif
N
N// <q> APP_USBD_MSC_CLASS_LOG_ENABLED  - Enables logging in the module.
N 
N
N#ifndef APP_USBD_MSC_CLASS_LOG_ENABLED
N#define APP_USBD_MSC_CLASS_LOG_ENABLED 0
N#endif
N
N// </h> 
N//==========================================================
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Log 
N
N//==========================================================
N// <e> NRF_LOG_ENABLED - nrf_log - Logging
N//==========================================================
N#ifndef NRF_LOG_ENABLED
N#define NRF_LOG_ENABLED 1
N#endif
N#if  NRF_LOG_ENABLED
X#if  1
N// <e> NRF_LOG_USES_COLORS - If enabled then ANSI escape code for colors is prefixed to every string
N//==========================================================
N#ifndef NRF_LOG_USES_COLORS
N#define NRF_LOG_USES_COLORS 1
N#endif
N#if  NRF_LOG_USES_COLORS
X#if  1
N// <o> NRF_LOG_COLOR_DEFAULT  - ANSI escape code prefix.
N 
N// <0=> Default 
N// <1=> Black 
N// <2=> Red 
N// <3=> Green 
N// <4=> Yellow 
N// <5=> Blue 
N// <6=> Magenta 
N// <7=> Cyan 
N// <8=> White 
N
N#ifndef NRF_LOG_COLOR_DEFAULT
N#define NRF_LOG_COLOR_DEFAULT 3
N#endif
N
N// <o> NRF_LOG_ERROR_COLOR  - ANSI escape code prefix.
N 
N// <0=> Default 
N// <1=> Black 
N// <2=> Red 
N// <3=> Green 
N// <4=> Yellow 
N// <5=> Blue 
N// <6=> Magenta 
N// <7=> Cyan 
N// <8=> White 
N
N#ifndef NRF_LOG_ERROR_COLOR
N#define NRF_LOG_ERROR_COLOR 2
N#endif
N
N// <o> NRF_LOG_WARNING_COLOR  - ANSI escape code prefix.
N 
N// <0=> Default 
N// <1=> Black 
N// <2=> Red 
N// <3=> Green 
N// <4=> Yellow 
N// <5=> Blue 
N// <6=> Magenta 
N// <7=> Cyan 
N// <8=> White 
N
N#ifndef NRF_LOG_WARNING_COLOR
N#define NRF_LOG_WARNING_COLOR 4
N#endif
N
N#endif //NRF_LOG_USES_COLORS
N// </e>
N
N// <o> NRF_LOG_DEFAULT_LEVEL  - Default Severity level
N 
N// <0=> Off 
N// <1=> Error 
N// <2=> Warning 
N// <3=> Info 
N// <4=> Debug 
N
N#ifndef NRF_LOG_DEFAULT_LEVEL
N#define NRF_LOG_DEFAULT_LEVEL 4
N#endif
N
N// <e> NRF_LOG_DEFERRED - Enable deffered logger.
N
N// <i> Log data is buffered and can be processed in idle.
N//==========================================================
N#ifndef NRF_LOG_DEFERRED
N#define NRF_LOG_DEFERRED 1
N#endif
N#if  NRF_LOG_DEFERRED
X#if  1
N// <o> NRF_LOG_DEFERRED_BUFSIZE - Size of the buffer for logs in words. 
N// <i> Must be power of 2
N
N#ifndef NRF_LOG_DEFERRED_BUFSIZE
N#define NRF_LOG_DEFERRED_BUFSIZE 256
N#endif
N
N#endif //NRF_LOG_DEFERRED
N// </e>
N
N// <q> NRF_LOG_USES_TIMESTAMP  - Enable timestamping
N 
N
N// <i> Function for getting the timestamp is provided by the user
N
N#ifndef NRF_LOG_USES_TIMESTAMP
N#define NRF_LOG_USES_TIMESTAMP 0
N#endif
N
N#endif //NRF_LOG_ENABLED
N// </e>
N
N// <h> nrf_log_backend - Logging sink
N
N//==========================================================
N// <o> NRF_LOG_BACKEND_MAX_STRING_LENGTH - Buffer for storing single output string 
N// <i> Logger backend RAM usage is determined by this value.
N
N#ifndef NRF_LOG_BACKEND_MAX_STRING_LENGTH
N#define NRF_LOG_BACKEND_MAX_STRING_LENGTH 256
N#endif
N
N// <o> NRF_LOG_TIMESTAMP_DIGITS - Number of digits for timestamp 
N// <i> If higher resolution timestamp source is used it might be needed to increase that
N
N#ifndef NRF_LOG_TIMESTAMP_DIGITS
N#define NRF_LOG_TIMESTAMP_DIGITS 8
N#endif
N
N// <e> NRF_LOG_BACKEND_SERIAL_USES_UART - If enabled data is printed over UART
N//==========================================================
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_UART
N#define NRF_LOG_BACKEND_SERIAL_USES_UART 1
N#endif
N#if  NRF_LOG_BACKEND_SERIAL_USES_UART
X#if  1
N// <o> NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE  - Default Baudrate
N 
N// <323584=> 1200 baud 
N// <643072=> 2400 baud 
N// <1290240=> 4800 baud 
N// <2576384=> 9600 baud 
N// <3862528=> 14400 baud 
N// <5152768=> 19200 baud 
N// <7716864=> 28800 baud 
N// <10289152=> 38400 baud 
N// <15400960=> 57600 baud 
N// <20615168=> 76800 baud 
N// <30924800=> 115200 baud 
N// <61865984=> 230400 baud 
N// <67108864=> 250000 baud 
N// <121634816=> 460800 baud 
N// <251658240=> 921600 baud 
N// <268435456=> 57600 baud 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE
N#define NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE 30924800
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_TX_PIN - UART TX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_TX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_TX_PIN 30//24 //30 DDB 24 JJYJS
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RX_PIN - UART RX pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RX_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RX_PIN 11
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN - UART RTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN 8
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN - UART CTS pin 
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN
N#define NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN 10
N#endif
N
N// <o> NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL  - Hardware Flow Control
N 
N// <0=> Disabled 
N// <1=> Enabled 
N
N#ifndef NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL
N#define NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL 0
N#endif
N
N// <o> NRF_LOG_BACKEND_UART_INSTANCE  - UART instance used
N 
N// <0=> 0 
N
N#ifndef NRF_LOG_BACKEND_UART_INSTANCE
N#define NRF_LOG_BACKEND_UART_INSTANCE 0
N#endif
N
N#endif //NRF_LOG_BACKEND_SERIAL_USES_UART
N// </e>
N
N// <e> NRF_LOG_BACKEND_SERIAL_USES_RTT - If enabled data is printed using RTT
N//==========================================================
N#ifndef NRF_LOG_BACKEND_SERIAL_USES_RTT
N#define NRF_LOG_BACKEND_SERIAL_USES_RTT 0
N#endif
N#if  NRF_LOG_BACKEND_SERIAL_USES_RTT
X#if  0
S// <o> NRF_LOG_BACKEND_RTT_OUTPUT_BUFFER_SIZE - RTT output buffer size. 
S// <i> Should be equal or bigger than \ref NRF_LOG_BACKEND_MAX_STRING_LENGTH.
S// <i> This value is used in Segger RTT configuration to set the buffer size
S// <i> if it is bigger than default RTT buffer size.
S
S#ifndef NRF_LOG_BACKEND_RTT_OUTPUT_BUFFER_SIZE
S#define NRF_LOG_BACKEND_RTT_OUTPUT_BUFFER_SIZE 512
S#endif
S
N#endif //NRF_LOG_BACKEND_SERIAL_USES_RTT
N// </e>
N
N// </h> 
N//==========================================================
N
N// </h> 
N//==========================================================
N
N// <h> nRF_Segger_RTT 
N
N//==========================================================
N// <h> segger_rtt - SEGGER RTT
N
N//==========================================================
N// <o> SEGGER_RTT_CONFIG_BUFFER_SIZE_UP - Size of upstream buffer. 
N#ifndef SEGGER_RTT_CONFIG_BUFFER_SIZE_UP
N#define SEGGER_RTT_CONFIG_BUFFER_SIZE_UP 64
N#endif
N
N// <o> SEGGER_RTT_CONFIG_MAX_NUM_UP_BUFFERS - Size of upstream buffer. 
N#ifndef SEGGER_RTT_CONFIG_MAX_NUM_UP_BUFFERS
N#define SEGGER_RTT_CONFIG_MAX_NUM_UP_BUFFERS 2
N#endif
N
N// <o> SEGGER_RTT_CONFIG_BUFFER_SIZE_DOWN - Size of upstream buffer. 
N#ifndef SEGGER_RTT_CONFIG_BUFFER_SIZE_DOWN
N#define SEGGER_RTT_CONFIG_BUFFER_SIZE_DOWN 16
N#endif
N
N// <o> SEGGER_RTT_CONFIG_MAX_NUM_DOWN_BUFFERS - Size of upstream buffer. 
N#ifndef SEGGER_RTT_CONFIG_MAX_NUM_DOWN_BUFFERS
N#define SEGGER_RTT_CONFIG_MAX_NUM_DOWN_BUFFERS 2
N#endif
N
N// </h> 
N//==========================================================
N
N// </h> 
N//==========================================================
N
N// <<< end of configuration section >>>
N#endif //SDK_CONFIG_H
N
L 58 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "nordic_common.h"
L 1 "..\..\..\..\..\..\components\libraries\util\nordic_common.h" 1
N/**
N * Copyright (c) 2008 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @file
N * @brief Common defines and macros for firmware developed by Nordic Semiconductor.
N */
N
N#ifndef NORDIC_COMMON_H__
N#define NORDIC_COMMON_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @brief Check if selected module is enabled
N *
N * This is save function for driver enable checking.
N * Correct from Lint point of view (not using default of undefined value).
N *
N * Usage:
N * @code
N   #if NRF_MODULE_ENABLED(UART)
N   ...
N   #endif
N * @endcode
N *
N * @param module The module name.
N *
N * @retval 1 The macro <module>_ENABLE is defined and is non-zero.
N * @retval 0 The macro <module>_ENABLE is not defined or it equals zero.
N *
N * @note
N * This macro intentionally does not implement second expansion level.
N * The name of the module to be checked has to be given directly as a parameter.
N * And given parameter would be connected with @c _ENABLED postfix directly
N * without evaluating its value.
N */
N//lint -e491 // Suppers warning 491 "non-standard use of 'defined' preprocessor operator"
N#define NRF_MODULE_ENABLED(module) \
N    ((defined(module ## _ENABLED) && (module ## _ENABLED)) ? 1 : 0)
X#define NRF_MODULE_ENABLED(module)     ((defined(module ## _ENABLED) && (module ## _ENABLED)) ? 1 : 0)
N
N/** The upper 8 bits of a 32 bit value */
N//lint -emacro(572,MSB) // Suppress warning 572 "Excessive shift value"
N#define MSB_32(a) (((a) & 0xFF000000) >> 24)
N/** The lower 8 bits (of a 32 bit value) */
N#define LSB_32(a) ((a) & 0x000000FF)
N
N/** The upper 8 bits of a 16 bit value */
N//lint -emacro(572,MSB_16) // Suppress warning 572 "Excessive shift value"
N#define MSB_16(a) (((a) & 0xFF00) >> 8)
N/** The lower 8 bits (of a 16 bit value) */
N#define LSB_16(a) ((a) & 0x00FF)
N
N/** Leaves the minimum of the two 32-bit arguments */
N/*lint -emacro(506, MIN) */ /* Suppress "Constant value Boolean */
N#define MIN(a, b) ((a) < (b) ? (a) : (b))
N/** Leaves the maximum of the two 32-bit arguments */
N/*lint -emacro(506, MAX) */ /* Suppress "Constant value Boolean */
N#define MAX(a, b) ((a) < (b) ? (b) : (a))
N
N/**@brief Concatenates two parameters.
N *
N * It realizes two level expansion to make it sure that all the parameters
N * are actually expanded before gluing them together.
N *
N * @param p1 First parameter to concatenating
N * @param p2 Second parameter to concatenating
N *
N * @return Two parameters glued together.
N *         They have to create correct C mnemonic in other case
N *         preprocessor error would be generated.
N *
N * @sa CONCAT_3
N */
N#define CONCAT_2(p1, p2)      CONCAT_2_(p1, p2)
N/** Auxiliary macro used by @ref CONCAT_2 */
N#define CONCAT_2_(p1, p2)     p1##p2
N
N/**@brief Concatenates three parameters.
N *
N * It realizes two level expansion to make it sure that all the parameters
N * are actually expanded before gluing them together.
N *
N * @param p1 First parameter to concatenating
N * @param p2 Second parameter to concatenating
N * @param p3 Third parameter to concatenating
N *
N * @return Three parameters glued together.
N *         They have to create correct C mnemonic in other case
N *         preprocessor error would be generated.
N *
N * @sa CONCAT_2
N */
N#define CONCAT_3(p1, p2, p3)  CONCAT_3_(p1, p2, p3)
N/** Auxiliary macro used by @ref CONCAT_3 */
N#define CONCAT_3_(p1, p2, p3) p1##p2##p3
N
N#define NUM_TO_STR_INTERNAL(val) #val
N/** Converts numeric value to string.
N */
N#define NUM_TO_STR(val) NUM_TO_STR_INTERNAL(val)
N
N/** Counts number of elements inside the array
N */
N#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
N
N/**@brief Set a bit in the uint32 word.
N *
N * @param[in] W  Word whose bit is being set.
N * @param[in] B  Bit number in the word to be set.
N */
N#define SET_BIT(W,B)  ((W) |= (uint32_t)(1U << (B)))
N
N
N/**@brief Clears a bit in the uint32 word.
N *
N * @param[in] W   Word whose bit is to be cleared.
N * @param[in] B   Bit number in the word to be cleared.
N */
N#define CLR_BIT(W, B) ((W) &= (~((uint32_t)1 << (B))))
N
N
N/**@brief Checks if a bit is set.
N *
N * @param[in] W   Word whose bit is to be checked.
N * @param[in] B   Bit number in the word to be checked.
N *
N * @retval 1 if bit is set.
N * @retval 0 if bit is not set.
N */
N#define IS_SET(W,B) (((W) >> (B)) & 1)
N
N#define BIT_0 0x01 /**< The value of bit 0 */
N#define BIT_1 0x02 /**< The value of bit 1 */
N#define BIT_2 0x04 /**< The value of bit 2 */
N#define BIT_3 0x08 /**< The value of bit 3 */
N#define BIT_4 0x10 /**< The value of bit 4 */
N#define BIT_5 0x20 /**< The value of bit 5 */
N#define BIT_6 0x40 /**< The value of bit 6 */
N#define BIT_7 0x80 /**< The value of bit 7 */
N#define BIT_8 0x0100 /**< The value of bit 8 */
N#define BIT_9 0x0200 /**< The value of bit 9 */
N#define BIT_10 0x0400 /**< The value of bit 10 */
N#define BIT_11 0x0800 /**< The value of bit 11 */
N#define BIT_12 0x1000 /**< The value of bit 12 */
N#define BIT_13 0x2000 /**< The value of bit 13 */
N#define BIT_14 0x4000 /**< The value of bit 14 */
N#define BIT_15 0x8000 /**< The value of bit 15 */
N#define BIT_16 0x00010000 /**< The value of bit 16 */
N#define BIT_17 0x00020000 /**< The value of bit 17 */
N#define BIT_18 0x00040000 /**< The value of bit 18 */
N#define BIT_19 0x00080000 /**< The value of bit 19 */
N#define BIT_20 0x00100000 /**< The value of bit 20 */
N#define BIT_21 0x00200000 /**< The value of bit 21 */
N#define BIT_22 0x00400000 /**< The value of bit 22 */
N#define BIT_23 0x00800000 /**< The value of bit 23 */
N#define BIT_24 0x01000000 /**< The value of bit 24 */
N#define BIT_25 0x02000000 /**< The value of bit 25 */
N#define BIT_26 0x04000000 /**< The value of bit 26 */
N#define BIT_27 0x08000000 /**< The value of bit 27 */
N#define BIT_28 0x10000000 /**< The value of bit 28 */
N#define BIT_29 0x20000000 /**< The value of bit 29 */
N#define BIT_30 0x40000000 /**< The value of bit 30 */
N#define BIT_31 0x80000000 /**< The value of bit 31 */
N
N#define UNUSED_VARIABLE(X)  ((void)(X))
N#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
N#define UNUSED_RETURN_VALUE(X) UNUSED_VARIABLE(X)
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // NORDIC_COMMON_H__
L 59 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "compiler_abstraction.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\compiler_abstraction.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef _COMPILER_ABSTRACTION_H
N#define _COMPILER_ABSTRACTION_H
N
N/*lint ++flb "Enter library region" */
N
N#if defined ( __CC_ARM )
X#if 1L
N
N    #ifndef __ASM
N        #define __ASM               __asm
N    #endif
N
N    #ifndef __INLINE
N        #define __INLINE            __inline
N    #endif
N
N    #ifndef __WEAK
N        #define __WEAK              __weak
N    #endif
N
N    #ifndef __ALIGN
N        #define __ALIGN(n)          __align(n)
N    #endif
N
N    #ifndef __PACKED
N        #define __PACKED            __packed
N    #endif
N
N    #define GET_SP()                __current_sp()
N
N#elif defined ( __ICCARM__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __weak
S    #endif
S
S    #ifndef __ALIGN
S        #define STRING_PRAGMA(x) _Pragma(#x)
S        #define __ALIGN(n) STRING_PRAGMA(data_alignment = n)
S    #endif
S
S    #ifndef __PACKED
S        #define __PACKED            __packed
S    #endif
S    
S    #define GET_SP()                __get_SP()
S
S#elif defined   ( __GNUC__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __attribute__((weak))
S    #endif
S
S    #ifndef __ALIGN
S        #define __ALIGN(n)          __attribute__((aligned(n)))
S    #endif
S
S    #ifndef __PACKED
S        #define __PACKED           __attribute__((packed)) 
S    #endif
S
S    #define GET_SP()                gcc_current_sp()
S
S    static inline unsigned int gcc_current_sp(void)
S    {
S        register unsigned sp __ASM("sp");
S        return sp;
S    }
S
S#elif defined   ( __TASKING__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __attribute__((weak))
S    #endif
S
S    #ifndef __ALIGN
S        #define __ALIGN(n)          __align(n)
S    #endif
S    
S    /* Not defined for TASKING. */
S    #ifndef __PACKED
S        #define __PACKED
S    #endif
S
S    #define GET_SP()                __get_MSP()
S
N#endif
N
N/*lint --flb "Leave library region" */
N
N#endif
L 60 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "sdk_os.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_os.h" 1
N/**
N * Copyright (c) 2013 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N /** @cond */
N/**@file
N *
N * @defgroup sdk_os SDK OS Abstraction
N * @ingroup experimental_api
N * @details In order to made SDK modules independent of use of an embedded OS, and permit
N *          application with varied task architecture, SDK abstracts the OS specific
N *          elements here in order to make all other modules agnostic to the OS or task
N *          architecture.
N * @{
N */
N
N#ifndef SDK_OS_H__
N#define SDK_OS_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define SDK_MUTEX_DEFINE(X)
N#define SDK_MUTEX_INIT(X)
N#define SDK_MUTEX_LOCK(X)
N#define SDK_MUTEX_UNLOCK(X)
N
N/**
N * @defgroup os_data_type Data types.
N */
N
N/** @} */
N/** @endcond */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_OS_H__
N
L 61 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "sdk_errors.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_errors.h" 1
N/**
N * Copyright (c) 2013 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/**@file
N *
N * @defgroup sdk_error SDK Error codes
N * @{
N * @ingroup app_common
N * @{
N * @details Error codes are 32-bit unsigned integers with the most significant 16-bit reserved for
N *          identifying the module where the error occurred while the least least significant LSB
N *          are used to provide the cause or nature of error. Each module is assigned a 16-bit
N *          unsigned integer. Which it will use to identify all errors that occurred in it. 16-bit
N *          LSB range is with module id as the MSB in the 32-bit error code is reserved for the
N *          module. As an example, if 0x8800 identifies a certain SDK module, all values from
N *          0x88000000 - 0x8800FFFF are reserved for this module.
N *          It should be noted that common error reasons have been assigned values to make it
N *          possible to decode error reason easily. As an example, lets module uninitialized has
N *          been assigned an error code 0x000A0. Then, if application encounters an error code
N *          0xZZZZ00A0, it knows that it accessing a certain module without initializing it.
N *          Apart from this, each module is allowed to define error codes that are not covered by
N *          the common ones, however, these values are defined in a range that does not conflict
N *          with common error values. For module, specific error however, it is possible that the
N *          same error value is used by two different modules to indicated errors of very different
N *          nature. If error is already defined by the NRF common error codes, these are reused.
N *          A range is reserved for application as well, it can use this range for defining
N *          application specific errors.
N *
N * @note Success code, NRF_SUCCESS, does not include any module identifier.
N
N */
N
N#ifndef SDK_ERRORS_H__
N#define SDK_ERRORS_H__
N
N#include <stdint.h>
N#include "nrf_error.h"
L 1 "..\..\..\..\..\..\components\softdevice\s130\headers\nrf_error.h" 1
N/* 
N * Copyright (c) Nordic Semiconductor ASA
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N *   1. Redistributions of source code must retain the above copyright notice, this
N *   list of conditions and the following disclaimer.
N * 
N *   2. Redistributions in binary form must reproduce the above copyright notice, this
N *   list of conditions and the following disclaimer in the documentation and/or
N *   other materials provided with the distribution.
N * 
N *   3. Neither the name of Nordic Semiconductor ASA nor the names of other
N *   contributors to this software may be used to endorse or promote products
N *   derived from this software without specific prior written permission.
N * 
N *   4. This software must only be used in a processor manufactured by Nordic
N *   Semiconductor ASA, or in a processor manufactured by a third party that
N *   is used in combination with a processor manufactured by Nordic Semiconductor.
N * 
N * 
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
N * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
N * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
N * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
N * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
N * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
N * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
N * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */ 
N /**
N  @defgroup nrf_error SoftDevice Global Error Codes
N  @{
N   
N  @brief Global Error definitions
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_H__
N#define NRF_ERROR_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @defgroup NRF_ERRORS_BASE Error Codes Base number definitions
N * @{ */
N#define NRF_ERROR_BASE_NUM      (0x0)       ///< Global error base
N#define NRF_ERROR_SDM_BASE_NUM  (0x1000)    ///< SDM error base
N#define NRF_ERROR_SOC_BASE_NUM  (0x2000)    ///< SoC error base
N#define NRF_ERROR_STK_BASE_NUM  (0x3000)    ///< STK error base
N/** @} */
N
N#define NRF_SUCCESS                           (NRF_ERROR_BASE_NUM + 0)  ///< Successful command
N#define NRF_ERROR_SVC_HANDLER_MISSING         (NRF_ERROR_BASE_NUM + 1)  ///< SVC handler is missing
N#define NRF_ERROR_SOFTDEVICE_NOT_ENABLED      (NRF_ERROR_BASE_NUM + 2)  ///< SoftDevice has not been enabled
N#define NRF_ERROR_INTERNAL                    (NRF_ERROR_BASE_NUM + 3)  ///< Internal Error
N#define NRF_ERROR_NO_MEM                      (NRF_ERROR_BASE_NUM + 4)  ///< No Memory for operation
N#define NRF_ERROR_NOT_FOUND                   (NRF_ERROR_BASE_NUM + 5)  ///< Not found
N#define NRF_ERROR_NOT_SUPPORTED               (NRF_ERROR_BASE_NUM + 6)  ///< Not supported
N#define NRF_ERROR_INVALID_PARAM               (NRF_ERROR_BASE_NUM + 7)  ///< Invalid Parameter
N#define NRF_ERROR_INVALID_STATE               (NRF_ERROR_BASE_NUM + 8)  ///< Invalid state, operation disallowed in this state
N#define NRF_ERROR_INVALID_LENGTH              (NRF_ERROR_BASE_NUM + 9)  ///< Invalid Length
N#define NRF_ERROR_INVALID_FLAGS               (NRF_ERROR_BASE_NUM + 10) ///< Invalid Flags
N#define NRF_ERROR_INVALID_DATA                (NRF_ERROR_BASE_NUM + 11) ///< Invalid Data
N#define NRF_ERROR_DATA_SIZE                   (NRF_ERROR_BASE_NUM + 12) ///< Invalid Data size
N#define NRF_ERROR_TIMEOUT                     (NRF_ERROR_BASE_NUM + 13) ///< Operation timed out
N#define NRF_ERROR_NULL                        (NRF_ERROR_BASE_NUM + 14) ///< Null Pointer
N#define NRF_ERROR_FORBIDDEN                   (NRF_ERROR_BASE_NUM + 15) ///< Forbidden Operation
N#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
N#define NRF_ERROR_BUSY                        (NRF_ERROR_BASE_NUM + 17) ///< Busy
N#define NRF_ERROR_CONN_COUNT                  (NRF_ERROR_BASE_NUM + 18) ///< Maximum connection count exceeded.
N#define NRF_ERROR_RESOURCES                   (NRF_ERROR_BASE_NUM + 19) ///< Not enough resources for operation
N
N#ifdef __cplusplus
S}
N#endif
N#endif // NRF_ERROR_H__
N
N/**
N  @}
N*/
L 75 "..\..\..\..\..\..\components\libraries\util\sdk_errors.h" 2
N#include "sdk_config.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @defgroup sdk_err_base Base defined for SDK Modules
N * @{
N */
N#define NRF_ERROR_SDK_ERROR_BASE         (NRF_ERROR_BASE_NUM + 0x8000)   /**< Base value defined for SDK module identifiers. */
N#define NRF_ERROR_SDK_COMMON_ERROR_BASE  (NRF_ERROR_BASE_NUM + 0x0080)   /**< Base error value to be used for SDK error values. */
N/* @} */
N
N/**
N * @defgroup sdk_module_codes Codes reserved as identification for module where the error occurred.
N * @{
N */
N#define NRF_ERROR_MEMORY_MANAGER_ERR_BASE   (0x8100)
N#define NRF_ERROR_PERIPH_DRIVERS_ERR_BASE   (0x8200)
N#define NRF_ERROR_GAZELLE_ERR_BASE          (0x8300)
N/* @} */
N
N
N/**
N * @defgroup sdk_iot_errors Codes reserved as identification for IoT errors.
N * @{
N */
N#define NRF_ERROR_IOT_ERR_BASE_START        (0xA000)
N#define NRF_ERROR_IOT_ERR_BASE_STOP         (0xAFFF)
N/* @} */
N
N
N/**
N * @defgroup sdk_common_errors Codes reserved as identification for common errors.
N * @{
N */
N#define NRF_ERROR_MODULE_NOT_INITIALZED      (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0000)
N#define NRF_ERROR_MUTEX_INIT_FAILED          (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0001)
N#define NRF_ERROR_MUTEX_LOCK_FAILED          (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0002)
N#define NRF_ERROR_MUTEX_UNLOCK_FAILED        (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0003)
N#define NRF_ERROR_MUTEX_COND_INIT_FAILED     (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0004)
N#define NRF_ERROR_MODULE_ALREADY_INITIALIZED (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0005)
N#define NRF_ERROR_STORAGE_FULL               (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0006)
N#define NRF_ERROR_API_NOT_IMPLEMENTED        (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0010)
N#define NRF_ERROR_FEATURE_NOT_ENABLED        (NRF_ERROR_SDK_COMMON_ERROR_BASE + 0x0011)
N/* @} */
N
N
N/**
N * @defgroup drv_specific_errors Error / status codes specific to drivers.
N * @{
N */
N#define NRF_ERROR_DRV_TWI_ERR_OVERRUN              (NRF_ERROR_PERIPH_DRIVERS_ERR_BASE + 0x0000)
N#define NRF_ERROR_DRV_TWI_ERR_ANACK                (NRF_ERROR_PERIPH_DRIVERS_ERR_BASE + 0x0001)
N#define NRF_ERROR_DRV_TWI_ERR_DNACK                (NRF_ERROR_PERIPH_DRIVERS_ERR_BASE + 0x0002)
N/* @} */
N
N/**
N * @brief API Result.
N *
N * @details Indicates success or failure of an API procedure. In case of failure, a comprehensive
N *          error code indicating cause or reason for failure is provided.
N *
N *          Though called an API result, it could used in Asynchronous notifications callback along
N *          with asynchronous callback as event result. This mechanism is employed when an event
N *          marks the end of procedure initiated using API. API result, in this case, will only be
N *          an indicative of whether the procedure has been requested successfully.
N */
Ntypedef uint32_t ret_code_t;
N
N#if defined(NRF_LOG_ENABLED) && NRF_LOG_ENABLED
X#if 1L && 1
N/**
N * @defgroup err_sizes Sizes of error code arrays.
N * @{
N */
N#define ERR_NAMES_SIZE          18
N#define ERR_NAMES_COMMON_SIZE   9
N#define ERR_NAMES_TWI_SIZE      3
N/* @} */
N
Nextern const char * m_sdk_errors_name[ERR_NAMES_SIZE];
Xextern const char * m_sdk_errors_name[18];
Nextern const char * m_sdk_errors_name_common[ERR_NAMES_COMMON_SIZE];
Xextern const char * m_sdk_errors_name_common[9];
Nextern const char * m_sdk_errors_name_twi[ERR_NAMES_TWI_SIZE];
Xextern const char * m_sdk_errors_name_twi[3];
N
N/**
N * @defgroup err_to_string Macros for converting error codes to strings.
N * @{
N */
N#define ERR_TO_STR(err_code)            m_sdk_errors_name[err_code]
N#define ERR_TO_STR_COMMON(err_code)     m_sdk_errors_name_common[err_code - NRF_ERROR_SDK_COMMON_ERROR_BASE]
N#define ERR_TO_STR_TWI(err_code)        m_sdk_errors_name_twi[err_code - NRF_ERROR_PERIPH_DRIVERS_ERR_BASE]
N#else
S#define ERR_TO_STR(err_code)            ""
S#define ERR_TO_STR_COMMON(err_code)     ""
S#define ERR_TO_STR_TWI(err_code)        ""
N#endif // NRF_LOG_ENABLED
N
N/* @} */
N/** @} */
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_ERRORS_H__
N
L 62 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "app_util.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_util.h" 1
N/**
N * Copyright (c) 2012 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @file
N *
N * @defgroup app_util Utility Functions and Definitions
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications.
N */
N
N#ifndef APP_UTIL_H__
N#define APP_UTIL_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "compiler_abstraction.h"
N#include "nrf.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef NRF_H
N#define NRF_H
N
N/* MDK version */
N#define MDK_MAJOR_VERSION   8
N#define MDK_MINOR_VERSION   11
N#define MDK_MICRO_VERSION   1
N
N/* Redefine "old" too-generic name NRF52 to NRF52832_XXAA to keep backwards compatibility. */
N#if defined (NRF52)
X#if 0L
S    #ifndef NRF52832_XXAA
S        #define NRF52832_XXAA
S    #endif
N#endif
N
N/* Define NRF52_SERIES for common use in nRF52 series devices. */
N#if defined (NRF52832_XXAA) || defined (NRF52840_XXAA)
X#if 0L || 0L
S    #define NRF52_SERIES
N#endif
N
N
N#if defined(_WIN32)
X#if 0L
S    /* Do not include nrf specific files when building for PC host */
S#elif defined(__unix)
X#elif 0L
S    /* Do not include nrf specific files when building for PC host */
S#elif defined(__APPLE__)
X#elif 0L
S    /* Do not include nrf specific files when building for PC host */
N#else
N
N    /* Device selection for device includes. */
N    #if defined (NRF51)
X    #if 1L
N        #include "nrf51.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51.h" 1
N
N/****************************************************************************************************//**
N * @file     nrf51.h
N *
N * @brief    CMSIS Cortex-M0 Peripheral Access Layer Header File for
N *           nrf51 from Nordic Semiconductor.
N *
N * @version  V522
N * @date     18. November 2016
N *
N * @note     Generated with SVDConv V2.81d 
N *           from CMSIS SVD File 'nrf51.svd' Version 522,
N *
N * @par      Copyright (c) 2016, Nordic Semiconductor ASA
N *           All rights reserved.
N *           
N *           Redistribution and use in source and binary forms, with or without
N *           modification, are permitted provided that the following conditions are met:
N *           
N *           * Redistributions of source code must retain the above copyright notice, this
N *           list of conditions and the following disclaimer.
N *           
N *           * Redistributions in binary form must reproduce the above copyright notice,
N *           this list of conditions and the following disclaimer in the documentation
N *           and/or other materials provided with the distribution.
N *           
N *           * Neither the name of Nordic Semiconductor ASA nor the names of its
N *           contributors may be used to endorse or promote products derived from
N *           this software without specific prior written permission.
N *           
N *           THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N *           AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N *           IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N *           DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N *           FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N *           DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N *           SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N *           CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N *           OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N *           OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *           
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup Nordic Semiconductor
N  * @{
N  */
N
N/** @addtogroup nrf51
N  * @{
N  */
N
N#ifndef NRF51_H
N#define NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M0 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* ----------------------  nrf51 Specific Interrupt Numbers  ---------------------- */
N  POWER_CLOCK_IRQn              =   0,              /*!<   0  POWER_CLOCK                                                      */
N  RADIO_IRQn                    =   1,              /*!<   1  RADIO                                                            */
N  UART0_IRQn                    =   2,              /*!<   2  UART0                                                            */
N  SPI0_TWI0_IRQn                =   3,              /*!<   3  SPI0_TWI0                                                        */
N  SPI1_TWI1_IRQn                =   4,              /*!<   4  SPI1_TWI1                                                        */
N  GPIOTE_IRQn                   =   6,              /*!<   6  GPIOTE                                                           */
N  ADC_IRQn                      =   7,              /*!<   7  ADC                                                              */
N  TIMER0_IRQn                   =   8,              /*!<   8  TIMER0                                                           */
N  TIMER1_IRQn                   =   9,              /*!<   9  TIMER1                                                           */
N  TIMER2_IRQn                   =  10,              /*!<  10  TIMER2                                                           */
N  RTC0_IRQn                     =  11,              /*!<  11  RTC0                                                             */
N  TEMP_IRQn                     =  12,              /*!<  12  TEMP                                                             */
N  RNG_IRQn                      =  13,              /*!<  13  RNG                                                              */
N  ECB_IRQn                      =  14,              /*!<  14  ECB                                                              */
N  CCM_AAR_IRQn                  =  15,              /*!<  15  CCM_AAR                                                          */
N  WDT_IRQn                      =  16,              /*!<  16  WDT                                                              */
N  RTC1_IRQn                     =  17,              /*!<  17  RTC1                                                             */
N  QDEC_IRQn                     =  18,              /*!<  18  QDEC                                                             */
N  LPCOMP_IRQn                   =  19,              /*!<  19  LPCOMP                                                           */
N  SWI0_IRQn                     =  20,              /*!<  20  SWI0                                                             */
N  SWI1_IRQn                     =  21,              /*!<  21  SWI1                                                             */
N  SWI2_IRQn                     =  22,              /*!<  22  SWI2                                                             */
N  SWI3_IRQn                     =  23,              /*!<  23  SWI3                                                             */
N  SWI4_IRQn                     =  24,              /*!<  24  SWI4                                                             */
N  SWI5_IRQn                     =  25               /*!<  25  SWI5                                                             */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the Cortex-M0 Processor and Core Peripherals---------------- */
N#define __CM0_REV                 0x0301            /*!< Cortex-M0 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               2            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include "core_cm0.h"                               /*!< Cortex-M0 processor and core peripherals                              */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V4.00
N * @date     22. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.00
N * @date     28. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050041 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x00) >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit. The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit. The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RRX(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
S{
S   __ASM volatile ("strbt %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
S{
S   __ASM volatile ("strht %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
S{
S   __ASM volatile ("strt %1, %0" : "=Q" (*addr) : "r" (value) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 149 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.00
N * @date     28. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050041 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x00) >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
X#if       ((0x00) == 0x04) || ((0x00) == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 150 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_CALIB_TENMS_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 120 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51.h" 2
N#include "system_nrf51.h"                           /*!< nrf51 System                                                          */
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\system_nrf51.h" 1
N/* Copyright (c) 2012 ARM LIMITED
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of ARM nor the names of its contributors may be used to
N *     endorse or promote products derived from this software without specific
N *     prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef SYSTEM_NRF51_H
N#define SYSTEM_NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_NRF51_H */
L 121 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51.h" 2
N
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
Ntypedef struct {
N  __O  uint32_t  EN;                                /*!< Enable channel group.                                                 */
X  volatile  uint32_t  EN;                                 
N  __O  uint32_t  DIS;                               /*!< Disable channel group.                                                */
X  volatile  uint32_t  DIS;                                
N} PPI_TASKS_CHG_Type;
N
Ntypedef struct {
N  __IO uint32_t  EEP;                               /*!< Channel event end-point.                                              */
X  volatile uint32_t  EEP;                                
N  __IO uint32_t  TEP;                               /*!< Channel task end-point.                                               */
X  volatile uint32_t  TEP;                                
N} PPI_CH_Type;
N
N
N/* ================================================================================ */
N/* ================                      POWER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Power Control. (POWER)
N  */
N
Ntypedef struct {                                    /*!< POWER Structure                                                       */
N  __I  uint32_t  RESERVED0[30];
X  volatile const  uint32_t  RESERVED0[30];
N  __O  uint32_t  TASKS_CONSTLAT;                    /*!< Enable constant latency mode.                                         */
X  volatile  uint32_t  TASKS_CONSTLAT;                     
N  __O  uint32_t  TASKS_LOWPWR;                      /*!< Enable low power mode (variable latency).                             */
X  volatile  uint32_t  TASKS_LOWPWR;                       
N  __I  uint32_t  RESERVED1[34];
X  volatile const  uint32_t  RESERVED1[34];
N  __IO uint32_t  EVENTS_POFWARN;                    /*!< Power failure warning.                                                */
X  volatile uint32_t  EVENTS_POFWARN;                     
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __IO uint32_t  RESETREAS;                         /*!< Reset reason.                                                         */
X  volatile uint32_t  RESETREAS;                          
N  __I  uint32_t  RESERVED4[9];
X  volatile const  uint32_t  RESERVED4[9];
N  __I  uint32_t  RAMSTATUS;                         /*!< Ram status register.                                                  */
X  volatile const  uint32_t  RAMSTATUS;                          
N  __I  uint32_t  RESERVED5[53];
X  volatile const  uint32_t  RESERVED5[53];
N  __O  uint32_t  SYSTEMOFF;                         /*!< System off register.                                                  */
X  volatile  uint32_t  SYSTEMOFF;                          
N  __I  uint32_t  RESERVED6[3];
X  volatile const  uint32_t  RESERVED6[3];
N  __IO uint32_t  POFCON;                            /*!< Power failure configuration.                                          */
X  volatile uint32_t  POFCON;                             
N  __I  uint32_t  RESERVED7[2];
X  volatile const  uint32_t  RESERVED7[2];
N  __IO uint32_t  GPREGRET;                          /*!< General purpose retention register. This register is a retained
X  volatile uint32_t  GPREGRET;                          
N                                                         register.                                                             */
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  RAMON;                             /*!< Ram on/off.                                                           */
X  volatile uint32_t  RAMON;                              
N  __I  uint32_t  RESERVED9[7];
X  volatile const  uint32_t  RESERVED9[7];
N  __IO uint32_t  RESET;                             /*!< Pin reset functionality configuration register. This register
X  volatile uint32_t  RESET;                             
N                                                         is a retained register.                                               */
N  __I  uint32_t  RESERVED10[3];
X  volatile const  uint32_t  RESERVED10[3];
N  __IO uint32_t  RAMONB;                            /*!< Ram on/off.                                                           */
X  volatile uint32_t  RAMONB;                             
N  __I  uint32_t  RESERVED11[8];
X  volatile const  uint32_t  RESERVED11[8];
N  __IO uint32_t  DCDCEN;                            /*!< DCDC converter enable configuration register.                         */
X  volatile uint32_t  DCDCEN;                             
N  __I  uint32_t  RESERVED12[291];
X  volatile const  uint32_t  RESERVED12[291];
N  __IO uint32_t  DCDCFORCE;                         /*!< DCDC power-up force register.                                         */
X  volatile uint32_t  DCDCFORCE;                          
N} NRF_POWER_Type;
N
N
N/* ================================================================================ */
N/* ================                      CLOCK                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Clock control. (CLOCK)
N  */
N
Ntypedef struct {                                    /*!< CLOCK Structure                                                       */
N  __O  uint32_t  TASKS_HFCLKSTART;                  /*!< Start HFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_HFCLKSTART;                   
N  __O  uint32_t  TASKS_HFCLKSTOP;                   /*!< Stop HFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_HFCLKSTOP;                    
N  __O  uint32_t  TASKS_LFCLKSTART;                  /*!< Start LFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_LFCLKSTART;                   
N  __O  uint32_t  TASKS_LFCLKSTOP;                   /*!< Stop LFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_LFCLKSTOP;                    
N  __O  uint32_t  TASKS_CAL;                         /*!< Start calibration of LFCLK RC oscillator.                             */
X  volatile  uint32_t  TASKS_CAL;                          
N  __O  uint32_t  TASKS_CTSTART;                     /*!< Start calibration timer.                                              */
X  volatile  uint32_t  TASKS_CTSTART;                      
N  __O  uint32_t  TASKS_CTSTOP;                      /*!< Stop calibration timer.                                               */
X  volatile  uint32_t  TASKS_CTSTOP;                       
N  __I  uint32_t  RESERVED0[57];
X  volatile const  uint32_t  RESERVED0[57];
N  __IO uint32_t  EVENTS_HFCLKSTARTED;               /*!< HFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_HFCLKSTARTED;                
N  __IO uint32_t  EVENTS_LFCLKSTARTED;               /*!< LFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_LFCLKSTARTED;                
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __IO uint32_t  EVENTS_DONE;                       /*!< Calibration of LFCLK RC oscillator completed.                         */
X  volatile uint32_t  EVENTS_DONE;                        
N  __IO uint32_t  EVENTS_CTTO;                       /*!< Calibration timer timeout.                                            */
X  volatile uint32_t  EVENTS_CTTO;                        
N  __I  uint32_t  RESERVED2[124];
X  volatile const  uint32_t  RESERVED2[124];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __I  uint32_t  HFCLKRUN;                          /*!< Task HFCLKSTART trigger status.                                       */
X  volatile const  uint32_t  HFCLKRUN;                           
N  __I  uint32_t  HFCLKSTAT;                         /*!< High frequency clock status.                                          */
X  volatile const  uint32_t  HFCLKSTAT;                          
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __I  uint32_t  LFCLKRUN;                          /*!< Task LFCLKSTART triggered status.                                     */
X  volatile const  uint32_t  LFCLKRUN;                           
N  __I  uint32_t  LFCLKSTAT;                         /*!< Low frequency clock status.                                           */
X  volatile const  uint32_t  LFCLKSTAT;                          
N  __I  uint32_t  LFCLKSRCCOPY;                      /*!< Clock source for the LFCLK clock, set when task LKCLKSTART is
X  volatile const  uint32_t  LFCLKSRCCOPY;                      
N                                                         triggered.                                                            */
N  __I  uint32_t  RESERVED5[62];
X  volatile const  uint32_t  RESERVED5[62];
N  __IO uint32_t  LFCLKSRC;                          /*!< Clock source for the LFCLK clock.                                     */
X  volatile uint32_t  LFCLKSRC;                           
N  __I  uint32_t  RESERVED6[7];
X  volatile const  uint32_t  RESERVED6[7];
N  __IO uint32_t  CTIV;                              /*!< Calibration timer interval.                                           */
X  volatile uint32_t  CTIV;                               
N  __I  uint32_t  RESERVED7[5];
X  volatile const  uint32_t  RESERVED7[5];
N  __IO uint32_t  XTALFREQ;                          /*!< Crystal frequency.                                                    */
X  volatile uint32_t  XTALFREQ;                           
N} NRF_CLOCK_Type;
N
N
N/* ================================================================================ */
N/* ================                       MPU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Memory Protection Unit. (MPU)
N  */
N
Ntypedef struct {                                    /*!< MPU Structure                                                         */
N  __I  uint32_t  RESERVED0[330];
X  volatile const  uint32_t  RESERVED0[330];
N  __IO uint32_t  PERR0;                             /*!< Configuration of peripherals in mpu regions.                          */
X  volatile uint32_t  PERR0;                              
N  __IO uint32_t  RLENR0;                            /*!< Length of RAM region 0.                                               */
X  volatile uint32_t  RLENR0;                             
N  __I  uint32_t  RESERVED1[52];
X  volatile const  uint32_t  RESERVED1[52];
N  __IO uint32_t  PROTENSET0;                        /*!< Erase and write protection bit enable set register.                   */
X  volatile uint32_t  PROTENSET0;                         
N  __IO uint32_t  PROTENSET1;                        /*!< Erase and write protection bit enable set register.                   */
X  volatile uint32_t  PROTENSET1;                         
N  __IO uint32_t  DISABLEINDEBUG;                    /*!< Disable erase and write protection mechanism in debug mode.           */
X  volatile uint32_t  DISABLEINDEBUG;                     
N  __IO uint32_t  PROTBLOCKSIZE;                     /*!< Erase and write protection block size.                                */
X  volatile uint32_t  PROTBLOCKSIZE;                      
N} NRF_MPU_Type;
N
N
N/* ================================================================================ */
N/* ================                      RADIO                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief The radio. (RADIO)
N  */
N
Ntypedef struct {                                    /*!< RADIO Structure                                                       */
N  __O  uint32_t  TASKS_TXEN;                        /*!< Enable radio in TX mode.                                              */
X  volatile  uint32_t  TASKS_TXEN;                         
N  __O  uint32_t  TASKS_RXEN;                        /*!< Enable radio in RX mode.                                              */
X  volatile  uint32_t  TASKS_RXEN;                         
N  __O  uint32_t  TASKS_START;                       /*!< Start radio.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop radio.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable radio.                                                        */
X  volatile  uint32_t  TASKS_DISABLE;                      
N  __O  uint32_t  TASKS_RSSISTART;                   /*!< Start the RSSI and take one sample of the receive signal strength.    */
X  volatile  uint32_t  TASKS_RSSISTART;                    
N  __O  uint32_t  TASKS_RSSISTOP;                    /*!< Stop the RSSI measurement.                                            */
X  volatile  uint32_t  TASKS_RSSISTOP;                     
N  __O  uint32_t  TASKS_BCSTART;                     /*!< Start the bit counter.                                                */
X  volatile  uint32_t  TASKS_BCSTART;                      
N  __O  uint32_t  TASKS_BCSTOP;                      /*!< Stop the bit counter.                                                 */
X  volatile  uint32_t  TASKS_BCSTOP;                       
N  __I  uint32_t  RESERVED0[55];
X  volatile const  uint32_t  RESERVED0[55];
N  __IO uint32_t  EVENTS_READY;                      /*!< Ready event.                                                          */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_ADDRESS;                    /*!< Address event.                                                        */
X  volatile uint32_t  EVENTS_ADDRESS;                     
N  __IO uint32_t  EVENTS_PAYLOAD;                    /*!< Payload event.                                                        */
X  volatile uint32_t  EVENTS_PAYLOAD;                     
N  __IO uint32_t  EVENTS_END;                        /*!< End event.                                                            */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_DISABLED;                   /*!< Disable event.                                                        */
X  volatile uint32_t  EVENTS_DISABLED;                    
N  __IO uint32_t  EVENTS_DEVMATCH;                   /*!< A device address match occurred on the last received packet.          */
X  volatile uint32_t  EVENTS_DEVMATCH;                    
N  __IO uint32_t  EVENTS_DEVMISS;                    /*!< No device address match occurred on the last received packet.         */
X  volatile uint32_t  EVENTS_DEVMISS;                     
N  __IO uint32_t  EVENTS_RSSIEND;                    /*!< Sampling of the receive signal strength complete. A new RSSI
X  volatile uint32_t  EVENTS_RSSIEND;                    
N                                                         sample is ready for readout at the RSSISAMPLE register.               */
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __IO uint32_t  EVENTS_BCMATCH;                    /*!< Bit counter reached bit count value specified in BCC register.        */
X  volatile uint32_t  EVENTS_BCMATCH;                     
N  __I  uint32_t  RESERVED2[53];
X  volatile const  uint32_t  RESERVED2[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the radio.                                              */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[61];
X  volatile const  uint32_t  RESERVED4[61];
N  __I  uint32_t  CRCSTATUS;                         /*!< CRC status of received packet.                                        */
X  volatile const  uint32_t  CRCSTATUS;                          
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __I  uint32_t  RXMATCH;                           /*!< Received address.                                                     */
X  volatile const  uint32_t  RXMATCH;                            
N  __I  uint32_t  RXCRC;                             /*!< Received CRC.                                                         */
X  volatile const  uint32_t  RXCRC;                              
N  __I  uint32_t  DAI;                               /*!< Device address match index.                                           */
X  volatile const  uint32_t  DAI;                                
N  __I  uint32_t  RESERVED6[60];
X  volatile const  uint32_t  RESERVED6[60];
N  __IO uint32_t  PACKETPTR;                         /*!< Packet pointer. Decision point: START task.                           */
X  volatile uint32_t  PACKETPTR;                          
N  __IO uint32_t  FREQUENCY;                         /*!< Frequency.                                                            */
X  volatile uint32_t  FREQUENCY;                          
N  __IO uint32_t  TXPOWER;                           /*!< Output power.                                                         */
X  volatile uint32_t  TXPOWER;                            
N  __IO uint32_t  MODE;                              /*!< Data rate and modulation.                                             */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  PCNF0;                             /*!< Packet configuration 0.                                               */
X  volatile uint32_t  PCNF0;                              
N  __IO uint32_t  PCNF1;                             /*!< Packet configuration 1.                                               */
X  volatile uint32_t  PCNF1;                              
N  __IO uint32_t  BASE0;                             /*!< Radio base address 0. Decision point: START task.                     */
X  volatile uint32_t  BASE0;                              
N  __IO uint32_t  BASE1;                             /*!< Radio base address 1. Decision point: START task.                     */
X  volatile uint32_t  BASE1;                              
N  __IO uint32_t  PREFIX0;                           /*!< Prefixes bytes for logical addresses 0 to 3.                          */
X  volatile uint32_t  PREFIX0;                            
N  __IO uint32_t  PREFIX1;                           /*!< Prefixes bytes for logical addresses 4 to 7.                          */
X  volatile uint32_t  PREFIX1;                            
N  __IO uint32_t  TXADDRESS;                         /*!< Transmit address select.                                              */
X  volatile uint32_t  TXADDRESS;                          
N  __IO uint32_t  RXADDRESSES;                       /*!< Receive address select.                                               */
X  volatile uint32_t  RXADDRESSES;                        
N  __IO uint32_t  CRCCNF;                            /*!< CRC configuration.                                                    */
X  volatile uint32_t  CRCCNF;                             
N  __IO uint32_t  CRCPOLY;                           /*!< CRC polynomial.                                                       */
X  volatile uint32_t  CRCPOLY;                            
N  __IO uint32_t  CRCINIT;                           /*!< CRC initial value.                                                    */
X  volatile uint32_t  CRCINIT;                            
N  __IO uint32_t  TEST;                              /*!< Test features enable register.                                        */
X  volatile uint32_t  TEST;                               
N  __IO uint32_t  TIFS;                              /*!< Inter Frame Spacing in microseconds.                                  */
X  volatile uint32_t  TIFS;                               
N  __I  uint32_t  RSSISAMPLE;                        /*!< RSSI sample.                                                          */
X  volatile const  uint32_t  RSSISAMPLE;                         
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __I  uint32_t  STATE;                             /*!< Current radio state.                                                  */
X  volatile const  uint32_t  STATE;                              
N  __IO uint32_t  DATAWHITEIV;                       /*!< Data whitening initial value.                                         */
X  volatile uint32_t  DATAWHITEIV;                        
N  __I  uint32_t  RESERVED8[2];
X  volatile const  uint32_t  RESERVED8[2];
N  __IO uint32_t  BCC;                               /*!< Bit counter compare.                                                  */
X  volatile uint32_t  BCC;                                
N  __I  uint32_t  RESERVED9[39];
X  volatile const  uint32_t  RESERVED9[39];
N  __IO uint32_t  DAB[8];                            /*!< Device address base segment.                                          */
X  volatile uint32_t  DAB[8];                             
N  __IO uint32_t  DAP[8];                            /*!< Device address prefix.                                                */
X  volatile uint32_t  DAP[8];                             
N  __IO uint32_t  DACNF;                             /*!< Device address match configuration.                                   */
X  volatile uint32_t  DACNF;                              
N  __I  uint32_t  RESERVED10[56];
X  volatile const  uint32_t  RESERVED10[56];
N  __IO uint32_t  OVERRIDE0;                         /*!< Trim value override register 0.                                       */
X  volatile uint32_t  OVERRIDE0;                          
N  __IO uint32_t  OVERRIDE1;                         /*!< Trim value override register 1.                                       */
X  volatile uint32_t  OVERRIDE1;                          
N  __IO uint32_t  OVERRIDE2;                         /*!< Trim value override register 2.                                       */
X  volatile uint32_t  OVERRIDE2;                          
N  __IO uint32_t  OVERRIDE3;                         /*!< Trim value override register 3.                                       */
X  volatile uint32_t  OVERRIDE3;                          
N  __IO uint32_t  OVERRIDE4;                         /*!< Trim value override register 4.                                       */
X  volatile uint32_t  OVERRIDE4;                          
N  __I  uint32_t  RESERVED11[561];
X  volatile const  uint32_t  RESERVED11[561];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RADIO_Type;
N
N
N/* ================================================================================ */
N/* ================                      UART                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Universal Asynchronous Receiver/Transmitter. (UART)
N  */
N
Ntypedef struct {                                    /*!< UART Structure                                                        */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start UART receiver.                                                  */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __O  uint32_t  TASKS_STOPRX;                      /*!< Stop UART receiver.                                                   */
X  volatile  uint32_t  TASKS_STOPRX;                       
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start UART transmitter.                                               */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __O  uint32_t  TASKS_STOPTX;                      /*!< Stop UART transmitter.                                                */
X  volatile  uint32_t  TASKS_STOPTX;                       
N  __I  uint32_t  RESERVED0[3];
X  volatile const  uint32_t  RESERVED0[3];
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend UART.                                                         */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __I  uint32_t  RESERVED1[56];
X  volatile const  uint32_t  RESERVED1[56];
N  __IO uint32_t  EVENTS_CTS;                        /*!< CTS activated.                                                        */
X  volatile uint32_t  EVENTS_CTS;                         
N  __IO uint32_t  EVENTS_NCTS;                       /*!< CTS deactivated.                                                      */
X  volatile uint32_t  EVENTS_NCTS;                        
N  __IO uint32_t  EVENTS_RXDRDY;                     /*!< Data received in RXD.                                                 */
X  volatile uint32_t  EVENTS_RXDRDY;                      
N  __I  uint32_t  RESERVED2[4];
X  volatile const  uint32_t  RESERVED2[4];
N  __IO uint32_t  EVENTS_TXDRDY;                     /*!< Data sent from TXD.                                                   */
X  volatile uint32_t  EVENTS_TXDRDY;                      
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error detected.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_RXTO;                       /*!< Receiver timeout.                                                     */
X  volatile uint32_t  EVENTS_RXTO;                        
N  __I  uint32_t  RESERVED5[46];
X  volatile const  uint32_t  RESERVED5[46];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for UART.                                                   */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED6[64];
X  volatile const  uint32_t  RESERVED6[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED7[93];
X  volatile const  uint32_t  RESERVED7[93];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source. Write error field to 1 to clear error.                  */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED8[31];
X  volatile const  uint32_t  RESERVED8[31];
N  __IO uint32_t  ENABLE;                            /*!< Enable UART and acquire IOs.                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  PSELRTS;                           /*!< Pin select for RTS.                                                   */
X  volatile uint32_t  PSELRTS;                            
N  __IO uint32_t  PSELTXD;                           /*!< Pin select for TXD.                                                   */
X  volatile uint32_t  PSELTXD;                            
N  __IO uint32_t  PSELCTS;                           /*!< Pin select for CTS.                                                   */
X  volatile uint32_t  PSELCTS;                            
N  __IO uint32_t  PSELRXD;                           /*!< Pin select for RXD.                                                   */
X  volatile uint32_t  PSELRXD;                            
N  __I  uint32_t  RXD;                               /*!< RXD register. On read action the buffer pointer is displaced.
X  volatile const  uint32_t  RXD;                               
N                                                         Once read the character is consumed. If read when no character
N                                                          available, the UART will stop working.                               */
N  __O  uint32_t  TXD;                               /*!< TXD register.                                                         */
X  volatile  uint32_t  TXD;                                
N  __I  uint32_t  RESERVED10;
X  volatile const  uint32_t  RESERVED10;
N  __IO uint32_t  BAUDRATE;                          /*!< UART Baudrate.                                                        */
X  volatile uint32_t  BAUDRATE;                           
N  __I  uint32_t  RESERVED11[17];
X  volatile const  uint32_t  RESERVED11[17];
N  __IO uint32_t  CONFIG;                            /*!< Configuration of parity and hardware flow control register.           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED12[675];
X  volatile const  uint32_t  RESERVED12[675];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_UART_Type;
N
N
N/* ================================================================================ */
N/* ================                       SPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI master 0. (SPI)
N  */
N
Ntypedef struct {                                    /*!< SPI Structure                                                         */
N  __I  uint32_t  RESERVED0[66];
X  volatile const  uint32_t  RESERVED0[66];
N  __IO uint32_t  EVENTS_READY;                      /*!< TXD byte sent and RXD byte received.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __I  uint32_t  RESERVED1[126];
X  volatile const  uint32_t  RESERVED1[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[125];
X  volatile const  uint32_t  RESERVED2[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPI.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __I  uint32_t  RXD;                               /*!< RX data.                                                              */
X  volatile const  uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data.                                                              */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  FREQUENCY;                         /*!< SPI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED7[681];
X  volatile const  uint32_t  RESERVED7[681];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPI_Type;
N
N
N/* ================================================================================ */
N/* ================                       TWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Two-wire interface master 0. (TWI)
N  */
N
Ntypedef struct {                                    /*!< TWI Structure                                                         */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start 2-Wire master receive sequence.                                 */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start 2-Wire master transmit sequence.                                */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop 2-Wire transaction.                                              */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend 2-Wire transaction.                                           */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume 2-Wire transaction.                                            */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED3[56];
X  volatile const  uint32_t  RESERVED3[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< Two-wire stopped.                                                     */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __IO uint32_t  EVENTS_RXDREADY;                   /*!< Two-wire ready to deliver new RXD byte received.                      */
X  volatile uint32_t  EVENTS_RXDREADY;                    
N  __I  uint32_t  RESERVED4[4];
X  volatile const  uint32_t  RESERVED4[4];
N  __IO uint32_t  EVENTS_TXDSENT;                    /*!< Two-wire finished sending last TXD byte.                              */
X  volatile uint32_t  EVENTS_TXDSENT;                     
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Two-wire error detected.                                              */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED6[4];
X  volatile const  uint32_t  RESERVED6[4];
N  __IO uint32_t  EVENTS_BB;                         /*!< Two-wire byte boundary.                                               */
X  volatile uint32_t  EVENTS_BB;                          
N  __I  uint32_t  RESERVED7[3];
X  volatile const  uint32_t  RESERVED7[3];
N  __IO uint32_t  EVENTS_SUSPENDED;                  /*!< Two-wire suspended.                                                   */
X  volatile uint32_t  EVENTS_SUSPENDED;                   
N  __I  uint32_t  RESERVED8[45];
X  volatile const  uint32_t  RESERVED8[45];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for TWI.                                                    */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED9[64];
X  volatile const  uint32_t  RESERVED9[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED10[110];
X  volatile const  uint32_t  RESERVED10[110];
N  __IO uint32_t  ERRORSRC;                          /*!< Two-wire error source. Write error field to 1 to clear error.         */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED11[14];
X  volatile const  uint32_t  RESERVED11[14];
N  __IO uint32_t  ENABLE;                            /*!< Enable two-wire master.                                               */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  PSELSCL;                           /*!< Pin select for SCL.                                                   */
X  volatile uint32_t  PSELSCL;                            
N  __IO uint32_t  PSELSDA;                           /*!< Pin select for SDA.                                                   */
X  volatile uint32_t  PSELSDA;                            
N  __I  uint32_t  RESERVED13[2];
X  volatile const  uint32_t  RESERVED13[2];
N  __I  uint32_t  RXD;                               /*!< RX data register.                                                     */
X  volatile const  uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data register.                                                     */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED14;
X  volatile const  uint32_t  RESERVED14;
N  __IO uint32_t  FREQUENCY;                         /*!< Two-wire frequency.                                                   */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED15[24];
X  volatile const  uint32_t  RESERVED15[24];
N  __IO uint32_t  ADDRESS;                           /*!< Address used in the two-wire transfer.                                */
X  volatile uint32_t  ADDRESS;                            
N  __I  uint32_t  RESERVED16[668];
X  volatile const  uint32_t  RESERVED16[668];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      SPIS                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI slave 1. (SPIS)
N  */
N
Ntypedef struct {                                    /*!< SPIS Structure                                                        */
N  __I  uint32_t  RESERVED0[9];
X  volatile const  uint32_t  RESERVED0[9];
N  __O  uint32_t  TASKS_ACQUIRE;                     /*!< Acquire SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_ACQUIRE;                      
N  __O  uint32_t  TASKS_RELEASE;                     /*!< Release SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_RELEASE;                      
N  __I  uint32_t  RESERVED1[54];
X  volatile const  uint32_t  RESERVED1[54];
N  __IO uint32_t  EVENTS_END;                        /*!< Granted transaction completed.                                        */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED2[2];
X  volatile const  uint32_t  RESERVED2[2];
N  __IO uint32_t  EVENTS_ENDRX;                      /*!< End of RXD buffer reached                                             */
X  volatile uint32_t  EVENTS_ENDRX;                       
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __IO uint32_t  EVENTS_ACQUIRED;                   /*!< Semaphore acquired.                                                   */
X  volatile uint32_t  EVENTS_ACQUIRED;                    
N  __I  uint32_t  RESERVED4[53];
X  volatile const  uint32_t  RESERVED4[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for SPIS.                                                   */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED5[64];
X  volatile const  uint32_t  RESERVED5[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED6[61];
X  volatile const  uint32_t  RESERVED6[61];
N  __I  uint32_t  SEMSTAT;                           /*!< Semaphore status.                                                     */
X  volatile const  uint32_t  SEMSTAT;                            
N  __I  uint32_t  RESERVED7[15];
X  volatile const  uint32_t  RESERVED7[15];
N  __IO uint32_t  STATUS;                            /*!< Status from last transaction.                                         */
X  volatile uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED8[47];
X  volatile const  uint32_t  RESERVED8[47];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPIS.                                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELCSN;                           /*!< Pin select for CSN.                                                   */
X  volatile uint32_t  PSELCSN;                            
N  __I  uint32_t  RESERVED10[7];
X  volatile const  uint32_t  RESERVED10[7];
N  __IO uint32_t  RXDPTR;                            /*!< RX data pointer.                                                      */
X  volatile uint32_t  RXDPTR;                             
N  __IO uint32_t  MAXRX;                             /*!< Maximum number of bytes in the receive buffer.                        */
X  volatile uint32_t  MAXRX;                              
N  __I  uint32_t  AMOUNTRX;                          /*!< Number of bytes received in last granted transaction.                 */
X  volatile const  uint32_t  AMOUNTRX;                           
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  TXDPTR;                            /*!< TX data pointer.                                                      */
X  volatile uint32_t  TXDPTR;                             
N  __IO uint32_t  MAXTX;                             /*!< Maximum number of bytes in the transmit buffer.                       */
X  volatile uint32_t  MAXTX;                              
N  __I  uint32_t  AMOUNTTX;                          /*!< Number of bytes transmitted in last granted transaction.              */
X  volatile const  uint32_t  AMOUNTTX;                           
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED13;
X  volatile const  uint32_t  RESERVED13;
N  __IO uint32_t  DEF;                               /*!< Default character.                                                    */
X  volatile uint32_t  DEF;                                
N  __I  uint32_t  RESERVED14[24];
X  volatile const  uint32_t  RESERVED14[24];
N  __IO uint32_t  ORC;                               /*!< Over-read character.                                                  */
X  volatile uint32_t  ORC;                                
N  __I  uint32_t  RESERVED15[654];
X  volatile const  uint32_t  RESERVED15[654];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPIS_Type;
N
N
N/* ================================================================================ */
N/* ================                     GPIOTE                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief GPIO tasks and events. (GPIOTE)
N  */
N
Ntypedef struct {                                    /*!< GPIOTE Structure                                                      */
N  __O  uint32_t  TASKS_OUT[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile  uint32_t  TASKS_OUT[4];                       
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_IN[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile uint32_t  EVENTS_IN[4];                       
N  __I  uint32_t  RESERVED1[27];
X  volatile const  uint32_t  RESERVED1[27];
N  __IO uint32_t  EVENTS_PORT;                       /*!< Event generated from multiple pins.                                   */
X  volatile uint32_t  EVENTS_PORT;                        
N  __I  uint32_t  RESERVED2[97];
X  volatile const  uint32_t  RESERVED2[97];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[129];
X  volatile const  uint32_t  RESERVED3[129];
N  __IO uint32_t  CONFIG[4];                         /*!< Channel configuration registers.                                      */
X  volatile uint32_t  CONFIG[4];                          
N  __I  uint32_t  RESERVED4[695];
X  volatile const  uint32_t  RESERVED4[695];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_GPIOTE_Type;
N
N
N/* ================================================================================ */
N/* ================                       ADC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Analog to digital converter. (ADC)
N  */
N
Ntypedef struct {                                    /*!< ADC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start an ADC conversion.                                              */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop ADC.                                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_END;                        /*!< ADC conversion complete.                                              */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  BUSY;                              /*!< ADC busy register.                                                    */
X  volatile const  uint32_t  BUSY;                               
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  ENABLE;                            /*!< ADC enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  CONFIG;                            /*!< ADC configuration register.                                           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESULT;                            /*!< Result of ADC conversion.                                             */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ADC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TIMER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Timer 0. (TIMER)
N  */
N
Ntypedef struct {                                    /*!< TIMER Structure                                                       */
N  __O  uint32_t  TASKS_START;                       /*!< Start Timer.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop Timer.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_COUNT;                       /*!< Increment Timer (In counter mode).                                    */
X  volatile  uint32_t  TASKS_COUNT;                        
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear timer.                                                          */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_SHUTDOWN;                    /*!< Shutdown timer.                                                       */
X  volatile  uint32_t  TASKS_SHUTDOWN;                     
N  __I  uint32_t  RESERVED0[11];
X  volatile const  uint32_t  RESERVED0[11];
N  __O  uint32_t  TASKS_CAPTURE[4];                  /*!< Capture Timer value to CC[n] registers.                               */
X  volatile  uint32_t  TASKS_CAPTURE[4];                   
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[44];
X  volatile const  uint32_t  RESERVED2[44];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for Timer.                                                  */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[126];
X  volatile const  uint32_t  RESERVED4[126];
N  __IO uint32_t  MODE;                              /*!< Timer Mode selection.                                                 */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  BITMODE;                           /*!< Sets timer behaviour.                                                 */
X  volatile uint32_t  BITMODE;                            
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  PRESCALER;                         /*!< 4-bit prescaler to source clock frequency (max value 9). Source
X  volatile uint32_t  PRESCALER;                         
N                                                         clock frequency is divided by 2^SCALE.                                */
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED7[683];
X  volatile const  uint32_t  RESERVED7[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TIMER_Type;
N
N
N/* ================================================================================ */
N/* ================                       RTC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Real time counter 0. (RTC)
N  */
N
Ntypedef struct {                                    /*!< RTC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop RTC Counter.                                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_TRIGOVRFLW;                  /*!< Set COUNTER to 0xFFFFFFF0.                                            */
X  volatile  uint32_t  TASKS_TRIGOVRFLW;                   
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_TICK;                       /*!< Event on COUNTER increment.                                           */
X  volatile uint32_t  EVENTS_TICK;                        
N  __IO uint32_t  EVENTS_OVRFLW;                     /*!< Event on COUNTER overflow.                                            */
X  volatile uint32_t  EVENTS_OVRFLW;                      
N  __I  uint32_t  RESERVED1[14];
X  volatile const  uint32_t  RESERVED1[14];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[109];
X  volatile const  uint32_t  RESERVED2[109];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[13];
X  volatile const  uint32_t  RESERVED3[13];
N  __IO uint32_t  EVTEN;                             /*!< Configures event enable routing to PPI for each RTC event.            */
X  volatile uint32_t  EVTEN;                              
N  __IO uint32_t  EVTENSET;                          /*!< Enable events routing to PPI. The reading of this register gives
X  volatile uint32_t  EVTENSET;                          
N                                                         the value of EVTEN.                                                   */
N  __IO uint32_t  EVTENCLR;                          /*!< Disable events routing to PPI. The reading of this register
X  volatile uint32_t  EVTENCLR;                          
N                                                         gives the value of EVTEN.                                             */
N  __I  uint32_t  RESERVED4[110];
X  volatile const  uint32_t  RESERVED4[110];
N  __I  uint32_t  COUNTER;                           /*!< Current COUNTER value.                                                */
X  volatile const  uint32_t  COUNTER;                            
N  __IO uint32_t  PRESCALER;                         /*!< 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).
X  volatile uint32_t  PRESCALER;                         
N                                                         Must be written when RTC is STOPed.                                   */
N  __I  uint32_t  RESERVED5[13];
X  volatile const  uint32_t  RESERVED5[13];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED6[683];
X  volatile const  uint32_t  RESERVED6[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RTC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TEMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Temperature Sensor. (TEMP)
N  */
N
Ntypedef struct {                                    /*!< TEMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start temperature measurement.                                        */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop temperature measurement.                                         */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_DATARDY;                    /*!< Temperature measurement complete, data ready event.                   */
X  volatile uint32_t  EVENTS_DATARDY;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[127];
X  volatile const  uint32_t  RESERVED2[127];
N  __I  int32_t   TEMP;                              /*!< Die temperature in degC, 2's complement format, 0.25 degC pecision.   */
X  volatile const  int32_t   TEMP;                               
N  __I  uint32_t  RESERVED3[700];
X  volatile const  uint32_t  RESERVED3[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TEMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       RNG                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Random Number Generator. (RNG)
N  */
N
Ntypedef struct {                                    /*!< RNG Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the random number generator.                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the random number generator.                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_VALRDY;                     /*!< New random number generated and written to VALUE register.            */
X  volatile uint32_t  EVENTS_VALRDY;                      
N  __I  uint32_t  RESERVED1[63];
X  volatile const  uint32_t  RESERVED1[63];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the RNG.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register                                         */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register                                       */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[126];
X  volatile const  uint32_t  RESERVED3[126];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  VALUE;                             /*!< RNG random number.                                                    */
X  volatile const  uint32_t  VALUE;                              
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RNG_Type;
N
N
N/* ================================================================================ */
N/* ================                       ECB                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES ECB Mode Encryption. (ECB)
N  */
N
Ntypedef struct {                                    /*!< ECB Structure                                                         */
N  __O  uint32_t  TASKS_STARTECB;                    /*!< Start ECB block encrypt. If a crypto operation is running, this
X  volatile  uint32_t  TASKS_STARTECB;                    
N                                                         will not initiate a new encryption and the ERRORECB event will
N                                                          be triggered.                                                        */
N  __O  uint32_t  TASKS_STOPECB;                     /*!< Stop current ECB encryption. If a crypto operation is running,
X  volatile  uint32_t  TASKS_STOPECB;                     
N                                                         this will will trigger the ERRORECB event.                            */
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_ENDECB;                     /*!< ECB block encrypt complete.                                           */
X  volatile uint32_t  EVENTS_ENDECB;                      
N  __IO uint32_t  EVENTS_ERRORECB;                   /*!< ECB block encrypt aborted due to a STOPECB task or due to an
X  volatile uint32_t  EVENTS_ERRORECB;                   
N                                                         error.                                                                */
N  __I  uint32_t  RESERVED1[127];
X  volatile const  uint32_t  RESERVED1[127];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  ECBDATAPTR;                        /*!< ECB block encrypt memory pointer.                                     */
X  volatile uint32_t  ECBDATAPTR;                         
N  __I  uint32_t  RESERVED3[701];
X  volatile const  uint32_t  RESERVED3[701];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ECB_Type;
N
N
N/* ================================================================================ */
N/* ================                       AAR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Accelerated Address Resolver. (AAR)
N  */
N
Ntypedef struct {                                    /*!< AAR Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start resolving addresses based on IRKs specified in the IRK
X  volatile  uint32_t  TASKS_START;                       
N                                                         data structure.                                                       */
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop resolving addresses.                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  EVENTS_END;                        /*!< Address resolution procedure completed.                               */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_RESOLVED;                   /*!< Address resolved.                                                     */
X  volatile uint32_t  EVENTS_RESOLVED;                    
N  __IO uint32_t  EVENTS_NOTRESOLVED;                /*!< Address not resolved.                                                 */
X  volatile uint32_t  EVENTS_NOTRESOLVED;                 
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  STATUS;                            /*!< Resolution status.                                                    */
X  volatile const  uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable AAR.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  NIRK;                              /*!< Number of Identity root Keys in the IRK data structure.               */
X  volatile uint32_t  NIRK;                               
N  __IO uint32_t  IRKPTR;                            /*!< Pointer to the IRK data structure.                                    */
X  volatile uint32_t  IRKPTR;                             
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  ADDRPTR;                           /*!< Pointer to the resolvable address (6 bytes).                          */
X  volatile uint32_t  ADDRPTR;                            
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to a scratch data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 3 bytes must be reserved.                    */
N  __I  uint32_t  RESERVED6[697];
X  volatile const  uint32_t  RESERVED6[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_AAR_Type;
N
N
N/* ================================================================================ */
N/* ================                       CCM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES CCM Mode Encryption. (CCM)
N  */
N
Ntypedef struct {                                    /*!< CCM Structure                                                         */
N  __O  uint32_t  TASKS_KSGEN;                       /*!< Start generation of key-stream. This operation will stop by
X  volatile  uint32_t  TASKS_KSGEN;                       
N                                                         itself when completed.                                                */
N  __O  uint32_t  TASKS_CRYPT;                       /*!< Start encrypt/decrypt. This operation will stop by itself when
X  volatile  uint32_t  TASKS_CRYPT;                       
N                                                         completed.                                                            */
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop encrypt/decrypt.                                                 */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_ENDKSGEN;                   /*!< Keystream generation completed.                                       */
X  volatile uint32_t  EVENTS_ENDKSGEN;                    
N  __IO uint32_t  EVENTS_ENDCRYPT;                   /*!< Encrypt/decrypt completed.                                            */
X  volatile uint32_t  EVENTS_ENDCRYPT;                    
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error happened.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the CCM.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  MICSTATUS;                         /*!< CCM RX MIC check result.                                              */
X  volatile const  uint32_t  MICSTATUS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< CCM enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  MODE;                              /*!< Operation mode.                                                       */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  CNFPTR;                            /*!< Pointer to a data structure holding AES key and NONCE vector.         */
X  volatile uint32_t  CNFPTR;                             
N  __IO uint32_t  INPTR;                             /*!< Pointer to the input packet.                                          */
X  volatile uint32_t  INPTR;                              
N  __IO uint32_t  OUTPTR;                            /*!< Pointer to the output packet.                                         */
X  volatile uint32_t  OUTPTR;                             
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to a scratch data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 43 bytes must be reserved.                   */
N  __I  uint32_t  RESERVED5[697];
X  volatile const  uint32_t  RESERVED5[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_CCM_Type;
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Watchdog Timer. (WDT)
N  */
N
Ntypedef struct {                                    /*!< WDT Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the watchdog.                                                   */
X  volatile  uint32_t  TASKS_START;                        
N  __I  uint32_t  RESERVED0[63];
X  volatile const  uint32_t  RESERVED0[63];
N  __IO uint32_t  EVENTS_TIMEOUT;                    /*!< Watchdog timeout.                                                     */
X  volatile uint32_t  EVENTS_TIMEOUT;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  RUNSTATUS;                         /*!< Watchdog running status.                                              */
X  volatile const  uint32_t  RUNSTATUS;                          
N  __I  uint32_t  REQSTATUS;                         /*!< Request status.                                                       */
X  volatile const  uint32_t  REQSTATUS;                          
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  CRV;                               /*!< Counter reload value in number of 32kiHz clock cycles.                */
X  volatile uint32_t  CRV;                                
N  __IO uint32_t  RREN;                              /*!< Reload request enable.                                                */
X  volatile uint32_t  RREN;                               
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED4[60];
X  volatile const  uint32_t  RESERVED4[60];
N  __O  uint32_t  RR[8];                             /*!< Reload requests registers.                                            */
X  volatile  uint32_t  RR[8];                              
N  __I  uint32_t  RESERVED5[631];
X  volatile const  uint32_t  RESERVED5[631];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_WDT_Type;
N
N
N/* ================================================================================ */
N/* ================                      QDEC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Rotary decoder. (QDEC)
N  */
N
Ntypedef struct {                                    /*!< QDEC Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the quadrature decoder.                                         */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the quadrature decoder.                                          */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_READCLRACC;                  /*!< Transfers the content from ACC registers to ACCREAD registers,
X  volatile  uint32_t  TASKS_READCLRACC;                  
N                                                         and clears the ACC registers.                                         */
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_SAMPLERDY;                  /*!< A new sample is written to the sample register.                       */
X  volatile uint32_t  EVENTS_SAMPLERDY;                   
N  __IO uint32_t  EVENTS_REPORTRDY;                  /*!< REPORTPER number of samples accumulated in ACC register, and
X  volatile uint32_t  EVENTS_REPORTRDY;                  
N                                                         ACC register different than zero.                                     */
N  __IO uint32_t  EVENTS_ACCOF;                      /*!< ACC or ACCDBL register overflow.                                      */
X  volatile uint32_t  EVENTS_ACCOF;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the QDEC.                                               */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[125];
X  volatile const  uint32_t  RESERVED3[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable the QDEC.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  LEDPOL;                            /*!< LED output pin polarity.                                              */
X  volatile uint32_t  LEDPOL;                             
N  __IO uint32_t  SAMPLEPER;                         /*!< Sample period.                                                        */
X  volatile uint32_t  SAMPLEPER;                          
N  __I  int32_t   SAMPLE;                            /*!< Motion sample value.                                                  */
X  volatile const  int32_t   SAMPLE;                             
N  __IO uint32_t  REPORTPER;                         /*!< Number of samples to generate an EVENT_REPORTRDY.                     */
X  volatile uint32_t  REPORTPER;                          
N  __I  int32_t   ACC;                               /*!< Accumulated valid transitions register.                               */
X  volatile const  int32_t   ACC;                                
N  __I  int32_t   ACCREAD;                           /*!< Snapshot of ACC register. Value generated by the TASKS_READCLEACC
X  volatile const  int32_t   ACCREAD;                           
N                                                         task.                                                                 */
N  __IO uint32_t  PSELLED;                           /*!< Pin select for LED output.                                            */
X  volatile uint32_t  PSELLED;                            
N  __IO uint32_t  PSELA;                             /*!< Pin select for phase A input.                                         */
X  volatile uint32_t  PSELA;                              
N  __IO uint32_t  PSELB;                             /*!< Pin select for phase B input.                                         */
X  volatile uint32_t  PSELB;                              
N  __IO uint32_t  DBFEN;                             /*!< Enable debouncer input filters.                                       */
X  volatile uint32_t  DBFEN;                              
N  __I  uint32_t  RESERVED4[5];
X  volatile const  uint32_t  RESERVED4[5];
N  __IO uint32_t  LEDPRE;                            /*!< Time LED is switched ON before the sample.                            */
X  volatile uint32_t  LEDPRE;                             
N  __I  uint32_t  ACCDBL;                            /*!< Accumulated double (error) transitions register.                      */
X  volatile const  uint32_t  ACCDBL;                             
N  __I  uint32_t  ACCDBLREAD;                        /*!< Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC
X  volatile const  uint32_t  ACCDBLREAD;                        
N                                                         task.                                                                 */
N  __I  uint32_t  RESERVED5[684];
X  volatile const  uint32_t  RESERVED5[684];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_QDEC_Type;
N
N
N/* ================================================================================ */
N/* ================                     LPCOMP                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Low power comparator. (LPCOMP)
N  */
N
Ntypedef struct {                                    /*!< LPCOMP Structure                                                      */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< LPCOMP is ready and output is valid.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the LPCOMP.                                             */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Result of last compare.                                               */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the LPCOMP.                                                    */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[4];
X  volatile const  uint32_t  RESERVED5[4];
N  __IO uint32_t  ANADETECT;                         /*!< Analog detect configuration.                                          */
X  volatile uint32_t  ANADETECT;                          
N  __I  uint32_t  RESERVED6[694];
X  volatile const  uint32_t  RESERVED6[694];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_LPCOMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       SWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SW Interrupts. (SWI)
N  */
N
Ntypedef struct {                                    /*!< SWI Structure                                                         */
N  __I  uint32_t  UNUSED;                            /*!< Unused.                                                               */
X  volatile const  uint32_t  UNUSED;                             
N} NRF_SWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      NVMC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Non Volatile Memory Controller. (NVMC)
N  */
N
Ntypedef struct {                                    /*!< NVMC Structure                                                        */
N  __I  uint32_t  RESERVED0[256];
X  volatile const  uint32_t  RESERVED0[256];
N  __I  uint32_t  READY;                             /*!< Ready flag.                                                           */
X  volatile const  uint32_t  READY;                              
N  __I  uint32_t  RESERVED1[64];
X  volatile const  uint32_t  RESERVED1[64];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  
N  union {
N    __IO uint32_t  ERASEPCR1;                       /*!< Register for erasing a non-protected non-volatile memory page.        */
X    volatile uint32_t  ERASEPCR1;                        
N    __IO uint32_t  ERASEPAGE;                       /*!< Register for erasing a non-protected non-volatile memory page.        */
X    volatile uint32_t  ERASEPAGE;                        
N  };
N  __IO uint32_t  ERASEALL;                          /*!< Register for erasing all non-volatile user memory.                    */
X  volatile uint32_t  ERASEALL;                           
N  __IO uint32_t  ERASEPCR0;                         /*!< Register for erasing a protected non-volatile memory page.            */
X  volatile uint32_t  ERASEPCR0;                          
N  __IO uint32_t  ERASEUICR;                         /*!< Register for start erasing User Information Congfiguration Registers. */
X  volatile uint32_t  ERASEUICR;                          
N} NRF_NVMC_Type;
N
N
N/* ================================================================================ */
N/* ================                       PPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief PPI controller. (PPI)
N  */
N
Ntypedef struct {                                    /*!< PPI Structure                                                         */
N  PPI_TASKS_CHG_Type TASKS_CHG[4];                  /*!< Channel group tasks.                                                  */
N  __I  uint32_t  RESERVED0[312];
X  volatile const  uint32_t  RESERVED0[312];
N  __IO uint32_t  CHEN;                              /*!< Channel enable.                                                       */
X  volatile uint32_t  CHEN;                               
N  __IO uint32_t  CHENSET;                           /*!< Channel enable set.                                                   */
X  volatile uint32_t  CHENSET;                            
N  __IO uint32_t  CHENCLR;                           /*!< Channel enable clear.                                                 */
X  volatile uint32_t  CHENCLR;                            
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  PPI_CH_Type CH[16];                               /*!< PPI Channel.                                                          */
N  __I  uint32_t  RESERVED2[156];
X  volatile const  uint32_t  RESERVED2[156];
N  __IO uint32_t  CHG[4];                            /*!< Channel group configuration.                                          */
X  volatile uint32_t  CHG[4];                             
N} NRF_PPI_Type;
N
N
N/* ================================================================================ */
N/* ================                      FICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Factory Information Configuration. (FICR)
N  */
N
Ntypedef struct {                                    /*!< FICR Structure                                                        */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __I  uint32_t  CODEPAGESIZE;                      /*!< Code memory page size in bytes.                                       */
X  volatile const  uint32_t  CODEPAGESIZE;                       
N  __I  uint32_t  CODESIZE;                          /*!< Code memory size in pages.                                            */
X  volatile const  uint32_t  CODESIZE;                           
N  __I  uint32_t  RESERVED1[4];
X  volatile const  uint32_t  RESERVED1[4];
N  __I  uint32_t  CLENR0;                            /*!< Length of code region 0 in bytes.                                     */
X  volatile const  uint32_t  CLENR0;                             
N  __I  uint32_t  PPFC;                              /*!< Pre-programmed factory code present.                                  */
X  volatile const  uint32_t  PPFC;                               
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __I  uint32_t  NUMRAMBLOCK;                       /*!< Number of individualy controllable RAM blocks.                        */
X  volatile const  uint32_t  NUMRAMBLOCK;                        
N  
N  union {
N    __I  uint32_t  SIZERAMBLOCK[4];                 /*!< Deprecated array of size of RAM block in bytes. This name is
X    volatile const  uint32_t  SIZERAMBLOCK[4];                 
N                                                         kept for backward compatinility purposes. Use SIZERAMBLOCKS
N                                                          instead.                                                             */
N    __I  uint32_t  SIZERAMBLOCKS;                   /*!< Size of RAM blocks in bytes.                                          */
X    volatile const  uint32_t  SIZERAMBLOCKS;                    
N  };
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __I  uint32_t  CONFIGID;                          /*!< Configuration identifier.                                             */
X  volatile const  uint32_t  CONFIGID;                           
N  __I  uint32_t  DEVICEID[2];                       /*!< Device identifier.                                                    */
X  volatile const  uint32_t  DEVICEID[2];                        
N  __I  uint32_t  RESERVED4[6];
X  volatile const  uint32_t  RESERVED4[6];
N  __I  uint32_t  ER[4];                             /*!< Encryption root.                                                      */
X  volatile const  uint32_t  ER[4];                              
N  __I  uint32_t  IR[4];                             /*!< Identity root.                                                        */
X  volatile const  uint32_t  IR[4];                              
N  __I  uint32_t  DEVICEADDRTYPE;                    /*!< Device address type.                                                  */
X  volatile const  uint32_t  DEVICEADDRTYPE;                     
N  __I  uint32_t  DEVICEADDR[2];                     /*!< Device address.                                                       */
X  volatile const  uint32_t  DEVICEADDR[2];                      
N  __I  uint32_t  OVERRIDEEN;                        /*!< Radio calibration override enable.                                    */
X  volatile const  uint32_t  OVERRIDEEN;                         
N  __I  uint32_t  NRF_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit
X  volatile const  uint32_t  NRF_1MBIT[5];                      
N                                                         mode.                                                                 */
N  __I  uint32_t  RESERVED5[10];
X  volatile const  uint32_t  RESERVED5[10];
N  __I  uint32_t  BLE_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit
X  volatile const  uint32_t  BLE_1MBIT[5];                      
N                                                         mode.                                                                 */
N} NRF_FICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      UICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief User Information Configuration. (UICR)
N  */
N
Ntypedef struct {                                    /*!< UICR Structure                                                        */
N  __IO uint32_t  CLENR0;                            /*!< Length of code region 0.                                              */
X  volatile uint32_t  CLENR0;                             
N  __IO uint32_t  RBPCONF;                           /*!< Readback protection configuration.                                    */
X  volatile uint32_t  RBPCONF;                            
N  __IO uint32_t  XTALFREQ;                          /*!< Reset value for CLOCK XTALFREQ register.                              */
X  volatile uint32_t  XTALFREQ;                           
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __I  uint32_t  FWID;                              /*!< Firmware ID.                                                          */
X  volatile const  uint32_t  FWID;                               
N  
N  union {
N    __IO uint32_t  NRFFW[15];                       /*!< Reserved for Nordic firmware design.                                  */
X    volatile uint32_t  NRFFW[15];                        
N    __IO uint32_t  BOOTLOADERADDR;                  /*!< Bootloader start address.                                             */
X    volatile uint32_t  BOOTLOADERADDR;                   
N  };
N  __IO uint32_t  NRFHW[12];                         /*!< Reserved for Nordic hardware design.                                  */
X  volatile uint32_t  NRFHW[12];                          
N  __IO uint32_t  CUSTOMER[32];                      /*!< Reserved for customer.                                                */
X  volatile uint32_t  CUSTOMER[32];                       
N} NRF_UICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      GPIO                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief General purpose input and output. (GPIO)
N  */
N
Ntypedef struct {                                    /*!< GPIO Structure                                                        */
N  __I  uint32_t  RESERVED0[321];
X  volatile const  uint32_t  RESERVED0[321];
N  __IO uint32_t  OUT;                               /*!< Write GPIO port.                                                      */
X  volatile uint32_t  OUT;                                
N  __IO uint32_t  OUTSET;                            /*!< Set individual bits in GPIO port.                                     */
X  volatile uint32_t  OUTSET;                             
N  __IO uint32_t  OUTCLR;                            /*!< Clear individual bits in GPIO port.                                   */
X  volatile uint32_t  OUTCLR;                             
N  __I  uint32_t  IN;                                /*!< Read GPIO port.                                                       */
X  volatile const  uint32_t  IN;                                 
N  __IO uint32_t  DIR;                               /*!< Direction of GPIO pins.                                               */
X  volatile uint32_t  DIR;                                
N  __IO uint32_t  DIRSET;                            /*!< DIR set register.                                                     */
X  volatile uint32_t  DIRSET;                             
N  __IO uint32_t  DIRCLR;                            /*!< DIR clear register.                                                   */
X  volatile uint32_t  DIRCLR;                             
N  __I  uint32_t  RESERVED1[120];
X  volatile const  uint32_t  RESERVED1[120];
N  __IO uint32_t  PIN_CNF[32];                       /*!< Configuration of GPIO pins.                                           */
X  volatile uint32_t  PIN_CNF[32];                        
N} NRF_GPIO_Type;
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER_BASE                  0x40000000UL
N#define NRF_CLOCK_BASE                  0x40000000UL
N#define NRF_MPU_BASE                    0x40000000UL
N#define NRF_RADIO_BASE                  0x40001000UL
N#define NRF_UART0_BASE                  0x40002000UL
N#define NRF_SPI0_BASE                   0x40003000UL
N#define NRF_TWI0_BASE                   0x40003000UL
N#define NRF_SPI1_BASE                   0x40004000UL
N#define NRF_TWI1_BASE                   0x40004000UL
N#define NRF_SPIS1_BASE                  0x40004000UL
N#define NRF_GPIOTE_BASE                 0x40006000UL
N#define NRF_ADC_BASE                    0x40007000UL
N#define NRF_TIMER0_BASE                 0x40008000UL
N#define NRF_TIMER1_BASE                 0x40009000UL
N#define NRF_TIMER2_BASE                 0x4000A000UL
N#define NRF_RTC0_BASE                   0x4000B000UL
N#define NRF_TEMP_BASE                   0x4000C000UL
N#define NRF_RNG_BASE                    0x4000D000UL
N#define NRF_ECB_BASE                    0x4000E000UL
N#define NRF_AAR_BASE                    0x4000F000UL
N#define NRF_CCM_BASE                    0x4000F000UL
N#define NRF_WDT_BASE                    0x40010000UL
N#define NRF_RTC1_BASE                   0x40011000UL
N#define NRF_QDEC_BASE                   0x40012000UL
N#define NRF_LPCOMP_BASE                 0x40013000UL
N#define NRF_SWI_BASE                    0x40014000UL
N#define NRF_NVMC_BASE                   0x4001E000UL
N#define NRF_PPI_BASE                    0x4001F000UL
N#define NRF_FICR_BASE                   0x10000000UL
N#define NRF_UICR_BASE                   0x10001000UL
N#define NRF_GPIO_BASE                   0x50000000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER                       ((NRF_POWER_Type          *) NRF_POWER_BASE)
N#define NRF_CLOCK                       ((NRF_CLOCK_Type          *) NRF_CLOCK_BASE)
N#define NRF_MPU                         ((NRF_MPU_Type            *) NRF_MPU_BASE)
N#define NRF_RADIO                       ((NRF_RADIO_Type          *) NRF_RADIO_BASE)
N#define NRF_UART0                       ((NRF_UART_Type           *) NRF_UART0_BASE)
N#define NRF_SPI0                        ((NRF_SPI_Type            *) NRF_SPI0_BASE)
N#define NRF_TWI0                        ((NRF_TWI_Type            *) NRF_TWI0_BASE)
N#define NRF_SPI1                        ((NRF_SPI_Type            *) NRF_SPI1_BASE)
N#define NRF_TWI1                        ((NRF_TWI_Type            *) NRF_TWI1_BASE)
N#define NRF_SPIS1                       ((NRF_SPIS_Type           *) NRF_SPIS1_BASE)
N#define NRF_GPIOTE                      ((NRF_GPIOTE_Type         *) NRF_GPIOTE_BASE)
N#define NRF_ADC                         ((NRF_ADC_Type            *) NRF_ADC_BASE)
N#define NRF_TIMER0                      ((NRF_TIMER_Type          *) NRF_TIMER0_BASE)
N#define NRF_TIMER1                      ((NRF_TIMER_Type          *) NRF_TIMER1_BASE)
N#define NRF_TIMER2                      ((NRF_TIMER_Type          *) NRF_TIMER2_BASE)
N#define NRF_RTC0                        ((NRF_RTC_Type            *) NRF_RTC0_BASE)
N#define NRF_TEMP                        ((NRF_TEMP_Type           *) NRF_TEMP_BASE)
N#define NRF_RNG                         ((NRF_RNG_Type            *) NRF_RNG_BASE)
N#define NRF_ECB                         ((NRF_ECB_Type            *) NRF_ECB_BASE)
N#define NRF_AAR                         ((NRF_AAR_Type            *) NRF_AAR_BASE)
N#define NRF_CCM                         ((NRF_CCM_Type            *) NRF_CCM_BASE)
N#define NRF_WDT                         ((NRF_WDT_Type            *) NRF_WDT_BASE)
N#define NRF_RTC1                        ((NRF_RTC_Type            *) NRF_RTC1_BASE)
N#define NRF_QDEC                        ((NRF_QDEC_Type           *) NRF_QDEC_BASE)
N#define NRF_LPCOMP                      ((NRF_LPCOMP_Type         *) NRF_LPCOMP_BASE)
N#define NRF_SWI                         ((NRF_SWI_Type            *) NRF_SWI_BASE)
N#define NRF_NVMC                        ((NRF_NVMC_Type           *) NRF_NVMC_BASE)
N#define NRF_PPI                         ((NRF_PPI_Type            *) NRF_PPI_BASE)
N#define NRF_FICR                        ((NRF_FICR_Type           *) NRF_FICR_BASE)
N#define NRF_UICR                        ((NRF_UICR_Type           *) NRF_UICR_BASE)
N#define NRF_GPIO                        ((NRF_GPIO_Type           *) NRF_GPIO_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group nrf51 */
N/** @} */ /* End of group Nordic Semiconductor */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* nrf51_H */
N
L 63 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 2
N        #include "nrf51_bitfields.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51_bitfields.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef __NRF51_BITS_H
N#define __NRF51_BITS_H
N
N/*lint ++flb "Enter library region" */
N
N/* Peripheral: AAR */
N/* Description: Accelerated Address Resolver. */
N
N/* Register: AAR_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on NOTRESOLVED event. */
N#define AAR_INTENSET_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Msk (0x1UL << AAR_INTENSET_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_NOTRESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on RESOLVED event. */
N#define AAR_INTENSET_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Msk (0x1UL << AAR_INTENSET_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_RESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define AAR_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENSET_END_Msk (0x1UL << AAR_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: AAR_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on NOTRESOLVED event. */
N#define AAR_INTENCLR_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Msk (0x1UL << AAR_INTENCLR_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on RESOLVED event. */
N#define AAR_INTENCLR_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Msk (0x1UL << AAR_INTENCLR_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_RESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define AAR_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENCLR_END_Msk (0x1UL << AAR_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: AAR_STATUS */
N/* Description: Resolution status. */
N
N/* Bits 3..0 : The IRK used last time an address was resolved. */
N#define AAR_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define AAR_STATUS_STATUS_Msk (0xFUL << AAR_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
N
N/* Register: AAR_ENABLE */
N/* Description: Enable AAR. */
N
N/* Bits 1..0 : Enable AAR. */
N#define AAR_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Msk (0x3UL << AAR_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled AAR. */
N#define AAR_ENABLE_ENABLE_Enabled (0x03UL) /*!< Enable AAR. */
N
N/* Register: AAR_NIRK */
N/* Description: Number of Identity root Keys in the IRK data structure. */
N
N/* Bits 4..0 : Number of Identity root Keys in the IRK data structure. */
N#define AAR_NIRK_NIRK_Pos (0UL) /*!< Position of NIRK field. */
N#define AAR_NIRK_NIRK_Msk (0x1FUL << AAR_NIRK_NIRK_Pos) /*!< Bit mask of NIRK field. */
N
N/* Register: AAR_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define AAR_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define AAR_POWER_POWER_Msk (0x1UL << AAR_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define AAR_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define AAR_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: ADC */
N/* Description: Analog to digital converter. */
N
N/* Register: ADC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define ADC_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENSET_END_Msk (0x1UL << ADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ADC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on END event. */
N#define ADC_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENCLR_END_Msk (0x1UL << ADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ADC_BUSY */
N/* Description: ADC busy register. */
N
N/* Bit 0 : ADC busy register. */
N#define ADC_BUSY_BUSY_Pos (0UL) /*!< Position of BUSY field. */
N#define ADC_BUSY_BUSY_Msk (0x1UL << ADC_BUSY_BUSY_Pos) /*!< Bit mask of BUSY field. */
N#define ADC_BUSY_BUSY_Ready (0UL) /*!< No ongoing ADC conversion is taking place. ADC is ready. */
N#define ADC_BUSY_BUSY_Busy (1UL) /*!< An ADC conversion is taking place. ADC is busy. */
N
N/* Register: ADC_ENABLE */
N/* Description: ADC enable. */
N
N/* Bits 1..0 : ADC enable. */
N#define ADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Msk (0x3UL << ADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Disabled (0x00UL) /*!< ADC is disabled. */
N#define ADC_ENABLE_ENABLE_Enabled (0x01UL) /*!< ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input. */
N
N/* Register: ADC_CONFIG */
N/* Description: ADC configuration register. */
N
N/* Bits 17..16 : ADC external reference pin selection. */
N#define ADC_CONFIG_EXTREFSEL_Pos (16UL) /*!< Position of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_Msk (0x3UL << ADC_CONFIG_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_None (0UL) /*!< Analog external reference inputs disabled. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference0 (1UL) /*!< Use analog reference 0 as reference. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference1 (2UL) /*!< Use analog reference 1 as reference. */
N
N/* Bits 15..8 : ADC analog pin selection. */
N#define ADC_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define ADC_CONFIG_PSEL_Msk (0xFFUL << ADC_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define ADC_CONFIG_PSEL_Disabled (0UL) /*!< Analog input pins disabled. */
N#define ADC_CONFIG_PSEL_AnalogInput0 (1UL) /*!< Use analog input 0 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput1 (2UL) /*!< Use analog input 1 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput2 (4UL) /*!< Use analog input 2 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput3 (8UL) /*!< Use analog input 3 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput4 (16UL) /*!< Use analog input 4 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput5 (32UL) /*!< Use analog input 5 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput6 (64UL) /*!< Use analog input 6 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput7 (128UL) /*!< Use analog input 7 as analog input. */
N
N/* Bits 6..5 : ADC reference selection. */
N#define ADC_CONFIG_REFSEL_Pos (5UL) /*!< Position of REFSEL field. */
N#define ADC_CONFIG_REFSEL_Msk (0x3UL << ADC_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define ADC_CONFIG_REFSEL_VBG (0x00UL) /*!< Use internal 1.2V bandgap voltage as reference for conversion. */
N#define ADC_CONFIG_REFSEL_External (0x01UL) /*!< Use external source configured by EXTREFSEL as reference for conversion. */
N#define ADC_CONFIG_REFSEL_SupplyOneHalfPrescaling (0x02UL) /*!< Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V. */
N#define ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling (0x03UL) /*!< Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V. */
N
N/* Bits 4..2 : ADC input selection. */
N#define ADC_CONFIG_INPSEL_Pos (2UL) /*!< Position of INPSEL field. */
N#define ADC_CONFIG_INPSEL_Msk (0x7UL << ADC_CONFIG_INPSEL_Pos) /*!< Bit mask of INPSEL field. */
N#define ADC_CONFIG_INPSEL_AnalogInputNoPrescaling (0x00UL) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputTwoThirdsPrescaling (0x01UL) /*!< Analog input specified by PSEL with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling (0x02UL) /*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyTwoThirdsPrescaling (0x05UL) /*!< Supply voltage with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling (0x06UL) /*!< Supply voltage with 1/3 prescaling used as input for the conversion. */
N
N/* Bits 1..0 : ADC resolution. */
N#define ADC_CONFIG_RES_Pos (0UL) /*!< Position of RES field. */
N#define ADC_CONFIG_RES_Msk (0x3UL << ADC_CONFIG_RES_Pos) /*!< Bit mask of RES field. */
N#define ADC_CONFIG_RES_8bit (0x00UL) /*!< 8bit ADC resolution. */
N#define ADC_CONFIG_RES_9bit (0x01UL) /*!< 9bit ADC resolution. */
N#define ADC_CONFIG_RES_10bit (0x02UL) /*!< 10bit ADC resolution. */
N
N/* Register: ADC_RESULT */
N/* Description: Result of ADC conversion. */
N
N/* Bits 9..0 : Result of ADC conversion. */
N#define ADC_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define ADC_RESULT_RESULT_Msk (0x3FFUL << ADC_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N
N/* Register: ADC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ADC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ADC_POWER_POWER_Msk (0x1UL << ADC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ADC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ADC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: CCM */
N/* Description: AES CCM Mode Encryption. */
N
N/* Register: CCM_SHORTS */
N/* Description: Shortcuts for the CCM. */
N
N/* Bit 0 : Shortcut between ENDKSGEN event and CRYPT task. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Pos (0UL) /*!< Position of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Msk (0x1UL << CCM_SHORTS_ENDKSGEN_CRYPT_Pos) /*!< Bit mask of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Disabled (0UL) /*!< Shortcut disabled. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: CCM_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ERROR event. */
N#define CCM_INTENSET_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENSET_ERROR_Msk (0x1UL << CCM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ENDCRYPT event. */
N#define CCM_INTENSET_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Msk (0x1UL << CCM_INTENSET_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDCRYPT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDKSGEN event. */
N#define CCM_INTENSET_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Msk (0x1UL << CCM_INTENSET_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDKSGEN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CCM_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ERROR event. */
N#define CCM_INTENCLR_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENCLR_ERROR_Msk (0x1UL << CCM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ENDCRYPT event. */
N#define CCM_INTENCLR_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Msk (0x1UL << CCM_INTENCLR_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDCRYPT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define CCM_INTENCLR_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Msk (0x1UL << CCM_INTENCLR_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDKSGEN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CCM_MICSTATUS */
N/* Description: CCM RX MIC check result. */
N
N/* Bit 0 : Result of the MIC check performed during the previous CCM RX STARTCRYPT */
N#define CCM_MICSTATUS_MICSTATUS_Pos (0UL) /*!< Position of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_Msk (0x1UL << CCM_MICSTATUS_MICSTATUS_Pos) /*!< Bit mask of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_CheckFailed (0UL) /*!< MIC check failed. */
N#define CCM_MICSTATUS_MICSTATUS_CheckPassed (1UL) /*!< MIC check passed. */
N
N/* Register: CCM_ENABLE */
N/* Description: CCM enable. */
N
N/* Bits 1..0 : CCM enable. */
N#define CCM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Msk (0x3UL << CCM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Disabled (0x00UL) /*!< CCM is disabled. */
N#define CCM_ENABLE_ENABLE_Enabled (0x02UL) /*!< CCM is enabled. */
N
N/* Register: CCM_MODE */
N/* Description: Operation mode. */
N
N/* Bit 0 : CCM mode operation. */
N#define CCM_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define CCM_MODE_MODE_Msk (0x1UL << CCM_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define CCM_MODE_MODE_Encryption (0UL) /*!< CCM mode TX */
N#define CCM_MODE_MODE_Decryption (1UL) /*!< CCM mode TX */
N
N/* Register: CCM_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define CCM_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define CCM_POWER_POWER_Msk (0x1UL << CCM_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define CCM_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define CCM_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: CLOCK */
N/* Description: Clock control. */
N
N/* Register: CLOCK_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 4 : Enable interrupt on CTTO event. */
N#define CLOCK_INTENSET_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Msk (0x1UL << CLOCK_INTENSET_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_CTTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on DONE event. */
N#define CLOCK_INTENSET_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENSET_DONE_Msk (0x1UL << CLOCK_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENSET_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_DONE_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CLOCK_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 4 : Disable interrupt on CTTO event. */
N#define CLOCK_INTENCLR_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Msk (0x1UL << CLOCK_INTENCLR_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_CTTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on DONE event. */
N#define CLOCK_INTENCLR_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENCLR_DONE_Msk (0x1UL << CLOCK_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENCLR_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_DONE_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CLOCK_HFCLKRUN */
N/* Description: Task HFCLKSTART trigger status. */
N
N/* Bit 0 : Task HFCLKSTART trigger status. */
N#define CLOCK_HFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define CLOCK_HFCLKRUN_STATUS_Msk (0x1UL << CLOCK_HFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
N#define CLOCK_HFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task HFCLKSTART has not been triggered. */
N#define CLOCK_HFCLKRUN_STATUS_Triggered (1UL) /*!< Task HFCLKSTART has been triggered. */
N
N/* Register: CLOCK_HFCLKSTAT */
N/* Description: High frequency clock status. */
N
N/* Bit 16 : State for the HFCLK. */
N#define CLOCK_HFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_Msk (0x1UL << CLOCK_HFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_NotRunning (0UL) /*!< HFCLK clock not running. */
N#define CLOCK_HFCLKSTAT_STATE_Running (1UL) /*!< HFCLK clock running. */
N
N/* Bit 0 : Active clock source for the HF clock. */
N#define CLOCK_HFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_Msk (0x1UL << CLOCK_HFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_RC (0UL) /*!< Internal 16MHz RC oscillator running and generating the HFCLK clock. */
N#define CLOCK_HFCLKSTAT_SRC_Xtal (1UL) /*!< External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock. */
N
N/* Register: CLOCK_LFCLKRUN */
N/* Description: Task LFCLKSTART triggered status. */
N
N/* Bit 0 : Task LFCLKSTART triggered status. */
N#define CLOCK_LFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define CLOCK_LFCLKRUN_STATUS_Msk (0x1UL << CLOCK_LFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
N#define CLOCK_LFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task LFCLKSTART has not been triggered. */
N#define CLOCK_LFCLKRUN_STATUS_Triggered (1UL) /*!< Task LFCLKSTART has been triggered. */
N
N/* Register: CLOCK_LFCLKSTAT */
N/* Description: Low frequency clock status. */
N
N/* Bit 16 : State for the LF clock. */
N#define CLOCK_LFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_Msk (0x1UL << CLOCK_LFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_NotRunning (0UL) /*!< LFCLK clock not running. */
N#define CLOCK_LFCLKSTAT_STATE_Running (1UL) /*!< LFCLK clock running. */
N
N/* Bits 1..0 : Active clock source for the LF clock. */
N#define CLOCK_LFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_Msk (0x3UL << CLOCK_LFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Xtal (1UL) /*!< External 32KiHz crystal oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock. */
N
N/* Register: CLOCK_LFCLKSRCCOPY */
N/* Description: Clock source for the LFCLK clock, set when task LKCLKSTART is triggered. */
N
N/* Bits 1..0 : Clock source for the LFCLK clock, set when task LKCLKSTART is triggered. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Msk (0x3UL << CLOCK_LFCLKSRCCOPY_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRCCOPY_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Xtal (1UL) /*!< External 32KiHz crystal. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from HFCLK system clock. */
N
N/* Register: CLOCK_LFCLKSRC */
N/* Description: Clock source for the LFCLK clock. */
N
N/* Bits 1..0 : Clock source. */
N#define CLOCK_LFCLKSRC_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_Msk (0x3UL << CLOCK_LFCLKSRC_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator. */
N#define CLOCK_LFCLKSRC_SRC_Xtal (1UL) /*!< External 32KiHz crystal. */
N#define CLOCK_LFCLKSRC_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from HFCLK system clock. */
N
N/* Register: CLOCK_CTIV */
N/* Description: Calibration timer interval. */
N
N/* Bits 6..0 : Calibration timer interval in 0.25s resolution. */
N#define CLOCK_CTIV_CTIV_Pos (0UL) /*!< Position of CTIV field. */
N#define CLOCK_CTIV_CTIV_Msk (0x7FUL << CLOCK_CTIV_CTIV_Pos) /*!< Bit mask of CTIV field. */
N
N/* Register: CLOCK_XTALFREQ */
N/* Description: Crystal frequency. */
N
N/* Bits 7..0 : External Xtal frequency selection. */
N#define CLOCK_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_Msk (0xFFUL << CLOCK_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz xtal is used as source for the HFCLK oscillator. */
N#define CLOCK_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz xtal is used as source for the HFCLK oscillator. */
N
N
N/* Peripheral: ECB */
N/* Description: AES ECB Mode Encryption. */
N
N/* Register: ECB_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 1 : Enable interrupt on ERRORECB event. */
N#define ECB_INTENSET_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Msk (0x1UL << ECB_INTENSET_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ERRORECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDECB event. */
N#define ECB_INTENSET_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Msk (0x1UL << ECB_INTENSET_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ENDECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ECB_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 1 : Disable interrupt on ERRORECB event. */
N#define ECB_INTENCLR_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Msk (0x1UL << ECB_INTENCLR_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ERRORECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDECB event. */
N#define ECB_INTENCLR_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Msk (0x1UL << ECB_INTENCLR_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ENDECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ECB_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ECB_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ECB_POWER_POWER_Msk (0x1UL << ECB_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ECB_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ECB_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: FICR */
N/* Description: Factory Information Configuration. */
N
N/* Register: FICR_PPFC */
N/* Description: Pre-programmed factory code present. */
N
N/* Bits 7..0 : Pre-programmed factory code present. */
N#define FICR_PPFC_PPFC_Pos (0UL) /*!< Position of PPFC field. */
N#define FICR_PPFC_PPFC_Msk (0xFFUL << FICR_PPFC_PPFC_Pos) /*!< Bit mask of PPFC field. */
N#define FICR_PPFC_PPFC_Present (0x00UL) /*!< Present. */
N#define FICR_PPFC_PPFC_NotPresent (0xFFUL) /*!< Not present. */
N
N/* Register: FICR_CONFIGID */
N/* Description: Configuration identifier. */
N
N/* Bits 31..16 : Firmware Identification Number pre-loaded into the flash. */
N#define FICR_CONFIGID_FWID_Pos (16UL) /*!< Position of FWID field. */
N#define FICR_CONFIGID_FWID_Msk (0xFFFFUL << FICR_CONFIGID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N/* Bits 15..0 : Hardware Identification Number. */
N#define FICR_CONFIGID_HWID_Pos (0UL) /*!< Position of HWID field. */
N#define FICR_CONFIGID_HWID_Msk (0xFFFFUL << FICR_CONFIGID_HWID_Pos) /*!< Bit mask of HWID field. */
N
N/* Register: FICR_DEVICEADDRTYPE */
N/* Description: Device address type. */
N
N/* Bit 0 : Device address type. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address. */
N
N/* Register: FICR_OVERRIDEEN */
N/* Description: Radio calibration override enable. */
N
N/* Bit 3 : Override default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Pos (3UL) /*!< Position of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Msk (0x1UL << FICR_OVERRIDEEN_BLE_1MBIT_Pos) /*!< Bit mask of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Override (0UL) /*!< Override the default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_NotOverride (1UL) /*!< Do not override the default values for BLE_1Mbit mode. */
N
N/* Bit 0 : Override default values for NRF_1Mbit mode. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_Pos (0UL) /*!< Position of NRF_1MBIT field. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_Msk (0x1UL << FICR_OVERRIDEEN_NRF_1MBIT_Pos) /*!< Bit mask of NRF_1MBIT field. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_Override (0UL) /*!< Override the default values for NRF_1Mbit mode. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_NotOverride (1UL) /*!< Do not override the default values for NRF_1Mbit mode. */
N
N
N/* Peripheral: GPIO */
N/* Description: General purpose input and output. */
N
N/* Register: GPIO_OUT */
N/* Description: Write GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUT_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUT_PIN31_Msk (0x1UL << GPIO_OUT_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUT_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN31_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUT_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUT_PIN30_Msk (0x1UL << GPIO_OUT_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUT_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN30_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUT_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUT_PIN29_Msk (0x1UL << GPIO_OUT_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUT_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN29_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUT_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUT_PIN28_Msk (0x1UL << GPIO_OUT_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUT_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN28_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUT_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUT_PIN27_Msk (0x1UL << GPIO_OUT_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUT_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN27_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUT_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUT_PIN26_Msk (0x1UL << GPIO_OUT_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUT_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN26_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUT_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUT_PIN25_Msk (0x1UL << GPIO_OUT_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUT_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN25_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUT_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUT_PIN24_Msk (0x1UL << GPIO_OUT_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUT_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN24_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUT_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUT_PIN23_Msk (0x1UL << GPIO_OUT_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUT_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN23_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUT_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUT_PIN22_Msk (0x1UL << GPIO_OUT_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUT_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN22_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUT_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUT_PIN21_Msk (0x1UL << GPIO_OUT_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUT_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN21_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUT_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUT_PIN20_Msk (0x1UL << GPIO_OUT_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUT_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN20_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUT_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUT_PIN19_Msk (0x1UL << GPIO_OUT_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUT_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN19_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUT_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUT_PIN18_Msk (0x1UL << GPIO_OUT_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUT_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN18_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUT_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUT_PIN17_Msk (0x1UL << GPIO_OUT_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUT_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN17_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUT_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUT_PIN16_Msk (0x1UL << GPIO_OUT_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUT_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN16_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUT_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUT_PIN15_Msk (0x1UL << GPIO_OUT_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUT_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN15_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUT_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUT_PIN14_Msk (0x1UL << GPIO_OUT_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUT_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN14_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUT_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUT_PIN13_Msk (0x1UL << GPIO_OUT_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUT_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN13_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUT_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUT_PIN12_Msk (0x1UL << GPIO_OUT_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUT_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN12_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUT_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUT_PIN11_Msk (0x1UL << GPIO_OUT_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUT_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN11_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUT_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUT_PIN10_Msk (0x1UL << GPIO_OUT_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUT_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN10_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUT_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUT_PIN9_Msk (0x1UL << GPIO_OUT_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUT_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN9_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUT_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUT_PIN8_Msk (0x1UL << GPIO_OUT_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUT_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN8_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUT_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUT_PIN7_Msk (0x1UL << GPIO_OUT_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUT_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN7_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUT_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUT_PIN6_Msk (0x1UL << GPIO_OUT_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUT_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN6_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUT_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUT_PIN5_Msk (0x1UL << GPIO_OUT_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUT_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN5_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUT_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUT_PIN4_Msk (0x1UL << GPIO_OUT_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUT_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN4_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUT_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUT_PIN3_Msk (0x1UL << GPIO_OUT_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUT_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN3_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUT_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUT_PIN2_Msk (0x1UL << GPIO_OUT_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUT_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN2_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUT_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUT_PIN1_Msk (0x1UL << GPIO_OUT_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUT_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN1_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUT_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUT_PIN0_Msk (0x1UL << GPIO_OUT_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUT_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN0_High (1UL) /*!< Pin driver is high. */
N
N/* Register: GPIO_OUTSET */
N/* Description: Set individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Msk (0x1UL << GPIO_OUTSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN31_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Msk (0x1UL << GPIO_OUTSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN30_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Msk (0x1UL << GPIO_OUTSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN29_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Msk (0x1UL << GPIO_OUTSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN28_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Msk (0x1UL << GPIO_OUTSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN27_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Msk (0x1UL << GPIO_OUTSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN26_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Msk (0x1UL << GPIO_OUTSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN25_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Msk (0x1UL << GPIO_OUTSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN24_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Msk (0x1UL << GPIO_OUTSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN23_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Msk (0x1UL << GPIO_OUTSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN22_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Msk (0x1UL << GPIO_OUTSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN21_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Msk (0x1UL << GPIO_OUTSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN20_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Msk (0x1UL << GPIO_OUTSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN19_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Msk (0x1UL << GPIO_OUTSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN18_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Msk (0x1UL << GPIO_OUTSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN17_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Msk (0x1UL << GPIO_OUTSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN16_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Msk (0x1UL << GPIO_OUTSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN15_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Msk (0x1UL << GPIO_OUTSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN14_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Msk (0x1UL << GPIO_OUTSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN13_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Msk (0x1UL << GPIO_OUTSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN12_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Msk (0x1UL << GPIO_OUTSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN11_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Msk (0x1UL << GPIO_OUTSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN10_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Msk (0x1UL << GPIO_OUTSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN9_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Msk (0x1UL << GPIO_OUTSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN8_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Msk (0x1UL << GPIO_OUTSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN7_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Msk (0x1UL << GPIO_OUTSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN6_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Msk (0x1UL << GPIO_OUTSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN5_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Msk (0x1UL << GPIO_OUTSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN4_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Msk (0x1UL << GPIO_OUTSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN3_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Msk (0x1UL << GPIO_OUTSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN2_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Msk (0x1UL << GPIO_OUTSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN1_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Msk (0x1UL << GPIO_OUTSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN0_Set (1UL) /*!< Set pin driver high. */
N
N/* Register: GPIO_OUTCLR */
N/* Description: Clear individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Msk (0x1UL << GPIO_OUTCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN31_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Msk (0x1UL << GPIO_OUTCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN30_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Msk (0x1UL << GPIO_OUTCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN29_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Msk (0x1UL << GPIO_OUTCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN28_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Msk (0x1UL << GPIO_OUTCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN27_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Msk (0x1UL << GPIO_OUTCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN26_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Msk (0x1UL << GPIO_OUTCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN25_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Msk (0x1UL << GPIO_OUTCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN24_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Msk (0x1UL << GPIO_OUTCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN23_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Msk (0x1UL << GPIO_OUTCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN22_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Msk (0x1UL << GPIO_OUTCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN21_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Msk (0x1UL << GPIO_OUTCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN20_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Msk (0x1UL << GPIO_OUTCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN19_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Msk (0x1UL << GPIO_OUTCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN18_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Msk (0x1UL << GPIO_OUTCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN17_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Msk (0x1UL << GPIO_OUTCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN16_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Msk (0x1UL << GPIO_OUTCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN15_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Msk (0x1UL << GPIO_OUTCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN14_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Msk (0x1UL << GPIO_OUTCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN13_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Msk (0x1UL << GPIO_OUTCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN12_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Msk (0x1UL << GPIO_OUTCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN11_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Msk (0x1UL << GPIO_OUTCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN10_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Msk (0x1UL << GPIO_OUTCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN9_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Msk (0x1UL << GPIO_OUTCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN8_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Msk (0x1UL << GPIO_OUTCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN7_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Msk (0x1UL << GPIO_OUTCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN6_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Msk (0x1UL << GPIO_OUTCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN5_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Msk (0x1UL << GPIO_OUTCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN4_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Msk (0x1UL << GPIO_OUTCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN3_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Msk (0x1UL << GPIO_OUTCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN2_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Msk (0x1UL << GPIO_OUTCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN1_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Msk (0x1UL << GPIO_OUTCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN0_Clear (1UL) /*!< Set pin driver low. */
N
N/* Register: GPIO_IN */
N/* Description: Read GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_IN_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_IN_PIN31_Msk (0x1UL << GPIO_IN_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_IN_PIN31_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN31_High (1UL) /*!< Pin input is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_IN_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_IN_PIN30_Msk (0x1UL << GPIO_IN_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_IN_PIN30_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN30_High (1UL) /*!< Pin input is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_IN_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_IN_PIN29_Msk (0x1UL << GPIO_IN_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_IN_PIN29_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN29_High (1UL) /*!< Pin input is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_IN_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_IN_PIN28_Msk (0x1UL << GPIO_IN_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_IN_PIN28_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN28_High (1UL) /*!< Pin input is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_IN_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_IN_PIN27_Msk (0x1UL << GPIO_IN_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_IN_PIN27_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN27_High (1UL) /*!< Pin input is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_IN_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_IN_PIN26_Msk (0x1UL << GPIO_IN_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_IN_PIN26_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN26_High (1UL) /*!< Pin input is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_IN_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_IN_PIN25_Msk (0x1UL << GPIO_IN_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_IN_PIN25_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN25_High (1UL) /*!< Pin input is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_IN_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_IN_PIN24_Msk (0x1UL << GPIO_IN_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_IN_PIN24_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN24_High (1UL) /*!< Pin input is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_IN_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_IN_PIN23_Msk (0x1UL << GPIO_IN_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_IN_PIN23_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN23_High (1UL) /*!< Pin input is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_IN_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_IN_PIN22_Msk (0x1UL << GPIO_IN_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_IN_PIN22_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN22_High (1UL) /*!< Pin input is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_IN_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_IN_PIN21_Msk (0x1UL << GPIO_IN_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_IN_PIN21_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN21_High (1UL) /*!< Pin input is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_IN_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_IN_PIN20_Msk (0x1UL << GPIO_IN_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_IN_PIN20_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN20_High (1UL) /*!< Pin input is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_IN_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_IN_PIN19_Msk (0x1UL << GPIO_IN_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_IN_PIN19_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN19_High (1UL) /*!< Pin input is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_IN_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_IN_PIN18_Msk (0x1UL << GPIO_IN_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_IN_PIN18_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN18_High (1UL) /*!< Pin input is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_IN_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_IN_PIN17_Msk (0x1UL << GPIO_IN_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_IN_PIN17_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN17_High (1UL) /*!< Pin input is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_IN_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_IN_PIN16_Msk (0x1UL << GPIO_IN_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_IN_PIN16_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN16_High (1UL) /*!< Pin input is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_IN_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_IN_PIN15_Msk (0x1UL << GPIO_IN_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_IN_PIN15_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN15_High (1UL) /*!< Pin input is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_IN_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_IN_PIN14_Msk (0x1UL << GPIO_IN_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_IN_PIN14_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN14_High (1UL) /*!< Pin input is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_IN_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_IN_PIN13_Msk (0x1UL << GPIO_IN_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_IN_PIN13_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN13_High (1UL) /*!< Pin input is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_IN_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_IN_PIN12_Msk (0x1UL << GPIO_IN_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_IN_PIN12_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN12_High (1UL) /*!< Pin input is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_IN_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_IN_PIN11_Msk (0x1UL << GPIO_IN_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_IN_PIN11_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN11_High (1UL) /*!< Pin input is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_IN_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_IN_PIN10_Msk (0x1UL << GPIO_IN_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_IN_PIN10_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN10_High (1UL) /*!< Pin input is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_IN_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_IN_PIN9_Msk (0x1UL << GPIO_IN_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_IN_PIN9_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN9_High (1UL) /*!< Pin input is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_IN_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_IN_PIN8_Msk (0x1UL << GPIO_IN_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_IN_PIN8_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN8_High (1UL) /*!< Pin input is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_IN_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_IN_PIN7_Msk (0x1UL << GPIO_IN_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_IN_PIN7_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN7_High (1UL) /*!< Pin input is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_IN_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_IN_PIN6_Msk (0x1UL << GPIO_IN_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_IN_PIN6_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN6_High (1UL) /*!< Pin input is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_IN_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_IN_PIN5_Msk (0x1UL << GPIO_IN_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_IN_PIN5_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN5_High (1UL) /*!< Pin input is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_IN_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_IN_PIN4_Msk (0x1UL << GPIO_IN_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_IN_PIN4_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN4_High (1UL) /*!< Pin input is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_IN_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_IN_PIN3_Msk (0x1UL << GPIO_IN_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_IN_PIN3_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN3_High (1UL) /*!< Pin input is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_IN_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_IN_PIN2_Msk (0x1UL << GPIO_IN_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_IN_PIN2_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN2_High (1UL) /*!< Pin input is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_IN_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_IN_PIN1_Msk (0x1UL << GPIO_IN_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_IN_PIN1_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN1_High (1UL) /*!< Pin input is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_IN_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_IN_PIN0_Msk (0x1UL << GPIO_IN_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_IN_PIN0_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN0_High (1UL) /*!< Pin input is high. */
N
N/* Register: GPIO_DIR */
N/* Description: Direction of GPIO pins. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_DIR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIR_PIN31_Msk (0x1UL << GPIO_DIR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN31_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_DIR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIR_PIN30_Msk (0x1UL << GPIO_DIR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN30_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_DIR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIR_PIN29_Msk (0x1UL << GPIO_DIR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN29_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_DIR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIR_PIN28_Msk (0x1UL << GPIO_DIR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN28_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_DIR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIR_PIN27_Msk (0x1UL << GPIO_DIR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN27_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_DIR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIR_PIN26_Msk (0x1UL << GPIO_DIR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN26_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_DIR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIR_PIN25_Msk (0x1UL << GPIO_DIR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN25_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_DIR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIR_PIN24_Msk (0x1UL << GPIO_DIR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN24_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_DIR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIR_PIN23_Msk (0x1UL << GPIO_DIR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN23_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_DIR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIR_PIN22_Msk (0x1UL << GPIO_DIR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN22_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_DIR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIR_PIN21_Msk (0x1UL << GPIO_DIR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN21_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_DIR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIR_PIN20_Msk (0x1UL << GPIO_DIR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN20_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_DIR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIR_PIN19_Msk (0x1UL << GPIO_DIR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN19_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_DIR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIR_PIN18_Msk (0x1UL << GPIO_DIR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN18_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_DIR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIR_PIN17_Msk (0x1UL << GPIO_DIR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN17_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_DIR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIR_PIN16_Msk (0x1UL << GPIO_DIR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN16_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_DIR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIR_PIN15_Msk (0x1UL << GPIO_DIR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN15_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_DIR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIR_PIN14_Msk (0x1UL << GPIO_DIR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN14_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_DIR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIR_PIN13_Msk (0x1UL << GPIO_DIR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN13_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_DIR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIR_PIN12_Msk (0x1UL << GPIO_DIR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN12_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_DIR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIR_PIN11_Msk (0x1UL << GPIO_DIR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN11_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_DIR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIR_PIN10_Msk (0x1UL << GPIO_DIR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN10_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_DIR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIR_PIN9_Msk (0x1UL << GPIO_DIR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN9_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_DIR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIR_PIN8_Msk (0x1UL << GPIO_DIR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN8_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_DIR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIR_PIN7_Msk (0x1UL << GPIO_DIR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN7_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_DIR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIR_PIN6_Msk (0x1UL << GPIO_DIR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN6_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_DIR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIR_PIN5_Msk (0x1UL << GPIO_DIR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN5_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_DIR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIR_PIN4_Msk (0x1UL << GPIO_DIR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN4_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_DIR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIR_PIN3_Msk (0x1UL << GPIO_DIR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN3_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_DIR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIR_PIN2_Msk (0x1UL << GPIO_DIR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN2_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_DIR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIR_PIN1_Msk (0x1UL << GPIO_DIR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN1_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_DIR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIR_PIN0_Msk (0x1UL << GPIO_DIR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN0_Output (1UL) /*!< Pin set as output. */
N
N/* Register: GPIO_DIRSET */
N/* Description: DIR set register. */
N
N/* Bit 31 : Set as output pin 31. */
N#define GPIO_DIRSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Msk (0x1UL << GPIO_DIRSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN31_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 30 : Set as output pin 30. */
N#define GPIO_DIRSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Msk (0x1UL << GPIO_DIRSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN30_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 29 : Set as output pin 29. */
N#define GPIO_DIRSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Msk (0x1UL << GPIO_DIRSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN29_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 28 : Set as output pin 28. */
N#define GPIO_DIRSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Msk (0x1UL << GPIO_DIRSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN28_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 27 : Set as output pin 27. */
N#define GPIO_DIRSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Msk (0x1UL << GPIO_DIRSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN27_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 26 : Set as output pin 26. */
N#define GPIO_DIRSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Msk (0x1UL << GPIO_DIRSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN26_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 25 : Set as output pin 25. */
N#define GPIO_DIRSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Msk (0x1UL << GPIO_DIRSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN25_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 24 : Set as output pin 24. */
N#define GPIO_DIRSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Msk (0x1UL << GPIO_DIRSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN24_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 23 : Set as output pin 23. */
N#define GPIO_DIRSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Msk (0x1UL << GPIO_DIRSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN23_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 22 : Set as output pin 22. */
N#define GPIO_DIRSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Msk (0x1UL << GPIO_DIRSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN22_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 21 : Set as output pin 21. */
N#define GPIO_DIRSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Msk (0x1UL << GPIO_DIRSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN21_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 20 : Set as output pin 20. */
N#define GPIO_DIRSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Msk (0x1UL << GPIO_DIRSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN20_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 19 : Set as output pin 19. */
N#define GPIO_DIRSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Msk (0x1UL << GPIO_DIRSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN19_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 18 : Set as output pin 18. */
N#define GPIO_DIRSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Msk (0x1UL << GPIO_DIRSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN18_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 17 : Set as output pin 17. */
N#define GPIO_DIRSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Msk (0x1UL << GPIO_DIRSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN17_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 16 : Set as output pin 16. */
N#define GPIO_DIRSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Msk (0x1UL << GPIO_DIRSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN16_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 15 : Set as output pin 15. */
N#define GPIO_DIRSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Msk (0x1UL << GPIO_DIRSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN15_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 14 : Set as output pin 14. */
N#define GPIO_DIRSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Msk (0x1UL << GPIO_DIRSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN14_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 13 : Set as output pin 13. */
N#define GPIO_DIRSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Msk (0x1UL << GPIO_DIRSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN13_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 12 : Set as output pin 12. */
N#define GPIO_DIRSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Msk (0x1UL << GPIO_DIRSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN12_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 11 : Set as output pin 11. */
N#define GPIO_DIRSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Msk (0x1UL << GPIO_DIRSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN11_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 10 : Set as output pin 10. */
N#define GPIO_DIRSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Msk (0x1UL << GPIO_DIRSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN10_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 9 : Set as output pin 9. */
N#define GPIO_DIRSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Msk (0x1UL << GPIO_DIRSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN9_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 8 : Set as output pin 8. */
N#define GPIO_DIRSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Msk (0x1UL << GPIO_DIRSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN8_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 7 : Set as output pin 7. */
N#define GPIO_DIRSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Msk (0x1UL << GPIO_DIRSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN7_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 6 : Set as output pin 6. */
N#define GPIO_DIRSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Msk (0x1UL << GPIO_DIRSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN6_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 5 : Set as output pin 5. */
N#define GPIO_DIRSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Msk (0x1UL << GPIO_DIRSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN5_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 4 : Set as output pin 4. */
N#define GPIO_DIRSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Msk (0x1UL << GPIO_DIRSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN4_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 3 : Set as output pin 3. */
N#define GPIO_DIRSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Msk (0x1UL << GPIO_DIRSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN3_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 2 : Set as output pin 2. */
N#define GPIO_DIRSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Msk (0x1UL << GPIO_DIRSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN2_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 1 : Set as output pin 1. */
N#define GPIO_DIRSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Msk (0x1UL << GPIO_DIRSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN1_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 0 : Set as output pin 0. */
N#define GPIO_DIRSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Msk (0x1UL << GPIO_DIRSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN0_Set (1UL) /*!< Set pin as output. */
N
N/* Register: GPIO_DIRCLR */
N/* Description: DIR clear register. */
N
N/* Bit 31 : Set as input pin 31. */
N#define GPIO_DIRCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Msk (0x1UL << GPIO_DIRCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN31_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 30 : Set as input pin 30. */
N#define GPIO_DIRCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Msk (0x1UL << GPIO_DIRCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN30_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 29 : Set as input pin 29. */
N#define GPIO_DIRCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Msk (0x1UL << GPIO_DIRCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN29_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 28 : Set as input pin 28. */
N#define GPIO_DIRCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Msk (0x1UL << GPIO_DIRCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN28_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 27 : Set as input pin 27. */
N#define GPIO_DIRCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Msk (0x1UL << GPIO_DIRCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN27_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 26 : Set as input pin 26. */
N#define GPIO_DIRCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Msk (0x1UL << GPIO_DIRCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN26_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 25 : Set as input pin 25. */
N#define GPIO_DIRCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Msk (0x1UL << GPIO_DIRCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN25_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 24 : Set as input pin 24. */
N#define GPIO_DIRCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Msk (0x1UL << GPIO_DIRCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN24_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 23 : Set as input pin 23. */
N#define GPIO_DIRCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Msk (0x1UL << GPIO_DIRCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN23_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 22 : Set as input pin 22. */
N#define GPIO_DIRCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Msk (0x1UL << GPIO_DIRCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN22_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 21 : Set as input pin 21. */
N#define GPIO_DIRCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Msk (0x1UL << GPIO_DIRCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN21_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 20 : Set as input pin 20. */
N#define GPIO_DIRCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Msk (0x1UL << GPIO_DIRCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN20_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 19 : Set as input pin 19. */
N#define GPIO_DIRCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Msk (0x1UL << GPIO_DIRCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN19_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 18 : Set as input pin 18. */
N#define GPIO_DIRCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Msk (0x1UL << GPIO_DIRCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN18_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 17 : Set as input pin 17. */
N#define GPIO_DIRCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Msk (0x1UL << GPIO_DIRCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN17_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 16 : Set as input pin 16. */
N#define GPIO_DIRCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Msk (0x1UL << GPIO_DIRCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN16_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 15 : Set as input pin 15. */
N#define GPIO_DIRCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Msk (0x1UL << GPIO_DIRCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN15_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 14 : Set as input pin 14. */
N#define GPIO_DIRCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Msk (0x1UL << GPIO_DIRCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN14_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 13 : Set as input pin 13. */
N#define GPIO_DIRCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Msk (0x1UL << GPIO_DIRCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN13_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 12 : Set as input pin 12. */
N#define GPIO_DIRCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Msk (0x1UL << GPIO_DIRCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN12_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 11 : Set as input pin 11. */
N#define GPIO_DIRCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Msk (0x1UL << GPIO_DIRCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN11_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 10 : Set as input pin 10. */
N#define GPIO_DIRCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Msk (0x1UL << GPIO_DIRCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN10_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 9 : Set as input pin 9. */
N#define GPIO_DIRCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Msk (0x1UL << GPIO_DIRCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN9_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 8 : Set as input pin 8. */
N#define GPIO_DIRCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Msk (0x1UL << GPIO_DIRCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN8_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 7 : Set as input pin 7. */
N#define GPIO_DIRCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Msk (0x1UL << GPIO_DIRCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN7_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 6 : Set as input pin 6. */
N#define GPIO_DIRCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Msk (0x1UL << GPIO_DIRCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN6_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 5 : Set as input pin 5. */
N#define GPIO_DIRCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Msk (0x1UL << GPIO_DIRCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN5_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 4 : Set as input pin 4. */
N#define GPIO_DIRCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Msk (0x1UL << GPIO_DIRCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN4_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 3 : Set as input pin 3. */
N#define GPIO_DIRCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Msk (0x1UL << GPIO_DIRCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN3_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 2 : Set as input pin 2. */
N#define GPIO_DIRCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Msk (0x1UL << GPIO_DIRCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN2_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 1 : Set as input pin 1. */
N#define GPIO_DIRCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Msk (0x1UL << GPIO_DIRCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN1_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 0 : Set as input pin 0. */
N#define GPIO_DIRCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Msk (0x1UL << GPIO_DIRCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN0_Clear (1UL) /*!< Set pin as input. */
N
N/* Register: GPIO_PIN_CNF */
N/* Description: Configuration of GPIO pins. */
N
N/* Bits 17..16 : Pin sensing mechanism. */
N#define GPIO_PIN_CNF_SENSE_Pos (16UL) /*!< Position of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Msk (0x3UL << GPIO_PIN_CNF_SENSE_Pos) /*!< Bit mask of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIO_PIN_CNF_SENSE_High (0x02UL) /*!< Wakeup on high level. */
N#define GPIO_PIN_CNF_SENSE_Low (0x03UL) /*!< Wakeup on low level. */
N
N/* Bits 10..8 : Drive configuration. */
N#define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_S0S1 (0x00UL) /*!< Standard '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0S1 (0x01UL) /*!< High '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0H1 (0x02UL) /*!< Standard '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0H1 (0x03UL) /*!< High '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0S1 (0x04UL) /*!< Disconnected '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0H1 (0x05UL) /*!< Disconnected '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0D1 (0x06UL) /*!< Standard '0', Disconnected '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0D1 (0x07UL) /*!< High '0', Disconnected '1'. */
N
N/* Bits 3..2 : Pull-up or -down configuration. */
N#define GPIO_PIN_CNF_PULL_Pos (2UL) /*!< Position of PULL field. */
N#define GPIO_PIN_CNF_PULL_Msk (0x3UL << GPIO_PIN_CNF_PULL_Pos) /*!< Bit mask of PULL field. */
N#define GPIO_PIN_CNF_PULL_Disabled (0x00UL) /*!< No pull. */
N#define GPIO_PIN_CNF_PULL_Pulldown (0x01UL) /*!< Pulldown on pin. */
N#define GPIO_PIN_CNF_PULL_Pullup (0x03UL) /*!< Pullup on pin. */
N
N/* Bit 1 : Connect or disconnect input path. */
N#define GPIO_PIN_CNF_INPUT_Pos (1UL) /*!< Position of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Msk (0x1UL << GPIO_PIN_CNF_INPUT_Pos) /*!< Bit mask of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Connect (0UL) /*!< Connect input pin. */
N#define GPIO_PIN_CNF_INPUT_Disconnect (1UL) /*!< Disconnect input pin. */
N
N/* Bit 0 : Pin direction. */
N#define GPIO_PIN_CNF_DIR_Pos (0UL) /*!< Position of DIR field. */
N#define GPIO_PIN_CNF_DIR_Msk (0x1UL << GPIO_PIN_CNF_DIR_Pos) /*!< Bit mask of DIR field. */
N#define GPIO_PIN_CNF_DIR_Input (0UL) /*!< Configure pin as an input pin. */
N#define GPIO_PIN_CNF_DIR_Output (1UL) /*!< Configure pin as an output pin. */
N
N
N/* Peripheral: GPIOTE */
N/* Description: GPIO tasks and events. */
N
N/* Register: GPIOTE_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 31 : Enable interrupt on PORT event. */
N#define GPIOTE_INTENSET_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENSET_PORT_Msk (0x1UL << GPIOTE_INTENSET_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENSET_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_PORT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on IN[3] event. */
N#define GPIOTE_INTENSET_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Msk (0x1UL << GPIOTE_INTENSET_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on IN[2] event. */
N#define GPIOTE_INTENSET_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Msk (0x1UL << GPIOTE_INTENSET_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on IN[1] event. */
N#define GPIOTE_INTENSET_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Msk (0x1UL << GPIOTE_INTENSET_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on IN[0] event. */
N#define GPIOTE_INTENSET_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Msk (0x1UL << GPIOTE_INTENSET_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: GPIOTE_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 31 : Disable interrupt on PORT event. */
N#define GPIOTE_INTENCLR_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Msk (0x1UL << GPIOTE_INTENCLR_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_PORT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on IN[3] event. */
N#define GPIOTE_INTENCLR_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Msk (0x1UL << GPIOTE_INTENCLR_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on IN[2] event. */
N#define GPIOTE_INTENCLR_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Msk (0x1UL << GPIOTE_INTENCLR_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on IN[1] event. */
N#define GPIOTE_INTENCLR_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Msk (0x1UL << GPIOTE_INTENCLR_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on IN[0] event. */
N#define GPIOTE_INTENCLR_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Msk (0x1UL << GPIOTE_INTENCLR_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: GPIOTE_CONFIG */
N/* Description: Channel configuration registers. */
N
N/* Bit 20 : Initial value of the output when the GPIOTE channel is configured as a Task. */
N#define GPIOTE_CONFIG_OUTINIT_Pos (20UL) /*!< Position of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Msk (0x1UL << GPIOTE_CONFIG_OUTINIT_Pos) /*!< Bit mask of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Low (0UL) /*!< Initial low output when in task mode. */
N#define GPIOTE_CONFIG_OUTINIT_High (1UL) /*!< Initial high output when in task mode. */
N
N/* Bits 17..16 : Effects on output when in Task mode, or events on input that generates an event. */
N#define GPIOTE_CONFIG_POLARITY_Pos (16UL) /*!< Position of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_Msk (0x3UL << GPIOTE_CONFIG_POLARITY_Pos) /*!< Bit mask of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_None (0x00UL) /*!< No task or event. */
N#define GPIOTE_CONFIG_POLARITY_LoToHi (0x01UL) /*!< Low to high. */
N#define GPIOTE_CONFIG_POLARITY_HiToLo (0x02UL) /*!< High to low. */
N#define GPIOTE_CONFIG_POLARITY_Toggle (0x03UL) /*!< Toggle. */
N
N/* Bits 12..8 : Pin select. */
N#define GPIOTE_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define GPIOTE_CONFIG_PSEL_Msk (0x1FUL << GPIOTE_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N
N/* Bits 1..0 : Mode */
N#define GPIOTE_CONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define GPIOTE_CONFIG_MODE_Msk (0x3UL << GPIOTE_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
N#define GPIOTE_CONFIG_MODE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIOTE_CONFIG_MODE_Event (0x01UL) /*!< Channel configure in event mode. */
N#define GPIOTE_CONFIG_MODE_Task (0x03UL) /*!< Channel configure in task mode. */
N
N/* Register: GPIOTE_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define GPIOTE_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define GPIOTE_POWER_POWER_Msk (0x1UL << GPIOTE_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define GPIOTE_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define GPIOTE_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: LPCOMP */
N/* Description: Low power comparator. */
N
N/* Register: LPCOMP_SHORTS */
N/* Description: Shortcuts for the LPCOMP. */
N
N/* Bit 4 : Shortcut between CROSS event and STOP task. */
N#define LPCOMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Msk (0x1UL << LPCOMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between UP event and STOP task. */
N#define LPCOMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Msk (0x1UL << LPCOMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between DOWN event and STOP task. */
N#define LPCOMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Msk (0x1UL << LPCOMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between RADY event and STOP task. */
N#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between READY event and SAMPLE task. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: LPCOMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 3 : Enable interrupt on CROSS event. */
N#define LPCOMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Msk (0x1UL << LPCOMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_CROSS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on UP event. */
N#define LPCOMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENSET_UP_Msk (0x1UL << LPCOMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENSET_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_UP_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on DOWN event. */
N#define LPCOMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Msk (0x1UL << LPCOMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_DOWN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: LPCOMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 3 : Disable interrupt on CROSS event. */
N#define LPCOMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Msk (0x1UL << LPCOMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on UP event. */
N#define LPCOMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENCLR_UP_Msk (0x1UL << LPCOMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENCLR_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_UP_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on DOWN event. */
N#define LPCOMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Msk (0x1UL << LPCOMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: LPCOMP_RESULT */
N/* Description: Result of last compare. */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define LPCOMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Msk (0x1UL << LPCOMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is bellow the reference threshold. */
N#define LPCOMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold. */
N
N/* Register: LPCOMP_ENABLE */
N/* Description: Enable the LPCOMP. */
N
N/* Bits 1..0 : Enable or disable LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Msk (0x3UL << LPCOMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable LPCOMP. */
N
N/* Register: LPCOMP_PSEL */
N/* Description: Input pin select. */
N
N/* Bits 2..0 : Analog input pin select. */
N#define LPCOMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define LPCOMP_PSEL_PSEL_Msk (0x7UL << LPCOMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define LPCOMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< Use analog input 0 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< Use analog input 1 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< Use analog input 2 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< Use analog input 3 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< Use analog input 4 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< Use analog input 5 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< Use analog input 6 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< Use analog input 7 as analog input. */
N
N/* Register: LPCOMP_REFSEL */
N/* Description: Reference select. */
N
N/* Bits 2..0 : Reference select. */
N#define LPCOMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_Msk (0x7UL << LPCOMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling (0UL) /*!< Use supply with a 1/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling (1UL) /*!< Use supply with a 2/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling (2UL) /*!< Use supply with a 3/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling (3UL) /*!< Use supply with a 4/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling (4UL) /*!< Use supply with a 5/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling (5UL) /*!< Use supply with a 6/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling (6UL) /*!< Use supply with a 7/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_ARef (7UL) /*!< Use external analog reference as reference. */
N
N/* Register: LPCOMP_EXTREFSEL */
N/* Description: External reference select. */
N
N/* Bit 0 : External analog reference pin selection. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use analog reference 0 as reference. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use analog reference 1 as reference. */
N
N/* Register: LPCOMP_ANADETECT */
N/* Description: Analog detect configuration. */
N
N/* Bits 1..0 : Analog detect configuration. */
N#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETEC on crossing, both upwards and downwards crossing. */
N#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETEC on upwards crossing only. */
N#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETEC on downwards crossing only. */
N
N/* Register: LPCOMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define LPCOMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define LPCOMP_POWER_POWER_Msk (0x1UL << LPCOMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define LPCOMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define LPCOMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: MPU */
N/* Description: Memory Protection Unit. */
N
N/* Register: MPU_PERR0 */
N/* Description: Configuration of peripherals in mpu regions. */
N
N/* Bit 31 : PPI region configuration. */
N#define MPU_PERR0_PPI_Pos (31UL) /*!< Position of PPI field. */
N#define MPU_PERR0_PPI_Msk (0x1UL << MPU_PERR0_PPI_Pos) /*!< Bit mask of PPI field. */
N#define MPU_PERR0_PPI_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_PPI_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 30 : NVMC region configuration. */
N#define MPU_PERR0_NVMC_Pos (30UL) /*!< Position of NVMC field. */
N#define MPU_PERR0_NVMC_Msk (0x1UL << MPU_PERR0_NVMC_Pos) /*!< Bit mask of NVMC field. */
N#define MPU_PERR0_NVMC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_NVMC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 19 : LPCOMP region configuration. */
N#define MPU_PERR0_LPCOMP_Pos (19UL) /*!< Position of LPCOMP field. */
N#define MPU_PERR0_LPCOMP_Msk (0x1UL << MPU_PERR0_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
N#define MPU_PERR0_LPCOMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_LPCOMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 18 : QDEC region configuration. */
N#define MPU_PERR0_QDEC_Pos (18UL) /*!< Position of QDEC field. */
N#define MPU_PERR0_QDEC_Msk (0x1UL << MPU_PERR0_QDEC_Pos) /*!< Bit mask of QDEC field. */
N#define MPU_PERR0_QDEC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_QDEC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 17 : RTC1 region configuration. */
N#define MPU_PERR0_RTC1_Pos (17UL) /*!< Position of RTC1 field. */
N#define MPU_PERR0_RTC1_Msk (0x1UL << MPU_PERR0_RTC1_Pos) /*!< Bit mask of RTC1 field. */
N#define MPU_PERR0_RTC1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 16 : WDT region configuration. */
N#define MPU_PERR0_WDT_Pos (16UL) /*!< Position of WDT field. */
N#define MPU_PERR0_WDT_Msk (0x1UL << MPU_PERR0_WDT_Pos) /*!< Bit mask of WDT field. */
N#define MPU_PERR0_WDT_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_WDT_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 15 : CCM and AAR region configuration. */
N#define MPU_PERR0_CCM_AAR_Pos (15UL) /*!< Position of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_Msk (0x1UL << MPU_PERR0_CCM_AAR_Pos) /*!< Bit mask of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_CCM_AAR_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 14 : ECB region configuration. */
N#define MPU_PERR0_ECB_Pos (14UL) /*!< Position of ECB field. */
N#define MPU_PERR0_ECB_Msk (0x1UL << MPU_PERR0_ECB_Pos) /*!< Bit mask of ECB field. */
N#define MPU_PERR0_ECB_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ECB_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 13 : RNG region configuration. */
N#define MPU_PERR0_RNG_Pos (13UL) /*!< Position of RNG field. */
N#define MPU_PERR0_RNG_Msk (0x1UL << MPU_PERR0_RNG_Pos) /*!< Bit mask of RNG field. */
N#define MPU_PERR0_RNG_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RNG_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 12 : TEMP region configuration. */
N#define MPU_PERR0_TEMP_Pos (12UL) /*!< Position of TEMP field. */
N#define MPU_PERR0_TEMP_Msk (0x1UL << MPU_PERR0_TEMP_Pos) /*!< Bit mask of TEMP field. */
N#define MPU_PERR0_TEMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TEMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 11 : RTC0 region configuration. */
N#define MPU_PERR0_RTC0_Pos (11UL) /*!< Position of RTC0 field. */
N#define MPU_PERR0_RTC0_Msk (0x1UL << MPU_PERR0_RTC0_Pos) /*!< Bit mask of RTC0 field. */
N#define MPU_PERR0_RTC0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 10 : TIMER2 region configuration. */
N#define MPU_PERR0_TIMER2_Pos (10UL) /*!< Position of TIMER2 field. */
N#define MPU_PERR0_TIMER2_Msk (0x1UL << MPU_PERR0_TIMER2_Pos) /*!< Bit mask of TIMER2 field. */
N#define MPU_PERR0_TIMER2_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER2_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 9 : TIMER1 region configuration. */
N#define MPU_PERR0_TIMER1_Pos (9UL) /*!< Position of TIMER1 field. */
N#define MPU_PERR0_TIMER1_Msk (0x1UL << MPU_PERR0_TIMER1_Pos) /*!< Bit mask of TIMER1 field. */
N#define MPU_PERR0_TIMER1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 8 : TIMER0 region configuration. */
N#define MPU_PERR0_TIMER0_Pos (8UL) /*!< Position of TIMER0 field. */
N#define MPU_PERR0_TIMER0_Msk (0x1UL << MPU_PERR0_TIMER0_Pos) /*!< Bit mask of TIMER0 field. */
N#define MPU_PERR0_TIMER0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 7 : ADC region configuration. */
N#define MPU_PERR0_ADC_Pos (7UL) /*!< Position of ADC field. */
N#define MPU_PERR0_ADC_Msk (0x1UL << MPU_PERR0_ADC_Pos) /*!< Bit mask of ADC field. */
N#define MPU_PERR0_ADC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ADC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 6 : GPIOTE region configuration. */
N#define MPU_PERR0_GPIOTE_Pos (6UL) /*!< Position of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_Msk (0x1UL << MPU_PERR0_GPIOTE_Pos) /*!< Bit mask of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_GPIOTE_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 4 : SPI1 and TWI1 region configuration. */
N#define MPU_PERR0_SPI1_TWI1_Pos (4UL) /*!< Position of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_Msk (0x1UL << MPU_PERR0_SPI1_TWI1_Pos) /*!< Bit mask of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI1_TWI1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 3 : SPI0 and TWI0 region configuration. */
N#define MPU_PERR0_SPI0_TWI0_Pos (3UL) /*!< Position of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_Msk (0x1UL << MPU_PERR0_SPI0_TWI0_Pos) /*!< Bit mask of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI0_TWI0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 2 : UART0 region configuration. */
N#define MPU_PERR0_UART0_Pos (2UL) /*!< Position of UART0 field. */
N#define MPU_PERR0_UART0_Msk (0x1UL << MPU_PERR0_UART0_Pos) /*!< Bit mask of UART0 field. */
N#define MPU_PERR0_UART0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_UART0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 1 : RADIO region configuration. */
N#define MPU_PERR0_RADIO_Pos (1UL) /*!< Position of RADIO field. */
N#define MPU_PERR0_RADIO_Msk (0x1UL << MPU_PERR0_RADIO_Pos) /*!< Bit mask of RADIO field. */
N#define MPU_PERR0_RADIO_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RADIO_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 0 : POWER_CLOCK region configuration. */
N#define MPU_PERR0_POWER_CLOCK_Pos (0UL) /*!< Position of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_Msk (0x1UL << MPU_PERR0_POWER_CLOCK_Pos) /*!< Bit mask of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_POWER_CLOCK_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Register: MPU_PROTENSET0 */
N/* Description: Erase and write protection bit enable set register. */
N
N/* Bit 31 : Protection enable for region 31. */
N#define MPU_PROTENSET0_PROTREG31_Pos (31UL) /*!< Position of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Msk (0x1UL << MPU_PROTENSET0_PROTREG31_Pos) /*!< Bit mask of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG31_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG31_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 30. */
N#define MPU_PROTENSET0_PROTREG30_Pos (30UL) /*!< Position of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Msk (0x1UL << MPU_PROTENSET0_PROTREG30_Pos) /*!< Bit mask of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG30_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG30_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 29. */
N#define MPU_PROTENSET0_PROTREG29_Pos (29UL) /*!< Position of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Msk (0x1UL << MPU_PROTENSET0_PROTREG29_Pos) /*!< Bit mask of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG29_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG29_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 28. */
N#define MPU_PROTENSET0_PROTREG28_Pos (28UL) /*!< Position of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Msk (0x1UL << MPU_PROTENSET0_PROTREG28_Pos) /*!< Bit mask of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG28_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG28_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 27. */
N#define MPU_PROTENSET0_PROTREG27_Pos (27UL) /*!< Position of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Msk (0x1UL << MPU_PROTENSET0_PROTREG27_Pos) /*!< Bit mask of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG27_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG27_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 26. */
N#define MPU_PROTENSET0_PROTREG26_Pos (26UL) /*!< Position of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Msk (0x1UL << MPU_PROTENSET0_PROTREG26_Pos) /*!< Bit mask of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG26_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG26_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 25. */
N#define MPU_PROTENSET0_PROTREG25_Pos (25UL) /*!< Position of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Msk (0x1UL << MPU_PROTENSET0_PROTREG25_Pos) /*!< Bit mask of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG25_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG25_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 24. */
N#define MPU_PROTENSET0_PROTREG24_Pos (24UL) /*!< Position of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Msk (0x1UL << MPU_PROTENSET0_PROTREG24_Pos) /*!< Bit mask of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG24_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG24_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 23. */
N#define MPU_PROTENSET0_PROTREG23_Pos (23UL) /*!< Position of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Msk (0x1UL << MPU_PROTENSET0_PROTREG23_Pos) /*!< Bit mask of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG23_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG23_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 22. */
N#define MPU_PROTENSET0_PROTREG22_Pos (22UL) /*!< Position of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Msk (0x1UL << MPU_PROTENSET0_PROTREG22_Pos) /*!< Bit mask of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG22_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG22_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 21. */
N#define MPU_PROTENSET0_PROTREG21_Pos (21UL) /*!< Position of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Msk (0x1UL << MPU_PROTENSET0_PROTREG21_Pos) /*!< Bit mask of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG21_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG21_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 20. */
N#define MPU_PROTENSET0_PROTREG20_Pos (20UL) /*!< Position of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Msk (0x1UL << MPU_PROTENSET0_PROTREG20_Pos) /*!< Bit mask of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG20_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG20_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 19. */
N#define MPU_PROTENSET0_PROTREG19_Pos (19UL) /*!< Position of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Msk (0x1UL << MPU_PROTENSET0_PROTREG19_Pos) /*!< Bit mask of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG19_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG19_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 18. */
N#define MPU_PROTENSET0_PROTREG18_Pos (18UL) /*!< Position of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Msk (0x1UL << MPU_PROTENSET0_PROTREG18_Pos) /*!< Bit mask of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG18_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG18_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 17. */
N#define MPU_PROTENSET0_PROTREG17_Pos (17UL) /*!< Position of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Msk (0x1UL << MPU_PROTENSET0_PROTREG17_Pos) /*!< Bit mask of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG17_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG17_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 16. */
N#define MPU_PROTENSET0_PROTREG16_Pos (16UL) /*!< Position of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Msk (0x1UL << MPU_PROTENSET0_PROTREG16_Pos) /*!< Bit mask of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG16_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG16_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 15. */
N#define MPU_PROTENSET0_PROTREG15_Pos (15UL) /*!< Position of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Msk (0x1UL << MPU_PROTENSET0_PROTREG15_Pos) /*!< Bit mask of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG15_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG15_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 14. */
N#define MPU_PROTENSET0_PROTREG14_Pos (14UL) /*!< Position of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Msk (0x1UL << MPU_PROTENSET0_PROTREG14_Pos) /*!< Bit mask of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG14_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG14_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 13. */
N#define MPU_PROTENSET0_PROTREG13_Pos (13UL) /*!< Position of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Msk (0x1UL << MPU_PROTENSET0_PROTREG13_Pos) /*!< Bit mask of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG13_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG13_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 12. */
N#define MPU_PROTENSET0_PROTREG12_Pos (12UL) /*!< Position of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Msk (0x1UL << MPU_PROTENSET0_PROTREG12_Pos) /*!< Bit mask of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG12_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG12_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 11. */
N#define MPU_PROTENSET0_PROTREG11_Pos (11UL) /*!< Position of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Msk (0x1UL << MPU_PROTENSET0_PROTREG11_Pos) /*!< Bit mask of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG11_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG11_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 10. */
N#define MPU_PROTENSET0_PROTREG10_Pos (10UL) /*!< Position of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Msk (0x1UL << MPU_PROTENSET0_PROTREG10_Pos) /*!< Bit mask of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG10_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG10_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 9. */
N#define MPU_PROTENSET0_PROTREG9_Pos (9UL) /*!< Position of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Msk (0x1UL << MPU_PROTENSET0_PROTREG9_Pos) /*!< Bit mask of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG9_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG9_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 8. */
N#define MPU_PROTENSET0_PROTREG8_Pos (8UL) /*!< Position of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Msk (0x1UL << MPU_PROTENSET0_PROTREG8_Pos) /*!< Bit mask of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG8_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG8_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 7. */
N#define MPU_PROTENSET0_PROTREG7_Pos (7UL) /*!< Position of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Msk (0x1UL << MPU_PROTENSET0_PROTREG7_Pos) /*!< Bit mask of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG7_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG7_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 6. */
N#define MPU_PROTENSET0_PROTREG6_Pos (6UL) /*!< Position of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Msk (0x1UL << MPU_PROTENSET0_PROTREG6_Pos) /*!< Bit mask of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG6_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG6_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 5. */
N#define MPU_PROTENSET0_PROTREG5_Pos (5UL) /*!< Position of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Msk (0x1UL << MPU_PROTENSET0_PROTREG5_Pos) /*!< Bit mask of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG5_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG5_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 4. */
N#define MPU_PROTENSET0_PROTREG4_Pos (4UL) /*!< Position of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Msk (0x1UL << MPU_PROTENSET0_PROTREG4_Pos) /*!< Bit mask of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG4_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG4_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 3. */
N#define MPU_PROTENSET0_PROTREG3_Pos (3UL) /*!< Position of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Msk (0x1UL << MPU_PROTENSET0_PROTREG3_Pos) /*!< Bit mask of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG3_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG3_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 2. */
N#define MPU_PROTENSET0_PROTREG2_Pos (2UL) /*!< Position of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Msk (0x1UL << MPU_PROTENSET0_PROTREG2_Pos) /*!< Bit mask of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG2_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG2_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 1. */
N#define MPU_PROTENSET0_PROTREG1_Pos (1UL) /*!< Position of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Msk (0x1UL << MPU_PROTENSET0_PROTREG1_Pos) /*!< Bit mask of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG1_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG1_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 0. */
N#define MPU_PROTENSET0_PROTREG0_Pos (0UL) /*!< Position of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Msk (0x1UL << MPU_PROTENSET0_PROTREG0_Pos) /*!< Bit mask of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG0_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG0_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_PROTENSET1 */
N/* Description: Erase and write protection bit enable set register. */
N
N/* Bit 31 : Protection enable for region 63. */
N#define MPU_PROTENSET1_PROTREG63_Pos (31UL) /*!< Position of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Msk (0x1UL << MPU_PROTENSET1_PROTREG63_Pos) /*!< Bit mask of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG63_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG63_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 62. */
N#define MPU_PROTENSET1_PROTREG62_Pos (30UL) /*!< Position of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Msk (0x1UL << MPU_PROTENSET1_PROTREG62_Pos) /*!< Bit mask of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG62_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG62_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 61. */
N#define MPU_PROTENSET1_PROTREG61_Pos (29UL) /*!< Position of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Msk (0x1UL << MPU_PROTENSET1_PROTREG61_Pos) /*!< Bit mask of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG61_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG61_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 60. */
N#define MPU_PROTENSET1_PROTREG60_Pos (28UL) /*!< Position of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Msk (0x1UL << MPU_PROTENSET1_PROTREG60_Pos) /*!< Bit mask of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG60_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG60_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 59. */
N#define MPU_PROTENSET1_PROTREG59_Pos (27UL) /*!< Position of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Msk (0x1UL << MPU_PROTENSET1_PROTREG59_Pos) /*!< Bit mask of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG59_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG59_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 58. */
N#define MPU_PROTENSET1_PROTREG58_Pos (26UL) /*!< Position of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Msk (0x1UL << MPU_PROTENSET1_PROTREG58_Pos) /*!< Bit mask of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG58_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG58_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 57. */
N#define MPU_PROTENSET1_PROTREG57_Pos (25UL) /*!< Position of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Msk (0x1UL << MPU_PROTENSET1_PROTREG57_Pos) /*!< Bit mask of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG57_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG57_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 56. */
N#define MPU_PROTENSET1_PROTREG56_Pos (24UL) /*!< Position of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Msk (0x1UL << MPU_PROTENSET1_PROTREG56_Pos) /*!< Bit mask of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG56_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG56_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 55. */
N#define MPU_PROTENSET1_PROTREG55_Pos (23UL) /*!< Position of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Msk (0x1UL << MPU_PROTENSET1_PROTREG55_Pos) /*!< Bit mask of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG55_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG55_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 54. */
N#define MPU_PROTENSET1_PROTREG54_Pos (22UL) /*!< Position of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Msk (0x1UL << MPU_PROTENSET1_PROTREG54_Pos) /*!< Bit mask of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG54_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG54_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 53. */
N#define MPU_PROTENSET1_PROTREG53_Pos (21UL) /*!< Position of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Msk (0x1UL << MPU_PROTENSET1_PROTREG53_Pos) /*!< Bit mask of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG53_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG53_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 52. */
N#define MPU_PROTENSET1_PROTREG52_Pos (20UL) /*!< Position of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Msk (0x1UL << MPU_PROTENSET1_PROTREG52_Pos) /*!< Bit mask of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG52_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG52_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 51. */
N#define MPU_PROTENSET1_PROTREG51_Pos (19UL) /*!< Position of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Msk (0x1UL << MPU_PROTENSET1_PROTREG51_Pos) /*!< Bit mask of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG51_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG51_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 50. */
N#define MPU_PROTENSET1_PROTREG50_Pos (18UL) /*!< Position of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Msk (0x1UL << MPU_PROTENSET1_PROTREG50_Pos) /*!< Bit mask of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG50_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG50_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 49. */
N#define MPU_PROTENSET1_PROTREG49_Pos (17UL) /*!< Position of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Msk (0x1UL << MPU_PROTENSET1_PROTREG49_Pos) /*!< Bit mask of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG49_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG49_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 48. */
N#define MPU_PROTENSET1_PROTREG48_Pos (16UL) /*!< Position of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Msk (0x1UL << MPU_PROTENSET1_PROTREG48_Pos) /*!< Bit mask of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG48_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG48_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 47. */
N#define MPU_PROTENSET1_PROTREG47_Pos (15UL) /*!< Position of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Msk (0x1UL << MPU_PROTENSET1_PROTREG47_Pos) /*!< Bit mask of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG47_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG47_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 46. */
N#define MPU_PROTENSET1_PROTREG46_Pos (14UL) /*!< Position of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Msk (0x1UL << MPU_PROTENSET1_PROTREG46_Pos) /*!< Bit mask of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG46_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG46_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 45. */
N#define MPU_PROTENSET1_PROTREG45_Pos (13UL) /*!< Position of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Msk (0x1UL << MPU_PROTENSET1_PROTREG45_Pos) /*!< Bit mask of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG45_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG45_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 44. */
N#define MPU_PROTENSET1_PROTREG44_Pos (12UL) /*!< Position of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Msk (0x1UL << MPU_PROTENSET1_PROTREG44_Pos) /*!< Bit mask of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG44_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG44_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 43. */
N#define MPU_PROTENSET1_PROTREG43_Pos (11UL) /*!< Position of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Msk (0x1UL << MPU_PROTENSET1_PROTREG43_Pos) /*!< Bit mask of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG43_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG43_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 42. */
N#define MPU_PROTENSET1_PROTREG42_Pos (10UL) /*!< Position of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Msk (0x1UL << MPU_PROTENSET1_PROTREG42_Pos) /*!< Bit mask of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG42_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG42_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 41. */
N#define MPU_PROTENSET1_PROTREG41_Pos (9UL) /*!< Position of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Msk (0x1UL << MPU_PROTENSET1_PROTREG41_Pos) /*!< Bit mask of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG41_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG41_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 40. */
N#define MPU_PROTENSET1_PROTREG40_Pos (8UL) /*!< Position of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Msk (0x1UL << MPU_PROTENSET1_PROTREG40_Pos) /*!< Bit mask of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG40_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG40_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 39. */
N#define MPU_PROTENSET1_PROTREG39_Pos (7UL) /*!< Position of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Msk (0x1UL << MPU_PROTENSET1_PROTREG39_Pos) /*!< Bit mask of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG39_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG39_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 38. */
N#define MPU_PROTENSET1_PROTREG38_Pos (6UL) /*!< Position of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Msk (0x1UL << MPU_PROTENSET1_PROTREG38_Pos) /*!< Bit mask of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG38_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG38_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 37. */
N#define MPU_PROTENSET1_PROTREG37_Pos (5UL) /*!< Position of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Msk (0x1UL << MPU_PROTENSET1_PROTREG37_Pos) /*!< Bit mask of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG37_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG37_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 36. */
N#define MPU_PROTENSET1_PROTREG36_Pos (4UL) /*!< Position of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Msk (0x1UL << MPU_PROTENSET1_PROTREG36_Pos) /*!< Bit mask of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG36_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG36_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 35. */
N#define MPU_PROTENSET1_PROTREG35_Pos (3UL) /*!< Position of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Msk (0x1UL << MPU_PROTENSET1_PROTREG35_Pos) /*!< Bit mask of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG35_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG35_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 34. */
N#define MPU_PROTENSET1_PROTREG34_Pos (2UL) /*!< Position of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Msk (0x1UL << MPU_PROTENSET1_PROTREG34_Pos) /*!< Bit mask of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG34_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG34_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 33. */
N#define MPU_PROTENSET1_PROTREG33_Pos (1UL) /*!< Position of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Msk (0x1UL << MPU_PROTENSET1_PROTREG33_Pos) /*!< Bit mask of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG33_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG33_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 32. */
N#define MPU_PROTENSET1_PROTREG32_Pos (0UL) /*!< Position of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Msk (0x1UL << MPU_PROTENSET1_PROTREG32_Pos) /*!< Bit mask of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG32_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG32_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_DISABLEINDEBUG */
N/* Description: Disable erase and write protection mechanism in debug mode. */
N
N/* Bit 0 : Disable protection mechanism in debug mode. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos (0UL) /*!< Position of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Msk (0x1UL << MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos) /*!< Bit mask of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Enabled (0UL) /*!< Protection enabled. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled (1UL) /*!< Protection disabled. */
N
N/* Register: MPU_PROTBLOCKSIZE */
N/* Description: Erase and write protection block size. */
N
N/* Bits 1..0 : Erase and write protection block size. */
N#define MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_Pos (0UL) /*!< Position of PROTBLOCKSIZE field. */
N#define MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_Msk (0x3UL << MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_Pos) /*!< Bit mask of PROTBLOCKSIZE field. */
N#define MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_4k (0UL) /*!< Erase and write protection block size is 4k. */
N
N
N/* Peripheral: NVMC */
N/* Description: Non Volatile Memory Controller. */
N
N/* Register: NVMC_READY */
N/* Description: Ready flag. */
N
N/* Bit 0 : NVMC ready. */
N#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
N#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
N#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation). */
N#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready. */
N
N/* Register: NVMC_CONFIG */
N/* Description: Configuration register. */
N
N/* Bits 1..0 : Program write enable. */
N#define NVMC_CONFIG_WEN_Pos (0UL) /*!< Position of WEN field. */
N#define NVMC_CONFIG_WEN_Msk (0x3UL << NVMC_CONFIG_WEN_Pos) /*!< Bit mask of WEN field. */
N#define NVMC_CONFIG_WEN_Ren (0x00UL) /*!< Read only access. */
N#define NVMC_CONFIG_WEN_Wen (0x01UL) /*!< Write enabled. */
N#define NVMC_CONFIG_WEN_Een (0x02UL) /*!< Erase enabled. */
N
N/* Register: NVMC_ERASEALL */
N/* Description: Register for erasing all non-volatile user memory. */
N
N/* Bit 0 : Starts the erasing of all user NVM (code region 0/1 and UICR registers). */
N#define NVMC_ERASEALL_ERASEALL_Pos (0UL) /*!< Position of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_Msk (0x1UL << NVMC_ERASEALL_ERASEALL_Pos) /*!< Bit mask of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEALL_ERASEALL_Erase (1UL) /*!< Start chip erase. */
N
N/* Register: NVMC_ERASEUICR */
N/* Description: Register for start erasing User Information Congfiguration Registers. */
N
N/* Bit 0 : It can only be used when all contents of code region 1 are erased. */
N#define NVMC_ERASEUICR_ERASEUICR_Pos (0UL) /*!< Position of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_Msk (0x1UL << NVMC_ERASEUICR_ERASEUICR_Pos) /*!< Bit mask of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEUICR_ERASEUICR_Erase (1UL) /*!< Start UICR erase. */
N
N
N/* Peripheral: POWER */
N/* Description: Power Control. */
N
N/* Register: POWER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on POFWARN event. */
N#define POWER_INTENSET_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Msk (0x1UL << POWER_INTENSET_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENSET_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENSET_POFWARN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: POWER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on POFWARN event. */
N#define POWER_INTENCLR_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Msk (0x1UL << POWER_INTENCLR_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENCLR_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENCLR_POFWARN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: POWER_RESETREAS */
N/* Description: Reset reason. */
N
N/* Bit 18 : Reset from wake-up from OFF mode detected by entering into debug interface mode. */
N#define POWER_RESETREAS_DIF_Pos (18UL) /*!< Position of DIF field. */
N#define POWER_RESETREAS_DIF_Msk (0x1UL << POWER_RESETREAS_DIF_Pos) /*!< Bit mask of DIF field. */
N#define POWER_RESETREAS_DIF_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_DIF_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 17 : Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP. */
N#define POWER_RESETREAS_LPCOMP_Pos (17UL) /*!< Position of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_Msk (0x1UL << POWER_RESETREAS_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_LPCOMP_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 16 : Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO. */
N#define POWER_RESETREAS_OFF_Pos (16UL) /*!< Position of OFF field. */
N#define POWER_RESETREAS_OFF_Msk (0x1UL << POWER_RESETREAS_OFF_Pos) /*!< Bit mask of OFF field. */
N#define POWER_RESETREAS_OFF_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_OFF_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 3 : Reset from CPU lock-up detected. */
N#define POWER_RESETREAS_LOCKUP_Pos (3UL) /*!< Position of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_Msk (0x1UL << POWER_RESETREAS_LOCKUP_Pos) /*!< Bit mask of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_LOCKUP_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 2 : Reset from AIRCR.SYSRESETREQ detected. */
N#define POWER_RESETREAS_SREQ_Pos (2UL) /*!< Position of SREQ field. */
N#define POWER_RESETREAS_SREQ_Msk (0x1UL << POWER_RESETREAS_SREQ_Pos) /*!< Bit mask of SREQ field. */
N#define POWER_RESETREAS_SREQ_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_SREQ_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 1 : Reset from watchdog detected. */
N#define POWER_RESETREAS_DOG_Pos (1UL) /*!< Position of DOG field. */
N#define POWER_RESETREAS_DOG_Msk (0x1UL << POWER_RESETREAS_DOG_Pos) /*!< Bit mask of DOG field. */
N#define POWER_RESETREAS_DOG_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_DOG_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 0 : Reset from pin-reset detected. */
N#define POWER_RESETREAS_RESETPIN_Pos (0UL) /*!< Position of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_Msk (0x1UL << POWER_RESETREAS_RESETPIN_Pos) /*!< Bit mask of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_RESETPIN_Detected (1UL) /*!< Reset detected. */
N
N/* Register: POWER_RAMSTATUS */
N/* Description: Ram status register. */
N
N/* Bit 3 : RAM block 3 status. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Pos (3UL) /*!< Position of RAMBLOCK3 field. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK3_Pos) /*!< Bit mask of RAMBLOCK3 field. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Off (0UL) /*!< RAM block 3 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK3_On (1UL) /*!< RAM block 3 is on. */
N
N/* Bit 2 : RAM block 2 status. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Pos (2UL) /*!< Position of RAMBLOCK2 field. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK2_Pos) /*!< Bit mask of RAMBLOCK2 field. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Off (0UL) /*!< RAM block 2 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK2_On (1UL) /*!< RAM block 2 is on. */
N
N/* Bit 1 : RAM block 1 status. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Pos (1UL) /*!< Position of RAMBLOCK1 field. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK1_Pos) /*!< Bit mask of RAMBLOCK1 field. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Off (0UL) /*!< RAM block 1 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK1_On (1UL) /*!< RAM block 1 is on. */
N
N/* Bit 0 : RAM block 0 status. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Pos (0UL) /*!< Position of RAMBLOCK0 field. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK0_Pos) /*!< Bit mask of RAMBLOCK0 field. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Off (0UL) /*!< RAM block 0 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK0_On (1UL) /*!< RAM block 0 is on. */
N
N/* Register: POWER_SYSTEMOFF */
N/* Description: System off register. */
N
N/* Bit 0 : Enter system off mode. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Pos (0UL) /*!< Position of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Msk (0x1UL << POWER_SYSTEMOFF_SYSTEMOFF_Pos) /*!< Bit mask of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Enter (1UL) /*!< Enter system off mode. */
N
N/* Register: POWER_POFCON */
N/* Description: Power failure configuration. */
N
N/* Bits 2..1 : Set threshold level. */
N#define POWER_POFCON_THRESHOLD_Pos (1UL) /*!< Position of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_Msk (0x3UL << POWER_POFCON_THRESHOLD_Pos) /*!< Bit mask of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_V21 (0x00UL) /*!< Set threshold to 2.1Volts. */
N#define POWER_POFCON_THRESHOLD_V23 (0x01UL) /*!< Set threshold to 2.3Volts. */
N#define POWER_POFCON_THRESHOLD_V25 (0x02UL) /*!< Set threshold to 2.5Volts. */
N#define POWER_POFCON_THRESHOLD_V27 (0x03UL) /*!< Set threshold to 2.7Volts. */
N
N/* Bit 0 : Power failure comparator enable. */
N#define POWER_POFCON_POF_Pos (0UL) /*!< Position of POF field. */
N#define POWER_POFCON_POF_Msk (0x1UL << POWER_POFCON_POF_Pos) /*!< Bit mask of POF field. */
N#define POWER_POFCON_POF_Disabled (0UL) /*!< Disabled. */
N#define POWER_POFCON_POF_Enabled (1UL) /*!< Enabled. */
N
N/* Register: POWER_GPREGRET */
N/* Description: General purpose retention register. This register is a retained register. */
N
N/* Bits 7..0 : General purpose retention register. */
N#define POWER_GPREGRET_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
N#define POWER_GPREGRET_GPREGRET_Msk (0xFFUL << POWER_GPREGRET_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
N
N/* Register: POWER_RAMON */
N/* Description: Ram on/off. */
N
N/* Bit 17 : RAM block 1 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM1_Pos (17UL) /*!< Position of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_Msk (0x1UL << POWER_RAMON_OFFRAM1_Pos) /*!< Bit mask of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM1_RAM1On (1UL) /*!< RAM block 1 ON in OFF mode. */
N
N/* Bit 16 : RAM block 0 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM0_Pos (16UL) /*!< Position of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_Msk (0x1UL << POWER_RAMON_OFFRAM0_Pos) /*!< Bit mask of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM0_RAM0On (1UL) /*!< RAM block 0 ON in OFF mode. */
N
N/* Bit 1 : RAM block 1 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM1_Pos (1UL) /*!< Position of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_Msk (0x1UL << POWER_RAMON_ONRAM1_Pos) /*!< Bit mask of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in ON mode. */
N#define POWER_RAMON_ONRAM1_RAM1On (1UL) /*!< RAM block 1 ON in ON mode. */
N
N/* Bit 0 : RAM block 0 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM0_Pos (0UL) /*!< Position of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_Msk (0x1UL << POWER_RAMON_ONRAM0_Pos) /*!< Bit mask of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in ON mode. */
N#define POWER_RAMON_ONRAM0_RAM0On (1UL) /*!< RAM block 0 ON in ON mode. */
N
N/* Register: POWER_RESET */
N/* Description: Pin reset functionality configuration register. This register is a retained register. */
N
N/* Bit 0 : Enable or disable pin reset in debug interface mode. */
N#define POWER_RESET_RESET_Pos (0UL) /*!< Position of RESET field. */
N#define POWER_RESET_RESET_Msk (0x1UL << POWER_RESET_RESET_Pos) /*!< Bit mask of RESET field. */
N#define POWER_RESET_RESET_Disabled (0UL) /*!< Pin reset in debug interface mode disabled. */
N#define POWER_RESET_RESET_Enabled (1UL) /*!< Pin reset in debug interface mode enabled. */
N
N/* Register: POWER_RAMONB */
N/* Description: Ram on/off. */
N
N/* Bit 17 : RAM block 3 behaviour in OFF mode. */
N#define POWER_RAMONB_OFFRAM3_Pos (17UL) /*!< Position of OFFRAM3 field. */
N#define POWER_RAMONB_OFFRAM3_Msk (0x1UL << POWER_RAMONB_OFFRAM3_Pos) /*!< Bit mask of OFFRAM3 field. */
N#define POWER_RAMONB_OFFRAM3_RAM3Off (0UL) /*!< RAM block 3 OFF in OFF mode. */
N#define POWER_RAMONB_OFFRAM3_RAM3On (1UL) /*!< RAM block 3 ON in OFF mode. */
N
N/* Bit 16 : RAM block 2 behaviour in OFF mode. */
N#define POWER_RAMONB_OFFRAM2_Pos (16UL) /*!< Position of OFFRAM2 field. */
N#define POWER_RAMONB_OFFRAM2_Msk (0x1UL << POWER_RAMONB_OFFRAM2_Pos) /*!< Bit mask of OFFRAM2 field. */
N#define POWER_RAMONB_OFFRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in OFF mode. */
N#define POWER_RAMONB_OFFRAM2_RAM2On (1UL) /*!< RAM block 2 ON in OFF mode. */
N
N/* Bit 1 : RAM block 3 behaviour in ON mode. */
N#define POWER_RAMONB_ONRAM3_Pos (1UL) /*!< Position of ONRAM3 field. */
N#define POWER_RAMONB_ONRAM3_Msk (0x1UL << POWER_RAMONB_ONRAM3_Pos) /*!< Bit mask of ONRAM3 field. */
N#define POWER_RAMONB_ONRAM3_RAM3Off (0UL) /*!< RAM block 33 OFF in ON mode. */
N#define POWER_RAMONB_ONRAM3_RAM3On (1UL) /*!< RAM block 3 ON in ON mode. */
N
N/* Bit 0 : RAM block 2 behaviour in ON mode. */
N#define POWER_RAMONB_ONRAM2_Pos (0UL) /*!< Position of ONRAM2 field. */
N#define POWER_RAMONB_ONRAM2_Msk (0x1UL << POWER_RAMONB_ONRAM2_Pos) /*!< Bit mask of ONRAM2 field. */
N#define POWER_RAMONB_ONRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in ON mode. */
N#define POWER_RAMONB_ONRAM2_RAM2On (1UL) /*!< RAM block 2 ON in ON mode. */
N
N/* Register: POWER_DCDCEN */
N/* Description: DCDC converter enable configuration register. */
N
N/* Bit 0 : Enable DCDC converter. */
N#define POWER_DCDCEN_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Msk (0x1UL << POWER_DCDCEN_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Disabled (0UL) /*!< DCDC converter disabled. */
N#define POWER_DCDCEN_DCDCEN_Enabled (1UL) /*!< DCDC converter enabled. */
N
N/* Register: POWER_DCDCFORCE */
N/* Description: DCDC power-up force register. */
N
N/* Bit 1 : DCDC power-up force on. */
N#define POWER_DCDCFORCE_FORCEON_Pos (1UL) /*!< Position of FORCEON field. */
N#define POWER_DCDCFORCE_FORCEON_Msk (0x1UL << POWER_DCDCFORCE_FORCEON_Pos) /*!< Bit mask of FORCEON field. */
N#define POWER_DCDCFORCE_FORCEON_NoForce (0UL) /*!< No force. */
N#define POWER_DCDCFORCE_FORCEON_Force (1UL) /*!< Force. */
N
N/* Bit 0 : DCDC power-up force off. */
N#define POWER_DCDCFORCE_FORCEOFF_Pos (0UL) /*!< Position of FORCEOFF field. */
N#define POWER_DCDCFORCE_FORCEOFF_Msk (0x1UL << POWER_DCDCFORCE_FORCEOFF_Pos) /*!< Bit mask of FORCEOFF field. */
N#define POWER_DCDCFORCE_FORCEOFF_NoForce (0UL) /*!< No force. */
N#define POWER_DCDCFORCE_FORCEOFF_Force (1UL) /*!< Force. */
N
N
N/* Peripheral: PPI */
N/* Description: PPI controller. */
N
N/* Register: PPI_CHEN */
N/* Description: Channel enable. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHEN_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHEN_CH31_Msk (0x1UL << PPI_CHEN_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHEN_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH31_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHEN_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHEN_CH30_Msk (0x1UL << PPI_CHEN_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHEN_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH30_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHEN_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHEN_CH29_Msk (0x1UL << PPI_CHEN_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHEN_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH29_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHEN_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHEN_CH28_Msk (0x1UL << PPI_CHEN_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHEN_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH28_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHEN_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHEN_CH27_Msk (0x1UL << PPI_CHEN_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHEN_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH27_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHEN_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHEN_CH26_Msk (0x1UL << PPI_CHEN_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHEN_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH26_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHEN_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHEN_CH25_Msk (0x1UL << PPI_CHEN_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHEN_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH25_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHEN_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHEN_CH24_Msk (0x1UL << PPI_CHEN_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHEN_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH24_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHEN_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHEN_CH23_Msk (0x1UL << PPI_CHEN_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHEN_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH23_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHEN_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHEN_CH22_Msk (0x1UL << PPI_CHEN_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHEN_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH22_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHEN_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHEN_CH21_Msk (0x1UL << PPI_CHEN_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHEN_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH21_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHEN_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHEN_CH20_Msk (0x1UL << PPI_CHEN_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHEN_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH20_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHEN_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHEN_CH15_Msk (0x1UL << PPI_CHEN_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHEN_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH15_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHEN_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHEN_CH14_Msk (0x1UL << PPI_CHEN_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHEN_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH14_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHEN_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHEN_CH13_Msk (0x1UL << PPI_CHEN_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHEN_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH13_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHEN_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHEN_CH12_Msk (0x1UL << PPI_CHEN_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHEN_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH12_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHEN_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHEN_CH11_Msk (0x1UL << PPI_CHEN_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHEN_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH11_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHEN_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHEN_CH10_Msk (0x1UL << PPI_CHEN_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHEN_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH10_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHEN_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHEN_CH9_Msk (0x1UL << PPI_CHEN_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHEN_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH9_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHEN_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHEN_CH8_Msk (0x1UL << PPI_CHEN_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHEN_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH8_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHEN_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHEN_CH7_Msk (0x1UL << PPI_CHEN_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHEN_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH7_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHEN_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHEN_CH6_Msk (0x1UL << PPI_CHEN_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHEN_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH6_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHEN_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHEN_CH5_Msk (0x1UL << PPI_CHEN_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHEN_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH5_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHEN_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHEN_CH4_Msk (0x1UL << PPI_CHEN_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHEN_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH4_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHEN_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHEN_CH3_Msk (0x1UL << PPI_CHEN_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHEN_CH3_Disabled (0UL) /*!< Channel disabled */
N#define PPI_CHEN_CH3_Enabled (1UL) /*!< Channel enabled */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHEN_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHEN_CH2_Msk (0x1UL << PPI_CHEN_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHEN_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH2_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHEN_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHEN_CH1_Msk (0x1UL << PPI_CHEN_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHEN_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH1_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHEN_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHEN_CH0_Msk (0x1UL << PPI_CHEN_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHEN_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH0_Enabled (1UL) /*!< Channel enabled. */
N
N/* Register: PPI_CHENSET */
N/* Description: Channel enable set. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHENSET_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENSET_CH31_Msk (0x1UL << PPI_CHENSET_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENSET_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH31_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHENSET_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENSET_CH30_Msk (0x1UL << PPI_CHENSET_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENSET_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH30_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHENSET_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENSET_CH29_Msk (0x1UL << PPI_CHENSET_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENSET_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH29_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHENSET_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENSET_CH28_Msk (0x1UL << PPI_CHENSET_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENSET_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH28_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHENSET_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENSET_CH27_Msk (0x1UL << PPI_CHENSET_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENSET_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH27_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHENSET_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENSET_CH26_Msk (0x1UL << PPI_CHENSET_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENSET_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH26_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHENSET_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENSET_CH25_Msk (0x1UL << PPI_CHENSET_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENSET_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH25_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHENSET_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENSET_CH24_Msk (0x1UL << PPI_CHENSET_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENSET_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH24_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHENSET_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENSET_CH23_Msk (0x1UL << PPI_CHENSET_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENSET_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH23_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHENSET_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENSET_CH22_Msk (0x1UL << PPI_CHENSET_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENSET_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH22_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHENSET_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENSET_CH21_Msk (0x1UL << PPI_CHENSET_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENSET_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH21_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHENSET_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENSET_CH20_Msk (0x1UL << PPI_CHENSET_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENSET_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH20_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHENSET_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENSET_CH15_Msk (0x1UL << PPI_CHENSET_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENSET_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH15_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHENSET_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENSET_CH14_Msk (0x1UL << PPI_CHENSET_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENSET_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH14_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHENSET_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENSET_CH13_Msk (0x1UL << PPI_CHENSET_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENSET_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH13_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHENSET_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENSET_CH12_Msk (0x1UL << PPI_CHENSET_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENSET_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH12_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHENSET_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENSET_CH11_Msk (0x1UL << PPI_CHENSET_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENSET_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH11_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHENSET_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENSET_CH10_Msk (0x1UL << PPI_CHENSET_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENSET_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH10_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHENSET_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENSET_CH9_Msk (0x1UL << PPI_CHENSET_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENSET_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH9_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHENSET_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENSET_CH8_Msk (0x1UL << PPI_CHENSET_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENSET_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH8_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHENSET_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENSET_CH7_Msk (0x1UL << PPI_CHENSET_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENSET_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH7_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHENSET_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENSET_CH6_Msk (0x1UL << PPI_CHENSET_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENSET_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH6_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHENSET_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENSET_CH5_Msk (0x1UL << PPI_CHENSET_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENSET_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH5_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHENSET_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENSET_CH4_Msk (0x1UL << PPI_CHENSET_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENSET_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH4_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHENSET_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENSET_CH3_Msk (0x1UL << PPI_CHENSET_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENSET_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH3_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHENSET_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENSET_CH2_Msk (0x1UL << PPI_CHENSET_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENSET_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH2_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHENSET_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENSET_CH1_Msk (0x1UL << PPI_CHENSET_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENSET_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH1_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHENSET_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENSET_CH0_Msk (0x1UL << PPI_CHENSET_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENSET_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH0_Set (1UL) /*!< Enable channel on write. */
N
N/* Register: PPI_CHENCLR */
N/* Description: Channel enable clear. */
N
N/* Bit 31 : Disable PPI channel 31. */
N#define PPI_CHENCLR_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENCLR_CH31_Msk (0x1UL << PPI_CHENCLR_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENCLR_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH31_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 30 : Disable PPI channel 30. */
N#define PPI_CHENCLR_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENCLR_CH30_Msk (0x1UL << PPI_CHENCLR_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENCLR_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH30_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 29 : Disable PPI channel 29. */
N#define PPI_CHENCLR_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENCLR_CH29_Msk (0x1UL << PPI_CHENCLR_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENCLR_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH29_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 28 : Disable PPI channel 28. */
N#define PPI_CHENCLR_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENCLR_CH28_Msk (0x1UL << PPI_CHENCLR_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENCLR_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH28_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 27 : Disable PPI channel 27. */
N#define PPI_CHENCLR_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENCLR_CH27_Msk (0x1UL << PPI_CHENCLR_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENCLR_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH27_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 26 : Disable PPI channel 26. */
N#define PPI_CHENCLR_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENCLR_CH26_Msk (0x1UL << PPI_CHENCLR_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENCLR_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH26_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 25 : Disable PPI channel 25. */
N#define PPI_CHENCLR_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENCLR_CH25_Msk (0x1UL << PPI_CHENCLR_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENCLR_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH25_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 24 : Disable PPI channel 24. */
N#define PPI_CHENCLR_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENCLR_CH24_Msk (0x1UL << PPI_CHENCLR_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENCLR_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH24_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 23 : Disable PPI channel 23. */
N#define PPI_CHENCLR_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENCLR_CH23_Msk (0x1UL << PPI_CHENCLR_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENCLR_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH23_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 22 : Disable PPI channel 22. */
N#define PPI_CHENCLR_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENCLR_CH22_Msk (0x1UL << PPI_CHENCLR_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENCLR_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH22_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 21 : Disable PPI channel 21. */
N#define PPI_CHENCLR_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENCLR_CH21_Msk (0x1UL << PPI_CHENCLR_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENCLR_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH21_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 20 : Disable PPI channel 20. */
N#define PPI_CHENCLR_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENCLR_CH20_Msk (0x1UL << PPI_CHENCLR_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENCLR_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH20_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 15 : Disable PPI channel 15. */
N#define PPI_CHENCLR_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENCLR_CH15_Msk (0x1UL << PPI_CHENCLR_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENCLR_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH15_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 14 : Disable PPI channel 14. */
N#define PPI_CHENCLR_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENCLR_CH14_Msk (0x1UL << PPI_CHENCLR_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENCLR_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH14_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 13 : Disable PPI channel 13. */
N#define PPI_CHENCLR_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENCLR_CH13_Msk (0x1UL << PPI_CHENCLR_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENCLR_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH13_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 12 : Disable PPI channel 12. */
N#define PPI_CHENCLR_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENCLR_CH12_Msk (0x1UL << PPI_CHENCLR_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENCLR_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH12_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 11 : Disable PPI channel 11. */
N#define PPI_CHENCLR_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENCLR_CH11_Msk (0x1UL << PPI_CHENCLR_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENCLR_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH11_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 10 : Disable PPI channel 10. */
N#define PPI_CHENCLR_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENCLR_CH10_Msk (0x1UL << PPI_CHENCLR_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENCLR_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH10_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 9 : Disable PPI channel 9. */
N#define PPI_CHENCLR_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENCLR_CH9_Msk (0x1UL << PPI_CHENCLR_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENCLR_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH9_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 8 : Disable PPI channel 8. */
N#define PPI_CHENCLR_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENCLR_CH8_Msk (0x1UL << PPI_CHENCLR_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENCLR_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH8_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 7 : Disable PPI channel 7. */
N#define PPI_CHENCLR_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENCLR_CH7_Msk (0x1UL << PPI_CHENCLR_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENCLR_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH7_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 6 : Disable PPI channel 6. */
N#define PPI_CHENCLR_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENCLR_CH6_Msk (0x1UL << PPI_CHENCLR_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENCLR_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH6_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 5 : Disable PPI channel 5. */
N#define PPI_CHENCLR_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENCLR_CH5_Msk (0x1UL << PPI_CHENCLR_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENCLR_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH5_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 4 : Disable PPI channel 4. */
N#define PPI_CHENCLR_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENCLR_CH4_Msk (0x1UL << PPI_CHENCLR_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENCLR_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH4_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 3 : Disable PPI channel 3. */
N#define PPI_CHENCLR_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENCLR_CH3_Msk (0x1UL << PPI_CHENCLR_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENCLR_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH3_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 2 : Disable PPI channel 2. */
N#define PPI_CHENCLR_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENCLR_CH2_Msk (0x1UL << PPI_CHENCLR_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENCLR_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH2_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 1 : Disable PPI channel 1. */
N#define PPI_CHENCLR_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENCLR_CH1_Msk (0x1UL << PPI_CHENCLR_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENCLR_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH1_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 0 : Disable PPI channel 0. */
N#define PPI_CHENCLR_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENCLR_CH0_Msk (0x1UL << PPI_CHENCLR_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENCLR_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH0_Clear (1UL) /*!< Disable channel on write. */
N
N/* Register: PPI_CHG */
N/* Description: Channel group configuration. */
N
N/* Bit 31 : Include CH31 in channel group. */
N#define PPI_CHG_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHG_CH31_Msk (0x1UL << PPI_CHG_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHG_CH31_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH31_Included (1UL) /*!< Channel included. */
N
N/* Bit 30 : Include CH30 in channel group. */
N#define PPI_CHG_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHG_CH30_Msk (0x1UL << PPI_CHG_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHG_CH30_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH30_Included (1UL) /*!< Channel included. */
N
N/* Bit 29 : Include CH29 in channel group. */
N#define PPI_CHG_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHG_CH29_Msk (0x1UL << PPI_CHG_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHG_CH29_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH29_Included (1UL) /*!< Channel included. */
N
N/* Bit 28 : Include CH28 in channel group. */
N#define PPI_CHG_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHG_CH28_Msk (0x1UL << PPI_CHG_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHG_CH28_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH28_Included (1UL) /*!< Channel included. */
N
N/* Bit 27 : Include CH27 in channel group. */
N#define PPI_CHG_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHG_CH27_Msk (0x1UL << PPI_CHG_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHG_CH27_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH27_Included (1UL) /*!< Channel included. */
N
N/* Bit 26 : Include CH26 in channel group. */
N#define PPI_CHG_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHG_CH26_Msk (0x1UL << PPI_CHG_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHG_CH26_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH26_Included (1UL) /*!< Channel included. */
N
N/* Bit 25 : Include CH25 in channel group. */
N#define PPI_CHG_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHG_CH25_Msk (0x1UL << PPI_CHG_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHG_CH25_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH25_Included (1UL) /*!< Channel included. */
N
N/* Bit 24 : Include CH24 in channel group. */
N#define PPI_CHG_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHG_CH24_Msk (0x1UL << PPI_CHG_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHG_CH24_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH24_Included (1UL) /*!< Channel included. */
N
N/* Bit 23 : Include CH23 in channel group. */
N#define PPI_CHG_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHG_CH23_Msk (0x1UL << PPI_CHG_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHG_CH23_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH23_Included (1UL) /*!< Channel included. */
N
N/* Bit 22 : Include CH22 in channel group. */
N#define PPI_CHG_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHG_CH22_Msk (0x1UL << PPI_CHG_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHG_CH22_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH22_Included (1UL) /*!< Channel included. */
N
N/* Bit 21 : Include CH21 in channel group. */
N#define PPI_CHG_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHG_CH21_Msk (0x1UL << PPI_CHG_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHG_CH21_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH21_Included (1UL) /*!< Channel included. */
N
N/* Bit 20 : Include CH20 in channel group. */
N#define PPI_CHG_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHG_CH20_Msk (0x1UL << PPI_CHG_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHG_CH20_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH20_Included (1UL) /*!< Channel included. */
N
N/* Bit 15 : Include CH15 in channel group. */
N#define PPI_CHG_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHG_CH15_Msk (0x1UL << PPI_CHG_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHG_CH15_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH15_Included (1UL) /*!< Channel included. */
N
N/* Bit 14 : Include CH14 in channel group. */
N#define PPI_CHG_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHG_CH14_Msk (0x1UL << PPI_CHG_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHG_CH14_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH14_Included (1UL) /*!< Channel included. */
N
N/* Bit 13 : Include CH13 in channel group. */
N#define PPI_CHG_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHG_CH13_Msk (0x1UL << PPI_CHG_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHG_CH13_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH13_Included (1UL) /*!< Channel included. */
N
N/* Bit 12 : Include CH12 in channel group. */
N#define PPI_CHG_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHG_CH12_Msk (0x1UL << PPI_CHG_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHG_CH12_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH12_Included (1UL) /*!< Channel included. */
N
N/* Bit 11 : Include CH11 in channel group. */
N#define PPI_CHG_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHG_CH11_Msk (0x1UL << PPI_CHG_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHG_CH11_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH11_Included (1UL) /*!< Channel included. */
N
N/* Bit 10 : Include CH10 in channel group. */
N#define PPI_CHG_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHG_CH10_Msk (0x1UL << PPI_CHG_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHG_CH10_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH10_Included (1UL) /*!< Channel included. */
N
N/* Bit 9 : Include CH9 in channel group. */
N#define PPI_CHG_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHG_CH9_Msk (0x1UL << PPI_CHG_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHG_CH9_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH9_Included (1UL) /*!< Channel included. */
N
N/* Bit 8 : Include CH8 in channel group. */
N#define PPI_CHG_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHG_CH8_Msk (0x1UL << PPI_CHG_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHG_CH8_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH8_Included (1UL) /*!< Channel included. */
N
N/* Bit 7 : Include CH7 in channel group. */
N#define PPI_CHG_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHG_CH7_Msk (0x1UL << PPI_CHG_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHG_CH7_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH7_Included (1UL) /*!< Channel included. */
N
N/* Bit 6 : Include CH6 in channel group. */
N#define PPI_CHG_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHG_CH6_Msk (0x1UL << PPI_CHG_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHG_CH6_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH6_Included (1UL) /*!< Channel included. */
N
N/* Bit 5 : Include CH5 in channel group. */
N#define PPI_CHG_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHG_CH5_Msk (0x1UL << PPI_CHG_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHG_CH5_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH5_Included (1UL) /*!< Channel included. */
N
N/* Bit 4 : Include CH4 in channel group. */
N#define PPI_CHG_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHG_CH4_Msk (0x1UL << PPI_CHG_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHG_CH4_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH4_Included (1UL) /*!< Channel included. */
N
N/* Bit 3 : Include CH3 in channel group. */
N#define PPI_CHG_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHG_CH3_Msk (0x1UL << PPI_CHG_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHG_CH3_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH3_Included (1UL) /*!< Channel included. */
N
N/* Bit 2 : Include CH2 in channel group. */
N#define PPI_CHG_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHG_CH2_Msk (0x1UL << PPI_CHG_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHG_CH2_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH2_Included (1UL) /*!< Channel included. */
N
N/* Bit 1 : Include CH1 in channel group. */
N#define PPI_CHG_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHG_CH1_Msk (0x1UL << PPI_CHG_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHG_CH1_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH1_Included (1UL) /*!< Channel included. */
N
N/* Bit 0 : Include CH0 in channel group. */
N#define PPI_CHG_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHG_CH0_Msk (0x1UL << PPI_CHG_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHG_CH0_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH0_Included (1UL) /*!< Channel included. */
N
N
N/* Peripheral: QDEC */
N/* Description: Rotary decoder. */
N
N/* Register: QDEC_SHORTS */
N/* Description: Shortcuts for the QDEC. */
N
N/* Bit 1 : Shortcut between SAMPLERDY event and STOP task. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Pos (1UL) /*!< Position of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_STOP_Pos) /*!< Bit mask of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between REPORTRDY event and READCLRACC task. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: QDEC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ACCOF event. */
N#define QDEC_INTENSET_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Msk (0x1UL << QDEC_INTENSET_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_ACCOF_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on REPORTRDY event. */
N#define QDEC_INTENSET_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Msk (0x1UL << QDEC_INTENSET_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_REPORTRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on SAMPLERDY event. */
N#define QDEC_INTENSET_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Msk (0x1UL << QDEC_INTENSET_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_SAMPLERDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: QDEC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ACCOF event. */
N#define QDEC_INTENCLR_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Msk (0x1UL << QDEC_INTENCLR_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_ACCOF_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on REPORTRDY event. */
N#define QDEC_INTENCLR_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Msk (0x1UL << QDEC_INTENCLR_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_REPORTRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on SAMPLERDY event. */
N#define QDEC_INTENCLR_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Msk (0x1UL << QDEC_INTENCLR_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: QDEC_ENABLE */
N/* Description: Enable the QDEC. */
N
N/* Bit 0 : Enable or disable QDEC. */
N#define QDEC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Msk (0x1UL << QDEC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Disabled (0UL) /*!< Disabled QDEC. */
N#define QDEC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable QDEC. */
N
N/* Register: QDEC_LEDPOL */
N/* Description: LED output pin polarity. */
N
N/* Bit 0 : LED output pin polarity. */
N#define QDEC_LEDPOL_LEDPOL_Pos (0UL) /*!< Position of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_Msk (0x1UL << QDEC_LEDPOL_LEDPOL_Pos) /*!< Bit mask of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_ActiveLow (0UL) /*!< LED output is active low. */
N#define QDEC_LEDPOL_LEDPOL_ActiveHigh (1UL) /*!< LED output is active high. */
N
N/* Register: QDEC_SAMPLEPER */
N/* Description: Sample period. */
N
N/* Bits 2..0 : Sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Pos (0UL) /*!< Position of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Msk (0x7UL << QDEC_SAMPLEPER_SAMPLEPER_Pos) /*!< Bit mask of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_128us (0x00UL) /*!< 128us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_256us (0x01UL) /*!< 256us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_512us (0x02UL) /*!< 512us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_1024us (0x03UL) /*!< 1024us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_2048us (0x04UL) /*!< 2048us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_4096us (0x05UL) /*!< 4096us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_8192us (0x06UL) /*!< 8192us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_16384us (0x07UL) /*!< 16384us sample period. */
N
N/* Register: QDEC_SAMPLE */
N/* Description: Motion sample value. */
N
N/* Bits 31..0 : Last sample taken in compliment to 2. */
N#define QDEC_SAMPLE_SAMPLE_Pos (0UL) /*!< Position of SAMPLE field. */
N#define QDEC_SAMPLE_SAMPLE_Msk (0xFFFFFFFFUL << QDEC_SAMPLE_SAMPLE_Pos) /*!< Bit mask of SAMPLE field. */
N
N/* Register: QDEC_REPORTPER */
N/* Description: Number of samples to generate an EVENT_REPORTRDY. */
N
N/* Bits 2..0 : Number of samples to generate an EVENT_REPORTRDY. */
N#define QDEC_REPORTPER_REPORTPER_Pos (0UL) /*!< Position of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_Msk (0x7UL << QDEC_REPORTPER_REPORTPER_Pos) /*!< Bit mask of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_10Smpl (0x00UL) /*!< 10 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_40Smpl (0x01UL) /*!< 40 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_80Smpl (0x02UL) /*!< 80 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_120Smpl (0x03UL) /*!< 120 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_160Smpl (0x04UL) /*!< 160 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_200Smpl (0x05UL) /*!< 200 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_240Smpl (0x06UL) /*!< 240 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_280Smpl (0x07UL) /*!< 280 samples per report. */
N
N/* Register: QDEC_DBFEN */
N/* Description: Enable debouncer input filters. */
N
N/* Bit 0 : Enable debounce input filters. */
N#define QDEC_DBFEN_DBFEN_Pos (0UL) /*!< Position of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Msk (0x1UL << QDEC_DBFEN_DBFEN_Pos) /*!< Bit mask of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Disabled (0UL) /*!< Debounce input filters disabled. */
N#define QDEC_DBFEN_DBFEN_Enabled (1UL) /*!< Debounce input filters enabled. */
N
N/* Register: QDEC_LEDPRE */
N/* Description: Time LED is switched ON before the sample. */
N
N/* Bits 8..0 : Period in us the LED in switched on prior to sampling. */
N#define QDEC_LEDPRE_LEDPRE_Pos (0UL) /*!< Position of LEDPRE field. */
N#define QDEC_LEDPRE_LEDPRE_Msk (0x1FFUL << QDEC_LEDPRE_LEDPRE_Pos) /*!< Bit mask of LEDPRE field. */
N
N/* Register: QDEC_ACCDBL */
N/* Description: Accumulated double (error) transitions register. */
N
N/* Bits 3..0 : Accumulated double (error) transitions. */
N#define QDEC_ACCDBL_ACCDBL_Pos (0UL) /*!< Position of ACCDBL field. */
N#define QDEC_ACCDBL_ACCDBL_Msk (0xFUL << QDEC_ACCDBL_ACCDBL_Pos) /*!< Bit mask of ACCDBL field. */
N
N/* Register: QDEC_ACCDBLREAD */
N/* Description: Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task. */
N
N/* Bits 3..0 : Snapshot of accumulated double (error) transitions. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
N
N/* Register: QDEC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define QDEC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define QDEC_POWER_POWER_Msk (0x1UL << QDEC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define QDEC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define QDEC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RADIO */
N/* Description: The radio. */
N
N/* Register: RADIO_SHORTS */
N/* Description: Shortcuts for the radio. */
N
N/* Bit 8 : Shortcut between DISABLED event and RSSISTOP task. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 6 : Shortcut between ADDRESS event and BCSTART task. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 5 : Shortcut between END event and START task. */
N#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
N#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
N#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 4 : Shortcut between ADDRESS event and RSSISTART task. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between DISABLED event and RXEN task. */
N#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between DISABLED event and TXEN task.  */
N#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between END event and DISABLE task. */
N#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between READY event and START task. */
N#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
N#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
N#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RADIO_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on BCMATCH event. */
N#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on RSSIEND event. */
N#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 6 : Enable interrupt on DEVMISS event. */
N#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 5 : Enable interrupt on DEVMATCH event. */
N#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 4 : Enable interrupt on DISABLED event. */
N#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on END event. */
N#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on PAYLOAD event. */
N#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ADDRESS event. */
N#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RADIO_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on BCMATCH event. */
N#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on RSSIEND event. */
N#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 6 : Disable interrupt on DEVMISS event. */
N#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 5 : Disable interrupt on DEVMATCH event. */
N#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 4 : Disable interrupt on DISABLED event. */
N#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on END event. */
N#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on PAYLOAD event. */
N#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ADDRESS event. */
N#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RADIO_CRCSTATUS */
N/* Description: CRC status of received packet. */
N
N/* Bit 0 : CRC status of received packet. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok. */
N
N/* Register: RADIO_RXMATCH */
N/* Description: Received address. */
N
N/* Bits 2..0 : Logical address in which previous packet was received. */
N#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
N#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
N
N/* Register: RADIO_RXCRC */
N/* Description: Received CRC. */
N
N/* Bits 23..0 : CRC field of previously received packet. */
N#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
N#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
N
N/* Register: RADIO_DAI */
N/* Description: Device address match index. */
N
N/* Bits 2..0 : Index (n) of device address (see DAB[n] and DAP[n]) that obtained an address match. */
N#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
N#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
N
N/* Register: RADIO_FREQUENCY */
N/* Description: Frequency. */
N
N/* Bits 6..0 : Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task.  */
N#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N
N/* Register: RADIO_TXPOWER */
N/* Description: Output power. */
N
N/* Bits 7..0 : Radio output power. Decision point: TXEN task. */
N#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_0dBm (0x00UL) /*!< 0dBm. */
N#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x04UL) /*!< +4dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xD8UL) /*!< -30dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4dBm. */
N
N/* Register: RADIO_MODE */
N/* Description: Data rate and modulation. */
N
N/* Bits 1..0 : Radio data rate and modulation setting. Decision point: TXEN or RXEN task. */
N#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define RADIO_MODE_MODE_Msk (0x3UL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define RADIO_MODE_MODE_Nrf_1Mbit (0x00UL) /*!< 1Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_2Mbit (0x01UL) /*!< 2Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_250Kbit (0x02UL) /*!< 250kbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Ble_1Mbit (0x03UL) /*!< 1Mbit/s Bluetooth Low Energy */
N
N/* Register: RADIO_PCNF0 */
N/* Description: Packet configuration 0. */
N
N/* Bits 19..16 : Length of S1 field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
N#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
N
N/* Bit 8 : Length of S0 field in number of bytes. Decision point: START task. */
N#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
N#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
N
N/* Bits 3..0 : Length of length field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
N#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
N
N/* Register: RADIO_PCNF1 */
N/* Description: Packet configuration 1. */
N
N/* Bit 25 : Packet whitening enable. */
N#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Whitening disabled. */
N#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Whitening enabled. */
N
N/* Bit 24 : On air endianness of packet length field. Decision point: START task. */
N#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least significant bit on air first */
N#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
N
N/* Bits 18..16 : Base address length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
N#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
N
N/* Bits 15..8 : Static length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
N#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
N
N/* Bits 7..0 : Maximum length of packet payload in number of bytes. */
N#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
N#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
N
N/* Register: RADIO_PREFIX0 */
N/* Description: Prefixes bytes for logical addresses 0 to 3. */
N
N/* Bits 31..24 : Address prefix 3. Decision point: START task. */
N#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
N#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
N
N/* Bits 23..16 : Address prefix 2. Decision point: START task. */
N#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
N#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
N
N/* Bits 15..8 : Address prefix 1. Decision point: START task. */
N#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
N#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
N
N/* Bits 7..0 : Address prefix 0. Decision point: START task. */
N#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
N#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
N
N/* Register: RADIO_PREFIX1 */
N/* Description: Prefixes bytes for logical addresses 4 to 7. */
N
N/* Bits 31..24 : Address prefix 7. Decision point: START task. */
N#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
N#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
N
N/* Bits 23..16 : Address prefix 6. Decision point: START task. */
N#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
N#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
N
N/* Bits 15..8 : Address prefix 5. Decision point: START task. */
N#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
N#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
N
N/* Bits 7..0 : Address prefix 4. Decision point: START task. */
N#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
N#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
N
N/* Register: RADIO_TXADDRESS */
N/* Description: Transmit address select. */
N
N/* Bits 2..0 : Logical address to be used when transmitting a packet. Decision point: START task. */
N#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
N#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
N
N/* Register: RADIO_RXADDRESSES */
N/* Description: Receive address select. */
N
N/* Bit 7 : Enable reception on logical address 7. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 6 : Enable reception on logical address 6. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 5 : Enable reception on logical address 5. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 4 : Enable reception on logical address 4. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 3 : Enable reception on logical address 3. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 2 : Enable reception on logical address 2. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 1 : Enable reception on logical address 1. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 0 : Enable reception on logical address 0. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Reception enabled. */
N
N/* Register: RADIO_CRCCNF */
N/* Description: CRC configuration. */
N
N/* Bit 8 : Leave packet address field out of the CRC calculation. Decision point: START task. */
N#define RADIO_CRCCNF_SKIPADDR_Pos (8UL) /*!< Position of SKIPADDR field. */
N#define RADIO_CRCCNF_SKIPADDR_Msk (0x1UL << RADIO_CRCCNF_SKIPADDR_Pos) /*!< Bit mask of SKIPADDR field. */
N#define RADIO_CRCCNF_SKIPADDR_Include (0UL) /*!< Include packet address in CRC calculation. */
N#define RADIO_CRCCNF_SKIPADDR_Skip (1UL) /*!< Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address. */
N
N/* Bits 1..0 : CRC length. Decision point: START task. */
N#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
N#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
N#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC calculation disabled. */
N#define RADIO_CRCCNF_LEN_One (1UL) /*!< One byte long CRC. */
N#define RADIO_CRCCNF_LEN_Two (2UL) /*!< Two bytes long CRC. */
N#define RADIO_CRCCNF_LEN_Three (3UL) /*!< Three bytes long CRC. */
N
N/* Register: RADIO_CRCPOLY */
N/* Description: CRC polynomial. */
N
N/* Bits 23..0 : CRC polynomial. Decision point: START task. */
N#define RADIO_CRCPOLY_CRCPOLY_Pos (0UL) /*!< Position of CRCPOLY field. */
N#define RADIO_CRCPOLY_CRCPOLY_Msk (0xFFFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
N
N/* Register: RADIO_CRCINIT */
N/* Description: CRC initial value. */
N
N/* Bits 23..0 : Initial value for CRC calculation. Decision point: START task. */
N#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
N#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
N
N/* Register: RADIO_TEST */
N/* Description: Test features enable register. */
N
N/* Bit 1 : PLL lock. Decision point: TXEN or RXEN task. */
N#define RADIO_TEST_PLLLOCK_Pos (1UL) /*!< Position of PLLLOCK field. */
N#define RADIO_TEST_PLLLOCK_Msk (0x1UL << RADIO_TEST_PLLLOCK_Pos) /*!< Bit mask of PLLLOCK field. */
N#define RADIO_TEST_PLLLOCK_Disabled (0UL) /*!< PLL lock disabled. */
N#define RADIO_TEST_PLLLOCK_Enabled (1UL) /*!< PLL lock enabled. */
N
N/* Bit 0 : Constant carrier. Decision point: TXEN task. */
N#define RADIO_TEST_CONSTCARRIER_Pos (0UL) /*!< Position of CONSTCARRIER field. */
N#define RADIO_TEST_CONSTCARRIER_Msk (0x1UL << RADIO_TEST_CONSTCARRIER_Pos) /*!< Bit mask of CONSTCARRIER field. */
N#define RADIO_TEST_CONSTCARRIER_Disabled (0UL) /*!< Constant carrier disabled. */
N#define RADIO_TEST_CONSTCARRIER_Enabled (1UL) /*!< Constant carrier enabled. */
N
N/* Register: RADIO_TIFS */
N/* Description: Inter Frame Spacing in microseconds. */
N
N/* Bits 7..0 : Inter frame spacing in microseconds. Decision point: START rask */
N#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
N#define RADIO_TIFS_TIFS_Msk (0xFFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
N
N/* Register: RADIO_RSSISAMPLE */
N/* Description: RSSI sample. */
N
N/* Bits 6..0 : RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
N
N/* Register: RADIO_STATE */
N/* Description: Current radio state. */
N
N/* Bits 3..0 : Current radio state. */
N#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
N#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
N#define RADIO_STATE_STATE_Disabled (0x00UL) /*!< Radio is in the Disabled state. */
N#define RADIO_STATE_STATE_RxRu (0x01UL) /*!< Radio is in the Rx Ramp Up state. */
N#define RADIO_STATE_STATE_RxIdle (0x02UL) /*!< Radio is in the Rx Idle state. */
N#define RADIO_STATE_STATE_Rx (0x03UL) /*!< Radio is in the Rx state. */
N#define RADIO_STATE_STATE_RxDisable (0x04UL) /*!< Radio is in the Rx Disable state. */
N#define RADIO_STATE_STATE_TxRu (0x09UL) /*!< Radio is in the Tx Ramp Up state. */
N#define RADIO_STATE_STATE_TxIdle (0x0AUL) /*!< Radio is in the Tx Idle state. */
N#define RADIO_STATE_STATE_Tx (0x0BUL) /*!< Radio is in the Tx state. */
N#define RADIO_STATE_STATE_TxDisable (0x0CUL) /*!< Radio is in the Tx Disable state. */
N
N/* Register: RADIO_DATAWHITEIV */
N/* Description: Data whitening initial value. */
N
N/* Bits 6..0 : Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x7FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
N
N/* Register: RADIO_DAP */
N/* Description: Device address prefix. */
N
N/* Bits 15..0 : Device address prefix. */
N#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
N#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
N
N/* Register: RADIO_DACNF */
N/* Description: Device address match configuration. */
N
N/* Bit 15 : TxAdd for device address 7. */
N#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
N#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
N
N/* Bit 14 : TxAdd for device address 6. */
N#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
N#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
N
N/* Bit 13 : TxAdd for device address 5. */
N#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
N#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
N
N/* Bit 12 : TxAdd for device address 4. */
N#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
N#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
N
N/* Bit 11 : TxAdd for device address 3. */
N#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
N#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
N
N/* Bit 10 : TxAdd for device address 2. */
N#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
N#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
N
N/* Bit 9 : TxAdd for device address 1. */
N#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
N#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
N
N/* Bit 8 : TxAdd for device address 0. */
N#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
N#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
N
N/* Bit 7 : Enable or disable device address matching using device address 7. */
N#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
N#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
N#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 6 : Enable or disable device address matching using device address 6. */
N#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
N#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
N#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 5 : Enable or disable device address matching using device address 5. */
N#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
N#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
N#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 4 : Enable or disable device address matching using device address 4. */
N#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
N#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
N#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 3 : Enable or disable device address matching using device address 3. */
N#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
N#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
N#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 2 : Enable or disable device address matching using device address 2. */
N#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
N#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
N#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 1 : Enable or disable device address matching using device address 1. */
N#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
N#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
N#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 0 : Enable or disable device address matching using device address 0. */
N#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
N#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
N#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled. */
N
N/* Register: RADIO_OVERRIDE0 */
N/* Description: Trim value override register 0. */
N
N/* Bits 31..0 : Trim value override 0. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Pos (0UL) /*!< Position of OVERRIDE0 field. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE0_OVERRIDE0_Pos) /*!< Bit mask of OVERRIDE0 field. */
N
N/* Register: RADIO_OVERRIDE1 */
N/* Description: Trim value override register 1. */
N
N/* Bits 31..0 : Trim value override 1. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Pos (0UL) /*!< Position of OVERRIDE1 field. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE1_OVERRIDE1_Pos) /*!< Bit mask of OVERRIDE1 field. */
N
N/* Register: RADIO_OVERRIDE2 */
N/* Description: Trim value override register 2. */
N
N/* Bits 31..0 : Trim value override 2. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Pos (0UL) /*!< Position of OVERRIDE2 field. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE2_OVERRIDE2_Pos) /*!< Bit mask of OVERRIDE2 field. */
N
N/* Register: RADIO_OVERRIDE3 */
N/* Description: Trim value override register 3. */
N
N/* Bits 31..0 : Trim value override 3. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Pos (0UL) /*!< Position of OVERRIDE3 field. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE3_OVERRIDE3_Pos) /*!< Bit mask of OVERRIDE3 field. */
N
N/* Register: RADIO_OVERRIDE4 */
N/* Description: Trim value override register 4. */
N
N/* Bit 31 : Enable or disable override of default trim values. */
N#define RADIO_OVERRIDE4_ENABLE_Pos (31UL) /*!< Position of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Msk (0x1UL << RADIO_OVERRIDE4_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Disabled (0UL) /*!< Override trim values disabled. */
N#define RADIO_OVERRIDE4_ENABLE_Enabled (1UL) /*!< Override trim values enabled. */
N
N/* Bits 27..0 : Trim value override 4. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Pos (0UL) /*!< Position of OVERRIDE4 field. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Msk (0xFFFFFFFUL << RADIO_OVERRIDE4_OVERRIDE4_Pos) /*!< Bit mask of OVERRIDE4 field. */
N
N/* Register: RADIO_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RADIO_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RADIO_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RNG */
N/* Description: Random Number Generator. */
N
N/* Register: RNG_SHORTS */
N/* Description: Shortcuts for the RNG. */
N
N/* Bit 0 : Shortcut between VALRDY event and STOP task. */
N#define RNG_SHORTS_VALRDY_STOP_Pos (0UL) /*!< Position of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Msk (0x1UL << RNG_SHORTS_VALRDY_STOP_Pos) /*!< Bit mask of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RNG_SHORTS_VALRDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RNG_INTENSET */
N/* Description: Interrupt enable set register */
N
N/* Bit 0 : Enable interrupt on VALRDY event. */
N#define RNG_INTENSET_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Msk (0x1UL << RNG_INTENSET_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENSET_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENSET_VALRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RNG_INTENCLR */
N/* Description: Interrupt enable clear register */
N
N/* Bit 0 : Disable interrupt on VALRDY event. */
N#define RNG_INTENCLR_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Msk (0x1UL << RNG_INTENCLR_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENCLR_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENCLR_VALRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RNG_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 0 : Digital error correction enable. */
N#define RNG_CONFIG_DERCEN_Pos (0UL) /*!< Position of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Msk (0x1UL << RNG_CONFIG_DERCEN_Pos) /*!< Bit mask of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Disabled (0UL) /*!< Digital error correction disabled. */
N#define RNG_CONFIG_DERCEN_Enabled (1UL) /*!< Digital error correction enabled. */
N
N/* Register: RNG_VALUE */
N/* Description: RNG random number. */
N
N/* Bits 7..0 : Generated random number. */
N#define RNG_VALUE_VALUE_Pos (0UL) /*!< Position of VALUE field. */
N#define RNG_VALUE_VALUE_Msk (0xFFUL << RNG_VALUE_VALUE_Pos) /*!< Bit mask of VALUE field. */
N
N/* Register: RNG_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RNG_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RNG_POWER_POWER_Msk (0x1UL << RNG_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RNG_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RNG_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RTC */
N/* Description: Real time counter 0. */
N
N/* Register: RTC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] event. */
N#define RTC_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Msk (0x1UL << RTC_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] event. */
N#define RTC_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Msk (0x1UL << RTC_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] event. */
N#define RTC_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Msk (0x1UL << RTC_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] event. */
N#define RTC_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Msk (0x1UL << RTC_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on OVRFLW event. */
N#define RTC_INTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Msk (0x1UL << RTC_INTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_OVRFLW_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on TICK event. */
N#define RTC_INTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENSET_TICK_Msk (0x1UL << RTC_INTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENSET_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_TICK_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RTC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] event. */
N#define RTC_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Msk (0x1UL << RTC_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] event. */
N#define RTC_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Msk (0x1UL << RTC_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] event. */
N#define RTC_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Msk (0x1UL << RTC_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] event. */
N#define RTC_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Msk (0x1UL << RTC_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on OVRFLW event. */
N#define RTC_INTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Msk (0x1UL << RTC_INTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_OVRFLW_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on TICK event. */
N#define RTC_INTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENCLR_TICK_Msk (0x1UL << RTC_INTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENCLR_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_TICK_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RTC_EVTEN */
N/* Description: Configures event enable routing to PPI for each RTC event. */
N
N/* Bit 19 : COMPARE[3] event enable. */
N#define RTC_EVTEN_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Msk (0x1UL << RTC_EVTEN_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 18 : COMPARE[2] event enable. */
N#define RTC_EVTEN_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Msk (0x1UL << RTC_EVTEN_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 17 : COMPARE[1] event enable. */
N#define RTC_EVTEN_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Msk (0x1UL << RTC_EVTEN_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 16 : COMPARE[0] event enable. */
N#define RTC_EVTEN_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Msk (0x1UL << RTC_EVTEN_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 1 : OVRFLW event enable. */
N#define RTC_EVTEN_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Msk (0x1UL << RTC_EVTEN_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 0 : TICK event enable. */
N#define RTC_EVTEN_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTEN_TICK_Msk (0x1UL << RTC_EVTEN_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTEN_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_TICK_Enabled (1UL) /*!< Event enabled. */
N
N/* Register: RTC_EVTENSET */
N/* Description: Enable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Enable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Msk (0x1UL << RTC_EVTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE3_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 18 : Enable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Msk (0x1UL << RTC_EVTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE2_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 17 : Enable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Msk (0x1UL << RTC_EVTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE1_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 16 : Enable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Msk (0x1UL << RTC_EVTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE0_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 1 : Enable routing to PPI of OVRFLW event. */
N#define RTC_EVTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Msk (0x1UL << RTC_EVTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_OVRFLW_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 0 : Enable routing to PPI of TICK event. */
N#define RTC_EVTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENSET_TICK_Msk (0x1UL << RTC_EVTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENSET_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_TICK_Set (1UL) /*!< Enable event on write. */
N
N/* Register: RTC_EVTENCLR */
N/* Description: Disable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Disable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Msk (0x1UL << RTC_EVTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE3_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 18 : Disable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Msk (0x1UL << RTC_EVTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE2_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 17 : Disable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Msk (0x1UL << RTC_EVTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE1_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 16 : Disable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Msk (0x1UL << RTC_EVTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE0_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 1 : Disable routing to PPI of OVRFLW event. */
N#define RTC_EVTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Msk (0x1UL << RTC_EVTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_OVRFLW_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 0 : Disable routing to PPI of TICK event. */
N#define RTC_EVTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENCLR_TICK_Msk (0x1UL << RTC_EVTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENCLR_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_TICK_Clear (1UL) /*!< Disable event on write. */
N
N/* Register: RTC_COUNTER */
N/* Description: Current COUNTER value. */
N
N/* Bits 23..0 : Counter value. */
N#define RTC_COUNTER_COUNTER_Pos (0UL) /*!< Position of COUNTER field. */
N#define RTC_COUNTER_COUNTER_Msk (0xFFFFFFUL << RTC_COUNTER_COUNTER_Pos) /*!< Bit mask of COUNTER field. */
N
N/* Register: RTC_PRESCALER */
N/* Description: 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed. */
N
N/* Bits 11..0 : RTC PRESCALER value. */
N#define RTC_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define RTC_PRESCALER_PRESCALER_Msk (0xFFFUL << RTC_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: RTC_CC */
N/* Description: Capture/compare registers. */
N
N/* Bits 23..0 : Compare value. */
N#define RTC_CC_COMPARE_Pos (0UL) /*!< Position of COMPARE field. */
N#define RTC_CC_COMPARE_Msk (0xFFFFFFUL << RTC_CC_COMPARE_Pos) /*!< Bit mask of COMPARE field. */
N
N/* Register: RTC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RTC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RTC_POWER_POWER_Msk (0x1UL << RTC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RTC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RTC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPI */
N/* Description: SPI master 0. */
N
N/* Register: SPI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on READY event. */
N#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPI_ENABLE */
N/* Description: Enable SPI. */
N
N/* Bits 2..0 : Enable or disable SPI. */
N#define SPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Msk (0x7UL << SPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPI. */
N#define SPI_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable SPI. */
N
N/* Register: SPI_RXD */
N/* Description: RX data. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define SPI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define SPI_RXD_RXD_Msk (0xFFUL << SPI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: SPI_TXD */
N/* Description: TX data. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define SPI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define SPI_TXD_TXD_Msk (0xFFUL << SPI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: SPI_FREQUENCY */
N/* Description: SPI frequency */
N
N/* Bits 31..0 : SPI data rate. */
N#define SPI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500kbps. */
N#define SPI_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8Mbps. */
N
N/* Register: SPI_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPI_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPI_CONFIG_CPOL_Msk (0x1UL << SPI_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPI_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPI_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPI_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPI_CONFIG_CPHA_Msk (0x1UL << SPI_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPI_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPI_CONFIG_ORDER_Msk (0x1UL << SPI_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPI_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPI_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPI_POWER_POWER_Msk (0x1UL << SPI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPIS */
N/* Description: SPI slave 1. */
N
N/* Register: SPIS_SHORTS */
N/* Description: Shortcuts for SPIS. */
N
N/* Bit 2 : Shortcut between END event and the ACQUIRE task. */
N#define SPIS_SHORTS_END_ACQUIRE_Pos (2UL) /*!< Position of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Msk (0x1UL << SPIS_SHORTS_END_ACQUIRE_Pos) /*!< Bit mask of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Disabled (0UL) /*!< Shortcut disabled. */
N#define SPIS_SHORTS_END_ACQUIRE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: SPIS_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on ACQUIRED event. */
N#define SPIS_INTENSET_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Msk (0x1UL << SPIS_INTENSET_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_ACQUIRED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 4 : enable interrupt on ENDRX event. */
N#define SPIS_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIS_INTENSET_ENDRX_Msk (0x1UL << SPIS_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIS_INTENSET_ENDRX_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_ENDRX_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_ENDRX_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on END event. */
N#define SPIS_INTENSET_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENSET_END_Msk (0x1UL << SPIS_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPIS_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on ACQUIRED event. */
N#define SPIS_INTENCLR_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Msk (0x1UL << SPIS_INTENCLR_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_ACQUIRED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 4 : Disable interrupt on ENDRX event. */
N#define SPIS_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIS_INTENCLR_ENDRX_Msk (0x1UL << SPIS_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIS_INTENCLR_ENDRX_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_ENDRX_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_ENDRX_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on END event. */
N#define SPIS_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENCLR_END_Msk (0x1UL << SPIS_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPIS_SEMSTAT */
N/* Description: Semaphore status. */
N
N/* Bits 1..0 : Semaphore status. */
N#define SPIS_SEMSTAT_SEMSTAT_Pos (0UL) /*!< Position of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Msk (0x3UL << SPIS_SEMSTAT_SEMSTAT_Pos) /*!< Bit mask of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Free (0x00UL) /*!< Semaphore is free. */
N#define SPIS_SEMSTAT_SEMSTAT_CPU (0x01UL) /*!< Semaphore is assigned to the CPU. */
N#define SPIS_SEMSTAT_SEMSTAT_SPIS (0x02UL) /*!< Semaphore is assigned to the SPIS. */
N#define SPIS_SEMSTAT_SEMSTAT_CPUPending (0x03UL) /*!< Semaphore is assigned to the SPIS, but a handover to the CPU is pending. */
N
N/* Register: SPIS_STATUS */
N/* Description: Status from last transaction. */
N
N/* Bit 1 : RX buffer overflow detected, and prevented. */
N#define SPIS_STATUS_OVERFLOW_Pos (1UL) /*!< Position of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_Msk (0x1UL << SPIS_STATUS_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERFLOW_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERFLOW_Clear (1UL) /*!< Clear on write. */
N
N/* Bit 0 : TX buffer overread detected, and prevented. */
N#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Clear on write. */
N
N/* Register: SPIS_ENABLE */
N/* Description: Enable SPIS. */
N
N/* Bits 2..0 : Enable or disable SPIS. */
N#define SPIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Msk (0x7UL << SPIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPIS. */
N#define SPIS_ENABLE_ENABLE_Enabled (0x02UL) /*!< Enable SPIS. */
N
N/* Register: SPIS_MAXRX */
N/* Description: Maximum number of bytes in the receive buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the receive buffer. */
N#define SPIS_MAXRX_MAXRX_Pos (0UL) /*!< Position of MAXRX field. */
N#define SPIS_MAXRX_MAXRX_Msk (0xFFUL << SPIS_MAXRX_MAXRX_Pos) /*!< Bit mask of MAXRX field. */
N
N/* Register: SPIS_AMOUNTRX */
N/* Description: Number of bytes received in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes received in last granted transaction. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Pos (0UL) /*!< Position of AMOUNTRX field. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Msk (0xFFUL << SPIS_AMOUNTRX_AMOUNTRX_Pos) /*!< Bit mask of AMOUNTRX field. */
N
N/* Register: SPIS_MAXTX */
N/* Description: Maximum number of bytes in the transmit buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the transmit buffer. */
N#define SPIS_MAXTX_MAXTX_Pos (0UL) /*!< Position of MAXTX field. */
N#define SPIS_MAXTX_MAXTX_Msk (0xFFUL << SPIS_MAXTX_MAXTX_Pos) /*!< Bit mask of MAXTX field. */
N
N/* Register: SPIS_AMOUNTTX */
N/* Description: Number of bytes transmitted in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes transmitted in last granted transaction. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Pos (0UL) /*!< Position of AMOUNTTX field. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Msk (0xFFUL << SPIS_AMOUNTTX_AMOUNTTX_Pos) /*!< Bit mask of AMOUNTTX field. */
N
N/* Register: SPIS_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPIS_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPIS_CONFIG_CPOL_Msk (0x1UL << SPIS_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPIS_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPIS_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPIS_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPIS_CONFIG_CPHA_Msk (0x1UL << SPIS_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPIS_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPIS_CONFIG_ORDER_Msk (0x1UL << SPIS_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPIS_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPIS_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPIS_DEF */
N/* Description: Default character. */
N
N/* Bits 7..0 : Default character. */
N#define SPIS_DEF_DEF_Pos (0UL) /*!< Position of DEF field. */
N#define SPIS_DEF_DEF_Msk (0xFFUL << SPIS_DEF_DEF_Pos) /*!< Bit mask of DEF field. */
N
N/* Register: SPIS_ORC */
N/* Description: Over-read character. */
N
N/* Bits 7..0 : Over-read character. */
N#define SPIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
N#define SPIS_ORC_ORC_Msk (0xFFUL << SPIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
N
N/* Register: SPIS_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPIS_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPIS_POWER_POWER_Msk (0x1UL << SPIS_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPIS_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPIS_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TEMP */
N/* Description: Temperature Sensor. */
N
N/* Register: TEMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on DATARDY event. */
N#define TEMP_INTENSET_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Msk (0x1UL << TEMP_INTENSET_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENSET_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENSET_DATARDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TEMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on DATARDY event. */
N#define TEMP_INTENCLR_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Msk (0x1UL << TEMP_INTENCLR_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENCLR_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENCLR_DATARDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TEMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TEMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TEMP_POWER_POWER_Msk (0x1UL << TEMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TEMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TEMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TIMER */
N/* Description: Timer 0. */
N
N/* Register: TIMER_SHORTS */
N/* Description: Shortcuts for Timer. */
N
N/* Bit 11 : Shortcut between CC[3] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE3_STOP_Pos (11UL) /*!< Position of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE3_STOP_Pos) /*!< Bit mask of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 10 : Shortcut between CC[2] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE2_STOP_Pos (10UL) /*!< Position of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE2_STOP_Pos) /*!< Bit mask of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 9 : Shortcut between CC[1] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE1_STOP_Pos (9UL) /*!< Position of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE1_STOP_Pos) /*!< Bit mask of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 8 : Shortcut between CC[0] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE0_STOP_Pos (8UL) /*!< Position of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE0_STOP_Pos) /*!< Bit mask of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between CC[3] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Pos (3UL) /*!< Position of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE3_CLEAR_Pos) /*!< Bit mask of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between CC[2] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Pos (2UL) /*!< Position of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE2_CLEAR_Pos) /*!< Bit mask of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between CC[1] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Pos (1UL) /*!< Position of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE1_CLEAR_Pos) /*!< Bit mask of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between CC[0] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Pos (0UL) /*!< Position of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE0_CLEAR_Pos) /*!< Bit mask of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TIMER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] */
N#define TIMER_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Msk (0x1UL << TIMER_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] */
N#define TIMER_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Msk (0x1UL << TIMER_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] */
N#define TIMER_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Msk (0x1UL << TIMER_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] */
N#define TIMER_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Msk (0x1UL << TIMER_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TIMER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] */
N#define TIMER_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Msk (0x1UL << TIMER_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] */
N#define TIMER_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Msk (0x1UL << TIMER_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] */
N#define TIMER_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Msk (0x1UL << TIMER_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] */
N#define TIMER_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Msk (0x1UL << TIMER_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TIMER_MODE */
N/* Description: Timer Mode selection. */
N
N/* Bit 0 : Select Normal or Counter mode. */
N#define TIMER_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define TIMER_MODE_MODE_Msk (0x1UL << TIMER_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define TIMER_MODE_MODE_Timer (0UL) /*!< Timer in Normal mode. */
N#define TIMER_MODE_MODE_Counter (1UL) /*!< Timer in Counter mode. */
N
N/* Register: TIMER_BITMODE */
N/* Description: Sets timer behaviour. */
N
N/* Bits 1..0 : Sets timer behaviour ro be like the implementation of a timer with width as indicated. */
N#define TIMER_BITMODE_BITMODE_Pos (0UL) /*!< Position of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_Msk (0x3UL << TIMER_BITMODE_BITMODE_Pos) /*!< Bit mask of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_16Bit (0x00UL) /*!< 16-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_08Bit (0x01UL) /*!< 8-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_24Bit (0x02UL) /*!< 24-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_32Bit (0x03UL) /*!< 32-bit timer behaviour. */
N
N/* Register: TIMER_PRESCALER */
N/* Description: 4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE. */
N
N/* Bits 3..0 : Timer PRESCALER value. Max value is 9. */
N#define TIMER_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define TIMER_PRESCALER_PRESCALER_Msk (0xFUL << TIMER_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: TIMER_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TIMER_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TIMER_POWER_POWER_Msk (0x1UL << TIMER_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TIMER_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TIMER_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TWI */
N/* Description: Two-wire interface master 0. */
N
N/* Register: TWI_SHORTS */
N/* Description: Shortcuts for TWI. */
N
N/* Bit 1 : Shortcut between BB event and the STOP task. */
N#define TWI_SHORTS_BB_STOP_Pos (1UL) /*!< Position of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Msk (0x1UL << TWI_SHORTS_BB_STOP_Pos) /*!< Bit mask of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between BB event and the SUSPEND task. */
N#define TWI_SHORTS_BB_SUSPEND_Pos (0UL) /*!< Position of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Msk (0x1UL << TWI_SHORTS_BB_SUSPEND_Pos) /*!< Bit mask of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_SUSPEND_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TWI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 18 : Enable interrupt on SUSPENDED event. */
N#define TWI_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWI_INTENSET_SUSPENDED_Msk (0x1UL << TWI_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWI_INTENSET_SUSPENDED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_SUSPENDED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_SUSPENDED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 14 : Enable interrupt on BB event. */
N#define TWI_INTENSET_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENSET_BB_Msk (0x1UL << TWI_INTENSET_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENSET_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_BB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define TWI_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENSET_ERROR_Msk (0x1UL << TWI_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXDSENT event. */
N#define TWI_INTENSET_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Msk (0x1UL << TWI_INTENSET_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_TXDSENT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on STOPPED event. */
N#define TWI_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Msk (0x1UL << TWI_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_STOPPED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TWI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 18 : Disable interrupt on SUSPENDED event. */
N#define TWI_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWI_INTENCLR_SUSPENDED_Msk (0x1UL << TWI_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWI_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 14 : Disable interrupt on BB event. */
N#define TWI_INTENCLR_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENCLR_BB_Msk (0x1UL << TWI_INTENCLR_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENCLR_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_BB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define TWI_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENCLR_ERROR_Msk (0x1UL << TWI_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXDSENT event. */
N#define TWI_INTENCLR_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Msk (0x1UL << TWI_INTENCLR_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_TXDSENT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXDREADY event. */
N#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on STOPPED event. */
N#define TWI_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Msk (0x1UL << TWI_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_STOPPED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TWI_ERRORSRC */
N/* Description: Two-wire error source. Write error field to 1 to clear error. */
N
N/* Bit 2 : NACK received after sending a data byte. */
N#define TWI_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
N#define TWI_ERRORSRC_DNACK_Msk (0x1UL << TWI_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
N#define TWI_ERRORSRC_DNACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_DNACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_DNACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : NACK received after sending the address. */
N#define TWI_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
N#define TWI_ERRORSRC_ANACK_Msk (0x1UL << TWI_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
N#define TWI_ERRORSRC_ANACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_ANACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_ANACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 0 : Byte received in RXD register before read of the last received byte (data loss). */
N#define TWI_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define TWI_ERRORSRC_OVERRUN_Msk (0x1UL << TWI_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define TWI_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_OVERRUN_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_OVERRUN_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: TWI_ENABLE */
N/* Description: Enable two-wire master. */
N
N/* Bits 2..0 : Enable or disable W2M */
N#define TWI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Msk (0x7UL << TWI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled. */
N#define TWI_ENABLE_ENABLE_Enabled (0x05UL) /*!< Enabled. */
N
N/* Register: TWI_RXD */
N/* Description: RX data register. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define TWI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define TWI_RXD_RXD_Msk (0xFFUL << TWI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: TWI_TXD */
N/* Description: TX data register. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define TWI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define TWI_TXD_TXD_Msk (0xFFUL << TWI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: TWI_FREQUENCY */
N/* Description: Two-wire frequency. */
N
N/* Bits 31..0 : Two-wire master clock frequency. */
N#define TWI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K400 (0x06680000UL) /*!< 400 kbps (actual rate 410.256 kbps). */
N
N/* Register: TWI_ADDRESS */
N/* Description: Address used in the two-wire transfer. */
N
N/* Bits 6..0 : Two-wire address. */
N#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
N#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N
N/* Register: TWI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TWI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TWI_POWER_POWER_Msk (0x1UL << TWI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TWI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TWI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UART */
N/* Description: Universal Asynchronous Receiver/Transmitter. */
N
N/* Register: UART_SHORTS */
N/* Description: Shortcuts for UART. */
N
N/* Bit 4 : Shortcut between NCTS event and STOPRX task. */
N#define UART_SHORTS_NCTS_STOPRX_Pos (4UL) /*!< Position of NCTS_STOPRX field. */
N#define UART_SHORTS_NCTS_STOPRX_Msk (0x1UL << UART_SHORTS_NCTS_STOPRX_Pos) /*!< Bit mask of NCTS_STOPRX field. */
N#define UART_SHORTS_NCTS_STOPRX_Disabled (0UL) /*!< Shortcut disabled. */
N#define UART_SHORTS_NCTS_STOPRX_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between CTS event and STARTRX task. */
N#define UART_SHORTS_CTS_STARTRX_Pos (3UL) /*!< Position of CTS_STARTRX field. */
N#define UART_SHORTS_CTS_STARTRX_Msk (0x1UL << UART_SHORTS_CTS_STARTRX_Pos) /*!< Bit mask of CTS_STARTRX field. */
N#define UART_SHORTS_CTS_STARTRX_Disabled (0UL) /*!< Shortcut disabled. */
N#define UART_SHORTS_CTS_STARTRX_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: UART_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 17 : Enable interrupt on RXTO event. */
N#define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENSET_RXTO_Msk (0x1UL << UART_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENSET_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENSET_ERROR_Msk (0x1UL << UART_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXRDY event. */
N#define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Msk (0x1UL << UART_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_TXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on RXRDY event. */
N#define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Msk (0x1UL << UART_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on NCTS event. */
N#define UART_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UART_INTENSET_NCTS_Msk (0x1UL << UART_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UART_INTENSET_NCTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_NCTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_NCTS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on CTS event. */
N#define UART_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UART_INTENSET_CTS_Msk (0x1UL << UART_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UART_INTENSET_CTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_CTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_CTS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: UART_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 17 : Disable interrupt on RXTO event. */
N#define UART_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENCLR_RXTO_Msk (0x1UL << UART_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENCLR_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define UART_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENCLR_ERROR_Msk (0x1UL << UART_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXRDY event. */
N#define UART_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Msk (0x1UL << UART_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXRDY event. */
N#define UART_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Msk (0x1UL << UART_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on NCTS event. */
N#define UART_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UART_INTENCLR_NCTS_Msk (0x1UL << UART_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UART_INTENCLR_NCTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_NCTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_NCTS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on CTS event. */
N#define UART_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UART_INTENCLR_CTS_Msk (0x1UL << UART_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UART_INTENCLR_CTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_CTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_CTS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: UART_ERRORSRC */
N/* Description: Error source. Write error field to 1 to clear error. */
N
N/* Bit 3 : The serial data input is '0' for longer than the length of a data frame. */
N#define UART_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
N#define UART_ERRORSRC_BREAK_Msk (0x1UL << UART_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
N#define UART_ERRORSRC_BREAK_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_BREAK_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_BREAK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 2 : A valid stop bit is not detected on the serial data input after all bits in a character have been received. */
N#define UART_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_Msk (0x1UL << UART_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_FRAMING_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_FRAMING_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : A character with bad parity is received. Only checked if HW parity control is enabled. */
N#define UART_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_ERRORSRC_PARITY_Msk (0x1UL << UART_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_ERRORSRC_PARITY_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_PARITY_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_PARITY_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 0 : A start bit is received while the previous data still lies in RXD. (Data loss). */
N#define UART_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_Msk (0x1UL << UART_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_OVERRUN_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_OVERRUN_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: UART_ENABLE */
N/* Description: Enable UART and acquire IOs. */
N
N/* Bits 2..0 : Enable or disable UART and acquire IOs. */
N#define UART_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define UART_ENABLE_ENABLE_Msk (0x7UL << UART_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define UART_ENABLE_ENABLE_Disabled (0x00UL) /*!< UART disabled. */
N#define UART_ENABLE_ENABLE_Enabled (0x04UL) /*!< UART enabled. */
N
N/* Register: UART_RXD */
N/* Description: RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working. */
N
N/* Bits 7..0 : RX data from previous transfer. Double buffered. */
N#define UART_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define UART_RXD_RXD_Msk (0xFFUL << UART_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: UART_TXD */
N/* Description: TXD register. */
N
N/* Bits 7..0 : TX data for transfer. */
N#define UART_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define UART_TXD_TXD_Msk (0xFFUL << UART_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: UART_BAUDRATE */
N/* Description: UART Baudrate. */
N
N/* Bits 31..0 : UART baudrate. */
N#define UART_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UART_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud14400 (0x003B0000UL) /*!< 14400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud28800 (0x0075F000UL) /*!< 28800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud31250 (0x00800000UL) /*!< 31250 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud38400 (0x009D5000UL) /*!< 38400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud57600 (0x00EBF000UL) /*!< 57600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud115200 (0x01D7E000UL) /*!< 115200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud230400 (0x03AFB000UL) /*!< 230400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud460800 (0x075F7000UL) /*!< 460800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud921600 (0x0EBED000UL) /*!< 921600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1M baud. */
N
N/* Register: UART_CONFIG */
N/* Description: Configuration of parity and hardware flow control register. */
N
N/* Bits 3..1 : Include parity bit. */
N#define UART_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_CONFIG_PARITY_Msk (0x7UL << UART_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_CONFIG_PARITY_Excluded (0UL) /*!< Parity bit excluded. */
N#define UART_CONFIG_PARITY_Included (7UL) /*!< Parity bit included. */
N
N/* Bit 0 : Hardware flow control. */
N#define UART_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
N#define UART_CONFIG_HWFC_Msk (0x1UL << UART_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
N#define UART_CONFIG_HWFC_Disabled (0UL) /*!< Hardware flow control disabled. */
N#define UART_CONFIG_HWFC_Enabled (1UL) /*!< Hardware flow control enabled. */
N
N/* Register: UART_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define UART_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define UART_POWER_POWER_Msk (0x1UL << UART_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define UART_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define UART_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UICR */
N/* Description: User Information Configuration. */
N
N/* Register: UICR_RBPCONF */
N/* Description: Readback protection configuration. */
N
N/* Bits 15..8 : Readback protect all code in the device. */
N#define UICR_RBPCONF_PALL_Pos (8UL) /*!< Position of PALL field. */
N#define UICR_RBPCONF_PALL_Msk (0xFFUL << UICR_RBPCONF_PALL_Pos) /*!< Bit mask of PALL field. */
N#define UICR_RBPCONF_PALL_Enabled (0x00UL) /*!< Enabled. */
N#define UICR_RBPCONF_PALL_Disabled (0xFFUL) /*!< Disabled. */
N
N/* Bits 7..0 : Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip. */
N#define UICR_RBPCONF_PR0_Pos (0UL) /*!< Position of PR0 field. */
N#define UICR_RBPCONF_PR0_Msk (0xFFUL << UICR_RBPCONF_PR0_Pos) /*!< Bit mask of PR0 field. */
N#define UICR_RBPCONF_PR0_Enabled (0x00UL) /*!< Enabled. */
N#define UICR_RBPCONF_PR0_Disabled (0xFFUL) /*!< Disabled. */
N
N/* Register: UICR_XTALFREQ */
N/* Description: Reset value for CLOCK XTALFREQ register. */
N
N/* Bits 7..0 : Reset value for CLOCK XTALFREQ register. */
N#define UICR_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_Msk (0xFFUL << UICR_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz Xtal is used. */
N#define UICR_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz Xtal is used. */
N
N/* Register: UICR_FWID */
N/* Description: Firmware ID. */
N
N/* Bits 15..0 : Identification number for the firmware loaded into the chip. */
N#define UICR_FWID_FWID_Pos (0UL) /*!< Position of FWID field. */
N#define UICR_FWID_FWID_Msk (0xFFFFUL << UICR_FWID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N
N/* Peripheral: WDT */
N/* Description: Watchdog Timer. */
N
N/* Register: WDT_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on TIMEOUT event. */
N#define WDT_INTENSET_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Msk (0x1UL << WDT_INTENSET_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENSET_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENSET_TIMEOUT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: WDT_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on TIMEOUT event. */
N#define WDT_INTENCLR_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Msk (0x1UL << WDT_INTENCLR_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENCLR_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENCLR_TIMEOUT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: WDT_RUNSTATUS */
N/* Description: Watchdog running status. */
N
N/* Bit 0 : Watchdog running status. */
N#define WDT_RUNSTATUS_RUNSTATUS_Pos (0UL) /*!< Position of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_Msk (0x1UL << WDT_RUNSTATUS_RUNSTATUS_Pos) /*!< Bit mask of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_NotRunning (0UL) /*!< Watchdog timer is not running. */
N#define WDT_RUNSTATUS_RUNSTATUS_Running (1UL) /*!< Watchdog timer is running. */
N
N/* Register: WDT_REQSTATUS */
N/* Description: Request status. */
N
N/* Bit 7 : Request status for RR[7]. */
N#define WDT_REQSTATUS_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_REQSTATUS_RR7_Msk (0x1UL << WDT_REQSTATUS_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR7_EnabledAndUnrequested (1UL) /*!< RR[7] register is enabled and has not jet requested. */
N
N/* Bit 6 : Request status for RR[6]. */
N#define WDT_REQSTATUS_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_REQSTATUS_RR6_Msk (0x1UL << WDT_REQSTATUS_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR6_EnabledAndUnrequested (1UL) /*!< RR[6] register is enabled and has not jet requested. */
N
N/* Bit 5 : Request status for RR[5]. */
N#define WDT_REQSTATUS_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_REQSTATUS_RR5_Msk (0x1UL << WDT_REQSTATUS_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR5_EnabledAndUnrequested (1UL) /*!< RR[5] register is enabled and has not jet requested. */
N
N/* Bit 4 : Request status for RR[4]. */
N#define WDT_REQSTATUS_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_REQSTATUS_RR4_Msk (0x1UL << WDT_REQSTATUS_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR4_EnabledAndUnrequested (1UL) /*!< RR[4] register is enabled and has not jet requested. */
N
N/* Bit 3 : Request status for RR[3]. */
N#define WDT_REQSTATUS_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_REQSTATUS_RR3_Msk (0x1UL << WDT_REQSTATUS_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR3_EnabledAndUnrequested (1UL) /*!< RR[3] register is enabled and has not jet requested. */
N
N/* Bit 2 : Request status for RR[2]. */
N#define WDT_REQSTATUS_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_REQSTATUS_RR2_Msk (0x1UL << WDT_REQSTATUS_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR2_EnabledAndUnrequested (1UL) /*!< RR[2] register is enabled and has not jet requested. */
N
N/* Bit 1 : Request status for RR[1]. */
N#define WDT_REQSTATUS_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_REQSTATUS_RR1_Msk (0x1UL << WDT_REQSTATUS_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR1_EnabledAndUnrequested (1UL) /*!< RR[1] register is enabled and has not jet requested. */
N
N/* Bit 0 : Request status for RR[0]. */
N#define WDT_REQSTATUS_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_REQSTATUS_RR0_Msk (0x1UL << WDT_REQSTATUS_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR0_EnabledAndUnrequested (1UL) /*!< RR[0] register is enabled and has not jet requested. */
N
N/* Register: WDT_RREN */
N/* Description: Reload request enable. */
N
N/* Bit 7 : Enable or disable RR[7] register. */
N#define WDT_RREN_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_RREN_RR7_Msk (0x1UL << WDT_RREN_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_RREN_RR7_Disabled (0UL) /*!< RR[7] register is disabled. */
N#define WDT_RREN_RR7_Enabled (1UL) /*!< RR[7] register is enabled. */
N
N/* Bit 6 : Enable or disable RR[6] register. */
N#define WDT_RREN_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_RREN_RR6_Msk (0x1UL << WDT_RREN_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_RREN_RR6_Disabled (0UL) /*!< RR[6] register is disabled. */
N#define WDT_RREN_RR6_Enabled (1UL) /*!< RR[6] register is enabled. */
N
N/* Bit 5 : Enable or disable RR[5] register. */
N#define WDT_RREN_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_RREN_RR5_Msk (0x1UL << WDT_RREN_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_RREN_RR5_Disabled (0UL) /*!< RR[5] register is disabled. */
N#define WDT_RREN_RR5_Enabled (1UL) /*!< RR[5] register is enabled. */
N
N/* Bit 4 : Enable or disable RR[4] register. */
N#define WDT_RREN_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_RREN_RR4_Msk (0x1UL << WDT_RREN_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_RREN_RR4_Disabled (0UL) /*!< RR[4] register is disabled. */
N#define WDT_RREN_RR4_Enabled (1UL) /*!< RR[4] register is enabled. */
N
N/* Bit 3 : Enable or disable RR[3] register. */
N#define WDT_RREN_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_RREN_RR3_Msk (0x1UL << WDT_RREN_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_RREN_RR3_Disabled (0UL) /*!< RR[3] register is disabled. */
N#define WDT_RREN_RR3_Enabled (1UL) /*!< RR[3] register is enabled. */
N
N/* Bit 2 : Enable or disable RR[2] register. */
N#define WDT_RREN_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_RREN_RR2_Msk (0x1UL << WDT_RREN_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_RREN_RR2_Disabled (0UL) /*!< RR[2] register is disabled. */
N#define WDT_RREN_RR2_Enabled (1UL) /*!< RR[2] register is enabled. */
N
N/* Bit 1 : Enable or disable RR[1] register. */
N#define WDT_RREN_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_RREN_RR1_Msk (0x1UL << WDT_RREN_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_RREN_RR1_Disabled (0UL) /*!< RR[1] register is disabled. */
N#define WDT_RREN_RR1_Enabled (1UL) /*!< RR[1] register is enabled. */
N
N/* Bit 0 : Enable or disable RR[0] register. */
N#define WDT_RREN_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_RREN_RR0_Msk (0x1UL << WDT_RREN_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_RREN_RR0_Disabled (0UL) /*!< RR[0] register is disabled. */
N#define WDT_RREN_RR0_Enabled (1UL) /*!< RR[0] register is enabled. */
N
N/* Register: WDT_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 3 : Configure the watchdog to pause or not while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Pos (3UL) /*!< Position of HALT field. */
N#define WDT_CONFIG_HALT_Msk (0x1UL << WDT_CONFIG_HALT_Pos) /*!< Bit mask of HALT field. */
N#define WDT_CONFIG_HALT_Pause (0UL) /*!< Pause watchdog while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Run (1UL) /*!< Do not pause watchdog while the CPU is halted by the debugger. */
N
N/* Bit 0 : Configure the watchdog to pause or not while the CPU is sleeping. */
N#define WDT_CONFIG_SLEEP_Pos (0UL) /*!< Position of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Msk (0x1UL << WDT_CONFIG_SLEEP_Pos) /*!< Bit mask of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Pause (0UL) /*!< Pause watchdog while the CPU is asleep. */
N#define WDT_CONFIG_SLEEP_Run (1UL) /*!< Do not pause watchdog while the CPU is asleep. */
N
N/* Register: WDT_RR */
N/* Description: Reload requests registers. */
N
N/* Bits 31..0 : Reload register. */
N#define WDT_RR_RR_Pos (0UL) /*!< Position of RR field. */
N#define WDT_RR_RR_Msk (0xFFFFFFFFUL << WDT_RR_RR_Pos) /*!< Bit mask of RR field. */
N#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer. */
N
N/* Register: WDT_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define WDT_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define WDT_POWER_POWER_Msk (0x1UL << WDT_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define WDT_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define WDT_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/*lint --flb "Leave library region" */
N#endif
L 64 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 2
N        #include "nrf51_deprecated.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51_deprecated.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef NRF51_DEPRECATED_H
N#define NRF51_DEPRECATED_H
N
N/*lint ++flb "Enter library region */
N
N/* This file is given to prevent your SW from not compiling with the updates made to nrf51.h and 
N * nrf51_bitfields.h. The macros defined in this file were available previously. Do not use these
N * macros on purpose. Use the ones defined in nrf51.h and nrf51_bitfields.h instead.
N */
N
N/* NVMC */
N/* The register ERASEPROTECTEDPAGE is called ERASEPCR0 in the documentation. */
N#define ERASEPROTECTEDPAGE   ERASEPCR0
N
N 
N/* LPCOMP */
N/* The interrupt ISR was renamed. Adding old name to the macros. */
N#define LPCOMP_COMP_IRQHandler          LPCOMP_IRQHandler
N#define LPCOMP_COMP_IRQn                LPCOMP_IRQn
N/* Corrected typo in RESULT register. */
N#define LPCOMP_RESULT_RESULT_Bellow     LPCOMP_RESULT_RESULT_Below
N 
N 
N/* MPU */
N/* The field MPU.PERR0.LPCOMP_COMP was renamed. Added into deprecated in case somebody was using the macros defined for it. */
N#define MPU_PERR0_LPCOMP_COMP_Pos           MPU_PERR0_LPCOMP_Pos
N#define MPU_PERR0_LPCOMP_COMP_Msk           MPU_PERR0_LPCOMP_Msk
N#define MPU_PERR0_LPCOMP_COMP_InRegion1     MPU_PERR0_LPCOMP_InRegion1
N#define MPU_PERR0_LPCOMP_COMP_InRegion0     MPU_PERR0_LPCOMP_InRegion0
N 
N 
N/* POWER */
N/* The field POWER.RAMON.OFFRAM3 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_OFFRAM3_Pos         (19UL)                                  
N#define POWER_RAMON_OFFRAM3_Msk         (0x1UL << POWER_RAMON_OFFRAM3_Pos)      
N#define POWER_RAMON_OFFRAM3_RAM3Off     (0UL)                                   
N#define POWER_RAMON_OFFRAM3_RAM3On      (1UL)                                   
N/* The field POWER.RAMON.OFFRAM2 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_OFFRAM2_Pos         (18UL)                                  
N#define POWER_RAMON_OFFRAM2_Msk         (0x1UL << POWER_RAMON_OFFRAM2_Pos)      
N#define POWER_RAMON_OFFRAM2_RAM2Off     (0UL)                                   
N#define POWER_RAMON_OFFRAM2_RAM2On      (1UL)                                  
N/* The field POWER.RAMON.ONRAM3 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_ONRAM3_Pos          (3UL)                                  
N#define POWER_RAMON_ONRAM3_Msk          (0x1UL << POWER_RAMON_ONRAM3_Pos)      
N#define POWER_RAMON_ONRAM3_RAM3Off      (0UL)                                  
N#define POWER_RAMON_ONRAM3_RAM3On       (1UL)                                  
N/* The field POWER.RAMON.ONRAM2 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_ONRAM2_Pos          (2UL)                                  
N#define POWER_RAMON_ONRAM2_Msk          (0x1UL << POWER_RAMON_ONRAM2_Pos)       
N#define POWER_RAMON_ONRAM2_RAM2Off      (0UL)                                  
N#define POWER_RAMON_ONRAM2_RAM2On       (1UL)                                 
N
N 
N/* RADIO */
N/* The enumerated value RADIO.TXPOWER.TXPOWER.Neg40dBm was renamed. Added into deprecated with the new macro name. */
N#define RADIO_TXPOWER_TXPOWER_Neg40dBm  RADIO_TXPOWER_TXPOWER_Neg30dBm      
N/* The name of the field SKIPADDR was corrected. Old macros added for compatibility. */
N#define RADIO_CRCCNF_SKIP_ADDR_Pos      RADIO_CRCCNF_SKIPADDR_Pos 
N#define RADIO_CRCCNF_SKIP_ADDR_Msk      RADIO_CRCCNF_SKIPADDR_Msk 
N#define RADIO_CRCCNF_SKIP_ADDR_Include  RADIO_CRCCNF_SKIPADDR_Include 
N#define RADIO_CRCCNF_SKIP_ADDR_Skip     RADIO_CRCCNF_SKIPADDR_Skip 
N/* The name of the field PLLLOCK was corrected. Old macros added for compatibility. */
N#define RADIO_TEST_PLL_LOCK_Pos         RADIO_TEST_PLLLOCK_Pos 
N#define RADIO_TEST_PLL_LOCK_Msk         RADIO_TEST_PLLLOCK_Msk 
N#define RADIO_TEST_PLL_LOCK_Disabled    RADIO_TEST_PLLLOCK_Disabled 
N#define RADIO_TEST_PLL_LOCK_Enabled     RADIO_TEST_PLLLOCK_Enabled 
N/* The name of the field CONSTCARRIER was corrected. Old macros added for compatibility. */
N#define RADIO_TEST_CONST_CARRIER_Pos        RADIO_TEST_CONSTCARRIER_Pos 
N#define RADIO_TEST_CONST_CARRIER_Msk        RADIO_TEST_CONSTCARRIER_Msk 
N#define RADIO_TEST_CONST_CARRIER_Disabled   RADIO_TEST_CONSTCARRIER_Disabled 
N#define RADIO_TEST_CONST_CARRIER_Enabled    RADIO_TEST_CONSTCARRIER_Enabled 
N
N
N/* FICR */
N/* The registers FICR.SIZERAMBLOCK0, FICR.SIZERAMBLOCK1, FICR.SIZERAMBLOCK2 and FICR.SIZERAMBLOCK3 were renamed into an array. */
N#define SIZERAMBLOCK0   SIZERAMBLOCKS                   
N#define SIZERAMBLOCK1   SIZERAMBLOCKS                   
N#define SIZERAMBLOCK2   SIZERAMBLOCK[2]                 /*!< Note that this macro will disapear when SIZERAMBLOCK array is eliminated. SIZERAMBLOCK is a deprecated array. */
N#define SIZERAMBLOCK3   SIZERAMBLOCK[3]                 /*!< Note that this macro will disapear when SIZERAMBLOCK array is eliminated. SIZERAMBLOCK is a deprecated array. */
N/* The registers FICR.DEVICEID0 and FICR.DEVICEID1 were renamed into an array. */
N#define DEVICEID0       DEVICEID[0]                     
N#define DEVICEID1       DEVICEID[1]                     
N/* The registers FICR.ER0, FICR.ER1, FICR.ER2 and FICR.ER3 were renamed into an array. */
N#define ER0             ER[0]                           
N#define ER1             ER[1]                          
N#define ER2             ER[2]                       
N#define ER3             ER[3]                      
N/* The registers FICR.IR0, FICR.IR1, FICR.IR2 and FICR.IR3 were renamed into an array. */
N#define IR0             IR[0]                         
N#define IR1             IR[1]                         
N#define IR2             IR[2]                         
N#define IR3             IR[3]                          
N/* The registers FICR.DEVICEADDR0 and FICR.DEVICEADDR1 were renamed into an array. */
N#define DEVICEADDR0     DEVICEADDR[0]                  
N#define DEVICEADDR1     DEVICEADDR[1]                  
N
N
N/* PPI */
N/* The tasks PPI.TASKS_CHGxEN and PPI.TASKS_CHGxDIS were renamed into an array of structs. */
N#define TASKS_CHG0EN     TASKS_CHG[0].EN                    
N#define TASKS_CHG0DIS    TASKS_CHG[0].DIS                  
N#define TASKS_CHG1EN     TASKS_CHG[1].EN                    
N#define TASKS_CHG1DIS    TASKS_CHG[1].DIS                  
N#define TASKS_CHG2EN     TASKS_CHG[2].EN                   
N#define TASKS_CHG2DIS    TASKS_CHG[2].DIS                  
N#define TASKS_CHG3EN     TASKS_CHG[3].EN                    
N#define TASKS_CHG3DIS    TASKS_CHG[3].DIS                  
N/* The registers PPI.CHx_EEP and PPI.CHx_TEP were renamed into an array of structs. */
N#define CH0_EEP          CH[0].EEP                          
N#define CH0_TEP          CH[0].TEP                          
N#define CH1_EEP          CH[1].EEP                         
N#define CH1_TEP          CH[1].TEP                         
N#define CH2_EEP          CH[2].EEP                          
N#define CH2_TEP          CH[2].TEP                         
N#define CH3_EEP          CH[3].EEP                          
N#define CH3_TEP          CH[3].TEP                         
N#define CH4_EEP          CH[4].EEP                         
N#define CH4_TEP          CH[4].TEP                         
N#define CH5_EEP          CH[5].EEP                          
N#define CH5_TEP          CH[5].TEP                          
N#define CH6_EEP          CH[6].EEP                          
N#define CH6_TEP          CH[6].TEP                         
N#define CH7_EEP          CH[7].EEP                          
N#define CH7_TEP          CH[7].TEP                          
N#define CH8_EEP          CH[8].EEP                         
N#define CH8_TEP          CH[8].TEP                          
N#define CH9_EEP          CH[9].EEP                          
N#define CH9_TEP          CH[9].TEP                          
N#define CH10_EEP         CH[10].EEP                         
N#define CH10_TEP         CH[10].TEP                         
N#define CH11_EEP         CH[11].EEP                         
N#define CH11_TEP         CH[11].TEP                         
N#define CH12_EEP         CH[12].EEP                         
N#define CH12_TEP         CH[12].TEP                         
N#define CH13_EEP         CH[13].EEP                         
N#define CH13_TEP         CH[13].TEP                         
N#define CH14_EEP         CH[14].EEP                         
N#define CH14_TEP         CH[14].TEP                         
N#define CH15_EEP         CH[15].EEP                         
N#define CH15_TEP         CH[15].TEP                        
N/* The registers PPI.CHG0, PPI.CHG1, PPI.CHG2 and PPI.CHG3 were renamed into an array. */
N#define CHG0             CHG[0]                            
N#define CHG1             CHG[1]                            
N#define CHG2             CHG[2]                             
N#define CHG3             CHG[3]                           
N/* All bitfield macros for the CHGx registers therefore changed name. */
N#define PPI_CHG0_CH15_Pos       PPI_CHG_CH15_Pos            
N#define PPI_CHG0_CH15_Msk       PPI_CHG_CH15_Msk            
N#define PPI_CHG0_CH15_Excluded  PPI_CHG_CH15_Excluded       
N#define PPI_CHG0_CH15_Included  PPI_CHG_CH15_Included       
N#define PPI_CHG0_CH14_Pos       PPI_CHG_CH14_Pos            
N#define PPI_CHG0_CH14_Msk       PPI_CHG_CH14_Msk           
N#define PPI_CHG0_CH14_Excluded  PPI_CHG_CH14_Excluded       
N#define PPI_CHG0_CH14_Included  PPI_CHG_CH14_Included       
N#define PPI_CHG0_CH13_Pos       PPI_CHG_CH13_Pos            
N#define PPI_CHG0_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG0_CH13_Excluded  PPI_CHG_CH13_Excluded      
N#define PPI_CHG0_CH13_Included  PPI_CHG_CH13_Included       
N#define PPI_CHG0_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG0_CH12_Msk       PPI_CHG_CH12_Msk            
N#define PPI_CHG0_CH12_Excluded  PPI_CHG_CH12_Excluded       
N#define PPI_CHG0_CH12_Included  PPI_CHG_CH12_Included       
N#define PPI_CHG0_CH11_Pos       PPI_CHG_CH11_Pos            
N#define PPI_CHG0_CH11_Msk       PPI_CHG_CH11_Msk            
N#define PPI_CHG0_CH11_Excluded  PPI_CHG_CH11_Excluded       
N#define PPI_CHG0_CH11_Included  PPI_CHG_CH11_Included       
N#define PPI_CHG0_CH10_Pos       PPI_CHG_CH10_Pos            
N#define PPI_CHG0_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG0_CH10_Excluded  PPI_CHG_CH10_Excluded       
N#define PPI_CHG0_CH10_Included  PPI_CHG_CH10_Included       
N#define PPI_CHG0_CH9_Pos        PPI_CHG_CH9_Pos             
N#define PPI_CHG0_CH9_Msk        PPI_CHG_CH9_Msk             
N#define PPI_CHG0_CH9_Excluded   PPI_CHG_CH9_Excluded        
N#define PPI_CHG0_CH9_Included   PPI_CHG_CH9_Included        
N#define PPI_CHG0_CH8_Pos        PPI_CHG_CH8_Pos             
N#define PPI_CHG0_CH8_Msk        PPI_CHG_CH8_Msk             
N#define PPI_CHG0_CH8_Excluded   PPI_CHG_CH8_Excluded        
N#define PPI_CHG0_CH8_Included   PPI_CHG_CH8_Included        
N#define PPI_CHG0_CH7_Pos        PPI_CHG_CH7_Pos             
N#define PPI_CHG0_CH7_Msk        PPI_CHG_CH7_Msk             
N#define PPI_CHG0_CH7_Excluded   PPI_CHG_CH7_Excluded        
N#define PPI_CHG0_CH7_Included   PPI_CHG_CH7_Included        
N#define PPI_CHG0_CH6_Pos        PPI_CHG_CH6_Pos             
N#define PPI_CHG0_CH6_Msk        PPI_CHG_CH6_Msk             
N#define PPI_CHG0_CH6_Excluded   PPI_CHG_CH6_Excluded        
N#define PPI_CHG0_CH6_Included   PPI_CHG_CH6_Included        
N#define PPI_CHG0_CH5_Pos        PPI_CHG_CH5_Pos             
N#define PPI_CHG0_CH5_Msk        PPI_CHG_CH5_Msk             
N#define PPI_CHG0_CH5_Excluded   PPI_CHG_CH5_Excluded       
N#define PPI_CHG0_CH5_Included   PPI_CHG_CH5_Included        
N#define PPI_CHG0_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG0_CH4_Msk        PPI_CHG_CH4_Msk             
N#define PPI_CHG0_CH4_Excluded   PPI_CHG_CH4_Excluded       
N#define PPI_CHG0_CH4_Included   PPI_CHG_CH4_Included       
N#define PPI_CHG0_CH3_Pos        PPI_CHG_CH3_Pos             
N#define PPI_CHG0_CH3_Msk        PPI_CHG_CH3_Msk            
N#define PPI_CHG0_CH3_Excluded   PPI_CHG_CH3_Excluded        
N#define PPI_CHG0_CH3_Included   PPI_CHG_CH3_Included       
N#define PPI_CHG0_CH2_Pos        PPI_CHG_CH2_Pos            
N#define PPI_CHG0_CH2_Msk        PPI_CHG_CH2_Msk             
N#define PPI_CHG0_CH2_Excluded   PPI_CHG_CH2_Excluded       
N#define PPI_CHG0_CH2_Included   PPI_CHG_CH2_Included       
N#define PPI_CHG0_CH1_Pos        PPI_CHG_CH1_Pos            
N#define PPI_CHG0_CH1_Msk        PPI_CHG_CH1_Msk            
N#define PPI_CHG0_CH1_Excluded   PPI_CHG_CH1_Excluded        
N#define PPI_CHG0_CH1_Included   PPI_CHG_CH1_Included       
N#define PPI_CHG0_CH0_Pos        PPI_CHG_CH0_Pos            
N#define PPI_CHG0_CH0_Msk        PPI_CHG_CH0_Msk            
N#define PPI_CHG0_CH0_Excluded   PPI_CHG_CH0_Excluded        
N#define PPI_CHG0_CH0_Included   PPI_CHG_CH0_Included       
N#define PPI_CHG1_CH15_Pos       PPI_CHG_CH15_Pos           
N#define PPI_CHG1_CH15_Msk       PPI_CHG_CH15_Msk           
N#define PPI_CHG1_CH15_Excluded  PPI_CHG_CH15_Excluded       
N#define PPI_CHG1_CH15_Included  PPI_CHG_CH15_Included      
N#define PPI_CHG1_CH14_Pos       PPI_CHG_CH14_Pos           
N#define PPI_CHG1_CH14_Msk       PPI_CHG_CH14_Msk            
N#define PPI_CHG1_CH14_Excluded  PPI_CHG_CH14_Excluded      
N#define PPI_CHG1_CH14_Included  PPI_CHG_CH14_Included       
N#define PPI_CHG1_CH13_Pos       PPI_CHG_CH13_Pos           
N#define PPI_CHG1_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG1_CH13_Excluded  PPI_CHG_CH13_Excluded      
N#define PPI_CHG1_CH13_Included  PPI_CHG_CH13_Included      
N#define PPI_CHG1_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG1_CH12_Msk       PPI_CHG_CH12_Msk           
N#define PPI_CHG1_CH12_Excluded  PPI_CHG_CH12_Excluded      
N#define PPI_CHG1_CH12_Included  PPI_CHG_CH12_Included      
N#define PPI_CHG1_CH11_Pos       PPI_CHG_CH11_Pos            
N#define PPI_CHG1_CH11_Msk       PPI_CHG_CH11_Msk           
N#define PPI_CHG1_CH11_Excluded  PPI_CHG_CH11_Excluded      
N#define PPI_CHG1_CH11_Included  PPI_CHG_CH11_Included      
N#define PPI_CHG1_CH10_Pos       PPI_CHG_CH10_Pos           
N#define PPI_CHG1_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG1_CH10_Excluded  PPI_CHG_CH10_Excluded      
N#define PPI_CHG1_CH10_Included  PPI_CHG_CH10_Included      
N#define PPI_CHG1_CH9_Pos        PPI_CHG_CH9_Pos            
N#define PPI_CHG1_CH9_Msk        PPI_CHG_CH9_Msk            
N#define PPI_CHG1_CH9_Excluded   PPI_CHG_CH9_Excluded       
N#define PPI_CHG1_CH9_Included   PPI_CHG_CH9_Included       
N#define PPI_CHG1_CH8_Pos        PPI_CHG_CH8_Pos            
N#define PPI_CHG1_CH8_Msk        PPI_CHG_CH8_Msk            
N#define PPI_CHG1_CH8_Excluded   PPI_CHG_CH8_Excluded       
N#define PPI_CHG1_CH8_Included   PPI_CHG_CH8_Included       
N#define PPI_CHG1_CH7_Pos        PPI_CHG_CH7_Pos             
N#define PPI_CHG1_CH7_Msk        PPI_CHG_CH7_Msk            
N#define PPI_CHG1_CH7_Excluded   PPI_CHG_CH7_Excluded        
N#define PPI_CHG1_CH7_Included   PPI_CHG_CH7_Included       
N#define PPI_CHG1_CH6_Pos        PPI_CHG_CH6_Pos             
N#define PPI_CHG1_CH6_Msk        PPI_CHG_CH6_Msk            
N#define PPI_CHG1_CH6_Excluded   PPI_CHG_CH6_Excluded       
N#define PPI_CHG1_CH6_Included   PPI_CHG_CH6_Included       
N#define PPI_CHG1_CH5_Pos        PPI_CHG_CH5_Pos             
N#define PPI_CHG1_CH5_Msk        PPI_CHG_CH5_Msk             
N#define PPI_CHG1_CH5_Excluded   PPI_CHG_CH5_Excluded       
N#define PPI_CHG1_CH5_Included   PPI_CHG_CH5_Included        
N#define PPI_CHG1_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG1_CH4_Msk        PPI_CHG_CH4_Msk             
N#define PPI_CHG1_CH4_Excluded   PPI_CHG_CH4_Excluded        
N#define PPI_CHG1_CH4_Included   PPI_CHG_CH4_Included        
N#define PPI_CHG1_CH3_Pos        PPI_CHG_CH3_Pos            
N#define PPI_CHG1_CH3_Msk        PPI_CHG_CH3_Msk             
N#define PPI_CHG1_CH3_Excluded   PPI_CHG_CH3_Excluded        
N#define PPI_CHG1_CH3_Included   PPI_CHG_CH3_Included       
N#define PPI_CHG1_CH2_Pos        PPI_CHG_CH2_Pos            
N#define PPI_CHG1_CH2_Msk        PPI_CHG_CH2_Msk             
N#define PPI_CHG1_CH2_Excluded   PPI_CHG_CH2_Excluded        
N#define PPI_CHG1_CH2_Included   PPI_CHG_CH2_Included        
N#define PPI_CHG1_CH1_Pos        PPI_CHG_CH1_Pos             
N#define PPI_CHG1_CH1_Msk        PPI_CHG_CH1_Msk            
N#define PPI_CHG1_CH1_Excluded   PPI_CHG_CH1_Excluded        
N#define PPI_CHG1_CH1_Included   PPI_CHG_CH1_Included       
N#define PPI_CHG1_CH0_Pos        PPI_CHG_CH0_Pos             
N#define PPI_CHG1_CH0_Msk        PPI_CHG_CH0_Msk            
N#define PPI_CHG1_CH0_Excluded   PPI_CHG_CH0_Excluded       
N#define PPI_CHG1_CH0_Included   PPI_CHG_CH0_Included       
N#define PPI_CHG2_CH15_Pos       PPI_CHG_CH15_Pos           
N#define PPI_CHG2_CH15_Msk       PPI_CHG_CH15_Msk            
N#define PPI_CHG2_CH15_Excluded  PPI_CHG_CH15_Excluded      
N#define PPI_CHG2_CH15_Included  PPI_CHG_CH15_Included      
N#define PPI_CHG2_CH14_Pos       PPI_CHG_CH14_Pos           
N#define PPI_CHG2_CH14_Msk       PPI_CHG_CH14_Msk           
N#define PPI_CHG2_CH14_Excluded  PPI_CHG_CH14_Excluded       
N#define PPI_CHG2_CH14_Included  PPI_CHG_CH14_Included      
N#define PPI_CHG2_CH13_Pos       PPI_CHG_CH13_Pos           
N#define PPI_CHG2_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG2_CH13_Excluded  PPI_CHG_CH13_Excluded       
N#define PPI_CHG2_CH13_Included  PPI_CHG_CH13_Included      
N#define PPI_CHG2_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG2_CH12_Msk       PPI_CHG_CH12_Msk            
N#define PPI_CHG2_CH12_Excluded  PPI_CHG_CH12_Excluded      
N#define PPI_CHG2_CH12_Included  PPI_CHG_CH12_Included       
N#define PPI_CHG2_CH11_Pos       PPI_CHG_CH11_Pos           
N#define PPI_CHG2_CH11_Msk       PPI_CHG_CH11_Msk           
N#define PPI_CHG2_CH11_Excluded  PPI_CHG_CH11_Excluded       
N#define PPI_CHG2_CH11_Included  PPI_CHG_CH11_Included       
N#define PPI_CHG2_CH10_Pos       PPI_CHG_CH10_Pos            
N#define PPI_CHG2_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG2_CH10_Excluded  PPI_CHG_CH10_Excluded      
N#define PPI_CHG2_CH10_Included  PPI_CHG_CH10_Included      
N#define PPI_CHG2_CH9_Pos        PPI_CHG_CH9_Pos            
N#define PPI_CHG2_CH9_Msk        PPI_CHG_CH9_Msk            
N#define PPI_CHG2_CH9_Excluded   PPI_CHG_CH9_Excluded        
N#define PPI_CHG2_CH9_Included   PPI_CHG_CH9_Included       
N#define PPI_CHG2_CH8_Pos        PPI_CHG_CH8_Pos            
N#define PPI_CHG2_CH8_Msk        PPI_CHG_CH8_Msk            
N#define PPI_CHG2_CH8_Excluded   PPI_CHG_CH8_Excluded       
N#define PPI_CHG2_CH8_Included   PPI_CHG_CH8_Included        
N#define PPI_CHG2_CH7_Pos        PPI_CHG_CH7_Pos            
N#define PPI_CHG2_CH7_Msk        PPI_CHG_CH7_Msk            
N#define PPI_CHG2_CH7_Excluded   PPI_CHG_CH7_Excluded       
N#define PPI_CHG2_CH7_Included   PPI_CHG_CH7_Included       
N#define PPI_CHG2_CH6_Pos        PPI_CHG_CH6_Pos            
N#define PPI_CHG2_CH6_Msk        PPI_CHG_CH6_Msk            
N#define PPI_CHG2_CH6_Excluded   PPI_CHG_CH6_Excluded       
N#define PPI_CHG2_CH6_Included   PPI_CHG_CH6_Included       
N#define PPI_CHG2_CH5_Pos        PPI_CHG_CH5_Pos            
N#define PPI_CHG2_CH5_Msk        PPI_CHG_CH5_Msk            
N#define PPI_CHG2_CH5_Excluded   PPI_CHG_CH5_Excluded       
N#define PPI_CHG2_CH5_Included   PPI_CHG_CH5_Included        
N#define PPI_CHG2_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG2_CH4_Msk        PPI_CHG_CH4_Msk             
N#define PPI_CHG2_CH4_Excluded   PPI_CHG_CH4_Excluded        
N#define PPI_CHG2_CH4_Included   PPI_CHG_CH4_Included       
N#define PPI_CHG2_CH3_Pos        PPI_CHG_CH3_Pos            
N#define PPI_CHG2_CH3_Msk        PPI_CHG_CH3_Msk            
N#define PPI_CHG2_CH3_Excluded   PPI_CHG_CH3_Excluded       
N#define PPI_CHG2_CH3_Included   PPI_CHG_CH3_Included       
N#define PPI_CHG2_CH2_Pos        PPI_CHG_CH2_Pos            
N#define PPI_CHG2_CH2_Msk        PPI_CHG_CH2_Msk           
N#define PPI_CHG2_CH2_Excluded   PPI_CHG_CH2_Excluded       
N#define PPI_CHG2_CH2_Included   PPI_CHG_CH2_Included       
N#define PPI_CHG2_CH1_Pos        PPI_CHG_CH1_Pos             
N#define PPI_CHG2_CH1_Msk        PPI_CHG_CH1_Msk             
N#define PPI_CHG2_CH1_Excluded   PPI_CHG_CH1_Excluded       
N#define PPI_CHG2_CH1_Included   PPI_CHG_CH1_Included       
N#define PPI_CHG2_CH0_Pos        PPI_CHG_CH0_Pos            
N#define PPI_CHG2_CH0_Msk        PPI_CHG_CH0_Msk            
N#define PPI_CHG2_CH0_Excluded   PPI_CHG_CH0_Excluded       
N#define PPI_CHG2_CH0_Included   PPI_CHG_CH0_Included        
N#define PPI_CHG3_CH15_Pos       PPI_CHG_CH15_Pos           
N#define PPI_CHG3_CH15_Msk       PPI_CHG_CH15_Msk           
N#define PPI_CHG3_CH15_Excluded  PPI_CHG_CH15_Excluded     
N#define PPI_CHG3_CH15_Included  PPI_CHG_CH15_Included      
N#define PPI_CHG3_CH14_Pos       PPI_CHG_CH14_Pos          
N#define PPI_CHG3_CH14_Msk       PPI_CHG_CH14_Msk           
N#define PPI_CHG3_CH14_Excluded  PPI_CHG_CH14_Excluded      
N#define PPI_CHG3_CH14_Included  PPI_CHG_CH14_Included       
N#define PPI_CHG3_CH13_Pos       PPI_CHG_CH13_Pos           
N#define PPI_CHG3_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG3_CH13_Excluded  PPI_CHG_CH13_Excluded      
N#define PPI_CHG3_CH13_Included  PPI_CHG_CH13_Included      
N#define PPI_CHG3_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG3_CH12_Msk       PPI_CHG_CH12_Msk            
N#define PPI_CHG3_CH12_Excluded  PPI_CHG_CH12_Excluded       
N#define PPI_CHG3_CH12_Included  PPI_CHG_CH12_Included       
N#define PPI_CHG3_CH11_Pos       PPI_CHG_CH11_Pos            
N#define PPI_CHG3_CH11_Msk       PPI_CHG_CH11_Msk            
N#define PPI_CHG3_CH11_Excluded  PPI_CHG_CH11_Excluded      
N#define PPI_CHG3_CH11_Included  PPI_CHG_CH11_Included       
N#define PPI_CHG3_CH10_Pos       PPI_CHG_CH10_Pos            
N#define PPI_CHG3_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG3_CH10_Excluded  PPI_CHG_CH10_Excluded      
N#define PPI_CHG3_CH10_Included  PPI_CHG_CH10_Included      
N#define PPI_CHG3_CH9_Pos        PPI_CHG_CH9_Pos            
N#define PPI_CHG3_CH9_Msk        PPI_CHG_CH9_Msk            
N#define PPI_CHG3_CH9_Excluded   PPI_CHG_CH9_Excluded       
N#define PPI_CHG3_CH9_Included   PPI_CHG_CH9_Included       
N#define PPI_CHG3_CH8_Pos        PPI_CHG_CH8_Pos            
N#define PPI_CHG3_CH8_Msk        PPI_CHG_CH8_Msk             
N#define PPI_CHG3_CH8_Excluded   PPI_CHG_CH8_Excluded       
N#define PPI_CHG3_CH8_Included   PPI_CHG_CH8_Included       
N#define PPI_CHG3_CH7_Pos        PPI_CHG_CH7_Pos             
N#define PPI_CHG3_CH7_Msk        PPI_CHG_CH7_Msk            
N#define PPI_CHG3_CH7_Excluded   PPI_CHG_CH7_Excluded        
N#define PPI_CHG3_CH7_Included   PPI_CHG_CH7_Included       
N#define PPI_CHG3_CH6_Pos        PPI_CHG_CH6_Pos             
N#define PPI_CHG3_CH6_Msk        PPI_CHG_CH6_Msk             
N#define PPI_CHG3_CH6_Excluded   PPI_CHG_CH6_Excluded       
N#define PPI_CHG3_CH6_Included   PPI_CHG_CH6_Included        
N#define PPI_CHG3_CH5_Pos        PPI_CHG_CH5_Pos             
N#define PPI_CHG3_CH5_Msk        PPI_CHG_CH5_Msk             
N#define PPI_CHG3_CH5_Excluded   PPI_CHG_CH5_Excluded        
N#define PPI_CHG3_CH5_Included   PPI_CHG_CH5_Included       
N#define PPI_CHG3_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG3_CH4_Msk        PPI_CHG_CH4_Msk            
N#define PPI_CHG3_CH4_Excluded   PPI_CHG_CH4_Excluded        
N#define PPI_CHG3_CH4_Included   PPI_CHG_CH4_Included        
N#define PPI_CHG3_CH3_Pos        PPI_CHG_CH3_Pos             
N#define PPI_CHG3_CH3_Msk        PPI_CHG_CH3_Msk            
N#define PPI_CHG3_CH3_Excluded   PPI_CHG_CH3_Excluded        
N#define PPI_CHG3_CH3_Included   PPI_CHG_CH3_Included        
N#define PPI_CHG3_CH2_Pos        PPI_CHG_CH2_Pos             
N#define PPI_CHG3_CH2_Msk        PPI_CHG_CH2_Msk             
N#define PPI_CHG3_CH2_Excluded   PPI_CHG_CH2_Excluded        
N#define PPI_CHG3_CH2_Included   PPI_CHG_CH2_Included       
N#define PPI_CHG3_CH1_Pos        PPI_CHG_CH1_Pos             
N#define PPI_CHG3_CH1_Msk        PPI_CHG_CH1_Msk             
N#define PPI_CHG3_CH1_Excluded   PPI_CHG_CH1_Excluded        
N#define PPI_CHG3_CH1_Included   PPI_CHG_CH1_Included        
N#define PPI_CHG3_CH0_Pos        PPI_CHG_CH0_Pos             
N#define PPI_CHG3_CH0_Msk        PPI_CHG_CH0_Msk             
N#define PPI_CHG3_CH0_Excluded   PPI_CHG_CH0_Excluded        
N#define PPI_CHG3_CH0_Included   PPI_CHG_CH0_Included        
N
N
N
N/*lint --flb "Leave library region" */
N
N#endif /* NRF51_DEPRECATED_H */
N
L 65 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 2
N    #elif defined (NRF52840_XXAA)
S        #include "nrf52840.h"
S        #include "nrf52840_bitfields.h"
S        #include "nrf51_to_nrf52840.h"
S        #include "nrf52_to_nrf52840.h"
S    #elif defined (NRF52832_XXAA)
S        #include "nrf52.h"
S        #include "nrf52_bitfields.h"
S        #include "nrf51_to_nrf52.h"
S        #include "nrf52_name_change.h"
S    #else
S        #error "Device must be defined. See nrf.h."
N    #endif /* NRF51, NRF52832_XXAA, NRF52840_XXAA */
N
N    #include "compiler_abstraction.h"
N
N#endif /* _WIN32 || __unix || __APPLE__ */
N
N#endif /* NRF_H */
N
L 57 "..\..\..\..\..\..\components\libraries\util\app_util.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N//lint -save -e27 -e10 -e19
N#if defined ( __CC_ARM )
X#if 1L
Nextern char STACK$$Base;
Nextern char STACK$$Length;
N#define STACK_BASE    &STACK$$Base
N#define STACK_TOP    ((void*)((uint32_t)STACK_BASE + (uint32_t)&STACK$$Length))
N#elif defined ( __ICCARM__ )
Sextern char CSTACK$$Base;
Sextern char CSTACK$$Length;
S#define STACK_BASE    &CSTACK$$Base
S#define STACK_TOP    ((void*)((uint32_t)STACK_BASE + (uint32_t)&CSTACK$$Length))
S#elif defined   ( __GNUC__ )
Sextern uint32_t __StackTop;
Sextern uint32_t __StackLimit;
S#define STACK_BASE    &__StackLimit
S#define STACK_TOP     &__StackTop
N#endif
N//lint -restore
N
Nenum
N{
N    UNIT_0_625_MS = 625,                                /**< Number of microseconds in 0.625 milliseconds. */
N    UNIT_1_25_MS  = 1250,                               /**< Number of microseconds in 1.25 milliseconds. */
N    UNIT_10_MS    = 10000                               /**< Number of microseconds in 10 milliseconds. */
N};
N
N
N/**@brief Implementation specific macro for delayed macro expansion used in string concatenation
N*
N* @param[in]   lhs   Left hand side in concatenation
N* @param[in]   rhs   Right hand side in concatenation
N*/
N#define STRING_CONCATENATE_IMPL(lhs, rhs) lhs ## rhs
N
N
N/**@brief Macro used to concatenate string using delayed macro expansion
N*
N* @note This macro will delay concatenation until the expressions have been resolved
N*
N* @param[in]   lhs   Left hand side in concatenation
N* @param[in]   rhs   Right hand side in concatenation
N*/
N#define STRING_CONCATENATE(lhs, rhs) STRING_CONCATENATE_IMPL(lhs, rhs)
N
N
N// Disable lint-warnings/errors for STATIC_ASSERT_MSG
N//lint --emacro(10, STATIC_ASSERT_MSG)
N//lint --emacro(18, STATIC_ASSERT_MSG)
N//lint --emacro(19, STATIC_ASSERT_MSG)
N//lint --emacro(30, STATIC_ASSERT_MSG)
N//lint --emacro(37, STATIC_ASSERT_MSG)
N//lint --emacro(42, STATIC_ASSERT_MSG)
N//lint --emacro(26, STATIC_ASSERT_MSG)
N//lint --emacro(102,STATIC_ASSERT_MSG)
N//lint --emacro(533,STATIC_ASSERT_MSG)
N//lint --emacro(534,STATIC_ASSERT_MSG)
N//lint --emacro(132,STATIC_ASSERT_MSG)
N//lint --emacro(414,STATIC_ASSERT_MSG)
N//lint --emacro(578,STATIC_ASSERT_MSG)
N//lint --emacro(628,STATIC_ASSERT_MSG)
N//lint --emacro(648,STATIC_ASSERT_MSG)
N//lint --emacro(830,STATIC_ASSERT_MSG)
N
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N*
N* @note If the EXPR isn't resolvable, then the error message won't be shown.
N*
N* @note The output of STATIC_ASSERT_MSG will be different across different compilers.
N*
N* @param[in] EXPR Constant expression to be verified.
N* @param[in] MSG  Name of the static assert.
N*/
N#if defined(__COUNTER__)
X#if 0L
S
S    #define STATIC_ASSERT_MSG(EXPR, MSG) \
S        ;enum { STRING_CONCATENATE(MSG, __COUNTER__) = 1 / (!!(EXPR)) }
X    #define STATIC_ASSERT_MSG(EXPR, MSG)         ;enum { STRING_CONCATENATE(MSG, __COUNTER__) = 1 / (!!(EXPR)) }
S
N#else
N
N    #define STATIC_ASSERT_MSG(EXPR, MSG) \
N        ;enum { STRING_CONCATENATE(MSG, __LINE__) = 1 / (!!(EXPR)) }
X    #define STATIC_ASSERT_MSG(EXPR, MSG)         ;enum { STRING_CONCATENATE(MSG, __LINE__) = 1 / (!!(EXPR)) }
N
N#endif
N
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N*
N* @note If the EXPR isn't resolvable, then the error message won't be shown.
N*
N* @note The output of STATIC_ASSERT will be different across different compilers.
N*
N* @param[in] EXPR Constant expression to be verified.
N*/
N#define STATIC_ASSERT(EXPR) STATIC_ASSERT_MSG((EXPR), static_assert_)
N
N
N/**@brief Implementation details for NUM_VAR_ARGS */
N#define NUM_VA_ARGS_IMPL(                              \
N    _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,       \
N    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,  \
N    _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,  \
N    _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,  \
N    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,  \
N    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,  \
N    _61, _62, N, ...) N
X#define NUM_VA_ARGS_IMPL(                                  _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,           _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,      _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,      _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,      _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,      _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,      _61, _62, N, ...) N
N
N
N/**@brief Macro to get the number of arguments in a call variadic macro call
N *
N * param[in]    ...     List of arguments
N *
N * @retval  Number of variadic arguments in the argument list
N */
N#define NUM_VA_ARGS(...) NUM_VA_ARGS_IMPL(__VA_ARGS__, 63, 62, 61,  \
N    60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                         \
N    50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                         \
N    40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                         \
N    30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                         \
N    20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                         \
N    10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
X#define NUM_VA_ARGS(...) NUM_VA_ARGS_IMPL(__VA_ARGS__, 63, 62, 61,      60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                             50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                             40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                             30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                             20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                             10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
N
N/**@brief Implementation details for NUM_VAR_ARGS */
N#define NUM_VA_ARGS_LESS_1_IMPL(                       \
N    _ignored,                                          \
N    _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,       \
N    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,  \
N    _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,  \
N    _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,  \
N    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,  \
N    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,  \
N    _61, _62, N, ...) N
X#define NUM_VA_ARGS_LESS_1_IMPL(                           _ignored,                                              _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,           _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,      _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,      _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,      _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,      _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,      _61, _62, N, ...) N
N
N/**@brief Macro to get the number of arguments in a call variadic macro call.
N * First argument is not counted.
N *
N * param[in]    ...     List of arguments
N *
N * @retval  Number of variadic arguments in the argument list
N */
N#define NUM_VA_ARGS_LESS_1(...) NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__, 63, 62, 61,  \
N    60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                         \
N    50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                         \
N    40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                         \
N    30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                         \
N    20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                         \
N    10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ~)
X#define NUM_VA_ARGS_LESS_1(...) NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__, 63, 62, 61,      60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                             50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                             40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                             30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                             20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                             10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ~)
N
N
N/**@brief type for holding an encoded (i.e. little endian) 16 bit unsigned integer. */
Ntypedef uint8_t uint16_le_t[2];
N
N/**@brief Type for holding an encoded (i.e. little endian) 32 bit unsigned integer. */
Ntypedef uint8_t uint32_le_t[4];
N
N/**@brief Byte array type. */
Ntypedef struct
N{
N    uint16_t  size;                 /**< Number of array entries. */
N    uint8_t * p_data;               /**< Pointer to array entries. */
N} uint8_array_t;
N
N
N/**@brief Macro for performing rounded integer division (as opposed to truncating the result).
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Rounded (integer) result of dividing A by B.
N */
N#define ROUNDED_DIV(A, B) (((A) + ((B) / 2)) / (B))
N
N
N/**@brief Macro for checking if an integer is a power of two.
N *
N * @param[in]   A   Number to be tested.
N *
N * @return      true if value is power of two.
N * @return      false if value not power of two.
N */
N#define IS_POWER_OF_TWO(A) ( ((A) != 0) && ((((A) - 1) & (A)) == 0) )
N
N
N/**@brief Macro for converting milliseconds to ticks.
N *
N * @param[in] TIME          Number of milliseconds to convert.
N * @param[in] RESOLUTION    Unit to be converted to in [us/ticks].
N */
N#define MSEC_TO_UNITS(TIME, RESOLUTION) (((TIME) * 1000) / (RESOLUTION))
N
N
N/**@brief Macro for performing integer division, making sure the result is rounded up.
N *
N * @details One typical use for this is to compute the number of objects with size B is needed to
N *          hold A number of bytes.
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Integer result of dividing A by B, rounded up.
N */
N#define CEIL_DIV(A, B)      \
N    (((A) + (B) - 1) / (B))
X#define CEIL_DIV(A, B)          (((A) + (B) - 1) / (B))
N
N
N/**@brief Macro for creating a buffer aligned to 4 bytes.
N *
N * @param[in]   NAME        Name of the buffor.
N * @param[in]   MIN_SIZE    Size of this buffor (it will be rounded up to multiples of 4 bytes).
N */
N#define WORD_ALIGNED_MEM_BUFF(NAME, MIN_SIZE) static uint32_t NAME[CEIL_DIV(MIN_SIZE, sizeof(uint32_t))]
N
N
N/**@brief Macro for calculating the number of words that are needed to hold a number of bytes.
N *
N * @details Adds 3 and divides by 4.
N *
N * @param[in]  n_bytes  The number of bytes.
N *
N * @return The number of words that @p n_bytes take up (rounded up).
N */
N#define BYTES_TO_WORDS(n_bytes) (((n_bytes) + 3) >> 2)
N
N
N/**@brief The number of bytes in a word.
N */
N#define BYTES_PER_WORD (4)
N
N
N/**@brief Macro for increasing a number to the nearest (larger) multiple of another number.
N *
N * @param[in]  alignment  The number to align to.
N * @param[in]  number     The number to align (increase).
N *
N * @return The aligned (increased) @p number.
N */
N#define ALIGN_NUM(alignment, number) ((number - 1) + alignment - ((number - 1) % alignment))
N
N/**@brief Macro for getting first of 2 parameters.
N *
N * @param[in] a1    First parameter.
N * @param[in] a2    Second parameter.
N */
N#define GET_ARG_1(a1, a2) a1
N
N/**@brief Macro for getting second of 2 parameters.
N *
N * @param[in] a1    First parameter.
N * @param[in] a2    Second parameter.
N */
N#define GET_ARG_2(a1, a2) a2
N
N
N/**@brief Container of macro (borrowed from Linux kernel).
N *
N * This macro returns parent structure address basing on child member address.
N *
N * @param ptr       Address of child type.
N * @param type      Type of parent structure.
N * @param member    Name of child field in parent structure.
N *
N * @return Parent structure address.
N * */
N#define CONTAINER_OF(ptr, type, member)                 \
N        (type *)((char *)ptr - offsetof(type, member))
X#define CONTAINER_OF(ptr, type, member)                         (type *)((char *)ptr - offsetof(type, member))
N
N
N/**
N * @brief Define Bit-field mask
N *
N * Macro that defined the mask with selected number of bits set, starting from
N * provided bit number.
N *
N * @param[in] bcnt Number of bits in the bit-field
N * @param[in] boff Lowest bit number
N */
N#define BF_MASK(bcnt, boff) ( ((1U << (bcnt)) - 1U) << (boff) )
N
N/**
N * @brief Get bit-field
N *
N * Macro that extracts selected bit-field from provided value
N *
N * @param[in] val  Value from witch selected bit-field would be extracted
N * @param[in] bcnt Number of bits in the bit-field
N * @param[in] boff Lowest bit number
N *
N * @return Value of the selected bits
N */
N#define BF_GET(val, bcnt, boff) ( ( (val) & BF_MASK((bcnt), (boff)) ) >> (boff) )
N
N/**
N * @brief Create bit-field value
N *
N * Value is masked and shifted to match given bit-field
N *
N * @param[in] val  Value to set on bit-field
N * @param[in] bcnt Number of bits for bit-field
N * @param[in] boff Offset of bit-field
N *
N * @return Value positioned of given bit-field.
N */
N#define BF_VAL(val, bcnt, boff) ( (((uint32_t)(val)) << (boff)) & BF_MASK(bcnt, boff) )
N
N/**
N * @name Configuration of complex bit-field
N *
N * @sa BF_CX
N * @{
N */
N/** @brief Position of bit count in complex bit-field value */
N#define BF_CX_BCNT_POS  0U
N/** @brief Mask of bit count in complex bit-field value */
N#define BF_CX_BCNT_MASK (0xffU << BF_CX_BCNT_POS)
N/** @brief Position of bit position in complex bit-field value */
N#define BF_CX_BOFF_POS  8U
N/** @brief Mask of bit position in complex bit-field value */
N#define BF_CX_BOFF_MASK (0xffU << BF_CX_BOFF_POS)
N/** @} */
N
N/**
N * @brief Define complex bit-field
N *
N * Complex bit-field would contain its position and size in one number.
N * @sa BF_CX_MASK
N * @sa BF_CX_POS
N * @sa BF_CX_GET
N *
N * @param[in] bcnt Number of bits in the bit-field
N * @param[in] boff Lowest bit number
N *
N * @return The single number that describes the bit-field completely.
N */
N#define BF_CX(bcnt, boff) ( ((((uint32_t)(bcnt)) << BF_CX_BCNT_POS) & BF_CX_BCNT_MASK) | ((((uint32_t)(boff)) << BF_CX_BOFF_POS) & BF_CX_BOFF_MASK) )
N
N/**
N * @brief Get number of bits in bit-field
N *
N * @sa BF_CX
N *
N * @param bf_cx Complex bit-field
N *
N * @return Number of bits in given bit-field
N */
N#define BF_CX_BCNT(bf_cx) ( ((bf_cx) & BF_CX_BCNT_MASK) >> BF_CX_BCNT_POS )
N
N/**
N * @brief Get lowest bit number in the field
N *
N * @sa BF_CX
N *
N * @param[in] bf_cx Complex bit-field
N *
N * @return Lowest bit number in given bit-field
N */
N#define BF_CX_BOFF(bf_cx) ( ((bf_cx) & BF_CX_BOFF_MASK) >> BF_CX_BOFF_POS )
N
N/**
N * @brief Get bit mask of the selected field
N *
N * @sa BF_CX
N *
N * @param[in] bf_cx Complex bit-field
N *
N * @return Mask of given bit-field
N */
N#define BF_CX_MASK(bf_cx) BF_MASK(BF_CX_BCNT(bf_cx), BF_CX_BOFF(bf_cx))
N
N/**
N * @brief Get bit-field
N *
N * Macro that extracts selected bit-field from provided value.
N * Bit-field is given as a complex value.
N *
N * @sa BF_CX
N * @sa BF_GET
N *
N * @param[in] val   Value from witch selected bit-field would be extracted
N * @param[in] bf_cx Complex bit-field
N *
N * @return Value of the selected bits.
N */
N#define BF_CX_GET(val, bf_cx) BF_GET(val, BF_CX_BCNT(bf_cx), BF_CX_BOFF(bf_cx))
N
N/**
N * @brief Create bit-field value
N *
N * Value is masked and shifted to match given bit-field.
N *
N * @param[in] val  Value to set on bit-field
N * @param[in] bf_cx Complex bit-field
N *
N * @return Value positioned of given bit-field.
N */
N#define BF_CX_VAL(val, bf_cx) BF_VAL(val, BF_CX_BCNT(bf_cx), BF_CX_BOFF(bf_cx))
N
N/**
N * @brief Extracting data from the brackets
N *
N * This macro get rid of brackets around the argument.
N * It can be used to pass multiple arguments in logical one argument to a macro.
N * Call it with arguments inside brackets:
N * @code
N * #define ARGUMENTS (a, b, c)
N * BRACKET_EXTRACT(ARGUMENTS)
N * @endcode
N * It would produce:
N * @code
N * a, b, c
N * @endcode
N *
N * @param a Argument with anything inside brackets
N * @return Anything that appears inside the brackets of the argument
N *
N * @note
N * The argument of the macro have to be inside brackets.
N * In other case the compilation would fail.
N */
N#define BRACKET_EXTRACT(a)  BRACKET_EXTRACT_(a)
N#define BRACKET_EXTRACT_(a) BRACKET_EXTRACT__ a
N#define BRACKET_EXTRACT__(...) __VA_ARGS__
N
N
N/**
N * @brief Check if number of parameters is more than 1
N *
N * @param ... Arguments to count
N *
N * @return 0 If argument count is <= 1
N * @return 1 If argument count is > 1
N *
N * @sa NUM_VA_ARGS
N * @sa NUM_IS_MORE_THAN_1
N */
N#define NUM_VA_ARGS_IS_MORE_THAN_1(...) NUM_IS_MORE_THAN_1(NUM_VA_ARGS(__VA_ARGS__))
N
N/**
N * @brief Check if given numeric value is bigger than 1
N *
N * This macro accepts numeric value, that may be the result of argument expansion.
N * This numeric value is then converted to 0 if it is lover than 1 or to 1 if
N * its value is higher than 1.
N * The generated result can be used to glue it into other macro mnemonic name.
N *
N * @param N Numeric value to check
N *
N * @return 0 If argument is <= 1
N * @return 1 If argument is > 1
N *
N * @note Any existing definition of a form NUM_IS_MORE_THAN_1_PROBE_[N] can
N *       broke the result of this macro
N */
N#define NUM_IS_MORE_THAN_1(N) NUM_IS_MORE_THAN_1_(N)
N#define NUM_IS_MORE_THAN_1_(N)  NUM_IS_MORE_THAN_1_PROBE_(NUM_IS_MORE_THAN_1_PROBE_ ## N, 1)
N#define NUM_IS_MORE_THAN_1_PROBE_(...) GET_VA_ARG_1(GET_ARGS_AFTER_1(__VA_ARGS__))
N#define NUM_IS_MORE_THAN_1_PROBE_0 ~, 0
N#define NUM_IS_MORE_THAN_1_PROBE_1 ~, 0
N
N/**
N * @brief Get the first argument
N *
N * @param ... Arguments to select
N *
N * @return First argument or empty if no arguments are provided
N */
N#define GET_VA_ARG_1(...) GET_VA_ARG_1_(__VA_ARGS__, ) // Make sure that also for 1 argument it works
N#define GET_VA_ARG_1_(a1, ...) a1
N
N/**
N * @brief Get all the arguments but the first one
N *
N * @param ... Arguments to select
N *
N * @return All arguments after the first one or empty if less than 2 arguments are provided
N */
N#define GET_ARGS_AFTER_1(...) GET_ARGS_AFTER_1_(__VA_ARGS__, ) // Make sure that also for 1 argument it works
N#define GET_ARGS_AFTER_1_(a1, ...) __VA_ARGS__
N
N/**
N * @brief Size of a field in declared structure
N *
N * Macro that returns the size of the structure field.
N * @param struct_type Variable type to get the field size from
N * @param field Field name to analyze. It can be even field inside field (field.somethingelse.and_another).
N *
N * @return Size of the field
N */
N#define FIELD_SIZE(struct_type, field) sizeof(((struct struct_type*)NULL)->field)
N
N/**
N * @brief Number of elements in field array in declared structure
N *
N * Macro that returns number of elementy in structure field.
N * @param struct_type Variable type to get the field size from
N * @param field Field name to analyze.
N *
N * @return Number of elements in field array
N *
N * @sa FIELD_SIZE
N */
N#define FIELD_ARRAY_SIZE(struct_type, field) (FIELD_SIZE(struct_type, field) / FIELD_SIZE(struct_type, field[0]))
N
N/**
N * @brief Mapping macro
N *
N * Macro that process all arguments using given macro
N *
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument)
N *
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP(...) MACRO_MAP_(__VA_ARGS__)
N#define MACRO_MAP_(...) MACRO_MAP_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), __VA_ARGS__) // To make sure it works also for 2 arguments in total
N
N/**
N * @brief Mapping macro, recursive version
N *
N *  Can be used in @ref MACRO_MAP macro
N */
N#define MACRO_MAP_REC(...) MACRO_MAP_REC_(__VA_ARGS__)
N#define MACRO_MAP_REC_(...) MACRO_MAP_REC_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), __VA_ARGS__) // To make sure it works also for 2 arguments in total
N/**
N * @brief Mapping N arguments macro
N *
N * Macro similar to @ref MACRO_MAP but maps exact number of arguments.
N * If there is more arguments given, the rest would be ignored.
N *
N * @param N   Number of arguments to map
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument)
N *
N * @return Selected number of arguments processed by given macro
N */
N#define MACRO_MAP_N(N, ...) MACRO_MAP_N_(N, __VA_ARGS__)
N#define MACRO_MAP_N_(N, ...) CONCAT_2(MACRO_MAP_, N)(__VA_ARGS__, )
N
N/**
N * @brief Mapping N arguments macro, recursive version
N *
N *  Can be used in @ref MACRO_MAP_N macro
N */
N#define MACRO_MAP_REC_N(N, ...) MACRO_MAP_REC_N_(N, __VA_ARGS__)
N#define MACRO_MAP_REC_N_(N, ...) CONCAT_2(MACRO_MAP_REC_, N)(__VA_ARGS__, )
N
N#define MACRO_MAP_0(           ...)
N#define MACRO_MAP_1( macro, a, ...) macro(a)
N#define MACRO_MAP_2( macro, a, ...) macro(a) MACRO_MAP_1 (macro, __VA_ARGS__, )
N#define MACRO_MAP_3( macro, a, ...) macro(a) MACRO_MAP_2 (macro, __VA_ARGS__, )
N#define MACRO_MAP_4( macro, a, ...) macro(a) MACRO_MAP_3 (macro, __VA_ARGS__, )
N#define MACRO_MAP_5( macro, a, ...) macro(a) MACRO_MAP_4 (macro, __VA_ARGS__, )
N#define MACRO_MAP_6( macro, a, ...) macro(a) MACRO_MAP_5 (macro, __VA_ARGS__, )
N#define MACRO_MAP_7( macro, a, ...) macro(a) MACRO_MAP_6 (macro, __VA_ARGS__, )
N#define MACRO_MAP_8( macro, a, ...) macro(a) MACRO_MAP_7 (macro, __VA_ARGS__, )
N#define MACRO_MAP_9( macro, a, ...) macro(a) MACRO_MAP_8 (macro, __VA_ARGS__, )
N#define MACRO_MAP_10(macro, a, ...) macro(a) MACRO_MAP_9 (macro, __VA_ARGS__, )
N#define MACRO_MAP_11(macro, a, ...) macro(a) MACRO_MAP_10(macro, __VA_ARGS__, )
N#define MACRO_MAP_12(macro, a, ...) macro(a) MACRO_MAP_11(macro, __VA_ARGS__, )
N#define MACRO_MAP_13(macro, a, ...) macro(a) MACRO_MAP_12(macro, __VA_ARGS__, )
N#define MACRO_MAP_14(macro, a, ...) macro(a) MACRO_MAP_13(macro, __VA_ARGS__, )
N#define MACRO_MAP_15(macro, a, ...) macro(a) MACRO_MAP_14(macro, __VA_ARGS__, )
N
N#define MACRO_MAP_REC_0(           ...)
N#define MACRO_MAP_REC_1( macro, a, ...) macro(a)
N#define MACRO_MAP_REC_2( macro, a, ...) macro(a) MACRO_MAP_REC_1 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_3( macro, a, ...) macro(a) MACRO_MAP_REC_2 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_4( macro, a, ...) macro(a) MACRO_MAP_REC_3 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_5( macro, a, ...) macro(a) MACRO_MAP_REC_4 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_6( macro, a, ...) macro(a) MACRO_MAP_REC_5 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_7( macro, a, ...) macro(a) MACRO_MAP_REC_6 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_8( macro, a, ...) macro(a) MACRO_MAP_REC_7 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_9( macro, a, ...) macro(a) MACRO_MAP_REC_8 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_10(macro, a, ...) macro(a) MACRO_MAP_REC_9 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_11(macro, a, ...) macro(a) MACRO_MAP_REC_10(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_12(macro, a, ...) macro(a) MACRO_MAP_REC_11(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_13(macro, a, ...) macro(a) MACRO_MAP_REC_12(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_14(macro, a, ...) macro(a) MACRO_MAP_REC_13(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_15(macro, a, ...) macro(a) MACRO_MAP_REC_14(macro, __VA_ARGS__, )
N
N/**
N * @brief Mapping macro with current index
N *
N * Basically macro similar to @ref MACRO_MAP, but the processing function would get an argument
N * and current argument index (beginning from 0).
N *
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument, index)
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP_FOR(...) MACRO_MAP_FOR_(__VA_ARGS__)
N#define MACRO_MAP_FOR_N_LIST 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
N#define MACRO_MAP_FOR_(...) MACRO_MAP_FOR_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), __VA_ARGS__)
N
N/**
N * @brief Mapping N arguments macro with current index
N *
N * Macro is similar to @ref MACRO_MAP_FOR but maps exact number of arguments.
N * If there is more arguments given, the rest would be ignored.
N *
N * @param N   Number of arguments to map
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument, index)
N *
N * @return Selected number of arguments processed by given macro
N */
N#define MACRO_MAP_FOR_N(N, ...) MACRO_MAP_FOR_N_(N, __VA_ARGS__)
N#define MACRO_MAP_FOR_N_(N, ...) CONCAT_2(MACRO_MAP_FOR_, N)((MACRO_MAP_FOR_N_LIST), __VA_ARGS__, )
N
N#define MACRO_MAP_FOR_0( n_list,           ...)
N#define MACRO_MAP_FOR_1( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)))
N#define MACRO_MAP_FOR_2( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_1 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_3( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_2 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_4( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_3 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_5( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_4 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_6( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_5 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_7( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_6 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_8( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_7 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_9( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_8 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_10(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_9 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_11(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_10((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_12(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_11((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_13(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_12((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_14(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_13((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_15(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_14((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N
N
N/**
N * @brief Mapping macro with current index and parameter
N *
N * Version of @ref MACRO_MAP_FOR that passes also the same parameter to all macros.
N *
N * @param param Parameter that would be passed to each macro call during mapping.
N * @param ...   Macro name to be used for argument processing followed by arguments to process.
N *              Macro should have following form: MACRO(argument, index, param)
N *
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP_FOR_PARAM(param, ...) MACRO_MAP_FOR_PARAM_(param, __VA_ARGS__)
N#define MACRO_MAP_FOR_PARAM_(param, ...) MACRO_MAP_FOR_PARAM_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), param, __VA_ARGS__)
N
N/**
N * @brief Mapping N arguments macro with with current index and parameter
N *
N * @param N     Number of arguments to map
N * @param param Parameter that would be passed to each macro call during mapping.
N * @param ...   Macro name to be used for argument processing followed by arguments to process.
N *              Macro should have following form: MACRO(argument, index, param)
N *
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP_FOR_PARAM_N(N, param, ...) MACRO_MAP_FOR_PARAM_N_(N, param, __VA_ARGS__)
N#define MACRO_MAP_FOR_PARAM_N_(N, param, ...) CONCAT_2(MACRO_MAP_FOR_PARAM_, N)((MACRO_MAP_FOR_N_LIST), param, __VA_ARGS__, )
N
N
N#define MACRO_MAP_FOR_PARAM_0( n_list, param, ...)
N#define MACRO_MAP_FOR_PARAM_1( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param)
N#define MACRO_MAP_FOR_PARAM_2( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_1 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_3( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_2 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_4( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_3 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_5( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_4 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_6( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_5 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_7( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_6 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_8( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_7 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_9( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_8 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_10(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_9 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_11(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_10((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_12(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_11((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_13(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_12((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_14(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_13((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_15(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_14((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N
N
N/**@brief Adding curly brace to macro parameter
N *
N * Useful in array of structures initialization.
N *
N * @param p parameter to put into the curly brace*/
N#define PARAM_CBRACE(p) { p },
N
N
N/**@brief Function for changing the value unit.
N *
N * @param[in]   value               Value to be rescaled.
N * @param[in]   old_unit_reversal   Reversal of the incoming unit.
N * @param[in]   new_unit_reversal   Reversal of the desired unit.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint64_t value_rescale(uint32_t value, uint32_t old_unit_reversal, uint16_t new_unit_reversal)
Xstatic __inline uint64_t value_rescale(uint32_t value, uint32_t old_unit_reversal, uint16_t new_unit_reversal)
N{
N    return (uint64_t)ROUNDED_DIV((uint64_t)value * new_unit_reversal, old_unit_reversal);
X    return (uint64_t)((((uint64_t)value * new_unit_reversal) + ((old_unit_reversal) / 2)) / (old_unit_reversal));
N}
N
N/**@brief Function for encoding a uint16 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
N    return sizeof(uint16_t);
N}
N
N/**@brief Function for encoding a three-byte value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint24_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint24_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    return 3;
N}
N
N/**@brief Function for encoding a uint32 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0xFF000000) >> 24);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for encoding a uint48 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint48_encode(uint64_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint48_encode(uint64_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x0000000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x00000000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x000000FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0x0000FF000000) >> 24);
N    p_encoded_data[4] = (uint8_t) ((value & 0x00FF00000000) >> 32);
N    p_encoded_data[5] = (uint8_t) ((value & 0xFF0000000000) >> 40);
N    return 6;
N}
N
N/**@brief Function for decoding a uint16 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
N}
N
N/**@brief Function for decoding a uint16 value in big-endian format.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_big_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_big_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0]) << 8 ) |
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1])) );
N}
N
N/**@brief Function for decoding a three-byte value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value (uint32_t).
N */
Nstatic __INLINE uint32_t uint24_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint24_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16));
N}
N
N/**@brief Function for decoding a uint32 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 ));
N}
N
N/**@brief Function for decoding a uint32 value in big-endian format.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_big_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_big_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 24) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 0) );
N}
N
N/**
N * @brief Function for encoding an uint16 value in big-endian format.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data will be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_big_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_big_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) (value >> 8);
N    p_encoded_data[1] = (uint8_t) (value & 0xFF);
N
N    return sizeof(uint16_t);
N}
N
N/**@brief Function for encoding a uint32 value in big-endian format.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data will be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_big_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_big_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    *(uint32_t *)p_encoded_data = __REV(value);
X    *(uint32_t *)p_encoded_data = __rev(value);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for decoding a uint48 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value. (uint64_t)
N */
Nstatic __INLINE uint64_t uint48_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint64_t uint48_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint64_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint64_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint64_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[3]) << 24) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[4]) << 32) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[5]) << 40 ));
N}
N
N/** @brief Function for converting the input voltage (in milli volts) into percentage of 3.0 Volts.
N *
N *  @details The calculation is based on a linearized version of the battery's discharge
N *           curve. 3.0V returns 100% battery level. The limit for power failure is 2.1V and
N *           is considered to be the lower boundary.
N *
N *           The discharge curve for CR2032 is non-linear. In this model it is split into
N *           4 linear sections:
N *           - Section 1: 3.0V - 2.9V = 100% - 42% (58% drop on 100 mV)
N *           - Section 2: 2.9V - 2.74V = 42% - 18% (24% drop on 160 mV)
N *           - Section 3: 2.74V - 2.44V = 18% - 6% (12% drop on 300 mV)
N *           - Section 4: 2.44V - 2.1V = 6% - 0% (6% drop on 340 mV)
N *
N *           These numbers are by no means accurate. Temperature and
N *           load in the actual application is not accounted for!
N *
N *  @param[in] mvolts The voltage in mV
N *
N *  @return    Battery level in percent.
N*/
Nstatic __INLINE uint8_t battery_level_in_percent(const uint16_t mvolts)
Xstatic __inline uint8_t battery_level_in_percent(const uint16_t mvolts)
N{
N    uint8_t battery_level;
N
N    if (mvolts >= 3000)
N    {
N        battery_level = 100;
N    }
N    else if (mvolts > 2900)
N    {
N        battery_level = 100 - ((3000 - mvolts) * 58) / 100;
N    }
N    else if (mvolts > 2740)
N    {
N        battery_level = 42 - ((2900 - mvolts) * 24) / 160;
N    }
N    else if (mvolts > 2440)
N    {
N        battery_level = 18 - ((2740 - mvolts) * 12) / 300;
N    }
N    else if (mvolts > 2100)
N    {
N        battery_level = 6 - ((2440 - mvolts) * 6) / 340;
N    }
N    else
N    {
N        battery_level = 0;
N    }
N
N    return battery_level;
N}
N
N/**@brief Function for checking if a pointer value is aligned to a 4 byte boundary.
N *
N * @param[in]   p   Pointer value to be checked.
N *
N * @return      TRUE if pointer is aligned to a 4 byte boundary, FALSE otherwise.
N */
Nstatic __INLINE bool is_word_aligned(void const* p)
Xstatic __inline _Bool is_word_aligned(void const* p)
N{
N    return (((uintptr_t)p & 0x03) == 0);
N}
N
N/**
N * @brief Function for checking if provided address is located in stack space.
N *
N * @param[in]   ptr Pointer to be checked.
N *
N * @return      true if address is in stack space, false otherwise.
N */
Nstatic __INLINE bool is_address_from_stack(void * ptr)
Xstatic __inline _Bool is_address_from_stack(void * ptr)
N{
N    if (((uint32_t)ptr >= (uint32_t)STACK_BASE) &&
X    if (((uint32_t)ptr >= (uint32_t)&STACK$$Base) &&
N        ((uint32_t)ptr <  (uint32_t)STACK_TOP) )
X        ((uint32_t)ptr <  (uint32_t)((void*)((uint32_t)&STACK$$Base + (uint32_t)&STACK$$Length))) )
N    {
N        return true;
X        return 1;
N    }
N    else
N    {
N        return false;
X        return 0;
N    }
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_UTIL_H__
N
N/** @} */
L 63 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N#include "sdk_macros.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_macros.h" 1
N/**
N * Copyright (c) 2013 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/**@file
N *
N
N * @defgroup sdk_common_macros SDK Common Header
N * @ingroup app_common
N * @brief Macros for parameter checking and similar tasks
N * @{
N */
N
N#ifndef SDK_MACROS_H__
N#define SDK_MACROS_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**@brief Macro for verifying statement to be true. It will cause the exterior function to return
N *        err_code if the statement is not true.
N *
N * @param[in]   statement   Statement to test.
N * @param[in]   err_code    Error value to return if test was invalid.
N *
N * @retval      nothing, but will cause the exterior function to return @p err_code if @p statement
N *              is false.
N */
N#define VERIFY_TRUE(statement, err_code)    \
Ndo                                          \
N{                                           \
N    if (!(statement))                       \
N    {                                       \
N        return err_code;                    \
N    }                                       \
N} while (0)
X#define VERIFY_TRUE(statement, err_code)    do                                          {                                               if (!(statement))                           {                                               return err_code;                        }                                       } while (0)
N
N
N/**@brief Macro for verifying statement to be true. It will cause the exterior function to return
N *        if the statement is not true.
N *
N * @param[in]   statement   Statement to test.
N */
N#define VERIFY_TRUE_VOID(statement) VERIFY_TRUE((statement), )
N
N
N/**@brief Macro for verifying statement to be false. It will cause the exterior function to return
N *        err_code if the statement is not false.
N *
N * @param[in]   statement   Statement to test.
N * @param[in]   err_code    Error value to return if test was invalid.
N *
N * @retval      nothing, but will cause the exterior function to return @p err_code if @p statement
N *              is true.
N */
N#define VERIFY_FALSE(statement, err_code)   \
Ndo                                          \
N{                                           \
N    if ((statement))                        \
N    {                                       \
N        return err_code;                    \
N    }                                       \
N} while (0)
X#define VERIFY_FALSE(statement, err_code)   do                                          {                                               if ((statement))                            {                                               return err_code;                        }                                       } while (0)
N
N
N/**@brief Macro for verifying statement to be false. It will cause the exterior function to return
N *        if the statement is not false.
N *
N * @param[in]   statement    Statement to test.
N */
N#define VERIFY_FALSE_VOID(statement) VERIFY_FALSE((statement), )
N
N
N/**@brief Macro for verifying that a function returned NRF_SUCCESS. It will cause the exterior
N *        function to return err_code if the err_code is not @ref NRF_SUCCESS.
N *
N * @param[in] err_code The error code to check.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_SUCCESS()
N#else
N#define VERIFY_SUCCESS(err_code) VERIFY_TRUE((err_code) == NRF_SUCCESS, (err_code))
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that a function returned NRF_SUCCESS. It will cause the exterior
N *        function to return if the err_code is not @ref NRF_SUCCESS.
N *
N * @param[in] err_code The error code to check.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_SUCCESS_VOID()
N#else
N#define VERIFY_SUCCESS_VOID(err_code) VERIFY_TRUE_VOID((err_code) == NRF_SUCCESS)
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return @ref NRF_ERROR_INVALID_STATE if not.
N *
N * @note MODULE_INITIALIZED must be defined in each module using this macro. MODULE_INITIALIZED
N *       should be true if the module is initialized, false if not.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_MODULE_INITIALIZED()
N#else
N#define VERIFY_MODULE_INITIALIZED() VERIFY_TRUE((MODULE_INITIALIZED), NRF_ERROR_INVALID_STATE)
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return if not.
N *
N * @note MODULE_INITIALIZED must be defined in each module using this macro. MODULE_INITIALIZED
N *       should be true if the module is initialized, false if not.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_MODULE_INITIALIZED_VOID()
N#else
N#define VERIFY_MODULE_INITIALIZED_VOID() VERIFY_TRUE_VOID((MODULE_INITIALIZED))
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return if not.
N *
N * @param[in] param  The variable to check if is NULL.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_PARAM_NOT_NULL()
N#else
N#define VERIFY_PARAM_NOT_NULL(param) VERIFY_FALSE(((param) == NULL), NRF_ERROR_NULL)
N#endif /* DISABLE_PARAM_CHECK */
N
N
N/**@brief Macro for verifying that the module is initialized. It will cause the exterior function to
N *        return if not.
N *
N * @param[in] param  The variable to check if is NULL.
N */
N#ifdef DISABLE_PARAM_CHECK
S#define VERIFY_PARAM_NOT_NULL_VOID()
N#else
N#define VERIFY_PARAM_NOT_NULL_VOID(param) VERIFY_FALSE_VOID(((param) == NULL))
N#endif /* DISABLE_PARAM_CHECK */
N
N/** @} */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_MACROS_H__
N
L 64 "..\..\..\..\..\..\components\libraries\util\sdk_common.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/** @} */
N/** @endcond */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // SDK_COMMON_H__
N
L 41 "..\..\..\..\..\..\components\libraries\button\app_button.c" 2
N#if NRF_MODULE_ENABLED(BUTTON)
X#if ((1L && (1)) ? 1 : 0)
N#include "app_button.h"
L 1 "..\..\..\..\..\..\components\libraries\button\app_button.h" 1
N/**
N * Copyright (c) 2012 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @file
N *
N * @defgroup app_button Button Handler
N * @{
N * @ingroup app_common
N *
N * @brief Buttons handling module.
N *
N * @details The button handler uses the @ref app_gpiote to detect that a button has been
N *          pushed. To handle debouncing, it will start a timer in the GPIOTE event handler.
N *          The button will only be reported as pushed if the corresponding pin is still active when
N *          the timer expires. If there is a new GPIOTE event while the timer is running, the timer
N *          is restarted.
N *
N * @note    The app_button module uses the app_timer module. The user must ensure that the queue in
N *          app_timer is large enough to hold the app_timer_stop() / app_timer_start() operations
N *          which will be executed on each event from GPIOTE module (2 operations), as well as other
N *          app_timer operations queued simultaneously in the application.
N *
N * @note    Even if the scheduler is not used, app_button.h will include app_scheduler.h, so when
N *          compiling, app_scheduler.h must be available in one of the compiler include paths.
N */
N
N#ifndef APP_BUTTON_H__
N#define APP_BUTTON_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "nrf.h"
N#include "app_error.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_error.h" 1
N/**
N * Copyright (c) 2013 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @file
N *
N * @defgroup app_error Common application error handler
N * @{
N * @ingroup app_common
N *
N * @brief Common application error handler and macros for utilizing a common error handler.
N */
N
N#ifndef APP_ERROR_H__
N#define APP_ERROR_H__
N
N#include <stdint.h>
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 185531 $
N * Checkin $Date: 2014-05-29 15:16:06 +0100 (Thu, 29 May 2014) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5050041
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199901L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 55 "..\..\..\..\..\..\components\libraries\util\app_error.h" 2
N#include <stdbool.h>
N#include "nrf.h"
N#include "sdk_errors.h"
N#include "nordic_common.h"
N#include "app_error_weak.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_error_weak.h" 1
N/**
N * Copyright (c) 2016 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N#ifndef APP_ERROR_WEAK_H__
N#define APP_ERROR_WEAK_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @file
N *
N * @defgroup app_error Common application error handler
N * @{
N * @ingroup app_common
N *
N * @brief Common application error handler.
N */
N
N/**@brief       Callback function for errors, asserts, and faults.
N *
N * @details     This function is called every time an error is raised in app_error, nrf_assert, or
N *              in the SoftDevice. Information about the error can be found in the @p info
N *              parameter.
N *
N *              See also @ref nrf_fault_handler_t for more details.
N *
N * @note        The function is implemented as weak so that it can be redefined by a custom error
N *              handler when needed.
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. The value of the @p id
N *                  parameter dictates how to interpret this parameter. Refer to the documentation
N *                  for each fault identifier (@ref NRF_FAULT_IDS and @ref APP_ERROR_FAULT_IDS) for
N *                  details about interpreting @p info.
N */
Nvoid app_error_fault_handler(uint32_t id, uint32_t pc, uint32_t info);
N
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_ERROR_WEAK_H__
L 60 "..\..\..\..\..\..\components\libraries\util\app_error.h" 2
N#ifdef ANT_STACK_SUPPORT_REQD
S#include "ant_error.h"
N#endif // ANT_STACK_SUPPORT_REQD
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define NRF_FAULT_ID_SDK_RANGE_START 0x00004000 /**< The start of the range of error IDs defined in the SDK. */
N
N/**@defgroup APP_ERROR_FAULT_IDS Fault ID types
N * @{ */
N#define NRF_FAULT_ID_SDK_ERROR       NRF_FAULT_ID_SDK_RANGE_START + 1 /**< An error stemming from a call to @ref APP_ERROR_CHECK or @ref APP_ERROR_CHECK_BOOL. The info parameter is a pointer to an @ref error_info_t variable. */
N#define NRF_FAULT_ID_SDK_ASSERT      NRF_FAULT_ID_SDK_RANGE_START + 2 /**< An error stemming from a call to ASSERT (nrf_assert.h). The info parameter is a pointer to an @ref assert_info_t variable. */
N/**@} */
N
N/**@brief Structure containing info about an error of the type @ref NRF_FAULT_ID_SDK_ERROR.
N */
Ntypedef struct
N{
N    uint16_t        line_num;    /**< The line number where the error occurred. */
N    uint8_t const * p_file_name; /**< The file in which the error occurred. */
N    uint32_t        err_code;    /**< The error code representing the error that occurred. */
N} error_info_t;
N
N/**@brief Structure containing info about an error of the type @ref NRF_FAULT_ID_SDK_ASSERT.
N */
Ntypedef struct
N{
N    uint16_t        line_num;    /**< The line number where the error occurred. */
N    uint8_t const * p_file_name; /**< The file in which the error occurred. */
N} assert_info_t;
N
N/**@brief Function for error handling, which is called when an error has occurred.
N *
N * @param[in] error_code  Error code supplied to the handler.
N * @param[in] line_num    Line number where the handler is called.
N * @param[in] p_file_name Pointer to the file name.
N */
Nvoid app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name);
N
N/**@brief Function for error handling, which is called when an error has occurred.
N *
N * @param[in] error_code  Error code supplied to the handler.
N */
Nvoid app_error_handler_bare(ret_code_t error_code);
N
N/**@brief       Function for saving the parameters and entering an eternal loop, for debug purposes.
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. Refer to each fault
N *                  identifier for details.
N */
Nvoid app_error_save_and_stop(uint32_t id, uint32_t pc, uint32_t info);
N
N/**@brief       Function for printing all error info (using nrf_log).
N *
N * @details     Nrf_log library must be initialized using NRF_LOG_INIT macro before calling
N *              this function.
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. Refer to each fault
N *                  identifier for details.
N */
Nstatic __INLINE void app_error_log(uint32_t id, uint32_t pc, uint32_t info)
Xstatic __inline void app_error_log(uint32_t id, uint32_t pc, uint32_t info)
N{
N    switch (id)
N    {
N        case NRF_FAULT_ID_SDK_ASSERT:
X        case 0x00004000 + 2:
N            //NRF_LOG_INFO(NRF_LOG_COLOR_RED "\r\n*** ASSERTION FAILED ***\r\n");
N            if (((assert_info_t *)(info))->p_file_name)
N            {
N               // NRF_LOG_INFO(NRF_LOG_COLOR_WHITE "Line Number: %u\r\n", (unsigned int) ((assert_info_t *)(info))->line_num);
N                //NRF_LOG_INFO("File Name:   %s\r\n", ((assert_info_t *)(info))->p_file_name);
N            }
N            //NRF_LOG_INFO(NRF_LOG_COLOR_DEFAULT "\r\n");
N            break;
N
N        case NRF_FAULT_ID_SDK_ERROR:
X        case 0x00004000 + 1:
N            //NRF_LOG_INFO(NRF_LOG_COLOR_RED "\r\n*** APPLICATION ERROR *** \r\n" NRF_LOG_COLOR_WHITE);
N            if (((error_info_t *)(info))->p_file_name)
N            {
N                //NRF_LOG_INFO("Line Number: %u\r\n", (unsigned int) ((error_info_t *)(info))->line_num);
N                //NRF_LOG_INFO("File Name:   %s\r\n", ((error_info_t *)(info))->p_file_name);
N            }
N            //NRF_LOG_INFO("Error Code:  0x%X\r\n" NRF_LOG_COLOR_DEFAULT "\r\n", (unsigned int) ((error_info_t *)(info))->err_code);
N            break;
N    }
N}
N
N/**@brief       Function for printing all error info (using printf).
N *
N * @param[in] id    Fault identifier. See @ref NRF_FAULT_IDS.
N * @param[in] pc    The program counter of the instruction that triggered the fault, or 0 if
N *                  unavailable.
N * @param[in] info  Optional additional information regarding the fault. Refer to each fault
N *                  identifier for details.
N */
N//lint -save -e438
Nstatic __INLINE void app_error_print(uint32_t id, uint32_t pc, uint32_t info)
Xstatic __inline void app_error_print(uint32_t id, uint32_t pc, uint32_t info)
N{
N    unsigned int tmp = id;
N    printf("app_error_print():\r\n");
N    printf("Fault identifier:  0x%X\r\n", tmp);
N    printf("Program counter:   0x%X\r\n", tmp = pc);
N    printf("Fault information: 0x%X\r\n", tmp = info);
N
N    switch (id)
N    {
N        case NRF_FAULT_ID_SDK_ASSERT:
X        case 0x00004000 + 2:
N            printf("Line Number: %u\r\n", tmp = ((assert_info_t *)(info))->line_num);
N            printf("File Name:   %s\r\n",       ((assert_info_t *)(info))->p_file_name);
N            break;
N
N        case NRF_FAULT_ID_SDK_ERROR:
X        case 0x00004000 + 1:
N            printf("Line Number: %u\r\n",   tmp = ((error_info_t *)(info))->line_num);
N            printf("File Name:   %s\r\n",         ((error_info_t *)(info))->p_file_name);
N            printf("Error Code:  0x%X\r\n", tmp = ((error_info_t *)(info))->err_code);
N            break;
N    }
N}
N//lint -restore
N
N
N/**@brief Macro for calling error handler function.
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */
N#ifdef DEBUG
S#define APP_ERROR_HANDLER(ERR_CODE)                                    \
S    do                                                                 \
S    {                                                                  \
S        app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);  \
S    } while (0)
X#define APP_ERROR_HANDLER(ERR_CODE)                                        do                                                                     {                                                                          app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);      } while (0)
N#else
N#define APP_ERROR_HANDLER(ERR_CODE)                                    \
N    do                                                                 \
N    {                                                                  \
N        app_error_handler_bare((ERR_CODE));                            \
N    } while (0)
X#define APP_ERROR_HANDLER(ERR_CODE)                                        do                                                                     {                                                                          app_error_handler_bare((ERR_CODE));                                } while (0)
N#endif
N/**@brief Macro for calling error handler function if supplied error code any other than NRF_SUCCESS.
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */
N#define APP_ERROR_CHECK(ERR_CODE)                           \
N    do                                                      \
N    {                                                       \
N        const uint32_t LOCAL_ERR_CODE = (ERR_CODE);         \
N        if (LOCAL_ERR_CODE != NRF_SUCCESS)                  \
N        {                                                   \
N            APP_ERROR_HANDLER(LOCAL_ERR_CODE);              \
N        }                                                   \
N    } while (0)
X#define APP_ERROR_CHECK(ERR_CODE)                               do                                                          {                                                               const uint32_t LOCAL_ERR_CODE = (ERR_CODE);                 if (LOCAL_ERR_CODE != NRF_SUCCESS)                          {                                                               APP_ERROR_HANDLER(LOCAL_ERR_CODE);                      }                                                       } while (0)
N
N/**@brief Macro for calling error handler function if supplied boolean value is false.
N *
N * @param[in] BOOLEAN_VALUE Boolean value to be evaluated.
N */
N#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                   \
N    do                                                        \
N    {                                                         \
N        const uint32_t LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE); \
N        if (!LOCAL_BOOLEAN_VALUE)                             \
N        {                                                     \
N            APP_ERROR_HANDLER(0);                             \
N        }                                                     \
N    } while (0)
X#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                       do                                                            {                                                                 const uint32_t LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);         if (!LOCAL_BOOLEAN_VALUE)                                     {                                                                 APP_ERROR_HANDLER(0);                                     }                                                         } while (0)
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_ERROR_H__
N
N/** @} */
L 71 "..\..\..\..\..\..\components\libraries\button\app_button.h" 2
N#include "nrf_gpio.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_gpio.h" 1
N/**
N * Copyright (c) 2015 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N#ifndef NRF_GPIO_H__
N#define NRF_GPIO_H__
N
N#include "nrf.h"
N#include "nrf_peripherals.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_peripherals.h" 1
N/**
N * Copyright (c) 2016 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N#ifndef NRF_PERIPHERALS_H
N#define NRF_PERIPHERALS_H
N
N/*lint ++flb "Enter library region */
N
N#ifdef NRF51422
S#include "nrf51422_peripherals.h"
N#endif
N
N#ifdef NRF51802
S#include "nrf51802_peripherals.h"
N#endif
N
N#ifdef NRF51822
N#include "nrf51822_peripherals.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51822_peripherals.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef _NRF51822_PERIPHERALS_H
N#define _NRF51822_PERIPHERALS_H
N
N
N/* Software Interrupts */
N#define SWI_PRESENT
N#define SWI_COUNT 6
N
N/* GPIO */
N#define GPIO_PRESENT
N#define GPIO_COUNT 1
N
N#define P0_PIN_NUM 32
N
N/* MPU and BPROT */
N#define BPROT_PRESENT
N
N#define BPROT_REGIONS_SIZE 4096
N#define BPROT_REGIONS_NUM 64
N
N/* Radio */
N#define RADIO_PRESENT
N#define RADIO_COUNT 1
N
N/* Accelerated Address Resolver */
N#define AAR_PRESENT
N#define AAR_COUNT 1
N
N#define AAR_MAX_IRK_NUM 8
N
N/* AES Electronic CodeBook mode encryption */
N#define ECB_PRESENT
N#define ECB_COUNT 1
N
N/* AES CCM mode encryption */
N#define CCM_PRESENT
N#define CCM_COUNT 1
N
N/* Peripheral to Peripheral Interconnect */
N#define PPI_PRESENT
N#define PPI_COUNT 1
N
N#define PPI_CH_NUM 16
N#define PPI_GROUP_NUM 4
N
N/* Timer/Counter */
N#define TIMER_PRESENT
N#define TIMER_COUNT 3
N
N#define TIMER0_MAX_SIZE 32
N#define TIMER1_MAX_SIZE 16
N#define TIMER2_MAX_SIZE 16
N
N#define TIMER0_CC_NUM 4
N#define TIMER1_CC_NUM 4
N#define TIMER2_CC_NUM 4
N
N/* Real Time Counter */
N#define RTC_PRESENT
N#define RTC_COUNT 2
N
N#define RTC0_CC_NUM 3
N#define RTC1_CC_NUM 4
N
N/* RNG */
N#define RNG_PRESENT
N#define RNG_COUNT 1
N
N/* Watchdog Timer */
N#define WDT_PRESENT
N#define WDT_COUNT 1
N
N/* Temperature Sensor */
N#define TEMP_PRESENT
N#define TEMP_COUNT 1
N
N/* Serial Peripheral Interface Master */
N#define SPI_PRESENT
N#define SPI_COUNT 2
N
N/* Serial Peripheral Interface Slave with DMA */
N#define SPIS_PRESENT
N#define SPIS_COUNT 1
N
N/* Two Wire Interface Master */
N#define TWI_PRESENT
N#define TWI_COUNT 2
N
N/* Universal Asynchronous Receiver-Transmitter */
N#define UART_PRESENT
N#define UART_COUNT 1
N
N/* Quadrature Decoder */
N#define QDEC_PRESENT
N#define QDEC_COUNT 1
N
N/* Analog to Digital Converter */
N#define ADC_PRESENT
N#define ADC_COUNT 1
N
N/* GPIO Tasks and Events */
N#define GPIOTE_PRESENT
N#define GPIOTE_COUNT 1
N
N#define GPIOTE_CH_NUM 4
N
N/* Low Power Comparator */
N#define LPCOMP_PRESENT
N#define LPCOMP_COUNT 1
N
N#define LPCOMP_REFSEL_RESOLUTION 8
N
N
N#endif      // _NRF51822_PERIPHERALS_H
L 56 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_peripherals.h" 2
N#endif
N
N#ifdef NRF52832
S#include "nrf52832_peripherals.h"
N#endif
N
N#ifdef NRF52840_XXAA
S#include "nrf52840_peripherals.h"
N#endif
N
N
N/*lint --flb "Leave library region" */
N
N#endif /* NRF_PERIPHERALS_H */
N
L 45 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_gpio.h" 2
N#include "nrf_assert.h"
L 1 "..\..\..\..\..\..\components\libraries\util\nrf_assert.h" 1
N/**
N * Copyright (c) 2006 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @file
N * @brief Utilities for verifying program logic
N */
N
N#ifndef NRF_ASSERT_H_
N#define NRF_ASSERT_H_
N
N#include <stdint.h>
N#include "nrf.h"
N#include "app_error.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/** @brief Function for handling assertions.
N *
N *
N * @note
N * This function is called when an assertion has triggered.
N *
N * @note
N * This function is deprecated and will be removed in future releases.
N * Use app_error_fault_handler instead.
N *
N *
N * @post
N * All hardware is put into an idle non-emitting state (in particular the radio is highly
N * important to switch off since the radio might be in a state that makes it send
N * packets continiously while a typical final infinit ASSERT loop is executing).
N *
N *
N * @param line_num The line number where the assertion is called
N * @param file_name Pointer to the file name
N */
N//lint -save -esym(14, assert_nrf_callback)
Nvoid assert_nrf_callback(uint16_t line_num, const uint8_t *file_name);
N//lint -restore
N
N#if (defined(DEBUG_NRF) || defined(DEBUG_NRF_USER))
X#if (0L || 0L)
S#define NRF_ASSERT_PRESENT 1
N#else
N#define NRF_ASSERT_PRESENT 0
N#endif
N
N//#if defined(DEBUG_NRF) || defined(DEBUG_NRF_USER)
N
N/*lint -emacro(506, ASSERT) */ /* Suppress "Constant value Boolean */
N/*lint -emacro(774, ASSERT) */ /* Suppress "Boolean within 'if' always evaluates to True" */ \
N
X    
N/** @brief Function for checking intended for production code.
N *
N * Check passes if "expr" evaluates to true. */
N
N#ifdef _lint
S#define ASSERT(expr) \
Sif (expr)                                                                     \
S{                                                                             \
S}                                                                             \
Selse                                                                          \
S{                                                                             \
S    while(1);             \
S}
X#define ASSERT(expr) if (expr)                                                                     {                                                                             }                                                                             else                                                                          {                                                                                 while(1);             }
N#else //_lint
N#define ASSERT(expr) \
Nif (NRF_ASSERT_PRESENT)                                                       \
N{                                                                             \
N    if (expr)                                                                 \
N    {                                                                         \
N    }                                                                         \
N    else                                                                      \
N    {                                                                         \
N        assert_nrf_callback((uint16_t)__LINE__, (uint8_t *)__FILE__);         \
N    }                                                                         \
N}
X#define ASSERT(expr) if (NRF_ASSERT_PRESENT)                                                       {                                                                                 if (expr)                                                                     {                                                                             }                                                                             else                                                                          {                                                                                 assert_nrf_callback((uint16_t)__LINE__, (uint8_t *)__FILE__);             }                                                                         }
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* NRF_ASSERT_H_ */
L 46 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_gpio.h" 2
N#include <stdbool.h>
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5050041
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199901L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 48 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_gpio.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @defgroup nrf_gpio GPIO abstraction
N * @{
N * @ingroup nrf_drivers
N * @brief GPIO pin abstraction and port abstraction for reading and writing byte-wise to GPIO ports.
N */
N
N#if (GPIO_COUNT == 1)
X#if (1 == 1)
N#define NUMBER_OF_PINS (P0_PIN_NUM)
N#define GPIO_REG_LIST  {NRF_GPIO}
N#elif (GPIO_COUNT == 2)
S#define NUMBER_OF_PINS (P0_PIN_NUM + P1_PIN_NUM)
S#define GPIO_REG_LIST  {NRF_P0, NRF_P1}
S#else
S#error "Not supported."
N#endif
N
N
N/**
N * @brief Macro for mapping port and pin numbers to values understandable for nrf_gpio functions.
N */
N#define NRF_GPIO_PIN_MAP(port, pin) ((port << 5) | (pin & 0x1F))
N
N/**
N * @brief Pin direction definitions.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_DIR_INPUT  = GPIO_PIN_CNF_DIR_Input, ///< Input.
X    NRF_GPIO_PIN_DIR_INPUT  = (0UL), 
N    NRF_GPIO_PIN_DIR_OUTPUT = GPIO_PIN_CNF_DIR_Output ///< Output.
X    NRF_GPIO_PIN_DIR_OUTPUT = (1UL) 
N} nrf_gpio_pin_dir_t;
N
N/**
N * @brief Connection of input buffer.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_INPUT_CONNECT    = GPIO_PIN_CNF_INPUT_Connect,   ///< Connect input buffer.
X    NRF_GPIO_PIN_INPUT_CONNECT    = (0UL),   
N    NRF_GPIO_PIN_INPUT_DISCONNECT = GPIO_PIN_CNF_INPUT_Disconnect ///< Disconnect input buffer.
X    NRF_GPIO_PIN_INPUT_DISCONNECT = (1UL) 
N} nrf_gpio_pin_input_t;
N
N/**
N * @brief Enumerator used for selecting the pin to be pulled down or up at the time of pin configuration.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_NOPULL   = GPIO_PIN_CNF_PULL_Disabled, ///<  Pin pull-up resistor disabled.
X    NRF_GPIO_PIN_NOPULL   = (0x00UL), 
N    NRF_GPIO_PIN_PULLDOWN = GPIO_PIN_CNF_PULL_Pulldown, ///<  Pin pull-down resistor enabled.
X    NRF_GPIO_PIN_PULLDOWN = (0x01UL), 
N    NRF_GPIO_PIN_PULLUP   = GPIO_PIN_CNF_PULL_Pullup,   ///<  Pin pull-up resistor enabled.
X    NRF_GPIO_PIN_PULLUP   = (0x03UL),   
N} nrf_gpio_pin_pull_t;
N
N/**
N * @brief Enumerator used for selecting output drive mode.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_S0S1 = GPIO_PIN_CNF_DRIVE_S0S1, ///< !< Standard '0', standard '1'.
X    NRF_GPIO_PIN_S0S1 = (0x00UL), 
N    NRF_GPIO_PIN_H0S1 = GPIO_PIN_CNF_DRIVE_H0S1, ///< !< High-drive '0', standard '1'.
X    NRF_GPIO_PIN_H0S1 = (0x01UL), 
N    NRF_GPIO_PIN_S0H1 = GPIO_PIN_CNF_DRIVE_S0H1, ///< !< Standard '0', high-drive '1'.
X    NRF_GPIO_PIN_S0H1 = (0x02UL), 
N    NRF_GPIO_PIN_H0H1 = GPIO_PIN_CNF_DRIVE_H0H1, ///< !< High drive '0', high-drive '1'.
X    NRF_GPIO_PIN_H0H1 = (0x03UL), 
N    NRF_GPIO_PIN_D0S1 = GPIO_PIN_CNF_DRIVE_D0S1, ///< !< Disconnect '0' standard '1'.
X    NRF_GPIO_PIN_D0S1 = (0x04UL), 
N    NRF_GPIO_PIN_D0H1 = GPIO_PIN_CNF_DRIVE_D0H1, ///< !< Disconnect '0', high-drive '1'.
X    NRF_GPIO_PIN_D0H1 = (0x05UL), 
N    NRF_GPIO_PIN_S0D1 = GPIO_PIN_CNF_DRIVE_S0D1, ///< !< Standard '0', disconnect '1'.
X    NRF_GPIO_PIN_S0D1 = (0x06UL), 
N    NRF_GPIO_PIN_H0D1 = GPIO_PIN_CNF_DRIVE_H0D1, ///< !< High-drive '0', disconnect '1'.
X    NRF_GPIO_PIN_H0D1 = (0x07UL), 
N} nrf_gpio_pin_drive_t;
N
N/**
N * @brief Enumerator used for selecting the pin to sense high or low level on the pin input.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_NOSENSE    = GPIO_PIN_CNF_SENSE_Disabled, ///<  Pin sense level disabled.
X    NRF_GPIO_PIN_NOSENSE    = (0x00UL), 
N    NRF_GPIO_PIN_SENSE_LOW  = GPIO_PIN_CNF_SENSE_Low,      ///<  Pin sense low level.
X    NRF_GPIO_PIN_SENSE_LOW  = (0x03UL),      
N    NRF_GPIO_PIN_SENSE_HIGH = GPIO_PIN_CNF_SENSE_High,     ///<  Pin sense high level.
X    NRF_GPIO_PIN_SENSE_HIGH = (0x02UL),     
N} nrf_gpio_pin_sense_t;
N
N
N#if (__LINT__ != 1)
N
N/**
N * @brief Function for configuring the GPIO pin range as output pins with normal drive strength.
N *        This function can be used to configure pin range as simple output with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_range_start Specifies the start number (inclusive) in the range of pin numbers to be configured (allowed values 0-30).
N *
N * @param pin_range_end Specifies the end number (inclusive) in the range of pin numbers to be configured (allowed values 0-30).
N *
N * @note For configuring only one pin as output, use @ref nrf_gpio_cfg_output.
N *       Sense capability on the pin is disabled and input is disconnected from the buffer as the pins are configured as output.
N */
N__STATIC_INLINE void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end);
Xstatic __inline void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end);
N
N/**
N * @brief Function for configuring the GPIO pin range as input pins with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input.
N *
N * @param pin_range_start Specifies the start number (inclusive) in the range of pin numbers to be configured (allowed values 0-30).
N *
N * @param pin_range_end Specifies the end number (inclusive) in the range of pin numbers to be configured (allowed values 0-30).
N *
N * @param pull_config State of the pin range pull resistor (no pull, pulled down, or pulled high).
N *
N * @note  For configuring only one pin as input, use @ref nrf_gpio_cfg_input.
N *        Sense capability on the pin is disabled and input is connected to buffer so that the GPIO->IN register is readable.
N */
N__STATIC_INLINE void nrf_gpio_range_cfg_input(uint32_t            pin_range_start,
Xstatic __inline void nrf_gpio_range_cfg_input(uint32_t            pin_range_start,
N                                              uint32_t            pin_range_end,
N                                              nrf_gpio_pin_pull_t pull_config);
N
N/**
N * @brief Pin configuration function.
N *
N * The main pin configuration function.
N * This function allows to set any aspect in PIN_CNF register.
N * @param pin_number Specifies the pin number.
N * @param dir        Pin direction.
N * @param input      Connect or disconnect the input buffer.
N * @param pull       Pull configuration.
N * @param drive      Drive configuration.
N * @param sense      Pin sensing mechanism.
N */
N__STATIC_INLINE void nrf_gpio_cfg(
Xstatic __inline void nrf_gpio_cfg(
N    uint32_t             pin_number,
N    nrf_gpio_pin_dir_t   dir,
N    nrf_gpio_pin_input_t input,
N    nrf_gpio_pin_pull_t  pull,
N    nrf_gpio_pin_drive_t drive,
N    nrf_gpio_pin_sense_t sense);
N
N/**
N * @brief Function for configuring the given GPIO pin number as output, hiding inner details.
N *        This function can be used to configure a pin as simple output with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_number Specifies the pin number.
N *
N * @note  Sense capability on the pin is disabled and input is disconnected from the buffer as the pins are configured as output.
N */
N__STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number);
Xstatic __inline void nrf_gpio_cfg_output(uint32_t pin_number);
N
N/**
N * @brief Function for configuring the given GPIO pin number as input, hiding inner details.
N *        This function can be used to configure a pin as simple input.
N *
N * @param pin_number Specifies the pin number.
N * @param pull_config State of the pin range pull resistor (no pull, pulled down, or pulled high).
N *
N * @note  Sense capability on the pin is disabled and input is connected to buffer so that the GPIO->IN register is readable.
N */
N__STATIC_INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config);
Xstatic __inline void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config);
N
N/**
N * @brief Function for resetting pin configuration to its default state.
N *
N * @param pin_number Specifies the pin number.
N */
N__STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number);
Xstatic __inline void nrf_gpio_cfg_default(uint32_t pin_number);
N
N/**
N * @brief Function for configuring the given GPIO pin number as a watcher. Only input is connected.
N *
N * @param pin_number Specifies the pin number.
N *
N */
N__STATIC_INLINE void nrf_gpio_cfg_watcher(uint32_t pin_number);
Xstatic __inline void nrf_gpio_cfg_watcher(uint32_t pin_number);
N
N/**
N * @brief Function for disconnecting input for the given GPIO.
N *
N * @param pin_number Specifies the pin number.
N *
N */
N__STATIC_INLINE void nrf_gpio_input_disconnect(uint32_t pin_number);
Xstatic __inline void nrf_gpio_input_disconnect(uint32_t pin_number);
N
N/**
N * @brief Function for configuring the given GPIO pin number as input, hiding inner details.
N *        This function can be used to configure pin range as simple input.
N *        Sense capability on the pin is configurable and input is connected to buffer so that the GPIO->IN register is readable.
N *
N * @param pin_number   Specifies the pin number.
N * @param pull_config  State of the pin pull resistor (no pull, pulled down, or pulled high).
N * @param sense_config Sense level of the pin (no sense, sense low, or sense high).
N */
N__STATIC_INLINE void nrf_gpio_cfg_sense_input(uint32_t             pin_number,
Xstatic __inline void nrf_gpio_cfg_sense_input(uint32_t             pin_number,
N                                              nrf_gpio_pin_pull_t  pull_config,
N                                              nrf_gpio_pin_sense_t sense_config);
N
N/**
N * @brief Function for configuring sense level for the given GPIO.
N *
N * @param pin_number   Specifies the pin number.
N * @param sense_config Sense configuration.
N *
N */
N__STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config);
Xstatic __inline void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config);
N
N/**
N * @brief Function for setting the direction for a GPIO pin.
N *
N * @param pin_number Specifies the pin number for which to set the direction.
N *
N * @param direction Specifies the direction.
N */
N__STATIC_INLINE void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction);
Xstatic __inline void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction);
N
N/**
N * @brief Function for setting a GPIO pin.
N *
N * Note that the pin must be configured as an output for this function to have any effect.
N *
N * @param pin_number Specifies the pin number to set.
N */
N__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number);
Xstatic __inline void nrf_gpio_pin_set(uint32_t pin_number);
N
N/**
N * @brief Function for clearing a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number Specifies the pin number to clear.
N */
N__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number);
Xstatic __inline void nrf_gpio_pin_clear(uint32_t pin_number);
N
N/**
N * @brief Function for toggling a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number Specifies the pin number to toggle.
N */
N__STATIC_INLINE void nrf_gpio_pin_toggle(uint32_t pin_number);
Xstatic __inline void nrf_gpio_pin_toggle(uint32_t pin_number);
N
N/**
N * @brief Function for writing a value to a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number Specifies the pin number to write.
N *
N * @param value Specifies the value to be written to the pin.
N * @arg 0 Clears the pin.
N * @arg >=1 Sets the pin.
N */
N__STATIC_INLINE void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value);
Xstatic __inline void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value);
N
N/**
N * @brief Function for reading the input level of a GPIO pin.
N *
N * Note that the pin must have input connected for the value
N * returned from this function to be valid.
N *
N * @param pin_number Specifies the pin number to read.
N *
N * @return 0 if the pin input level is low. Positive value if the pin is high.
N */
N__STATIC_INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number);
Xstatic __inline uint32_t nrf_gpio_pin_read(uint32_t pin_number);
N
N/**
N * @brief Function for reading the output level of a GPIO pin.
N *
N * @param pin_number Specifies the pin number to read.
N *
N * @return 0 if the pin output level is low. Positive value if pin output is high.
N */
N__STATIC_INLINE uint32_t nrf_gpio_pin_out_read(uint32_t pin_number);
Xstatic __inline uint32_t nrf_gpio_pin_out_read(uint32_t pin_number);
N
N/**
N * @brief Function for reading the sense configuration of a GPIO pin.
N *
N * @param pin_number Specifies the pin number to read.
N *
N * @retval Sense configuration.
N */
N__STATIC_INLINE nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number);
Xstatic __inline nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number);
N
N/**
N * @brief Function for setting output direction on selected pins on a given port.
N *
N * @param p_reg    Pointer to the peripheral registers structure.
N * @param out_mask Mask specifying the pins to set as output.
N *
N */
N__STATIC_INLINE void nrf_gpio_port_dir_output_set(NRF_GPIO_Type * p_reg, uint32_t out_mask);
Xstatic __inline void nrf_gpio_port_dir_output_set(NRF_GPIO_Type * p_reg, uint32_t out_mask);
N
N/**
N * @brief Function for setting input direction on selected pins on a given port.
N *
N * @param p_reg    Pointer to the peripheral registers structure.
N * @param in_mask  Mask specifying the pins to set as input.
N *
N */
N__STATIC_INLINE void nrf_gpio_port_dir_input_set(NRF_GPIO_Type * p_reg, uint32_t in_mask);
Xstatic __inline void nrf_gpio_port_dir_input_set(NRF_GPIO_Type * p_reg, uint32_t in_mask);
N
N/**
N * @brief Function for writing the direction configuration of GPIO pins in a given port.
N *
N * @param p_reg    Pointer to the peripheral registers structure.
N * @param dir_mask Mask specifying the direction of pins. Bit set means that the given pin is configured as output.
N *
N */
N__STATIC_INLINE void nrf_gpio_port_dir_write(NRF_GPIO_Type * p_reg, uint32_t dir_mask);
Xstatic __inline void nrf_gpio_port_dir_write(NRF_GPIO_Type * p_reg, uint32_t dir_mask);
N
N/**
N * @brief Function for reading the direction configuration of a GPIO port.
N *
N * @param p_reg    Pointer to the peripheral registers structure.
N *
N * @retval Pin configuration of the current direction settings. Bit set means that the given pin is configured as output.
N */
N__STATIC_INLINE uint32_t nrf_gpio_port_dir_read(NRF_GPIO_Type const * p_reg);
Xstatic __inline uint32_t nrf_gpio_port_dir_read(NRF_GPIO_Type const * p_reg);
N
N/**
N * @brief Function for reading the input signals of GPIO pins on a given port.
N *
N * @param p_reg Pointer to the peripheral registers structure.
N *
N * @retval Port input values.
N */
N__STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg);
Xstatic __inline uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg);
N
N/**
N * @brief Function for reading the output signals of GPIO pins of a given port.
N *
N * @param p_reg Pointer to the peripheral registers structure.
N *
N * @retval Port output values.
N */
N__STATIC_INLINE uint32_t nrf_gpio_port_out_read(NRF_GPIO_Type const * p_reg);
Xstatic __inline uint32_t nrf_gpio_port_out_read(NRF_GPIO_Type const * p_reg);
N
N/**
N * @brief Function for writing the GPIO pins output on a given port.
N *
N * @param p_reg Pointer to the peripheral registers structure.
N * @param value Output port mask.
N *
N */
N__STATIC_INLINE void nrf_gpio_port_out_write(NRF_GPIO_Type * p_reg, uint32_t value);
Xstatic __inline void nrf_gpio_port_out_write(NRF_GPIO_Type * p_reg, uint32_t value);
N
N/**
N * @brief Function for setting high level on selected GPIO pins of a given port.
N *
N * @param p_reg    Pointer to the peripheral registers structure.
N * @param set_mask Mask with pins to set as logical high level.
N *
N */
N__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask);
Xstatic __inline void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask);
N
N/**
N * @brief Function for setting low level on selected GPIO pins of a given port.
N *
N * @param p_reg    Pointer to the peripheral registers structure.
N * @param clr_mask Mask with pins to set as logical low level.
N *
N */
N__STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask);
Xstatic __inline void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask);
N
N/**
N * @brief Function for reading pins state of multiple consecutive ports.
N *
N * @param start_port Index of the first port to read.
N * @param length     Number of ports to read.
N * @param p_masks    Pointer to output array where port states will be stored.
N */
N__STATIC_INLINE void nrf_gpio_ports_read(uint32_t start_port, uint32_t length, uint32_t * p_masks);
Xstatic __inline void nrf_gpio_ports_read(uint32_t start_port, uint32_t length, uint32_t * p_masks);
N
N#ifdef GPIO_DETECTMODE_DETECTMODE_LDETECT
S/**
S * @brief Function for reading latch state of multiple consecutive ports.
S *
S * @param start_port Index of the first port to read.
S * @param length     Number of ports to read.
S * @param p_masks    Pointer to output array where latch states will be stored.
S */
S__STATIC_INLINE void nrf_gpio_latches_read(uint32_t start_port, uint32_t length,
S                                           uint32_t * p_masks);
S
S/**
S * @brief Function for reading latch state of single pin.
S *
S * @param pin_number Pin number.
S * @return 0 if latch is not set. Positive value otherwise.
S *
S */
S__STATIC_INLINE uint32_t nrf_gpio_pin_latch_get(uint32_t pin_number);
S
S/**
S * @brief Function for clearing latch state of a single pin.
S *
S * @param pin_number Pin number.
S *
S */
S__STATIC_INLINE void nrf_gpio_pin_latch_clear(uint32_t pin_number);
N#endif
N
N
N#endif // #ifndef (__LINT__ != 1)
N
N#ifndef SUPPRESS_INLINE_IMPLEMENTATION
N
N/**
N * @brief Function for extracting port and relative pin number from absolute pin number.
N *
N * @param[inout] Pointer to absolute pin number which is overriden by relative to port pin number.
N *
N * @return Pointer to port register set.
N *
N */
N__STATIC_INLINE NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
Xstatic __inline NRF_GPIO_Type * nrf_gpio_pin_port_decode(uint32_t * p_pin)
N{
N    ASSERT(*p_pin < NUMBER_OF_PINS);
X    if (0) { if (*p_pin < (32)) { } else { assert_nrf_callback((uint16_t)464, (uint8_t *)"..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\hal\\nrf_gpio.h"); } };
N#if (GPIO_COUNT == 1)
X#if (1 == 1)
N    // The oldest definition case
N    return NRF_GPIO;
X    return ((NRF_GPIO_Type *) 0x50000000UL);
N#else
S    if (*p_pin < P0_PIN_NUM)
S    {
S        return NRF_P0;
S    }
S    else
S    {
S        *p_pin = *p_pin & (P0_PIN_NUM - 1);
S        return NRF_P1;
S    }
N#endif
N}
N
N
N__STATIC_INLINE void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end)
Xstatic __inline void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    for (; pin_range_start <= pin_range_end; pin_range_start++)
N    {
N        nrf_gpio_cfg_output(pin_range_start);
N    }
N}
N
N
N__STATIC_INLINE void nrf_gpio_range_cfg_input(uint32_t            pin_range_start,
Xstatic __inline void nrf_gpio_range_cfg_input(uint32_t            pin_range_start,
N                                              uint32_t            pin_range_end,
N                                              nrf_gpio_pin_pull_t pull_config)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    for (; pin_range_start <= pin_range_end; pin_range_start++)
N    {
N        nrf_gpio_cfg_input(pin_range_start, pull_config);
N    }
N}
N
N
N__STATIC_INLINE void nrf_gpio_cfg(
Xstatic __inline void nrf_gpio_cfg(
N    uint32_t             pin_number,
N    nrf_gpio_pin_dir_t   dir,
N    nrf_gpio_pin_input_t input,
N    nrf_gpio_pin_pull_t  pull,
N    nrf_gpio_pin_drive_t drive,
N    nrf_gpio_pin_sense_t sense)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N
N    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
X    reg->PIN_CNF[pin_number] = ((uint32_t)dir << (0UL))
N                               | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
X                               | ((uint32_t)input << (1UL))
N                               | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
X                               | ((uint32_t)pull << (2UL))
N                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
X                               | ((uint32_t)drive << (8UL))
N                               | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
X                               | ((uint32_t)sense << (16UL));
N}
N
N
N__STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
Xstatic __inline void nrf_gpio_cfg_output(uint32_t pin_number)
N{
N    nrf_gpio_cfg(
N        pin_number,
N        NRF_GPIO_PIN_DIR_OUTPUT,
N        NRF_GPIO_PIN_INPUT_DISCONNECT,
N        NRF_GPIO_PIN_NOPULL,
N        NRF_GPIO_PIN_S0S1,
N        NRF_GPIO_PIN_NOSENSE);
N}
N
N
N__STATIC_INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
Xstatic __inline void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
N{
N    nrf_gpio_cfg(
N        pin_number,
N        NRF_GPIO_PIN_DIR_INPUT,
N        NRF_GPIO_PIN_INPUT_CONNECT,
N        pull_config,
N        NRF_GPIO_PIN_S0S1,
N        NRF_GPIO_PIN_NOSENSE);
N}
N
N
N__STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
Xstatic __inline void nrf_gpio_cfg_default(uint32_t pin_number)
N{
N    nrf_gpio_cfg(
N        pin_number,
N        NRF_GPIO_PIN_DIR_INPUT,
N        NRF_GPIO_PIN_INPUT_DISCONNECT,
N        NRF_GPIO_PIN_NOPULL,
N        NRF_GPIO_PIN_S0S1,
N        NRF_GPIO_PIN_NOSENSE);
N}
N
N
N__STATIC_INLINE void nrf_gpio_cfg_watcher(uint32_t pin_number)
Xstatic __inline void nrf_gpio_cfg_watcher(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_INPUT_Msk;
X    uint32_t cnf = reg->PIN_CNF[pin_number] & ~(0x1UL << (1UL));
N
N    reg->PIN_CNF[pin_number] = cnf | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos);
X    reg->PIN_CNF[pin_number] = cnf | ((0UL) << (1UL));
N}
N
N
N__STATIC_INLINE void nrf_gpio_input_disconnect(uint32_t pin_number)
Xstatic __inline void nrf_gpio_input_disconnect(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_INPUT_Msk;
X    uint32_t cnf = reg->PIN_CNF[pin_number] & ~(0x1UL << (1UL));
N
N    reg->PIN_CNF[pin_number] = cnf | (GPIO_PIN_CNF_INPUT_Disconnect << GPIO_PIN_CNF_INPUT_Pos);
X    reg->PIN_CNF[pin_number] = cnf | ((1UL) << (1UL));
N}
N
N
N__STATIC_INLINE void nrf_gpio_cfg_sense_input(uint32_t             pin_number,
Xstatic __inline void nrf_gpio_cfg_sense_input(uint32_t             pin_number,
N                                              nrf_gpio_pin_pull_t  pull_config,
N                                              nrf_gpio_pin_sense_t sense_config)
N{
N    nrf_gpio_cfg(
N        pin_number,
N        NRF_GPIO_PIN_DIR_INPUT,
N        NRF_GPIO_PIN_INPUT_CONNECT,
N        pull_config,
N        NRF_GPIO_PIN_S0S1,
N        sense_config);
N}
N
N
N__STATIC_INLINE void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
Xstatic __inline void nrf_gpio_cfg_sense_set(uint32_t pin_number, nrf_gpio_pin_sense_t sense_config)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    reg->PIN_CNF[pin_number] &= ~GPIO_PIN_CNF_SENSE_Msk;
X    reg->PIN_CNF[pin_number] &= ~(0x3UL << (16UL));
N    reg->PIN_CNF[pin_number] |= (sense_config << GPIO_PIN_CNF_SENSE_Pos);
X    reg->PIN_CNF[pin_number] |= (sense_config << (16UL));
N}
N
N
N__STATIC_INLINE void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction)
Xstatic __inline void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction)
N{
N    if (direction == NRF_GPIO_PIN_DIR_INPUT)
N    {
N        nrf_gpio_cfg(
N            pin_number,
N            NRF_GPIO_PIN_DIR_INPUT,
N            NRF_GPIO_PIN_INPUT_CONNECT,
N            NRF_GPIO_PIN_NOPULL,
N            NRF_GPIO_PIN_S0S1,
N            NRF_GPIO_PIN_NOSENSE);
N    }
N    else
N    {
N        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N        reg->DIRSET = (1UL << pin_number);
N    }
N}
N
N
N__STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_set(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N
N    nrf_gpio_port_out_set(reg, 1UL << pin_number);
N}
N
N
N__STATIC_INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_clear(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N
N    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
N}
N
N
N__STATIC_INLINE void nrf_gpio_pin_toggle(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_toggle(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg        = nrf_gpio_pin_port_decode(&pin_number);
N    uint32_t        pins_state = reg->OUT;
N
N    reg->OUTSET = (~pins_state & (1UL << pin_number));
N    reg->OUTCLR = (pins_state & (1UL << pin_number));
N}
N
N
N__STATIC_INLINE void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
Xstatic __inline void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
N{
N    if (value == 0)
N    {
N        nrf_gpio_pin_clear(pin_number);
N    }
N    else
N    {
N        nrf_gpio_pin_set(pin_number);
N    }
N}
N
N
N__STATIC_INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number)
Xstatic __inline uint32_t nrf_gpio_pin_read(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N
N    return ((nrf_gpio_port_in_read(reg) >> pin_number) & 1UL);
N}
N
N
N__STATIC_INLINE uint32_t nrf_gpio_pin_out_read(uint32_t pin_number)
Xstatic __inline uint32_t nrf_gpio_pin_out_read(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N
N    return ((nrf_gpio_port_out_read(reg) >> pin_number) & 1UL);
N}
N
N
N__STATIC_INLINE nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number)
Xstatic __inline nrf_gpio_pin_sense_t nrf_gpio_pin_sense_get(uint32_t pin_number)
N{
N    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
N
N    return (nrf_gpio_pin_sense_t)((reg->PIN_CNF[pin_number] &
N                                   GPIO_PIN_CNF_SENSE_Msk) >> GPIO_PIN_CNF_SENSE_Pos);
X                                   (0x3UL << (16UL))) >> (16UL));
N}
N
N
N__STATIC_INLINE void nrf_gpio_port_dir_output_set(NRF_GPIO_Type * p_reg, uint32_t out_mask)
Xstatic __inline void nrf_gpio_port_dir_output_set(NRF_GPIO_Type * p_reg, uint32_t out_mask)
N{
N    p_reg->DIRSET = out_mask;
N}
N
N
N__STATIC_INLINE void nrf_gpio_port_dir_input_set(NRF_GPIO_Type * p_reg, uint32_t in_mask)
Xstatic __inline void nrf_gpio_port_dir_input_set(NRF_GPIO_Type * p_reg, uint32_t in_mask)
N{
N    p_reg->DIRCLR = in_mask;
N}
N
N
N__STATIC_INLINE void nrf_gpio_port_dir_write(NRF_GPIO_Type * p_reg, uint32_t value)
Xstatic __inline void nrf_gpio_port_dir_write(NRF_GPIO_Type * p_reg, uint32_t value)
N{
N    p_reg->DIR = value;
N}
N
N
N__STATIC_INLINE uint32_t nrf_gpio_port_dir_read(NRF_GPIO_Type const * p_reg)
Xstatic __inline uint32_t nrf_gpio_port_dir_read(NRF_GPIO_Type const * p_reg)
N{
N    return p_reg->DIR;
N}
N
N
N__STATIC_INLINE uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
Xstatic __inline uint32_t nrf_gpio_port_in_read(NRF_GPIO_Type const * p_reg)
N{
N    return p_reg->IN;
N}
N
N
N__STATIC_INLINE uint32_t nrf_gpio_port_out_read(NRF_GPIO_Type const * p_reg)
Xstatic __inline uint32_t nrf_gpio_port_out_read(NRF_GPIO_Type const * p_reg)
N{
N    return p_reg->OUT;
N}
N
N
N__STATIC_INLINE void nrf_gpio_port_out_write(NRF_GPIO_Type * p_reg, uint32_t value)
Xstatic __inline void nrf_gpio_port_out_write(NRF_GPIO_Type * p_reg, uint32_t value)
N{
N    p_reg->OUT = value;
N}
N
N
N__STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
Xstatic __inline void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
N{
N    p_reg->OUTSET = set_mask;
N}
N
N
N__STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
Xstatic __inline void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
N{
N    p_reg->OUTCLR = clr_mask;
N}
N
N
N__STATIC_INLINE void nrf_gpio_ports_read(uint32_t start_port, uint32_t length, uint32_t * p_masks)
Xstatic __inline void nrf_gpio_ports_read(uint32_t start_port, uint32_t length, uint32_t * p_masks)
N{
N    NRF_GPIO_Type * gpio_regs[GPIO_COUNT] = GPIO_REG_LIST;
X    NRF_GPIO_Type * gpio_regs[1] = {((NRF_GPIO_Type *) 0x50000000UL)};
N
N    ASSERT(start_port + length <= GPIO_COUNT);
X    if (0) { if (start_port + length <= 1) { } else { assert_nrf_callback((uint16_t)744, (uint8_t *)"..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\hal\\nrf_gpio.h"); } };
N    uint32_t i;
N
N    for (i = start_port; i < (start_port + length); i++)
N    {
N        *p_masks = nrf_gpio_port_in_read(gpio_regs[i]);
N        p_masks++;
N    }
N}
N
N
N#ifdef GPIO_DETECTMODE_DETECTMODE_LDETECT
S__STATIC_INLINE void nrf_gpio_latches_read(uint32_t start_port, uint32_t length, uint32_t * p_masks)
S{
S    NRF_GPIO_Type * gpio_regs[GPIO_COUNT] = GPIO_REG_LIST;
S    uint32_t        i;
S
S    for (i = start_port; i < (start_port + length); i++)
S    {
S        *p_masks = gpio_regs[i]->LATCH;
S        p_masks++;
S    }
S}
S
S
S__STATIC_INLINE uint32_t nrf_gpio_pin_latch_get(uint32_t pin_number)
S{
S    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
S
S    return (reg->LATCH & (1 << pin_number)) ? 1 : 0;
S}
S
S
S__STATIC_INLINE void nrf_gpio_pin_latch_clear(uint32_t pin_number)
S{
S    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
S
S    reg->LATCH = (1 << pin_number);
S}
S
S
N#endif
N#endif // SUPPRESS_INLINE_IMPLEMENTATION
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 72 "..\..\..\..\..\..\components\libraries\button\app_button.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define APP_BUTTON_PUSH        1                               /**< Indicates that a button is pushed. */
N#define APP_BUTTON_RELEASE     0                               /**< Indicates that a button is released. */
N#define APP_BUTTON_ACTIVE_HIGH 1                               /**< Indicates that a button is active high. */
N#define APP_BUTTON_ACTIVE_LOW  0                               /**< Indicates that a button is active low. */
N
N/**@brief Button event handler type. */
Ntypedef void (*app_button_handler_t)(uint8_t pin_no, uint8_t button_action);
N
N/**@brief Button configuration structure. */
Ntypedef struct
N{
N    uint8_t              pin_no;           /**< Pin to be used as a button. */
N    uint8_t              active_state;     /**< APP_BUTTON_ACTIVE_HIGH or APP_BUTTON_ACTIVE_LOW. */
N    nrf_gpio_pin_pull_t  pull_cfg;         /**< Pull-up or -down configuration. */
N    app_button_handler_t button_handler;   /**< Handler to be called when button is pushed. */
N} app_button_cfg_t;
N
N/**@brief  Pin transition direction struct. */
Ntypedef struct
N{
N    uint32_t high_to_low;   /**Pin went from high to low */
N    uint32_t low_to_high;   /**Pin went from low to high */
N} pin_transition_t;
N
N/**@brief Function for initializing the Buttons.
N *
N * @details This function will initialize the specified pins as buttons, and configure the Button
N *          Handler module as a GPIOTE user (but it will not enable button detection).
N *
N * @note Normally initialization should be done using the APP_BUTTON_INIT() macro
N *
N * @note app_button_enable() function must be called in order to enable the button detection.
N *
N * @param[in]  p_buttons           Array of buttons to be used (NOTE: Must be static!).
N * @param[in]  button_count        Number of buttons.
N * @param[in]  detection_delay     Delay from a GPIOTE event until a button is reported as pushed.
N *
N * @return   NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t app_button_init(app_button_cfg_t const *       p_buttons,
N                         uint8_t                        button_count,
N                         uint32_t                       detection_delay);
N
N/**@brief Function for enabling button detection.
N *
N * @retval NRF_SUCCESS Module successfully enabled.
N */
Nuint32_t app_button_enable(void);
N
N/**@brief Function for disabling button detection.
N *
N * @retval  NRF_SUCCESS               Button detection successfully disabled. Error code otherwise.
N */
Nuint32_t app_button_disable(void);
N
N/**@brief Function for checking if a button is currently being pushed.
N *
N * @param[in]  button_id     Button index (in the app_button_cfg_t array given to app_button_init) to be checked.
N * 
N * @return     Button state.
N */
Nbool app_button_is_pushed(uint8_t button_id);
X_Bool app_button_is_pushed(uint8_t button_id);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_BUTTON_H__
N
N/** @} */
L 43 "..\..\..\..\..\..\components\libraries\button\app_button.c" 2
N#include "app_timer.h"
L 1 "..\..\..\..\..\..\components\libraries\timer\app_timer.h" 1
N/**
N * Copyright (c) 2012 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @file
N *
N * @defgroup app_timer Application Timer
N * @{
N * @ingroup app_common
N *
N * @brief Application timer functionality.
N *
N * @details This module enables the application to create multiple timer instances based on the RTC1
N *          peripheral. Checking for time-outs and invocation of user time-out handlers is performed
N *          in the RTC1 interrupt handler. List handling is done using a software interrupt (SWI0).
N *          Both interrupt handlers are running in APP_LOW priority level.
N *
N * @details When calling app_timer_start() or app_timer_stop(), the timer operation is just queued,
N *          and the software interrupt is triggered. The actual timer start/stop operation is
N *          executed by the SWI0 interrupt handler. Since the SWI0 interrupt is running in APP_LOW,
N *          if the application code calling the timer function is running in APP_LOW or APP_HIGH,
N *          the timer operation will not be performed until the application handler has returned.
N *          This will be the case, for example, when stopping a timer from a time-out handler when not using
N *          the scheduler.
N *
N * @details Use the USE_SCHEDULER parameter of the APP_TIMER_INIT() macro to select if the
N *          @ref app_scheduler should be used or not. Even if the scheduler is
N *          not used, app_timer.h will include app_scheduler.h, so when
N *          compiling, app_scheduler.h must be available in one of the compiler include paths.
N */
N
N#ifndef APP_TIMER_H__
N#define APP_TIMER_H__
N#include "sdk_config.h"
N#include "app_error.h"
N#include "app_util.h"
N#include "compiler_abstraction.h"
N#include <stdint.h>
N#include <stdbool.h>
N#include <stdio.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define APP_TIMER_CLOCK_FREQ         32768                      /**< Clock frequency of the RTC timer used to implement the app timer module. */
N#define APP_TIMER_MIN_TIMEOUT_TICKS  5                          /**< Minimum value of the timeout_ticks parameter of app_timer_start(). */
N
N#ifdef RTX
S#define APP_TIMER_NODE_SIZE          40                         /**< Size of app_timer.timer_node_t (used to allocate data). */
N#else
N#define APP_TIMER_NODE_SIZE          32                         /**< Size of app_timer.timer_node_t (used to allocate data). */
N#endif // RTX
N#define APP_TIMER_USER_OP_SIZE       24                         /**< Size of app_timer.timer_user_op_t (only for use inside APP_TIMER_BUF_SIZE()). */
N
N/**@brief Compute number of bytes required to hold the application timer data structures.
N *
N * @param[in]  OP_QUEUE_SIZE   Size of the queue holding timer operations that are pending execution.
N *                             Note that due to the queue implementation, this size must be one more
N *                             than the size that is actually needed.
N *
N * @return     Required application timer buffer size (in bytes).
N */
N#define APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE)                                  \
N    (                                                                      \
N        (                                                                  \
N            (((OP_QUEUE_SIZE) + 1) * APP_TIMER_USER_OP_SIZE)               \
N        )                                                                  \
N    )
X#define APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE)                                      (                                                                              (                                                                              (((OP_QUEUE_SIZE) + 1) * APP_TIMER_USER_OP_SIZE)                       )                                                                      )
N
N/**@brief Convert milliseconds to timer ticks.
N *
N * This macro uses 64-bit integer arithmetic, but as long as the macro parameters are
N *       constants (i.e. defines), the computation will be done by the preprocessor.
N *
N * When using this macro, ensure that the
N *         values provided as input result in an output value that is supported by the
N *         @ref app_timer_start function. For example, when the ticks for 1 ms is needed, the
N *         maximum possible value of PRESCALER must be 6, when @ref APP_TIMER_CLOCK_FREQ is 32768.
N *         This will result in a ticks value as 5. Any higher value for PRESCALER will result in a
N *         ticks value that is not supported by this module.
N *
N * @param[in]  MS          Milliseconds.
N * @param[in]  PRESCALER   Value of the RTC1 PRESCALER register (must be the same value that was
N *                         passed to APP_TIMER_INIT()).
N *
N * @return     Number of timer ticks.
N */
N#define APP_TIMER_TICKS(MS, PRESCALER)\
N            ((uint32_t)ROUNDED_DIV((MS) * (uint64_t)APP_TIMER_CLOCK_FREQ, ((PRESCALER) + 1) * 1000))
X#define APP_TIMER_TICKS(MS, PRESCALER)            ((uint32_t)ROUNDED_DIV((MS) * (uint64_t)APP_TIMER_CLOCK_FREQ, ((PRESCALER) + 1) * 1000))
N
Ntypedef struct app_timer_t { uint32_t data[CEIL_DIV(APP_TIMER_NODE_SIZE, sizeof(uint32_t))]; } app_timer_t;
Xtypedef struct app_timer_t { uint32_t data[(((32) + (sizeof(uint32_t)) - 1) / (sizeof(uint32_t)))]; } app_timer_t;
N
N/**@brief Timer ID type.
N * Never declare a variable of this type, but use the macro @ref APP_TIMER_DEF instead.*/
Ntypedef app_timer_t * app_timer_id_t;
N
N/**
N * @brief Create a timer identifier and statically allocate memory for the timer.
N *
N * @param timer_id Name of the timer identifier variable that will be used to control the timer.
N */
N#define APP_TIMER_DEF(timer_id)                                  \
N    static app_timer_t timer_id##_data = { {0} };                  \
N    static const app_timer_id_t timer_id = &timer_id##_data
X#define APP_TIMER_DEF(timer_id)                                      static app_timer_t timer_id##_data = { {0} };                      static const app_timer_id_t timer_id = &timer_id##_data
N
N
N/**@brief Application time-out handler type. */
Ntypedef void (*app_timer_timeout_handler_t)(void * p_context);
N
N/**@brief Type of function for passing events from the timer module to the scheduler. */
Ntypedef uint32_t (*app_timer_evt_schedule_func_t) (app_timer_timeout_handler_t timeout_handler,
N                                                   void *                      p_context);
N
N/**@brief Timer modes. */
Ntypedef enum
N{
N    APP_TIMER_MODE_SINGLE_SHOT,                 /**< The timer will expire only once. */
N    APP_TIMER_MODE_REPEATED                     /**< The timer will restart each time it expires. */
N} app_timer_mode_t;
N
N/**@brief Initialize the application timer module.
N *
N * @details This macro handles dimensioning and allocation of the memory buffer required by the timer,
N *          making sure that the buffer is correctly aligned. It will also connect the timer module
N *          to the scheduler (if specified).
N *
N * @note    This module assumes that the LFCLK is already running. If it is not, the module will
N *          be non-functional, since the RTC will not run. If you do not use a SoftDevice, you
N *          must start the LFCLK manually. See the rtc_example's lfclk_config() function
N *          for an example of how to do this. If you use a SoftDevice, the LFCLK is started on
N *          SoftDevice init.
N *
N *
N * @param[in]  PRESCALER        Value of the RTC1 PRESCALER register. This will decide the
N *                              timer tick rate. Set to 0 for no prescaling.
N * @param[in]  OP_QUEUE_SIZE    Size of the queue holding timer operations that are pending execution.
N * @param[in]  SCHEDULER_FUNC   Pointer to scheduler event handler
N *
N * @note Since this macro allocates a buffer, it must only be called once (it is OK to call it
N *       several times as long as it is from the same location, for example, to do a re-initialization).
N */
N/*lint -emacro(506, APP_TIMER_INIT) */ /* Suppress "Constant value Boolean */
N#define APP_TIMER_INIT(PRESCALER, OP_QUEUE_SIZE, SCHEDULER_FUNC)                  \
N    do                                                                            \
N    {                                                                             \
N        static uint32_t APP_TIMER_BUF[CEIL_DIV(APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE), \
N                                               sizeof(uint32_t))];                \
N        uint32_t ERR_CODE = app_timer_init((PRESCALER),                           \
N                                           (OP_QUEUE_SIZE) + 1,                   \
N                                           APP_TIMER_BUF,                         \
N                                           SCHEDULER_FUNC);                       \
N        APP_ERROR_CHECK(ERR_CODE);                                                \
N    } while (0)
X#define APP_TIMER_INIT(PRESCALER, OP_QUEUE_SIZE, SCHEDULER_FUNC)                      do                                                                                {                                                                                     static uint32_t APP_TIMER_BUF[CEIL_DIV(APP_TIMER_BUF_SIZE(OP_QUEUE_SIZE),                                                sizeof(uint32_t))];                        uint32_t ERR_CODE = app_timer_init((PRESCALER),                                                                      (OP_QUEUE_SIZE) + 1,                                                              APP_TIMER_BUF,                                                                    SCHEDULER_FUNC);                               APP_ERROR_CHECK(ERR_CODE);                                                    } while (0)
N
N
N
N/**@brief Function for initializing the timer module.
N *
N * Normally, initialization should be done using the APP_TIMER_INIT() macro, because that macro will both
N *       allocate the buffers needed by the timer module (including aligning the buffers correctly)
N *       and take care of connecting the timer module to the scheduler (if specified).
N *
N * @param[in]  prescaler           Value of the RTC1 PRESCALER register. Set to 0 for no prescaling.
N * @param[in]  op_queue_size       Size of the queue holding timer operations that are pending
N *                                 execution. Note that due to the queue implementation, this size must
N *                                 be one more than the size that is actually needed.
N * @param[in]  p_buffer            Pointer to memory buffer for internal use in the app_timer
N *                                 module. The size of the buffer can be computed using the
N *                                 APP_TIMER_BUF_SIZE() macro. The buffer must be aligned to a
N *                                 4 byte boundary.
N * @param[in]  evt_schedule_func   Function for passing time-out events to the scheduler. Point to
N *                                 app_timer_evt_schedule() to connect to the scheduler. Set to NULL
N *                                 to make the timer module call the time-out handler directly from
N *                                 the timer interrupt handler.
N *
N * @retval     NRF_SUCCESS               If the module was initialized successfully.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid (buffer not aligned to a 4 byte
N *                                       boundary or NULL).
N */
Nuint32_t app_timer_init(uint32_t                      prescaler,
N                        uint8_t                       op_queue_size,
N                        void *                        p_buffer,
N                        app_timer_evt_schedule_func_t evt_schedule_func);
N
N/**@brief Function for creating a timer instance.
N *
N * @param[in]  p_timer_id        Pointer to timer identifier.
N * @param[in]  mode              Timer mode.
N * @param[in]  timeout_handler   Function to be executed when the timer expires.
N *
N * @retval     NRF_SUCCESS               If the timer was successfully created.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or
N *                                       the timer is running.
N *
N * @note This function does the timer allocation in the caller's context. It is also not protected
N *       by a critical region. Therefore care must be taken not to call it from several interrupt
N *       levels simultaneously.
N * @note The function can be called again on the timer instance and will re-initialize the instance if
N *       the timer is not running.
N * @attention The FreeRTOS and RTX app_timer implementation does not allow app_timer_create to
N *       be called on the previously initialized instance.
N */
Nuint32_t app_timer_create(app_timer_id_t const *      p_timer_id,
N                          app_timer_mode_t            mode,
N                          app_timer_timeout_handler_t timeout_handler);
N
N/**@brief Function for starting a timer.
N *
N * @param[in]       timer_id      Timer identifier.
N * @param[in]       timeout_ticks Number of ticks (of RTC1, including prescaling) to time-out event
N *                                (minimum 5 ticks).
N * @param[in]       p_context     General purpose pointer. Will be passed to the time-out handler when
N *                                the timer expires.
N *
N * @retval     NRF_SUCCESS               If the timer was successfully started.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or the timer
N *                                       has not been created.
N * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
N *
N * @note The minimum timeout_ticks value is 5.
N * @note For multiple active timers, time-outs occurring in close proximity to each other (in the
N *       range of 1 to 3 ticks) will have a positive jitter of maximum 3 ticks.
N * @note When calling this method on a timer that is already running, the second start operation
N *       is ignored.
N */
Nuint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context);
N
N/**@brief Function for stopping the specified timer.
N *
N * @param[in]  timer_id                  Timer identifier.
N *
N * @retval     NRF_SUCCESS               If the timer was successfully stopped.
N * @retval     NRF_ERROR_INVALID_PARAM   If a parameter was invalid.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized or the timer
N *                                       has not been created.
N * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
N */
Nuint32_t app_timer_stop(app_timer_id_t timer_id);
N
N/**@brief Function for stopping all running timers.
N *
N * @retval     NRF_SUCCESS               If all timers were successfully stopped.
N * @retval     NRF_ERROR_INVALID_STATE   If the application timer module has not been initialized.
N * @retval     NRF_ERROR_NO_MEM          If the timer operations queue was full.
N */
Nuint32_t app_timer_stop_all(void);
N
N/**@brief Function for returning the current value of the RTC1 counter.
N *
N * @return    Current value of the RTC1 counter.
N */
Nuint32_t app_timer_cnt_get(void);
N
N/**@brief Function for computing the difference between two RTC1 counter values.
N *
N * @param[in]  ticks_to       Value returned by app_timer_cnt_get().
N * @param[in]  ticks_from     Value returned by app_timer_cnt_get().
N * @param[out] p_ticks_diff   Number of ticks from ticks_from to ticks_to.
N *
N * @retval     NRF_SUCCESS   If the counter difference was successfully computed.
N */
Nuint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
N                                    uint32_t   ticks_from,
N                                    uint32_t * p_ticks_diff);
N
N
N/**@brief Function for getting the maximum observed operation queue utilization.
N *
N * Function for tuning the module and determining OP_QUEUE_SIZE value and thus module RAM usage.
N *
N * @note APP_TIMER_WITH_PROFILER must be enabled to use this functionality.
N *
N * @return Maximum number of events in queue observed so far.
N */
Nuint8_t app_timer_op_queue_utilization_get(void);
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_TIMER_H__
N
N/** @} */
L 44 "..\..\..\..\..\..\components\libraries\button\app_button.c" 2
N#include "app_error.h"
N#include "nrf_drv_gpiote.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\gpiote\nrf_drv_gpiote.h" 1
N/**
N * Copyright (c) 2015 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N#ifndef NRF_DRV_GPIOTE__
N#define NRF_DRV_GPIOTE__
N
N/**
N * @addtogroup nrf_gpiote GPIOTE abstraction and driver
N * @ingroup nrf_drivers
N * @brief GPIOTE APIs.
N * @defgroup nrf_drv_gpiote GPIOTE driver
N * @{
N * @ingroup nrf_gpiote
N * @brief GPIOTE driver for managing input and output pins.
N */
N
N#include "nrf_gpiote.h"
L 1 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_gpiote.h" 1
N/**
N * Copyright (c) 2015 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N#ifndef NRF_GPIOTE_H__
N#define NRF_GPIOTE_H__
N
N#include "nrf_peripherals.h"
N#include "nrf.h"
N#include <stdint.h>
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5050041
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 47 "..\..\..\..\..\..\components\drivers_nrf\hal\nrf_gpiote.h" 2
N#include <stdbool.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#ifdef GPIOTE_CONFIG_PORT_Msk
S#define GPIOTE_CONFIG_PORT_PIN_Msk (GPIOTE_CONFIG_PORT_Msk | GPIOTE_CONFIG_PSEL_Msk)
N#else
N#define GPIOTE_CONFIG_PORT_PIN_Msk GPIOTE_CONFIG_PSEL_Msk
N#endif
N/**
N* @defgroup nrf_gpiote_abs GPIOTE abstraction
N* @{
N* @ingroup nrf_gpiote
N* @brief GPIOTE abstraction for configuration of channels.
N*/
N
N /**
N * @enum nrf_gpiote_polarity_t
N * @brief Polarity for the GPIOTE channel.
N */
Ntypedef enum
N{
N  NRF_GPIOTE_POLARITY_LOTOHI = GPIOTE_CONFIG_POLARITY_LoToHi,       ///<  Low to high.
X  NRF_GPIOTE_POLARITY_LOTOHI = (0x01UL),       
N  NRF_GPIOTE_POLARITY_HITOLO = GPIOTE_CONFIG_POLARITY_HiToLo,       ///<  High to low.
X  NRF_GPIOTE_POLARITY_HITOLO = (0x02UL),       
N  NRF_GPIOTE_POLARITY_TOGGLE = GPIOTE_CONFIG_POLARITY_Toggle        ///<  Toggle.
X  NRF_GPIOTE_POLARITY_TOGGLE = (0x03UL)        
N} nrf_gpiote_polarity_t;
N
N
N /**
N * @enum nrf_gpiote_outinit_t
N * @brief Initial output value for the GPIOTE channel.
N */
Ntypedef enum
N{
N  NRF_GPIOTE_INITIAL_VALUE_LOW  = GPIOTE_CONFIG_OUTINIT_Low,       ///<  Low to high.
X  NRF_GPIOTE_INITIAL_VALUE_LOW  = (0UL),       
N  NRF_GPIOTE_INITIAL_VALUE_HIGH = GPIOTE_CONFIG_OUTINIT_High       ///<  High to low.
X  NRF_GPIOTE_INITIAL_VALUE_HIGH = (1UL)       
N} nrf_gpiote_outinit_t;
N
N/**
N * @brief Tasks.
N */
Ntypedef enum /*lint -save -e30 -esym(628,__INTADDR__) */
N{
N    NRF_GPIOTE_TASKS_OUT_0     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[0]), /**< Out task 0.*/
X    NRF_GPIOTE_TASKS_OUT_0     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->TASKS_OUT[0]))),  
N    NRF_GPIOTE_TASKS_OUT_1     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[1]), /**< Out task 1.*/
X    NRF_GPIOTE_TASKS_OUT_1     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->TASKS_OUT[1]))),  
N    NRF_GPIOTE_TASKS_OUT_2     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[2]), /**< Out task 2.*/
X    NRF_GPIOTE_TASKS_OUT_2     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->TASKS_OUT[2]))),  
N    NRF_GPIOTE_TASKS_OUT_3     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[3]), /**< Out task 3.*/
X    NRF_GPIOTE_TASKS_OUT_3     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->TASKS_OUT[3]))),  
N#if (GPIOTE_CH_NUM > 4) || defined(__SDK_DOXYGEN__)
X#if (4 > 4) || 0L
S    NRF_GPIOTE_TASKS_OUT_4     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[4]), /**< Out task 4.*/
S    NRF_GPIOTE_TASKS_OUT_5     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[5]), /**< Out task 5.*/
S    NRF_GPIOTE_TASKS_OUT_6     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[6]), /**< Out task 6.*/
S    NRF_GPIOTE_TASKS_OUT_7     = offsetof(NRF_GPIOTE_Type, TASKS_OUT[7]), /**< Out task 7.*/
N#endif
N#if defined(GPIOTE_FEATURE_SET_PRESENT) || defined(__SDK_DOXYGEN__)
X#if 0L || 0L
S    NRF_GPIOTE_TASKS_SET_0     = offsetof(NRF_GPIOTE_Type, TASKS_SET[0]), /**< Set task 0.*/
S    NRF_GPIOTE_TASKS_SET_1     = offsetof(NRF_GPIOTE_Type, TASKS_SET[1]), /**< Set task 1.*/
S    NRF_GPIOTE_TASKS_SET_2     = offsetof(NRF_GPIOTE_Type, TASKS_SET[2]), /**< Set task 2.*/
S    NRF_GPIOTE_TASKS_SET_3     = offsetof(NRF_GPIOTE_Type, TASKS_SET[3]), /**< Set task 3.*/
S    NRF_GPIOTE_TASKS_SET_4     = offsetof(NRF_GPIOTE_Type, TASKS_SET[4]), /**< Set task 4.*/
S    NRF_GPIOTE_TASKS_SET_5     = offsetof(NRF_GPIOTE_Type, TASKS_SET[5]), /**< Set task 5.*/
S    NRF_GPIOTE_TASKS_SET_6     = offsetof(NRF_GPIOTE_Type, TASKS_SET[6]), /**< Set task 6.*/
S    NRF_GPIOTE_TASKS_SET_7     = offsetof(NRF_GPIOTE_Type, TASKS_SET[7]), /**< Set task 7.*/
N#endif
N#if defined(GPIOTE_FEATURE_CLR_PRESENT) || defined(__SDK_DOXYGEN__)
X#if 0L || 0L
S    NRF_GPIOTE_TASKS_CLR_0     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[0]), /**< Clear task 0.*/
S    NRF_GPIOTE_TASKS_CLR_1     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[1]), /**< Clear task 1.*/
S    NRF_GPIOTE_TASKS_CLR_2     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[2]), /**< Clear task 2.*/
S    NRF_GPIOTE_TASKS_CLR_3     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[3]), /**< Clear task 3.*/
S    NRF_GPIOTE_TASKS_CLR_4     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[4]), /**< Clear task 4.*/
S    NRF_GPIOTE_TASKS_CLR_5     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[5]), /**< Clear task 5.*/
S    NRF_GPIOTE_TASKS_CLR_6     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[6]), /**< Clear task 6.*/
S    NRF_GPIOTE_TASKS_CLR_7     = offsetof(NRF_GPIOTE_Type, TASKS_CLR[7]), /**< Clear task 7.*/
N#endif
N    /*lint -restore*/
N} nrf_gpiote_tasks_t;
N
N/**
N * @brief Events.
N */
Ntypedef enum /*lint -save -e30 -esym(628,__INTADDR__) */
N{
N    NRF_GPIOTE_EVENTS_IN_0     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[0]), /**< In event 0.*/
X    NRF_GPIOTE_EVENTS_IN_0     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->EVENTS_IN[0]))),  
N    NRF_GPIOTE_EVENTS_IN_1     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[1]), /**< In event 1.*/
X    NRF_GPIOTE_EVENTS_IN_1     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->EVENTS_IN[1]))),  
N    NRF_GPIOTE_EVENTS_IN_2     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[2]), /**< In event 2.*/
X    NRF_GPIOTE_EVENTS_IN_2     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->EVENTS_IN[2]))),  
N    NRF_GPIOTE_EVENTS_IN_3     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[3]), /**< In event 3.*/
X    NRF_GPIOTE_EVENTS_IN_3     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->EVENTS_IN[3]))),  
N#if (GPIOTE_CH_NUM > 4) || defined(__SDK_DOXYGEN__)
X#if (4 > 4) || 0L
S    NRF_GPIOTE_EVENTS_IN_4     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[4]), /**< In event 4.*/
S    NRF_GPIOTE_EVENTS_IN_5     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[5]), /**< In event 5.*/
S    NRF_GPIOTE_EVENTS_IN_6     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[6]), /**< In event 6.*/
S    NRF_GPIOTE_EVENTS_IN_7     = offsetof(NRF_GPIOTE_Type, EVENTS_IN[7]), /**< In event 7.*/
N#endif
N    NRF_GPIOTE_EVENTS_PORT     = offsetof(NRF_GPIOTE_Type, EVENTS_PORT), /**<  Port event.*/
X    NRF_GPIOTE_EVENTS_PORT     = (( size_t)__INTADDR__(&(((NRF_GPIOTE_Type *)0)->EVENTS_PORT))),  
N    /*lint -restore*/
N} nrf_gpiote_events_t;
N
N/**
N * @enum nrf_gpiote_int_t
N * @brief GPIOTE interrupts.
N */
Ntypedef enum
N{
N    NRF_GPIOTE_INT_IN0_MASK  = GPIOTE_INTENSET_IN0_Msk,  /**< GPIOTE interrupt from IN0. */
X    NRF_GPIOTE_INT_IN0_MASK  = (0x1UL << (0UL)),   
N    NRF_GPIOTE_INT_IN1_MASK  = GPIOTE_INTENSET_IN1_Msk,  /**< GPIOTE interrupt from IN1. */
X    NRF_GPIOTE_INT_IN1_MASK  = (0x1UL << (1UL)),   
N    NRF_GPIOTE_INT_IN2_MASK  = GPIOTE_INTENSET_IN2_Msk,  /**< GPIOTE interrupt from IN2. */
X    NRF_GPIOTE_INT_IN2_MASK  = (0x1UL << (2UL)),   
N    NRF_GPIOTE_INT_IN3_MASK  = GPIOTE_INTENSET_IN3_Msk,  /**< GPIOTE interrupt from IN3. */
X    NRF_GPIOTE_INT_IN3_MASK  = (0x1UL << (3UL)),   
N#if (GPIOTE_CH_NUM > 4) || defined(__SDK_DOXYGEN__)
X#if (4 > 4) || 0L
S    NRF_GPIOTE_INT_IN4_MASK  = GPIOTE_INTENSET_IN4_Msk,  /**< GPIOTE interrupt from IN4. */
S    NRF_GPIOTE_INT_IN5_MASK  = GPIOTE_INTENSET_IN5_Msk,  /**< GPIOTE interrupt from IN5. */
S    NRF_GPIOTE_INT_IN6_MASK  = GPIOTE_INTENSET_IN6_Msk,  /**< GPIOTE interrupt from IN6. */
S    NRF_GPIOTE_INT_IN7_MASK  = GPIOTE_INTENSET_IN7_Msk,  /**< GPIOTE interrupt from IN7. */
N#endif
N    NRF_GPIOTE_INT_PORT_MASK = (int)GPIOTE_INTENSET_PORT_Msk, /**< GPIOTE interrupt from PORT event. */
X    NRF_GPIOTE_INT_PORT_MASK = (int)(0x1UL << (31UL)),  
N} nrf_gpiote_int_t;
N
N#define NRF_GPIOTE_INT_IN_MASK (NRF_GPIOTE_INT_IN0_MASK | NRF_GPIOTE_INT_IN1_MASK |\
N                                NRF_GPIOTE_INT_IN2_MASK | NRF_GPIOTE_INT_IN3_MASK)
X#define NRF_GPIOTE_INT_IN_MASK (NRF_GPIOTE_INT_IN0_MASK | NRF_GPIOTE_INT_IN1_MASK |                                NRF_GPIOTE_INT_IN2_MASK | NRF_GPIOTE_INT_IN3_MASK)
N#if (GPIOTE_CH_NUM > 4)
X#if (4 > 4)
S#undef NRF_GPIOTE_INT_IN_MASK
S#define NRF_GPIOTE_INT_IN_MASK (NRF_GPIOTE_INT_IN0_MASK | NRF_GPIOTE_INT_IN1_MASK |\
S                                NRF_GPIOTE_INT_IN2_MASK | NRF_GPIOTE_INT_IN3_MASK |\
S                                NRF_GPIOTE_INT_IN4_MASK | NRF_GPIOTE_INT_IN5_MASK |\
S                                NRF_GPIOTE_INT_IN6_MASK | NRF_GPIOTE_INT_IN7_MASK)
X#define NRF_GPIOTE_INT_IN_MASK (NRF_GPIOTE_INT_IN0_MASK | NRF_GPIOTE_INT_IN1_MASK |                                NRF_GPIOTE_INT_IN2_MASK | NRF_GPIOTE_INT_IN3_MASK |                                NRF_GPIOTE_INT_IN4_MASK | NRF_GPIOTE_INT_IN5_MASK |                                NRF_GPIOTE_INT_IN6_MASK | NRF_GPIOTE_INT_IN7_MASK)
N#endif
N
N/**
N * @brief Function for activating a specific GPIOTE task.
N *
N * @param[in]  task Task.
N */
N__STATIC_INLINE void nrf_gpiote_task_set(nrf_gpiote_tasks_t task);
Xstatic __inline void nrf_gpiote_task_set(nrf_gpiote_tasks_t task);
N
N/**
N * @brief Function for getting the address of a specific GPIOTE task.
N *
N * @param[in] task Task.
N *
N * @returns Address.
N */
N__STATIC_INLINE uint32_t nrf_gpiote_task_addr_get(nrf_gpiote_tasks_t task);
Xstatic __inline uint32_t nrf_gpiote_task_addr_get(nrf_gpiote_tasks_t task);
N
N/**
N * @brief Function for getting the state of a specific GPIOTE event.
N *
N * @param[in] event Event.
N */
N__STATIC_INLINE bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event);
Xstatic __inline _Bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event);
N
N/**
N * @brief Function for clearing a specific GPIOTE event.
N *
N * @param[in] event Event.
N */
N__STATIC_INLINE void nrf_gpiote_event_clear(nrf_gpiote_events_t event);
Xstatic __inline void nrf_gpiote_event_clear(nrf_gpiote_events_t event);
N
N/**
N * @brief Function for getting the address of a specific GPIOTE event.
N *
N * @param[in] event Event.
N *
N * @return Address
N */
N__STATIC_INLINE uint32_t nrf_gpiote_event_addr_get(nrf_gpiote_events_t event);
Xstatic __inline uint32_t nrf_gpiote_event_addr_get(nrf_gpiote_events_t event);
N
N/**@brief Function for enabling interrupts.
N *
N * @param[in]  mask          Interrupt mask to be enabled.
N */
N__STATIC_INLINE void nrf_gpiote_int_enable(uint32_t mask);
Xstatic __inline void nrf_gpiote_int_enable(uint32_t mask);
N
N/**@brief Function for disabling interrupts.
N *
N * @param[in]  mask          Interrupt mask to be disabled.
N */
N__STATIC_INLINE void nrf_gpiote_int_disable(uint32_t mask);
Xstatic __inline void nrf_gpiote_int_disable(uint32_t mask);
N
N/**@brief Function for checking if interrupts are enabled.
N *
N * @param[in]  mask          Mask of interrupt flags to check.
N *
N * @return                   Mask with enabled interrupts.
N */
N__STATIC_INLINE uint32_t nrf_gpiote_int_is_enabled(uint32_t mask);
Xstatic __inline uint32_t nrf_gpiote_int_is_enabled(uint32_t mask);
N
N/**@brief Function for enabling a GPIOTE event.
N *
N * @param[in]  idx        Task-Event index.
N */
N__STATIC_INLINE void nrf_gpiote_event_enable(uint32_t idx);
Xstatic __inline void nrf_gpiote_event_enable(uint32_t idx);
N
N/**@brief Function for disabling a GPIOTE event.
N *
N * @param[in]  idx        Task-Event index.
N */
N__STATIC_INLINE void nrf_gpiote_event_disable(uint32_t idx);
Xstatic __inline void nrf_gpiote_event_disable(uint32_t idx);
N
N/**@brief Function for configuring a GPIOTE event.
N *
N * @param[in]  idx        Task-Event index.
N * @param[in]  pin        Pin associated with event.
N * @param[in]  polarity   Transition that should generate an event.
N */
N__STATIC_INLINE void nrf_gpiote_event_configure(uint32_t idx, uint32_t pin,
Xstatic __inline void nrf_gpiote_event_configure(uint32_t idx, uint32_t pin,
N                                                nrf_gpiote_polarity_t polarity);
N
N/**@brief Function for getting the pin associated with a GPIOTE event.
N *
N * @param[in]  idx        Task-Event index.
N *
N * @return Pin number.
N */
N__STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(uint32_t idx);
Xstatic __inline uint32_t nrf_gpiote_event_pin_get(uint32_t idx);
N
N/**@brief Function for getting the polarity associated with a GPIOTE event.
N *
N * @param[in]  idx        Task-Event index.
N *
N * @return Polarity.
N */
N__STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(uint32_t idx);
Xstatic __inline nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(uint32_t idx);
N
N/**@brief Function for enabling a GPIOTE task.
N *
N * @param[in]  idx        Task-Event index.
N */
N__STATIC_INLINE void nrf_gpiote_task_enable(uint32_t idx);
Xstatic __inline void nrf_gpiote_task_enable(uint32_t idx);
N
N/**@brief Function for disabling a GPIOTE task.
N *
N * @param[in]  idx        Task-Event index.
N */
N__STATIC_INLINE void nrf_gpiote_task_disable(uint32_t idx);
Xstatic __inline void nrf_gpiote_task_disable(uint32_t idx);
N
N/**@brief Function for configuring a GPIOTE task.
N * @note  Function is not configuring mode field so task is disabled after this function is called.
N *
N * @param[in]  idx        Task-Event index.
N * @param[in]  pin        Pin associated with event.
N * @param[in]  polarity   Transition that should generate an event.
N * @param[in]  init_val   Initial value of the pin.
N */
N__STATIC_INLINE void nrf_gpiote_task_configure(uint32_t idx, uint32_t pin,
Xstatic __inline void nrf_gpiote_task_configure(uint32_t idx, uint32_t pin,
N                                               nrf_gpiote_polarity_t polarity,
N                                               nrf_gpiote_outinit_t  init_val);
N
N/**@brief Function for forcing a specific state on the pin connected to GPIOTE.
N *
N * @param[in]  idx        Task-Event index.
N * @param[in]  init_val   Pin state.
N */
N__STATIC_INLINE void nrf_gpiote_task_force(uint32_t idx, nrf_gpiote_outinit_t init_val);
Xstatic __inline void nrf_gpiote_task_force(uint32_t idx, nrf_gpiote_outinit_t init_val);
N
N/**@brief Function for resetting a GPIOTE task event configuration to the default state.
N *
N * @param[in]  idx        Task-Event index.
N */
N__STATIC_INLINE void nrf_gpiote_te_default(uint32_t idx);
Xstatic __inline void nrf_gpiote_te_default(uint32_t idx);
N
N#ifndef SUPPRESS_INLINE_IMPLEMENTATION
N__STATIC_INLINE void nrf_gpiote_task_set(nrf_gpiote_tasks_t task)
Xstatic __inline void nrf_gpiote_task_set(nrf_gpiote_tasks_t task)
N{
N    *(__IO uint32_t *)((uint32_t)NRF_GPIOTE + task) = 0x1UL;
X    *(volatile uint32_t *)((uint32_t)((NRF_GPIOTE_Type *) 0x40006000UL) + task) = 0x1UL;
N}
N
N__STATIC_INLINE uint32_t nrf_gpiote_task_addr_get(nrf_gpiote_tasks_t task)
Xstatic __inline uint32_t nrf_gpiote_task_addr_get(nrf_gpiote_tasks_t task)
N{
N    return ((uint32_t)NRF_GPIOTE + task);
X    return ((uint32_t)((NRF_GPIOTE_Type *) 0x40006000UL) + task);
N}
N
N__STATIC_INLINE bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event)
Xstatic __inline _Bool nrf_gpiote_event_is_set(nrf_gpiote_events_t event)
N{
N    return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? true : false;
X    return (*(uint32_t *)nrf_gpiote_event_addr_get(event) == 0x1UL) ? 1 : 0;
N}
N
N__STATIC_INLINE void nrf_gpiote_event_clear(nrf_gpiote_events_t event)
Xstatic __inline void nrf_gpiote_event_clear(nrf_gpiote_events_t event)
N{
N    *(uint32_t *)nrf_gpiote_event_addr_get(event) = 0;
N#if __CORTEX_M == 0x04
X#if (0x00) == 0x04
S    volatile uint32_t dummy = *((volatile uint32_t *)nrf_gpiote_event_addr_get(event));
S    (void)dummy;
N#endif
N}
N
N__STATIC_INLINE uint32_t nrf_gpiote_event_addr_get(nrf_gpiote_events_t event)
Xstatic __inline uint32_t nrf_gpiote_event_addr_get(nrf_gpiote_events_t event)
N{
N    return ((uint32_t)NRF_GPIOTE + event);
X    return ((uint32_t)((NRF_GPIOTE_Type *) 0x40006000UL) + event);
N}
N
N__STATIC_INLINE void nrf_gpiote_int_enable(uint32_t mask)
Xstatic __inline void nrf_gpiote_int_enable(uint32_t mask)
N{
N    NRF_GPIOTE->INTENSET = mask;
X    ((NRF_GPIOTE_Type *) 0x40006000UL)->INTENSET = mask;
N}
N
N__STATIC_INLINE void nrf_gpiote_int_disable(uint32_t mask)
Xstatic __inline void nrf_gpiote_int_disable(uint32_t mask)
N{
N    NRF_GPIOTE->INTENCLR = mask;
X    ((NRF_GPIOTE_Type *) 0x40006000UL)->INTENCLR = mask;
N}
N
N__STATIC_INLINE uint32_t nrf_gpiote_int_is_enabled(uint32_t mask)
Xstatic __inline uint32_t nrf_gpiote_int_is_enabled(uint32_t mask)
N{
N    return (NRF_GPIOTE->INTENSET & mask);
X    return (((NRF_GPIOTE_Type *) 0x40006000UL)->INTENSET & mask);
N}
N
N__STATIC_INLINE void nrf_gpiote_event_enable(uint32_t idx)
Xstatic __inline void nrf_gpiote_event_enable(uint32_t idx)
N{
N   NRF_GPIOTE->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
X   ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] |= (0x01UL);
N}
N
N__STATIC_INLINE void nrf_gpiote_event_disable(uint32_t idx)
Xstatic __inline void nrf_gpiote_event_disable(uint32_t idx)
N{
N   NRF_GPIOTE->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
X   ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] &= ~(0x01UL);
N}
N
N__STATIC_INLINE void nrf_gpiote_event_configure(uint32_t idx, uint32_t pin, nrf_gpiote_polarity_t polarity)
Xstatic __inline void nrf_gpiote_event_configure(uint32_t idx, uint32_t pin, nrf_gpiote_polarity_t polarity)
N{
N  NRF_GPIOTE->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
X  ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] &= ~((0x1FUL << (8UL)) | (0x3UL << (16UL)));
N  NRF_GPIOTE->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
X  ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] |= ((pin << (8UL)) & (0x1FUL << (8UL))) |
N                              ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
X                              ((polarity << (16UL)) & (0x3UL << (16UL)));
N}
N
N__STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(uint32_t idx)
Xstatic __inline uint32_t nrf_gpiote_event_pin_get(uint32_t idx)
N{
N    return ((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
X    return ((((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] & (0x1FUL << (8UL))) >> (8UL));
N}
N
N__STATIC_INLINE nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(uint32_t idx)
Xstatic __inline nrf_gpiote_polarity_t nrf_gpiote_event_polarity_get(uint32_t idx)
N{
N    return (nrf_gpiote_polarity_t)((NRF_GPIOTE->CONFIG[idx] & GPIOTE_CONFIG_POLARITY_Msk) >> GPIOTE_CONFIG_POLARITY_Pos);
X    return (nrf_gpiote_polarity_t)((((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] & (0x3UL << (16UL))) >> (16UL));
N}
N
N__STATIC_INLINE void nrf_gpiote_task_enable(uint32_t idx)
Xstatic __inline void nrf_gpiote_task_enable(uint32_t idx)
N{
N    uint32_t final_config = NRF_GPIOTE->CONFIG[idx] | GPIOTE_CONFIG_MODE_Task;
X    uint32_t final_config = ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] | (0x03UL);
N#ifdef NRF51
N    /* Workaround for the OUTINIT PAN. When nrf_gpiote_task_config() is called a glitch happens
N    on the GPIO if the GPIO in question is already assigned to GPIOTE and the pin is in the
N    correct state in GPIOTE but not in the OUT register. */
N    /* Configure channel to not existing, not connected to the pin, and configure as a tasks that will set it to proper level */
N    NRF_GPIOTE->CONFIG[idx] = final_config | (((31) << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk);
X    ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] = final_config | (((31) << (8UL)) & (0x1FUL << (8UL)));
N    __NOP();
X    __nop();
N    __NOP();
X    __nop();
N    __NOP();
X    __nop();
N#endif
N    NRF_GPIOTE->CONFIG[idx] = final_config;
X    ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] = final_config;
N}
N
N__STATIC_INLINE void nrf_gpiote_task_disable(uint32_t idx)
Xstatic __inline void nrf_gpiote_task_disable(uint32_t idx)
N{
N    NRF_GPIOTE->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Task;
X    ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] &= ~(0x03UL);
N}
N
N__STATIC_INLINE void nrf_gpiote_task_configure(uint32_t idx, uint32_t pin,
Xstatic __inline void nrf_gpiote_task_configure(uint32_t idx, uint32_t pin,
N                                                nrf_gpiote_polarity_t polarity,
N                                                nrf_gpiote_outinit_t  init_val)
N{
N  NRF_GPIOTE->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk |
X  ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] &= ~((0x1FUL << (8UL)) |
N                               GPIOTE_CONFIG_POLARITY_Msk |
X                               (0x3UL << (16UL)) |
N                               GPIOTE_CONFIG_OUTINIT_Msk);
X                               (0x1UL << (20UL)));
N
N  NRF_GPIOTE->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
X  ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] |= ((pin << (8UL)) & (0x1FUL << (8UL))) |
N                             ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk) |
X                             ((polarity << (16UL)) & (0x3UL << (16UL))) |
N                             ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
X                             ((init_val << (20UL)) & (0x1UL << (20UL)));
N}
N
N__STATIC_INLINE void nrf_gpiote_task_force(uint32_t idx, nrf_gpiote_outinit_t init_val)
Xstatic __inline void nrf_gpiote_task_force(uint32_t idx, nrf_gpiote_outinit_t init_val)
N{
N    NRF_GPIOTE->CONFIG[idx] = (NRF_GPIOTE->CONFIG[idx] & ~GPIOTE_CONFIG_OUTINIT_Msk)
X    ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] = (((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] & ~(0x1UL << (20UL)))
N                              | ((init_val << GPIOTE_CONFIG_OUTINIT_Pos) & GPIOTE_CONFIG_OUTINIT_Msk);
X                              | ((init_val << (20UL)) & (0x1UL << (20UL)));
N}
N
N__STATIC_INLINE void nrf_gpiote_te_default(uint32_t idx)
Xstatic __inline void nrf_gpiote_te_default(uint32_t idx)
N{
N    NRF_GPIOTE->CONFIG[idx] = 0;
X    ((NRF_GPIOTE_Type *) 0x40006000UL)->CONFIG[idx] = 0;
N}
N#endif //SUPPRESS_INLINE_IMPLEMENTATION
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 55 "..\..\..\..\..\..\components\drivers_nrf\gpiote\nrf_drv_gpiote.h" 2
N#include "nrf_gpio.h"
N#include "sdk_errors.h"
N#include <stdint.h>
N#include <stdbool.h>
N#include "sdk_config.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**@brief Input pin configuration. */
Ntypedef struct
N{
N    nrf_gpiote_polarity_t sense;      /**< Transition that triggers interrupt. */
N    nrf_gpio_pin_pull_t   pull;       /**< Pulling mode. */
N    bool                  is_watcher; /**< True when the input pin is tracking an output pin. */
X    _Bool                  is_watcher;  
N    bool                  hi_accuracy;/**< True when high accuracy (IN_EVENT) is used. */
X    _Bool                  hi_accuracy; 
N} nrf_drv_gpiote_in_config_t;
N
N/**@brief Macro for configuring a pin to use a GPIO IN or PORT EVENT to detect low-to-high transition.
N * @details Set hi_accu to true to use IN_EVENT. */
N#define GPIOTE_CONFIG_IN_SENSE_LOTOHI(hi_accu)     \
N    {                                            \
N        .is_watcher = false,                     \
N        .hi_accuracy = hi_accu,                  \
N        .pull = NRF_GPIO_PIN_NOPULL,             \
N        .sense = NRF_GPIOTE_POLARITY_LOTOHI,     \
N    }
X#define GPIOTE_CONFIG_IN_SENSE_LOTOHI(hi_accu)         {                                                    .is_watcher = false,                             .hi_accuracy = hi_accu,                          .pull = NRF_GPIO_PIN_NOPULL,                     .sense = NRF_GPIOTE_POLARITY_LOTOHI,         }
N
N/**@brief Macro for configuring a pin to use a GPIO IN or PORT EVENT to detect high-to-low transition.
N * @details Set hi_accu to true to use IN_EVENT. */
N#define GPIOTE_CONFIG_IN_SENSE_HITOLO(hi_accu)      \
N    {                                            \
N        .is_watcher = false,                     \
N        .hi_accuracy = hi_accu,                  \
N        .pull = NRF_GPIO_PIN_NOPULL,             \
N        .sense = NRF_GPIOTE_POLARITY_HITOLO,     \
N    }
X#define GPIOTE_CONFIG_IN_SENSE_HITOLO(hi_accu)          {                                                    .is_watcher = false,                             .hi_accuracy = hi_accu,                          .pull = NRF_GPIO_PIN_NOPULL,                     .sense = NRF_GPIOTE_POLARITY_HITOLO,         }
N
N/**@brief Macro for configuring a pin to use a GPIO IN or PORT EVENT to detect any change on the pin.
N * @details Set hi_accu to true to use IN_EVENT.*/
N#define GPIOTE_CONFIG_IN_SENSE_TOGGLE(hi_accu)   \
N    {                                            \
N        .is_watcher = false,                     \
N        .hi_accuracy = hi_accu,                  \
N        .pull = NRF_GPIO_PIN_NOPULL,             \
N        .sense = NRF_GPIOTE_POLARITY_TOGGLE,     \
N    }
X#define GPIOTE_CONFIG_IN_SENSE_TOGGLE(hi_accu)       {                                                    .is_watcher = false,                             .hi_accuracy = hi_accu,                          .pull = NRF_GPIO_PIN_NOPULL,                     .sense = NRF_GPIOTE_POLARITY_TOGGLE,         }
N
N/**@brief Output pin configuration. */
Ntypedef struct
N{
N    nrf_gpiote_polarity_t action;    /**< Configuration of the pin task. */
N    nrf_gpiote_outinit_t  init_state; /**< Initial state of the output pin. */
N    bool                  task_pin;  /**< True if the pin is controlled by a GPIOTE task. */
X    _Bool                  task_pin;   
N} nrf_drv_gpiote_out_config_t;
N
N/**@brief Macro for configuring a pin to use as output. GPIOTE is not used for the pin. */
N#define GPIOTE_CONFIG_OUT_SIMPLE(init_high)                                                        \
N    {                                                                                              \
N        .init_state = init_high ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW,    \
N        .task_pin = false,                                                                         \
N    }
X#define GPIOTE_CONFIG_OUT_SIMPLE(init_high)                                                            {                                                                                                      .init_state = init_high ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW,            .task_pin = false,                                                                             }
N
N/**@brief Macro for configuring a pin to use the GPIO OUT TASK to change the state from high to low.
N * @details The task will clear the pin. Therefore, the pin is set initially.  */
N#define GPIOTE_CONFIG_OUT_TASK_LOW                                                                 \
N    {                                                                                              \
N        .init_state = NRF_GPIOTE_INITIAL_VALUE_HIGH,                                               \
N        .task_pin   = true,                                                                        \
N        .action     = NRF_GPIOTE_POLARITY_HITOLO,                                                  \
N    }
X#define GPIOTE_CONFIG_OUT_TASK_LOW                                                                     {                                                                                                      .init_state = NRF_GPIOTE_INITIAL_VALUE_HIGH,                                                       .task_pin   = true,                                                                                .action     = NRF_GPIOTE_POLARITY_HITOLO,                                                      }
N
N/**@brief Macro for configuring a pin to use the GPIO OUT TASK to change the state from low to high.
N * @details The task will set the pin. Therefore, the pin is cleared initially.  */
N#define GPIOTE_CONFIG_OUT_TASK_HIGH                                                                \
N    {                                                                                              \
N        .init_state = NRF_GPIOTE_INITIAL_VALUE_LOW,                                                \
N        .task_pin   = true,                                                                        \
N        .action     = NRF_GPIOTE_POLARITY_LOTOHI,                                                  \
N    }
X#define GPIOTE_CONFIG_OUT_TASK_HIGH                                                                    {                                                                                                      .init_state = NRF_GPIOTE_INITIAL_VALUE_LOW,                                                        .task_pin   = true,                                                                                .action     = NRF_GPIOTE_POLARITY_LOTOHI,                                                      }
N
N/**@brief Macro for configuring a pin to use the GPIO OUT TASK to toggle the pin state.
N * @details The initial pin state must be provided.  */
N#define GPIOTE_CONFIG_OUT_TASK_TOGGLE(init_high)                                                   \
N    {                                                                                              \
N        .init_state = init_high ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW,    \
N        .task_pin   = true,                                                                        \
N        .action     = NRF_GPIOTE_POLARITY_TOGGLE,                                                  \
N    }
X#define GPIOTE_CONFIG_OUT_TASK_TOGGLE(init_high)                                                       {                                                                                                      .init_state = init_high ? NRF_GPIOTE_INITIAL_VALUE_HIGH : NRF_GPIOTE_INITIAL_VALUE_LOW,            .task_pin   = true,                                                                                .action     = NRF_GPIOTE_POLARITY_TOGGLE,                                                      }
N
N/** @brief Pin. */
Ntypedef uint32_t nrf_drv_gpiote_pin_t;
N
N/**
N * @brief Pin event handler prototype.
N * @param pin    Pin that triggered this event.
N * @param action Action that lead to triggering this event.
N */
Ntypedef void (*nrf_drv_gpiote_evt_handler_t)(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action);
N
N/**
N * @brief Function for initializing the GPIOTE module.
N *
N * @details Only static configuration is supported to prevent the shared
N * resource being customized by the initiator.
N *
N * @retval    NRF_SUCCESS If initialization was successful.
N * @retval    NRF_ERROR_INVALID_STATE If the driver was already initialized.
N */
Nret_code_t nrf_drv_gpiote_init(void);
N
N/**
N * @brief Function for checking if the GPIOTE module is initialized.
N *
N * @details The GPIOTE module is a shared module. Therefore, you should check if
N * the module is already initialized and skip initialization if it is.
N *
N * @retval    true  If the module is already initialized.
N * @retval    false If the module is not initialized.
N */
Nbool nrf_drv_gpiote_is_init(void);
X_Bool nrf_drv_gpiote_is_init(void);
N
N/**
N * @brief Function for uninitializing the GPIOTE module.
N */
Nvoid nrf_drv_gpiote_uninit(void);
N
N/**
N * @brief Function for initializing a GPIOTE output pin.
N * @details The output pin can be controlled by the CPU or by PPI. The initial
N * configuration specifies which mode is used. If PPI mode is used, the driver
N * attempts to allocate one of the available GPIOTE channels. If no channel is
N * available, an error is returned.
N *
N * @param[in] pin       Pin.
N * @param[in] p_config  Initial configuration.
N *
N * @retval NRF_SUCCESS             If initialization was successful.
N * @retval NRF_ERROR_INVALID_STATE If the driver is not initialized or the pin is already used.
N * @retval NRF_ERROR_NO_MEM        If no GPIOTE channel is available.
N */
Nret_code_t nrf_drv_gpiote_out_init(nrf_drv_gpiote_pin_t pin,
N                                   nrf_drv_gpiote_out_config_t const * p_config);
N
N/**
N * @brief Function for uninitializing a GPIOTE output pin.
N * @details The driver frees the GPIOTE channel if the output pin was using one.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_out_uninit(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for setting a GPIOTE output pin.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_out_set(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for clearing a GPIOTE output pin.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_out_clear(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for toggling a GPIOTE output pin.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_out_toggle(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for enabling a GPIOTE output pin task.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_out_task_enable(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for disabling a GPIOTE output pin task.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_out_task_disable(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for getting the address of a configurable GPIOTE task.
N *
N * @param[in] pin       Pin.
N *
N * @return Address of OUT task.
N */
Nuint32_t nrf_drv_gpiote_out_task_addr_get(nrf_drv_gpiote_pin_t pin);
N
N#if defined(GPIOTE_FEATURE_SET_PRESENT)
X#if 0L
S/**
S * @brief Function for getting the address of a configurable GPIOTE task.
S *
S * @param[in] pin       Pin.
S *
S * @return Address of SET task.
S */
Suint32_t nrf_drv_gpiote_set_task_addr_get(nrf_drv_gpiote_pin_t pin);
N#endif // defined(GPIOTE_FEATURE_SET_PRESENT)
N
N#if defined(GPIOTE_FEATURE_CLR_PRESENT)
X#if 0L
S/**
S * @brief Function for getting the address of a configurable GPIOTE task.
S *
S * @param[in] pin       Pin.
S *
S * @return Address of CLR task.
S */
Suint32_t nrf_drv_gpiote_clr_task_addr_get(nrf_drv_gpiote_pin_t pin);
N#endif // defined(GPIOTE_FEATURE_CLR_PRESENT)
N
N/**
N * @brief Function for initializing a GPIOTE input pin.
N * @details The input pin can act in two ways:
N * - lower accuracy but low power (high frequency clock not needed)
N * - higher accuracy (high frequency clock required)
N *
N * The initial configuration specifies which mode is used.
N * If high-accuracy mode is used, the driver attempts to allocate one
N * of the available GPIOTE channels. If no channel is
N * available, an error is returned.
N * In low accuracy mode SENSE feature is used. In this case only one active pin
N * can be detected at a time. It can be worked around by setting all of the used
N * low accuracy pins to toggle mode.
N * For more information about SENSE functionality, refer to Product Specification.
N *
N * @param[in] pin       Pin.
N * @param[in] p_config    Initial configuration.
N * @param[in] evt_handler User function to be called when the configured transition occurs.
N *
N * @retval NRF_SUCCESS             If initialization was successful.
N * @retval NRF_ERROR_INVALID_STATE If the driver is not initialized or the pin is already used.
N * @retval NRF_ERROR_NO_MEM        If no GPIOTE channel is available.
N */
Nret_code_t nrf_drv_gpiote_in_init(nrf_drv_gpiote_pin_t pin,
N                                  nrf_drv_gpiote_in_config_t const * p_config,
N                                  nrf_drv_gpiote_evt_handler_t evt_handler);
N
N/**
N * @brief Function for uninitializing a GPIOTE input pin.
N * @details The driver frees the GPIOTE channel if the input pin was using one.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_in_uninit(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for enabling sensing of a GPIOTE input pin.
N *
N * @details If the input pin is configured as high-accuracy pin, the function
N * enables an IN_EVENT. Otherwise, the function enables the GPIO sense mechanism.
N * Note that a PORT event is shared between multiple pins, therefore the
N * interrupt is always enabled.
N *
N * @param[in] pin       Pin.
N * @param[in] int_enable  True to enable the interrupt. Always valid for a high-accuracy pin.
N */
Nvoid nrf_drv_gpiote_in_event_enable(nrf_drv_gpiote_pin_t pin, bool int_enable);
Xvoid nrf_drv_gpiote_in_event_enable(nrf_drv_gpiote_pin_t pin, _Bool int_enable);
N
N/**
N * @brief Function for disabling a GPIOTE input pin.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_in_event_disable(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for checking if a GPIOTE input pin is set.
N *
N * @param[in] pin       Pin.
N * @retval    true If the input pin is set.
N * @retval    false If the input pin is not set.
N */
Nbool nrf_drv_gpiote_in_is_set(nrf_drv_gpiote_pin_t pin);
X_Bool nrf_drv_gpiote_in_is_set(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for getting the address of a GPIOTE input pin event.
N * @details If the pin is configured to use low-accuracy mode, the address of the PORT event is returned.
N *
N * @param[in] pin       Pin.
N */
Nuint32_t nrf_drv_gpiote_in_event_addr_get(nrf_drv_gpiote_pin_t pin);
N
N/**
N * @brief Function for forcing a specific state on the pin configured as task.
N *
N * @param[in] pin       Pin.
N * @param[in] state     Pin state.
N */
Nvoid nrf_drv_gpiote_out_task_force(nrf_drv_gpiote_pin_t pin, uint8_t state);
N
N/**
N * @brief Function for triggering the task OUT manually.
N *
N * @param[in] pin       Pin.
N */
Nvoid nrf_drv_gpiote_out_task_trigger(nrf_drv_gpiote_pin_t pin);
N
N#ifdef NRF52_SERIES
S/**
S * @brief Function for triggering the task SET manually.
S *
S * @param[in] pin       Pin.
S */
Svoid nrf_drv_gpiote_set_task_trigger(nrf_drv_gpiote_pin_t pin);
S
S/**
S * @brief Function for triggering the task CLR manually.
S *
S * @param[in] pin       Pin.
S */
Svoid nrf_drv_gpiote_clr_task_trigger(nrf_drv_gpiote_pin_t pin);
N#endif
N
N/**
N *@}
N **/
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //NRF_DRV_GPIOTE__
L 46 "..\..\..\..\..\..\components\libraries\button\app_button.c" 2
N#include "nrf_assert.h"
N
N
Nstatic app_button_cfg_t const *       mp_buttons = NULL;           /**< Button configuration. */
Xstatic app_button_cfg_t const *       mp_buttons = 0;            
Nstatic uint8_t                        m_button_count;              /**< Number of configured buttons. */
Nstatic uint32_t                       m_detection_delay;           /**< Delay before a button is reported as pushed. */
NAPP_TIMER_DEF(m_detection_delay_timer_id);  /**< Polling timer id. */
Xstatic app_timer_t m_detection_delay_timer_id_data = { {0} }; static const app_timer_id_t m_detection_delay_timer_id = &m_detection_delay_timer_id_data;   
N
N
Nstatic uint32_t m_pin_state;
Nstatic uint32_t m_pin_transition;
N
N/**@brief Function for handling the timeout that delays reporting buttons as pushed.
N *
N * @details    The detection_delay_timeout_handler(...) is a call-back issued from the app_timer
N *             module. It is called with the p_context parameter. The p_context parameter is
N *             provided to the app_timer module when a timer is started, using the call
N *             @ref app_timer_start. On @ref app_timer_start the p_context will be holding the
N *             currently pressed buttons.
N *
N * @param[in]  p_context   Pointer used for passing information app_start_timer() was called.
N *                         In the app_button module the p_context holds information on pressed
N *                         buttons.
N */
Nstatic void detection_delay_timeout_handler(void * p_context)
N{
N    uint8_t i;
N
N    // Pushed button(s) detected, execute button handler(s).
N    for (i = 0; i < m_button_count; i++)
N    {
N        app_button_cfg_t const * p_btn = &mp_buttons[i];
N        uint32_t btn_mask = 1 << p_btn->pin_no;
N        if (btn_mask & m_pin_transition)
N        {
N            m_pin_transition &= ~btn_mask;
N            bool pin_is_set = nrf_drv_gpiote_in_is_set(p_btn->pin_no);
X            _Bool pin_is_set = nrf_drv_gpiote_in_is_set(p_btn->pin_no);
N            if ((m_pin_state & (1 << p_btn->pin_no)) == (pin_is_set << p_btn->pin_no))
N            {
N                uint32_t transition = !(pin_is_set ^ (p_btn->active_state == APP_BUTTON_ACTIVE_HIGH));
X                uint32_t transition = !(pin_is_set ^ (p_btn->active_state == 1));
N
N                if (p_btn->button_handler)
N                {
N                    p_btn->button_handler(p_btn->pin_no, transition);
N                }
N            }
N        }
N    }
N}
N
Nstatic void gpiote_event_handler(nrf_drv_gpiote_pin_t pin, nrf_gpiote_polarity_t action)
N{
N    uint32_t err_code;
N    uint32_t pin_mask = 1 << pin;
N
N    // Start detection timer. If timer is already running, the detection period is restarted.
N    // NOTE: Using the p_context parameter of app_timer_start() to transfer the pin states to the
N    //       timeout handler (by casting event_pins_mask into the equally sized void * p_context
N    //       parameter).
N    err_code = app_timer_stop(m_detection_delay_timer_id);
N    if (err_code != NRF_SUCCESS)
X    if (err_code != ((0x0) + 0))
N    {
N        // The impact in app_button of the app_timer queue running full is losing a button press.
N        // The current implementation ensures that the system will continue working as normal.
N        return;
N    }
N
N    if (!(m_pin_transition & pin_mask))
N    {
N        if (nrf_drv_gpiote_in_is_set(pin))
N        {
N            m_pin_state |= pin_mask;
N        }
N        else
N        {
N            m_pin_state &= ~(pin_mask);
N        }
N        m_pin_transition |= (pin_mask);
N
N        err_code = app_timer_start(m_detection_delay_timer_id, m_detection_delay, NULL);
X        err_code = app_timer_start(m_detection_delay_timer_id, m_detection_delay, 0);
N        if (err_code != NRF_SUCCESS)
X        if (err_code != ((0x0) + 0))
N        {
N            // The impact in app_button of the app_timer queue running full is losing a button press.
N            // The current implementation ensures that the system will continue working as normal.
N        }
N    }
N    else
N    {
N        m_pin_transition &= ~pin_mask;
N    }
N}
N
Nuint32_t app_button_init(app_button_cfg_t const *       p_buttons,
N                         uint8_t                        button_count,
N                         uint32_t                       detection_delay)
N{
N    uint32_t err_code;
N
N    if (detection_delay < APP_TIMER_MIN_TIMEOUT_TICKS)
X    if (detection_delay < 5)
N    {
N        return NRF_ERROR_INVALID_PARAM;
X        return ((0x0) + 7);
N    }
N
N    if (!nrf_drv_gpiote_is_init())
N    {
N        err_code = nrf_drv_gpiote_init();
N        VERIFY_SUCCESS(err_code);
X        do { if (!((err_code) == ((0x0) + 0))) { return (err_code); } } while (0);
N    }
N
N    // Save configuration.
N    mp_buttons          = p_buttons;
N    m_button_count      = button_count;
N    m_detection_delay   = detection_delay;
N
N    m_pin_state      = 0;
N    m_pin_transition = 0;
N
N    while (button_count--)
N    {
N        app_button_cfg_t const * p_btn = &p_buttons[button_count];
N
N        nrf_drv_gpiote_in_config_t config = GPIOTE_CONFIG_IN_SENSE_TOGGLE(false);
X        nrf_drv_gpiote_in_config_t config = { . is_watcher = 0, . hi_accuracy = 0, . pull = NRF_GPIO_PIN_NOPULL, . sense = NRF_GPIOTE_POLARITY_TOGGLE, };
N        config.pull = p_btn->pull_cfg;
N
N        err_code = nrf_drv_gpiote_in_init(p_btn->pin_no, &config, gpiote_event_handler);
N        VERIFY_SUCCESS(err_code);
X        do { if (!((err_code) == ((0x0) + 0))) { return (err_code); } } while (0);
N    }
N
N    // Create polling timer.
N    return app_timer_create(&m_detection_delay_timer_id,
N                            APP_TIMER_MODE_SINGLE_SHOT,
N                            detection_delay_timeout_handler);
N}
N
Nuint32_t app_button_enable(void)
N{
N    ASSERT(mp_buttons);
X    if (0) { if (mp_buttons) { } else { assert_nrf_callback((uint16_t)182, (uint8_t *)"..\\..\\..\\..\\..\\..\\components\\libraries\\button\\app_button.c"); } };
N
N    uint32_t i;
N    for (i = 0; i < m_button_count; i++)
N    {
N        nrf_drv_gpiote_in_event_enable(mp_buttons[i].pin_no, true);
X        nrf_drv_gpiote_in_event_enable(mp_buttons[i].pin_no, 1);
N    }
N
N    return NRF_SUCCESS;
X    return ((0x0) + 0);
N}
N
N
Nuint32_t app_button_disable(void)
N{
N    ASSERT(mp_buttons);
X    if (0) { if (mp_buttons) { } else { assert_nrf_callback((uint16_t)196, (uint8_t *)"..\\..\\..\\..\\..\\..\\components\\libraries\\button\\app_button.c"); } };
N
N    uint32_t i;
N    for (i = 0; i < m_button_count; i++)
N    {
N       nrf_drv_gpiote_in_event_disable(mp_buttons[i].pin_no);
N    }
N
N    // Make sure polling timer is not running.
N    return app_timer_stop(m_detection_delay_timer_id);
N}
N
N
Nbool app_button_is_pushed(uint8_t button_id)
X_Bool app_button_is_pushed(uint8_t button_id)
N{
N    ASSERT(button_id <= m_button_count);
X    if (0) { if (button_id <= m_button_count) { } else { assert_nrf_callback((uint16_t)211, (uint8_t *)"..\\..\\..\\..\\..\\..\\components\\libraries\\button\\app_button.c"); } };
N    ASSERT(mp_buttons != NULL);
X    if (0) { if (mp_buttons != 0) { } else { assert_nrf_callback((uint16_t)212, (uint8_t *)"..\\..\\..\\..\\..\\..\\components\\libraries\\button\\app_button.c"); } };
N
N    app_button_cfg_t const * p_btn = &mp_buttons[button_id];
N    bool is_set = nrf_drv_gpiote_in_is_set(p_btn->pin_no);
X    _Bool is_set = nrf_drv_gpiote_in_is_set(p_btn->pin_no);
N
N    return !(is_set ^ (p_btn->active_state == APP_BUTTON_ACTIVE_HIGH));
X    return !(is_set ^ (p_btn->active_state == 1));
N}
N#endif //NRF_MODULE_ENABLED(BUTTON)
