; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\ble_advdata.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\ble_advdata.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\ble_advdata.crf ..\..\..\..\..\..\components\ble\common\ble_advdata.c]
                          THUMB

                          AREA ||i.adv_data_encode||, CODE, READONLY, ALIGN=1

                  adv_data_encode PROC
;;;501    
;;;502    uint32_t adv_data_encode(ble_advdata_t const * const p_advdata,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;503                             uint8_t             * const p_encoded_data,
;;;504                             uint16_t            * const p_len)
;;;505    {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4616              MOV      r6,r2
;;;506        uint32_t err_code = NRF_SUCCESS;
000008  2500              MOVS     r5,#0
;;;507        uint16_t max_size = *p_len;
00000a  8837              LDRH     r7,[r6,#0]
;;;508        *p_len = 0;
00000c  2000              MOVS     r0,#0
00000e  8030              STRH     r0,[r6,#0]
;;;509    
;;;510        // Encode LE Bluetooth Device Address
;;;511        if (p_advdata->include_ble_device_addr)
000010  202d              MOVS     r0,#0x2d
000012  5d00              LDRB     r0,[r0,r4]
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L1.50|
;;;512        {
;;;513            err_code = ble_device_addr_encode(p_encoded_data, p_len, max_size);
000018  463a              MOV      r2,r7
00001a  4631              MOV      r1,r6
00001c  9803              LDR      r0,[sp,#0xc]
00001e  f7fffffe          BL       ble_device_addr_encode
000022  4605              MOV      r5,r0
;;;514            VERIFY_SUCCESS(err_code);
000024  bf00              NOP      
000026  2d00              CMP      r5,#0
000028  d002              BEQ      |L1.48|
00002a  4628              MOV      r0,r5
                  |L1.44|
;;;515        }
;;;516    
;;;517        // Encode appearance.
;;;518        if (p_advdata->include_appearance)
;;;519        {
;;;520            err_code = appearance_encode(p_encoded_data, p_len, max_size);
;;;521            VERIFY_SUCCESS(err_code);
;;;522        }
;;;523    
;;;524        //Encode Flags
;;;525        if (p_advdata->flags != 0 )
;;;526        {
;;;527            err_code = flags_encode(p_advdata->flags, p_encoded_data, p_len, max_size);
;;;528            VERIFY_SUCCESS(err_code);
;;;529        }
;;;530    
;;;531        // Encode TX power level.
;;;532        if (p_advdata->p_tx_power_level != NULL)
;;;533        {
;;;534            err_code = tx_power_level_encode(*p_advdata->p_tx_power_level,
;;;535                                             p_encoded_data,
;;;536                                             p_len,
;;;537                                             max_size);
;;;538            VERIFY_SUCCESS(err_code);
;;;539        }
;;;540    
;;;541        // Encode 'more available' uuid list.
;;;542        if (p_advdata->uuids_more_available.uuid_cnt > 0)
;;;543        {
;;;544            err_code = uuid_list_encode(&p_advdata->uuids_more_available,
;;;545                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;546                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE,
;;;547                                        p_encoded_data,
;;;548                                        p_len,
;;;549                                        max_size);
;;;550            VERIFY_SUCCESS(err_code);
;;;551        }
;;;552    
;;;553        // Encode 'complete' uuid list.
;;;554        if (p_advdata->uuids_complete.uuid_cnt > 0)
;;;555        {
;;;556            err_code = uuid_list_encode(&p_advdata->uuids_complete,
;;;557                                        BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE,
;;;558                                        BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE,
;;;559                                        p_encoded_data,
;;;560                                        p_len,
;;;561                                        max_size);
;;;562            VERIFY_SUCCESS(err_code);
;;;563        }
;;;564    
;;;565        // Encode 'solicited service' uuid list.
;;;566        if (p_advdata->uuids_solicited.uuid_cnt > 0)
;;;567        {
;;;568            err_code = uuid_list_encode(&p_advdata->uuids_solicited,
;;;569                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT,
;;;570                                        BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT,
;;;571                                        p_encoded_data,
;;;572                                        p_len,
;;;573                                        max_size);
;;;574            VERIFY_SUCCESS(err_code);
;;;575        }
;;;576    
;;;577        // Encode Slave Connection Interval Range.
;;;578        if (p_advdata->p_slave_conn_int != NULL)
;;;579        {
;;;580            err_code = conn_int_encode(p_advdata->p_slave_conn_int, p_encoded_data, p_len, max_size);
;;;581            VERIFY_SUCCESS(err_code);
;;;582        }
;;;583    
;;;584        // Encode Manufacturer Specific Data.
;;;585        if (p_advdata->p_manuf_specific_data != NULL)
;;;586        {
;;;587            err_code = manuf_specific_data_encode(p_advdata->p_manuf_specific_data,
;;;588                                                  p_encoded_data,
;;;589                                                  p_len,
;;;590                                                  max_size);
;;;591            VERIFY_SUCCESS(err_code);
;;;592        }
;;;593    
;;;594        // Encode Service Data.
;;;595        if (p_advdata->service_data_count > 0)
;;;596        {
;;;597            err_code = service_data_encode(p_advdata, p_encoded_data, p_len, max_size);
;;;598            VERIFY_SUCCESS(err_code);
;;;599        }
;;;600    
;;;601        // Encode name. WARNING: it is encoded last on purpose since too long device name is truncated.
;;;602        if (p_advdata->name_type != BLE_ADVDATA_NO_NAME)
;;;603        {
;;;604            err_code = name_encode(p_advdata, p_encoded_data, p_len, max_size);
;;;605            VERIFY_SUCCESS(err_code);
;;;606        }
;;;607    
;;;608        return err_code;
;;;609    }
00002c  b005              ADD      sp,sp,#0x14
00002e  bdf0              POP      {r4-r7,pc}
                  |L1.48|
000030  bf00              NOP                            ;514
                  |L1.50|
000032  78a0              LDRB     r0,[r4,#2]            ;518
000034  2800              CMP      r0,#0                 ;518
000036  d00b              BEQ      |L1.80|
000038  463a              MOV      r2,r7                 ;520
00003a  4631              MOV      r1,r6                 ;520
00003c  9803              LDR      r0,[sp,#0xc]          ;520
00003e  f7fffffe          BL       appearance_encode
000042  4605              MOV      r5,r0                 ;520
000044  bf00              NOP                            ;521
000046  2d00              CMP      r5,#0                 ;521
000048  d001              BEQ      |L1.78|
00004a  4628              MOV      r0,r5                 ;521
00004c  e7ee              B        |L1.44|
                  |L1.78|
00004e  bf00              NOP                            ;521
                  |L1.80|
000050  78e0              LDRB     r0,[r4,#3]            ;525
000052  2800              CMP      r0,#0                 ;525
000054  d00d              BEQ      |L1.114|
000056  78e1              LDRB     r1,[r4,#3]            ;527
000058  b248              SXTB     r0,r1                 ;527
00005a  463b              MOV      r3,r7                 ;527
00005c  4632              MOV      r2,r6                 ;527
00005e  9903              LDR      r1,[sp,#0xc]          ;527
000060  f7fffffe          BL       flags_encode
000064  4605              MOV      r5,r0                 ;527
000066  bf00              NOP                            ;528
000068  2d00              CMP      r5,#0                 ;528
00006a  d001              BEQ      |L1.112|
00006c  4628              MOV      r0,r5                 ;528
00006e  e7dd              B        |L1.44|
                  |L1.112|
000070  bf00              NOP                            ;528
                  |L1.114|
000072  6860              LDR      r0,[r4,#4]            ;532
000074  2800              CMP      r0,#0                 ;532
000076  d00e              BEQ      |L1.150|
000078  2000              MOVS     r0,#0                 ;534
00007a  6861              LDR      r1,[r4,#4]            ;534
00007c  5608              LDRSB    r0,[r1,r0]            ;534
00007e  463b              MOV      r3,r7                 ;534
000080  4632              MOV      r2,r6                 ;534
000082  9903              LDR      r1,[sp,#0xc]          ;534
000084  f7fffffe          BL       tx_power_level_encode
000088  4605              MOV      r5,r0                 ;534
00008a  bf00              NOP                            ;538
00008c  2d00              CMP      r5,#0                 ;538
00008e  d001              BEQ      |L1.148|
000090  4628              MOV      r0,r5                 ;538
000092  e7cb              B        |L1.44|
                  |L1.148|
000094  bf00              NOP                            ;538
                  |L1.150|
000096  8920              LDRH     r0,[r4,#8]            ;542
000098  2800              CMP      r0,#0                 ;542
00009a  dd0f              BLE      |L1.188|
00009c  9701              STR      r7,[sp,#4]            ;544
00009e  9600              STR      r6,[sp,#0]            ;544
0000a0  2206              MOVS     r2,#6                 ;544
0000a2  2102              MOVS     r1,#2                 ;544
0000a4  4620              MOV      r0,r4                 ;544
0000a6  3008              ADDS     r0,r0,#8              ;544
0000a8  9b03              LDR      r3,[sp,#0xc]          ;544
0000aa  f7fffffe          BL       uuid_list_encode
0000ae  4605              MOV      r5,r0                 ;544
0000b0  bf00              NOP                            ;550
0000b2  2d00              CMP      r5,#0                 ;550
0000b4  d001              BEQ      |L1.186|
0000b6  4628              MOV      r0,r5                 ;550
0000b8  e7b8              B        |L1.44|
                  |L1.186|
0000ba  bf00              NOP                            ;550
                  |L1.188|
0000bc  8a20              LDRH     r0,[r4,#0x10]         ;554
0000be  2800              CMP      r0,#0                 ;554
0000c0  dd0f              BLE      |L1.226|
0000c2  9701              STR      r7,[sp,#4]            ;556
0000c4  9600              STR      r6,[sp,#0]            ;556
0000c6  2207              MOVS     r2,#7                 ;556
0000c8  2103              MOVS     r1,#3                 ;556
0000ca  4620              MOV      r0,r4                 ;556
0000cc  3010              ADDS     r0,r0,#0x10           ;556
0000ce  9b03              LDR      r3,[sp,#0xc]          ;556
0000d0  f7fffffe          BL       uuid_list_encode
0000d4  4605              MOV      r5,r0                 ;556
0000d6  bf00              NOP                            ;562
0000d8  2d00              CMP      r5,#0                 ;562
0000da  d001              BEQ      |L1.224|
0000dc  4628              MOV      r0,r5                 ;562
0000de  e7a5              B        |L1.44|
                  |L1.224|
0000e0  bf00              NOP                            ;562
                  |L1.226|
0000e2  8b20              LDRH     r0,[r4,#0x18]         ;566
0000e4  2800              CMP      r0,#0                 ;566
0000e6  dd0f              BLE      |L1.264|
0000e8  9701              STR      r7,[sp,#4]            ;568
0000ea  9600              STR      r6,[sp,#0]            ;568
0000ec  2215              MOVS     r2,#0x15              ;568
0000ee  2114              MOVS     r1,#0x14              ;568
0000f0  4620              MOV      r0,r4                 ;568
0000f2  3018              ADDS     r0,r0,#0x18           ;568
0000f4  9b03              LDR      r3,[sp,#0xc]          ;568
0000f6  f7fffffe          BL       uuid_list_encode
0000fa  4605              MOV      r5,r0                 ;568
0000fc  bf00              NOP                            ;574
0000fe  2d00              CMP      r5,#0                 ;574
000100  d001              BEQ      |L1.262|
000102  4628              MOV      r0,r5                 ;574
000104  e792              B        |L1.44|
                  |L1.262|
000106  bf00              NOP                            ;574
                  |L1.264|
000108  6a20              LDR      r0,[r4,#0x20]         ;578
00010a  2800              CMP      r0,#0                 ;578
00010c  d00c              BEQ      |L1.296|
00010e  463b              MOV      r3,r7                 ;580
000110  4632              MOV      r2,r6                 ;580
000112  6a20              LDR      r0,[r4,#0x20]         ;580
000114  9903              LDR      r1,[sp,#0xc]          ;580
000116  f7fffffe          BL       conn_int_encode
00011a  4605              MOV      r5,r0                 ;580
00011c  bf00              NOP                            ;581
00011e  2d00              CMP      r5,#0                 ;581
000120  d001              BEQ      |L1.294|
000122  4628              MOV      r0,r5                 ;581
000124  e782              B        |L1.44|
                  |L1.294|
000126  bf00              NOP                            ;581
                  |L1.296|
000128  6a60              LDR      r0,[r4,#0x24]         ;585
00012a  2800              CMP      r0,#0                 ;585
00012c  d00c              BEQ      |L1.328|
00012e  463b              MOV      r3,r7                 ;587
000130  4632              MOV      r2,r6                 ;587
000132  6a60              LDR      r0,[r4,#0x24]         ;587
000134  9903              LDR      r1,[sp,#0xc]          ;587
000136  f7fffffe          BL       manuf_specific_data_encode
00013a  4605              MOV      r5,r0                 ;587
00013c  bf00              NOP                            ;591
00013e  2d00              CMP      r5,#0                 ;591
000140  d001              BEQ      |L1.326|
000142  4628              MOV      r0,r5                 ;591
000144  e772              B        |L1.44|
                  |L1.326|
000146  bf00              NOP                            ;591
                  |L1.328|
000148  202c              MOVS     r0,#0x2c              ;595
00014a  5d00              LDRB     r0,[r0,r4]            ;595
00014c  2800              CMP      r0,#0                 ;595
00014e  dd0c              BLE      |L1.362|
000150  463b              MOV      r3,r7                 ;597
000152  4632              MOV      r2,r6                 ;597
000154  4620              MOV      r0,r4                 ;597
000156  9903              LDR      r1,[sp,#0xc]          ;597
000158  f7fffffe          BL       service_data_encode
00015c  4605              MOV      r5,r0                 ;597
00015e  bf00              NOP                            ;598
000160  2d00              CMP      r5,#0                 ;598
000162  d001              BEQ      |L1.360|
000164  4628              MOV      r0,r5                 ;598
000166  e761              B        |L1.44|
                  |L1.360|
000168  bf00              NOP                            ;598
                  |L1.362|
00016a  7820              LDRB     r0,[r4,#0]            ;602
00016c  2800              CMP      r0,#0                 ;602
00016e  d00c              BEQ      |L1.394|
000170  463b              MOV      r3,r7                 ;604
000172  4632              MOV      r2,r6                 ;604
000174  4620              MOV      r0,r4                 ;604
000176  9903              LDR      r1,[sp,#0xc]          ;604
000178  f7fffffe          BL       name_encode
00017c  4605              MOV      r5,r0                 ;604
00017e  bf00              NOP                            ;605
000180  2d00              CMP      r5,#0                 ;605
000182  d001              BEQ      |L1.392|
000184  4628              MOV      r0,r5                 ;605
000186  e751              B        |L1.44|
                  |L1.392|
000188  bf00              NOP                            ;605
                  |L1.394|
00018a  4628              MOV      r0,r5                 ;608
00018c  e74e              B        |L1.44|
;;;610    
                          ENDP


                          AREA ||i.advdata_check||, CODE, READONLY, ALIGN=1

                  advdata_check PROC
;;;611    
;;;612    static uint32_t advdata_check(const ble_advdata_t * p_advdata)
000000  4601              MOV      r1,r0
;;;613    {
;;;614        // Flags must be included in advertising data, and the BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED flag must be set.
;;;615        if (
000002  78c8              LDRB     r0,[r1,#3]
000004  2204              MOVS     r2,#4
000006  4010              ANDS     r0,r0,r2
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L2.16|
;;;616            ((p_advdata->flags & BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED) == 0)
;;;617           )
;;;618        {
;;;619            return NRF_ERROR_INVALID_PARAM;
00000c  2007              MOVS     r0,#7
                  |L2.14|
;;;620        }
;;;621    
;;;622        return NRF_SUCCESS;
;;;623    }
00000e  4770              BX       lr
                  |L2.16|
000010  2000              MOVS     r0,#0                 ;622
000012  e7fc              B        |L2.14|
;;;624    
                          ENDP


                          AREA ||i.appearance_encode||, CODE, READONLY, ALIGN=1

                  appearance_encode PROC
;;;169    
;;;170    static uint32_t appearance_encode(uint8_t  * p_encoded_data,
000000  b5f8              PUSH     {r3-r7,lr}
;;;171                                      uint16_t * p_offset,
;;;172                                      uint16_t   max_size)
;;;173    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;174        uint32_t err_code;
;;;175        uint16_t appearance;
;;;176    
;;;177        // Check for buffer overflow.
;;;178        if (((*p_offset) + AD_TYPE_APPEARANCE_SIZE) > max_size)
000008  8820              LDRH     r0,[r4,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  42b8              CMP      r0,r7
00000e  d901              BLS      |L3.20|
;;;179        {
;;;180            return NRF_ERROR_DATA_SIZE;
000010  200c              MOVS     r0,#0xc
                  |L3.18|
;;;181        }
;;;182    
;;;183        // Get GAP appearance field.
;;;184        err_code = sd_ble_gap_appearance_get(&appearance);
;;;185        VERIFY_SUCCESS(err_code);
;;;186    
;;;187        // Encode Length, AD Type and Appearance.
;;;188        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + AD_TYPE_APPEARANCE_DATA_SIZE);
;;;189        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;190        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_APPEARANCE;
;;;191        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;192        *p_offset                 += uint16_encode(appearance, &p_encoded_data[*p_offset]);
;;;193    
;;;194        return NRF_SUCCESS;
;;;195    }
000012  bdf8              POP      {r3-r7,pc}
                  |L3.20|
000014  4668              MOV      r0,sp                 ;184
000016  df79              SVC      #0x79                 ;184
000018  4606              MOV      r6,r0                 ;184
00001a  bf00              NOP                            ;185
00001c  2e00              CMP      r6,#0                 ;185
00001e  d001              BEQ      |L3.36|
000020  4630              MOV      r0,r6                 ;185
000022  e7f6              B        |L3.18|
                  |L3.36|
000024  bf00              NOP                            ;185
000026  2003              MOVS     r0,#3                 ;188
000028  8821              LDRH     r1,[r4,#0]            ;188
00002a  5468              STRB     r0,[r5,r1]            ;188
00002c  8820              LDRH     r0,[r4,#0]            ;189
00002e  1c40              ADDS     r0,r0,#1              ;189
000030  8020              STRH     r0,[r4,#0]            ;189
000032  2019              MOVS     r0,#0x19              ;190
000034  8821              LDRH     r1,[r4,#0]            ;190
000036  5468              STRB     r0,[r5,r1]            ;190
000038  8820              LDRH     r0,[r4,#0]            ;191
00003a  1c40              ADDS     r0,r0,#1              ;191
00003c  8020              STRH     r0,[r4,#0]            ;191
00003e  8820              LDRH     r0,[r4,#0]            ;192
000040  1941              ADDS     r1,r0,r5              ;192
000042  4668              MOV      r0,sp                 ;192
000044  8800              LDRH     r0,[r0,#0]            ;192
000046  f7fffffe          BL       uint16_encode
00004a  8821              LDRH     r1,[r4,#0]            ;192
00004c  1840              ADDS     r0,r0,r1              ;192
00004e  8020              STRH     r0,[r4,#0]            ;192
000050  2000              MOVS     r0,#0                 ;194
000052  e7de              B        |L3.18|
;;;196    
                          ENDP


                          AREA ||i.ble_advdata_set||, CODE, READONLY, ALIGN=1

                  ble_advdata_set PROC
;;;637    
;;;638    uint32_t ble_advdata_set(const ble_advdata_t * p_advdata, const ble_advdata_t * p_srdata)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;639    {
000002  b093              SUB      sp,sp,#0x4c
000004  460d              MOV      r5,r1
;;;640        uint32_t  err_code;
;;;641        uint16_t  len_advdata = BLE_GAP_ADV_MAX_SIZE;
000006  211f              MOVS     r1,#0x1f
000008  9112              STR      r1,[sp,#0x48]
;;;642        uint16_t  len_srdata  = BLE_GAP_ADV_MAX_SIZE;
00000a  9111              STR      r1,[sp,#0x44]
;;;643        uint8_t   encoded_advdata[BLE_GAP_ADV_MAX_SIZE];
;;;644        uint8_t   encoded_srdata[BLE_GAP_ADV_MAX_SIZE];
;;;645        uint8_t * p_encoded_advdata;
;;;646        uint8_t * p_encoded_srdata;
;;;647    
;;;648        // Encode advertising data (if supplied).
;;;649        if (p_advdata != NULL)
00000c  9813              LDR      r0,[sp,#0x4c]
00000e  2800              CMP      r0,#0
000010  d018              BEQ      |L4.68|
;;;650        {
;;;651            err_code = advdata_check(p_advdata);
000012  9813              LDR      r0,[sp,#0x4c]
000014  f7fffffe          BL       advdata_check
000018  4604              MOV      r4,r0
;;;652            VERIFY_SUCCESS(err_code);
00001a  bf00              NOP      
00001c  2c00              CMP      r4,#0
00001e  d002              BEQ      |L4.38|
000020  4620              MOV      r0,r4
                  |L4.34|
;;;653    
;;;654            err_code = adv_data_encode(p_advdata, encoded_advdata, &len_advdata);
;;;655            VERIFY_SUCCESS(err_code);
;;;656            p_encoded_advdata = encoded_advdata;
;;;657        }
;;;658        else
;;;659        {
;;;660            p_encoded_advdata = NULL;
;;;661            len_advdata = 0;
;;;662        }
;;;663    
;;;664        // Encode scan response data (if supplied).
;;;665        if (p_srdata != NULL)
;;;666        {
;;;667            err_code = srdata_check(p_srdata);
;;;668            VERIFY_SUCCESS(err_code);
;;;669    
;;;670            err_code = adv_data_encode(p_srdata, encoded_srdata, &len_srdata);
;;;671            VERIFY_SUCCESS(err_code);
;;;672            p_encoded_srdata = encoded_srdata;
;;;673        }
;;;674        else
;;;675        {
;;;676            p_encoded_srdata = NULL;
;;;677            len_srdata = 0;
;;;678        }
;;;679    
;;;680        // Pass encoded advertising data and/or scan response data to the stack.
;;;681        return sd_ble_gap_adv_data_set(p_encoded_advdata, len_advdata, p_encoded_srdata, len_srdata);
;;;682    }
000022  b015              ADD      sp,sp,#0x54
000024  bdf0              POP      {r4-r7,pc}
                  |L4.38|
000026  bf00              NOP                            ;652
000028  aa12              ADD      r2,sp,#0x48           ;654
00002a  a909              ADD      r1,sp,#0x24           ;654
00002c  9813              LDR      r0,[sp,#0x4c]         ;654
00002e  f7fffffe          BL       adv_data_encode
000032  4604              MOV      r4,r0                 ;654
000034  bf00              NOP                            ;655
000036  2c00              CMP      r4,#0                 ;655
000038  d001              BEQ      |L4.62|
00003a  4620              MOV      r0,r4                 ;655
00003c  e7f1              B        |L4.34|
                  |L4.62|
00003e  bf00              NOP                            ;655
000040  ae09              ADD      r6,sp,#0x24           ;656
000042  e002              B        |L4.74|
                  |L4.68|
000044  2600              MOVS     r6,#0                 ;660
000046  2000              MOVS     r0,#0                 ;661
000048  9012              STR      r0,[sp,#0x48]         ;661
                  |L4.74|
00004a  2d00              CMP      r5,#0                 ;665
00004c  d017              BEQ      |L4.126|
00004e  4628              MOV      r0,r5                 ;667
000050  f7fffffe          BL       srdata_check
000054  4604              MOV      r4,r0                 ;667
000056  bf00              NOP                            ;668
000058  2c00              CMP      r4,#0                 ;668
00005a  d001              BEQ      |L4.96|
00005c  4620              MOV      r0,r4                 ;668
00005e  e7e0              B        |L4.34|
                  |L4.96|
000060  bf00              NOP                            ;668
000062  aa11              ADD      r2,sp,#0x44           ;670
000064  a901              ADD      r1,sp,#4              ;670
000066  4628              MOV      r0,r5                 ;670
000068  f7fffffe          BL       adv_data_encode
00006c  4604              MOV      r4,r0                 ;670
00006e  bf00              NOP                            ;671
000070  2c00              CMP      r4,#0                 ;671
000072  d001              BEQ      |L4.120|
000074  4620              MOV      r0,r4                 ;671
000076  e7d4              B        |L4.34|
                  |L4.120|
000078  bf00              NOP                            ;671
00007a  af01              ADD      r7,sp,#4              ;672
00007c  e002              B        |L4.132|
                  |L4.126|
00007e  2700              MOVS     r7,#0                 ;676
000080  2000              MOVS     r0,#0                 ;677
000082  9011              STR      r0,[sp,#0x44]         ;677
                  |L4.132|
000084  a810              ADD      r0,sp,#0x40           ;681
000086  8880              LDRH     r0,[r0,#4]            ;681
000088  b2c3              UXTB     r3,r0                 ;681
00008a  a810              ADD      r0,sp,#0x40           ;681
00008c  8900              LDRH     r0,[r0,#8]            ;681
00008e  b2c1              UXTB     r1,r0                 ;681
000090  463a              MOV      r2,r7                 ;681
000092  4630              MOV      r0,r6                 ;681
000094  df72              SVC      #0x72                 ;681
000096  e7c4              B        |L4.34|
                          ENDP


                          AREA ||i.ble_device_addr_encode||, CODE, READONLY, ALIGN=1

                  ble_device_addr_encode PROC
;;;51     
;;;52     static uint32_t ble_device_addr_encode(uint8_t  * p_encoded_data,
000000  b5fe              PUSH     {r1-r7,lr}
;;;53                                            uint16_t * p_offset,
;;;54                                            uint16_t   max_size)
;;;55     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;56         uint32_t err_code;
;;;57         ble_gap_addr_t device_addr;
;;;58     
;;;59         // Check for buffer overflow.
;;;60         if (((*p_offset) + AD_TYPE_BLE_DEVICE_ADDR_SIZE) > max_size)
000008  8820              LDRH     r0,[r4,#0]
00000a  3009              ADDS     r0,r0,#9
00000c  42b8              CMP      r0,r7
00000e  d901              BLS      |L5.20|
;;;61         {
;;;62             return NRF_ERROR_DATA_SIZE;
000010  200c              MOVS     r0,#0xc
                  |L5.18|
;;;63         }
;;;64     
;;;65         // Get BLE address.
;;;66         #if (NRF_SD_BLE_API_VERSION == 3)
;;;67             err_code = sd_ble_gap_addr_get(&device_addr);
;;;68         #else
;;;69             err_code = sd_ble_gap_address_get(&device_addr);
;;;70         #endif
;;;71         VERIFY_SUCCESS(err_code);
;;;72     
;;;73         // Encode LE Bluetooth Device Address.
;;;74         p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE +
;;;75                                                    AD_TYPE_BLE_DEVICE_ADDR_DATA_SIZE);
;;;76         *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;77         p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS;
;;;78         *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;79         memcpy(&p_encoded_data[*p_offset], &device_addr.addr[0], BLE_GAP_ADDR_LEN);
;;;80         *p_offset                 += BLE_GAP_ADDR_LEN;
;;;81         if (BLE_GAP_ADDR_TYPE_PUBLIC == device_addr.addr_type)
;;;82         {
;;;83             p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_PUBLIC;
;;;84         }
;;;85         else
;;;86         {
;;;87             p_encoded_data[*p_offset] = AD_TYPE_BLE_DEVICE_ADDR_TYPE_RANDOM;
;;;88         }
;;;89         *p_offset += AD_TYPE_BLE_DEVICE_ADDR_TYPE_SIZE;
;;;90     
;;;91         return NRF_SUCCESS;
;;;92     }
000012  bdfe              POP      {r1-r7,pc}
                  |L5.20|
000014  4668              MOV      r0,sp                 ;69
000016  df71              SVC      #0x71                 ;69
000018  4606              MOV      r6,r0                 ;69
00001a  bf00              NOP                            ;71
00001c  2e00              CMP      r6,#0                 ;71
00001e  d001              BEQ      |L5.36|
000020  4630              MOV      r0,r6                 ;71
000022  e7f6              B        |L5.18|
                  |L5.36|
000024  bf00              NOP                            ;71
000026  2008              MOVS     r0,#8                 ;74
000028  8821              LDRH     r1,[r4,#0]            ;74
00002a  5468              STRB     r0,[r5,r1]            ;74
00002c  8820              LDRH     r0,[r4,#0]            ;76
00002e  1c40              ADDS     r0,r0,#1              ;76
000030  8020              STRH     r0,[r4,#0]            ;76
000032  201b              MOVS     r0,#0x1b              ;77
000034  8821              LDRH     r1,[r4,#0]            ;77
000036  5468              STRB     r0,[r5,r1]            ;77
000038  8820              LDRH     r0,[r4,#0]            ;78
00003a  1c40              ADDS     r0,r0,#1              ;78
00003c  8020              STRH     r0,[r4,#0]            ;78
00003e  8821              LDRH     r1,[r4,#0]            ;79
000040  1948              ADDS     r0,r1,r5              ;79
000042  2206              MOVS     r2,#6                 ;79
000044  a900              ADD      r1,sp,#0              ;79
000046  3101              ADDS     r1,#1                 ;79
000048  f7fffffe          BL       __aeabi_memcpy
00004c  8820              LDRH     r0,[r4,#0]            ;80
00004e  1d80              ADDS     r0,r0,#6              ;80
000050  8020              STRH     r0,[r4,#0]            ;80
000052  4668              MOV      r0,sp                 ;81
000054  7800              LDRB     r0,[r0,#0]            ;81
000056  2800              CMP      r0,#0                 ;81
000058  d102              BNE      |L5.96|
00005a  8821              LDRH     r1,[r4,#0]            ;83
00005c  5468              STRB     r0,[r5,r1]            ;83
00005e  e002              B        |L5.102|
                  |L5.96|
000060  2001              MOVS     r0,#1                 ;87
000062  8821              LDRH     r1,[r4,#0]            ;87
000064  5468              STRB     r0,[r5,r1]            ;87
                  |L5.102|
000066  8820              LDRH     r0,[r4,#0]            ;89
000068  1c40              ADDS     r0,r0,#1              ;89
00006a  8020              STRH     r0,[r4,#0]            ;89
00006c  2000              MOVS     r0,#0                 ;91
00006e  e7d0              B        |L5.18|
;;;93     
                          ENDP


                          AREA ||i.conn_int_check||, CODE, READONLY, ALIGN=2

                  conn_int_check PROC
;;;338    
;;;339    static uint32_t conn_int_check(const ble_advdata_conn_int_t *p_conn_int)
000000  4601              MOV      r1,r0
;;;340    {
;;;341        // Check Minimum Connection Interval.
;;;342        if ((p_conn_int->min_conn_interval < 0x0006) ||
000002  8808              LDRH     r0,[r1,#0]
000004  2806              CMP      r0,#6
000006  db08              BLT      |L6.26|
;;;343            (
;;;344                (p_conn_int->min_conn_interval > 0x0c80) &&
000008  8808              LDRH     r0,[r1,#0]
00000a  2219              MOVS     r2,#0x19
00000c  01d2              LSLS     r2,r2,#7
00000e  4290              CMP      r0,r2
000010  dd05              BLE      |L6.30|
;;;345                (p_conn_int->min_conn_interval != 0xffff)
000012  8808              LDRH     r0,[r1,#0]
000014  4a10              LDR      r2,|L6.88|
000016  4290              CMP      r0,r2
000018  d001              BEQ      |L6.30|
                  |L6.26|
;;;346            )
;;;347           )
;;;348        {
;;;349            return NRF_ERROR_INVALID_PARAM;
00001a  2007              MOVS     r0,#7
                  |L6.28|
;;;350        }
;;;351    
;;;352        // Check Maximum Connection Interval.
;;;353        if ((p_conn_int->max_conn_interval < 0x0006) ||
;;;354            (
;;;355                (p_conn_int->max_conn_interval > 0x0c80) &&
;;;356                (p_conn_int->max_conn_interval != 0xffff)
;;;357            )
;;;358           )
;;;359        {
;;;360            return NRF_ERROR_INVALID_PARAM;
;;;361        }
;;;362    
;;;363        // Make sure Minimum Connection Interval is not bigger than Maximum Connection Interval.
;;;364        if ((p_conn_int->min_conn_interval != 0xffff) &&
;;;365            (p_conn_int->max_conn_interval != 0xffff) &&
;;;366            (p_conn_int->min_conn_interval > p_conn_int->max_conn_interval)
;;;367            )
;;;368        {
;;;369            return NRF_ERROR_INVALID_PARAM;
;;;370        }
;;;371    
;;;372        return NRF_SUCCESS;
;;;373    }
00001c  4770              BX       lr
                  |L6.30|
00001e  8848              LDRH     r0,[r1,#2]            ;353
000020  2806              CMP      r0,#6                 ;353
000022  db08              BLT      |L6.54|
000024  8848              LDRH     r0,[r1,#2]            ;355
000026  2219              MOVS     r2,#0x19              ;355
000028  01d2              LSLS     r2,r2,#7              ;355
00002a  4290              CMP      r0,r2                 ;355
00002c  dd05              BLE      |L6.58|
00002e  8848              LDRH     r0,[r1,#2]            ;356
000030  4a09              LDR      r2,|L6.88|
000032  4290              CMP      r0,r2                 ;356
000034  d001              BEQ      |L6.58|
                  |L6.54|
000036  2007              MOVS     r0,#7                 ;360
000038  e7f0              B        |L6.28|
                  |L6.58|
00003a  8808              LDRH     r0,[r1,#0]            ;364
00003c  4a06              LDR      r2,|L6.88|
00003e  4290              CMP      r0,r2                 ;364
000040  d008              BEQ      |L6.84|
000042  8848              LDRH     r0,[r1,#2]            ;365
000044  4290              CMP      r0,r2                 ;365
000046  d005              BEQ      |L6.84|
000048  8808              LDRH     r0,[r1,#0]            ;366
00004a  884a              LDRH     r2,[r1,#2]            ;366
00004c  4290              CMP      r0,r2                 ;366
00004e  dd01              BLE      |L6.84|
000050  2007              MOVS     r0,#7                 ;369
000052  e7e3              B        |L6.28|
                  |L6.84|
000054  2000              MOVS     r0,#0                 ;372
000056  e7e1              B        |L6.28|
;;;374    
                          ENDP

                  |L6.88|
                          DCD      0x0000ffff

                          AREA ||i.conn_int_encode||, CODE, READONLY, ALIGN=1

                  conn_int_encode PROC
;;;375    
;;;376    static uint32_t conn_int_encode(const ble_advdata_conn_int_t * p_conn_int,
000000  b5ff              PUSH     {r0-r7,lr}
;;;377                                    uint8_t                      * p_encoded_data,
;;;378                                    uint16_t                     * p_offset,
;;;379                                    uint16_t                       max_size)
;;;380    {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;381        uint32_t err_code;
;;;382    
;;;383        // Check for buffer overflow.
;;;384        if (((*p_offset) + AD_TYPE_CONN_INT_SIZE) > max_size)
00000a  8820              LDRH     r0,[r4,#0]
00000c  1d80              ADDS     r0,r0,#6
00000e  9904              LDR      r1,[sp,#0x10]
000010  4288              CMP      r0,r1
000012  d902              BLS      |L7.26|
;;;385        {
;;;386            return NRF_ERROR_DATA_SIZE;
000014  200c              MOVS     r0,#0xc
                  |L7.22|
;;;387        }
;;;388    
;;;389        // Check parameters.
;;;390        err_code = conn_int_check(p_conn_int);
;;;391        VERIFY_SUCCESS(err_code);
;;;392    
;;;393        // Encode Length and AD Type.
;;;394        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + AD_TYPE_CONN_INT_DATA_SIZE);
;;;395        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;396        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE;
;;;397        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;398    
;;;399        // Encode Minimum and Maximum Connection Intervals.
;;;400        *p_offset += uint16_encode(p_conn_int->min_conn_interval, &p_encoded_data[*p_offset]);
;;;401        *p_offset += uint16_encode(p_conn_int->max_conn_interval, &p_encoded_data[*p_offset]);
;;;402    
;;;403        return NRF_SUCCESS;
;;;404    }
000016  b005              ADD      sp,sp,#0x14
000018  bdf0              POP      {r4-r7,pc}
                  |L7.26|
00001a  4630              MOV      r0,r6                 ;390
00001c  f7fffffe          BL       conn_int_check
000020  4607              MOV      r7,r0                 ;390
000022  bf00              NOP                            ;391
000024  2f00              CMP      r7,#0                 ;391
000026  d001              BEQ      |L7.44|
000028  4638              MOV      r0,r7                 ;391
00002a  e7f4              B        |L7.22|
                  |L7.44|
00002c  bf00              NOP                            ;391
00002e  2005              MOVS     r0,#5                 ;394
000030  8821              LDRH     r1,[r4,#0]            ;394
000032  5468              STRB     r0,[r5,r1]            ;394
000034  8820              LDRH     r0,[r4,#0]            ;395
000036  1c40              ADDS     r0,r0,#1              ;395
000038  8020              STRH     r0,[r4,#0]            ;395
00003a  2012              MOVS     r0,#0x12              ;396
00003c  8821              LDRH     r1,[r4,#0]            ;396
00003e  5468              STRB     r0,[r5,r1]            ;396
000040  8820              LDRH     r0,[r4,#0]            ;397
000042  1c40              ADDS     r0,r0,#1              ;397
000044  8020              STRH     r0,[r4,#0]            ;397
000046  8822              LDRH     r2,[r4,#0]            ;400
000048  1951              ADDS     r1,r2,r5              ;400
00004a  8830              LDRH     r0,[r6,#0]            ;400
00004c  f7fffffe          BL       uint16_encode
000050  8821              LDRH     r1,[r4,#0]            ;400
000052  1840              ADDS     r0,r0,r1              ;400
000054  8020              STRH     r0,[r4,#0]            ;400
000056  8822              LDRH     r2,[r4,#0]            ;401
000058  1951              ADDS     r1,r2,r5              ;401
00005a  8870              LDRH     r0,[r6,#2]            ;401
00005c  f7fffffe          BL       uint16_encode
000060  8821              LDRH     r1,[r4,#0]            ;401
000062  1840              ADDS     r0,r0,r1              ;401
000064  8020              STRH     r0,[r4,#0]            ;401
000066  2000              MOVS     r0,#0                 ;403
000068  e7d5              B        |L7.22|
;;;405    
                          ENDP


                          AREA ||i.flags_encode||, CODE, READONLY, ALIGN=1

                  flags_encode PROC
;;;196    
;;;197    static uint32_t flags_encode(int8_t     flags,
000000  b530              PUSH     {r4,r5,lr}
;;;198                                 uint8_t  * p_encoded_data,
;;;199                                 uint16_t * p_offset,
;;;200                                 uint16_t   max_size)
;;;201    {
000002  4604              MOV      r4,r0
;;;202        // Check for buffer overflow.
;;;203        if (((*p_offset) + AD_TYPE_FLAGS_SIZE) > max_size)
000004  8810              LDRH     r0,[r2,#0]
000006  1cc0              ADDS     r0,r0,#3
000008  4298              CMP      r0,r3
00000a  d901              BLS      |L8.16|
;;;204        {
;;;205            return NRF_ERROR_DATA_SIZE;
00000c  200c              MOVS     r0,#0xc
                  |L8.14|
;;;206        }
;;;207    
;;;208        // Encode flags.
;;;209        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + AD_TYPE_FLAGS_DATA_SIZE);
;;;210        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;211        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_FLAGS;
;;;212        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;213        p_encoded_data[*p_offset]  = flags;
;;;214        *p_offset                 += AD_TYPE_FLAGS_DATA_SIZE;
;;;215    
;;;216        return NRF_SUCCESS;
;;;217    }
00000e  bd30              POP      {r4,r5,pc}
                  |L8.16|
000010  2002              MOVS     r0,#2                 ;209
000012  8815              LDRH     r5,[r2,#0]            ;209
000014  5548              STRB     r0,[r1,r5]            ;209
000016  8810              LDRH     r0,[r2,#0]            ;210
000018  1c40              ADDS     r0,r0,#1              ;210
00001a  8010              STRH     r0,[r2,#0]            ;210
00001c  2001              MOVS     r0,#1                 ;211
00001e  8815              LDRH     r5,[r2,#0]            ;211
000020  5548              STRB     r0,[r1,r5]            ;211
000022  8810              LDRH     r0,[r2,#0]            ;212
000024  1c40              ADDS     r0,r0,#1              ;212
000026  8010              STRH     r0,[r2,#0]            ;212
000028  8815              LDRH     r5,[r2,#0]            ;213
00002a  554c              STRB     r4,[r1,r5]            ;213
00002c  8810              LDRH     r0,[r2,#0]            ;214
00002e  1c40              ADDS     r0,r0,#1              ;214
000030  8010              STRH     r0,[r2,#0]            ;214
000032  2000              MOVS     r0,#0                 ;216
000034  e7eb              B        |L8.14|
;;;218    
                          ENDP


                          AREA ||i.manuf_specific_data_encode||, CODE, READONLY, ALIGN=1

                  manuf_specific_data_encode PROC
;;;406    
;;;407    static uint32_t manuf_specific_data_encode(const ble_advdata_manuf_data_t * p_manuf_sp_data,
000000  b5ff              PUSH     {r0-r7,lr}
;;;408                                               uint8_t                        * p_encoded_data,
;;;409                                               uint16_t                       * p_offset,
;;;410                                               uint16_t                         max_size)
;;;411    {
000002  b081              SUB      sp,sp,#4
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;412        uint32_t data_size = AD_TYPE_MANUF_SPEC_DATA_ID_SIZE + p_manuf_sp_data->data.size;
00000a  88a8              LDRH     r0,[r5,#4]
00000c  1c87              ADDS     r7,r0,#2
;;;413    
;;;414        // Check for buffer overflow.
;;;415        if (((*p_offset) + ADV_AD_DATA_OFFSET + data_size) > max_size)
00000e  8820              LDRH     r0,[r4,#0]
000010  1c80              ADDS     r0,r0,#2
000012  19c1              ADDS     r1,r0,r7
000014  9804              LDR      r0,[sp,#0x10]
000016  4281              CMP      r1,r0
000018  d902              BLS      |L9.32|
;;;416        {
;;;417            return NRF_ERROR_DATA_SIZE;
00001a  200c              MOVS     r0,#0xc
                  |L9.28|
;;;418        }
;;;419    
;;;420        // There is only 1 byte intended to encode length which is (data_size + ADV_AD_TYPE_FIELD_SIZE)
;;;421        if (data_size > (0x00FF - ADV_AD_TYPE_FIELD_SIZE))
;;;422        {
;;;423            return NRF_ERROR_DATA_SIZE;
;;;424        }
;;;425    
;;;426        // Encode Length and AD Type.
;;;427        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + data_size);
;;;428        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;429        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA;
;;;430        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;431    
;;;432        // Encode Company Identifier.
;;;433        *p_offset += uint16_encode(p_manuf_sp_data->company_identifier, &p_encoded_data[*p_offset]);
;;;434    
;;;435        // Encode additional manufacturer specific data.
;;;436        if (p_manuf_sp_data->data.size > 0)
;;;437        {
;;;438            if (p_manuf_sp_data->data.p_data == NULL)
;;;439            {
;;;440                return NRF_ERROR_INVALID_PARAM;
;;;441            }
;;;442            memcpy(&p_encoded_data[*p_offset], p_manuf_sp_data->data.p_data, p_manuf_sp_data->data.size);
;;;443            *p_offset += p_manuf_sp_data->data.size;
;;;444        }
;;;445    
;;;446        return NRF_SUCCESS;
;;;447    }
00001c  b005              ADD      sp,sp,#0x14
00001e  bdf0              POP      {r4-r7,pc}
                  |L9.32|
000020  2ffe              CMP      r7,#0xfe              ;421
000022  d901              BLS      |L9.40|
000024  200c              MOVS     r0,#0xc               ;423
000026  e7f9              B        |L9.28|
                  |L9.40|
000028  1c78              ADDS     r0,r7,#1              ;427
00002a  8821              LDRH     r1,[r4,#0]            ;427
00002c  5470              STRB     r0,[r6,r1]            ;427
00002e  8820              LDRH     r0,[r4,#0]            ;428
000030  1c40              ADDS     r0,r0,#1              ;428
000032  8020              STRH     r0,[r4,#0]            ;428
000034  20ff              MOVS     r0,#0xff              ;429
000036  8821              LDRH     r1,[r4,#0]            ;429
000038  5470              STRB     r0,[r6,r1]            ;429
00003a  8820              LDRH     r0,[r4,#0]            ;430
00003c  1c40              ADDS     r0,r0,#1              ;430
00003e  8020              STRH     r0,[r4,#0]            ;430
000040  8822              LDRH     r2,[r4,#0]            ;433
000042  1991              ADDS     r1,r2,r6              ;433
000044  8828              LDRH     r0,[r5,#0]            ;433
000046  f7fffffe          BL       uint16_encode
00004a  8821              LDRH     r1,[r4,#0]            ;433
00004c  1840              ADDS     r0,r0,r1              ;433
00004e  8020              STRH     r0,[r4,#0]            ;433
000050  88a8              LDRH     r0,[r5,#4]            ;436
000052  2800              CMP      r0,#0                 ;436
000054  dd0e              BLE      |L9.116|
000056  68a8              LDR      r0,[r5,#8]            ;438
000058  2800              CMP      r0,#0                 ;438
00005a  d101              BNE      |L9.96|
00005c  2007              MOVS     r0,#7                 ;440
00005e  e7dd              B        |L9.28|
                  |L9.96|
000060  88aa              LDRH     r2,[r5,#4]            ;442
000062  8823              LDRH     r3,[r4,#0]            ;442
000064  1998              ADDS     r0,r3,r6              ;442
000066  68a9              LDR      r1,[r5,#8]            ;442
000068  f7fffffe          BL       __aeabi_memcpy
00006c  8820              LDRH     r0,[r4,#0]            ;443
00006e  88a9              LDRH     r1,[r5,#4]            ;443
000070  1840              ADDS     r0,r0,r1              ;443
000072  8020              STRH     r0,[r4,#0]            ;443
                  |L9.116|
000074  2000              MOVS     r0,#0                 ;446
000076  e7d1              B        |L9.28|
;;;448    
                          ENDP


                          AREA ||i.name_encode||, CODE, READONLY, ALIGN=1

                  name_encode PROC
;;;93     
;;;94     static uint32_t name_encode(const ble_advdata_t * p_advdata,
000000  b5ff              PUSH     {r0-r7,lr}
;;;95                                 uint8_t             * p_encoded_data,
;;;96                                 uint16_t            * p_offset,
;;;97                                 uint16_t              max_size)
;;;98     {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;99         uint32_t err_code;
;;;100        uint16_t rem_adv_data_len;
;;;101        uint16_t actual_length;
;;;102        uint8_t  adv_data_format;
;;;103    
;;;104    
;;;105        // Validate parameters
;;;106        if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) && (0 == p_advdata->short_name_len))
00000a  7828              LDRB     r0,[r5,#0]
00000c  2801              CMP      r0,#1
00000e  d105              BNE      |L10.28|
000010  7868              LDRB     r0,[r5,#1]
000012  2800              CMP      r0,#0
000014  d102              BNE      |L10.28|
;;;107        {
;;;108            return NRF_ERROR_INVALID_PARAM;
000016  2007              MOVS     r0,#7
                  |L10.24|
;;;109        }
;;;110    
;;;111        // Check for buffer overflow.
;;;112        if ( (((*p_offset) + ADV_AD_DATA_OFFSET) > max_size) ||
;;;113             ( (BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
;;;114               (((*p_offset) + ADV_AD_DATA_OFFSET + p_advdata->short_name_len) > max_size)))
;;;115        {
;;;116            return NRF_ERROR_DATA_SIZE;
;;;117        }
;;;118    
;;;119        rem_adv_data_len = max_size - (*p_offset) - ADV_AD_DATA_OFFSET;
;;;120        actual_length    = rem_adv_data_len;
;;;121    
;;;122        // Get GAP device name and length
;;;123        err_code = sd_ble_gap_device_name_get(&p_encoded_data[(*p_offset) + ADV_AD_DATA_OFFSET],
;;;124                                              &actual_length);
;;;125        VERIFY_SUCCESS(err_code);
;;;126    
;;;127        // Check if device intend to use short name and it can fit available data size.
;;;128        if ((p_advdata->name_type == BLE_ADVDATA_FULL_NAME) && (actual_length <= rem_adv_data_len))
;;;129        {
;;;130            // Complete device name can fit, setting Complete Name in Adv Data.
;;;131            adv_data_format = BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME;
;;;132        }
;;;133        else
;;;134        {
;;;135            // Else short name needs to be used. Or application has requested use of short name.
;;;136            adv_data_format = BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME;
;;;137    
;;;138            // If application has set a preference on the short name size, it needs to be considered,
;;;139            // else fit what can be fit.
;;;140            if ((BLE_ADVDATA_SHORT_NAME == p_advdata->name_type) &&
;;;141                    (p_advdata->short_name_len <= rem_adv_data_len))
;;;142            {
;;;143                // Short name fits available size.
;;;144                actual_length = p_advdata->short_name_len;
;;;145            }
;;;146            // Else whatever can fit the data buffer will be packed.
;;;147            else
;;;148            {
;;;149                actual_length = rem_adv_data_len;
;;;150            }
;;;151        }
;;;152    
;;;153        // There is only 1 byte intended to encode length which is (actual_length + ADV_AD_TYPE_FIELD_SIZE)
;;;154        if (actual_length > (0x00FF - ADV_AD_TYPE_FIELD_SIZE))
;;;155        {
;;;156            return NRF_ERROR_DATA_SIZE;
;;;157        }
;;;158    
;;;159        // Complete name field in encoded data.
;;;160        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + actual_length);
;;;161        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;162        p_encoded_data[*p_offset]  = adv_data_format;
;;;163        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;164        *p_offset                 += actual_length;
;;;165    
;;;166        return NRF_SUCCESS;
;;;167    }
000018  b007              ADD      sp,sp,#0x1c
00001a  bdf0              POP      {r4-r7,pc}
                  |L10.28|
00001c  8820              LDRH     r0,[r4,#0]            ;112
00001e  1c80              ADDS     r0,r0,#2              ;112
000020  9906              LDR      r1,[sp,#0x18]         ;112
000022  4288              CMP      r0,r1                 ;112
000024  d809              BHI      |L10.58|
000026  7828              LDRB     r0,[r5,#0]            ;113
000028  2801              CMP      r0,#1                 ;113
00002a  d108              BNE      |L10.62|
00002c  8820              LDRH     r0,[r4,#0]            ;114
00002e  1c80              ADDS     r0,r0,#2              ;114
000030  7869              LDRB     r1,[r5,#1]            ;114
000032  1841              ADDS     r1,r0,r1              ;114
000034  9806              LDR      r0,[sp,#0x18]         ;114
000036  4281              CMP      r1,r0                 ;114
000038  d901              BLS      |L10.62|
                  |L10.58|
00003a  200c              MOVS     r0,#0xc               ;116
00003c  e7ec              B        |L10.24|
                  |L10.62|
00003e  8821              LDRH     r1,[r4,#0]            ;119
000040  9806              LDR      r0,[sp,#0x18]         ;119
000042  1a40              SUBS     r0,r0,r1              ;119
000044  1e80              SUBS     r0,r0,#2              ;119
000046  b286              UXTH     r6,r0                 ;119
000048  9601              STR      r6,[sp,#4]            ;120
00004a  8821              LDRH     r1,[r4,#0]            ;123
00004c  1c89              ADDS     r1,r1,#2              ;123
00004e  19c8              ADDS     r0,r1,r7              ;123
000050  a901              ADD      r1,sp,#4              ;123
000052  df7d              SVC      #0x7d                 ;123
000054  9002              STR      r0,[sp,#8]            ;123
000056  bf00              NOP                            ;125
000058  9802              LDR      r0,[sp,#8]            ;125
00005a  2800              CMP      r0,#0                 ;125
00005c  d001              BEQ      |L10.98|
00005e  9802              LDR      r0,[sp,#8]            ;125
000060  e7da              B        |L10.24|
                  |L10.98|
000062  bf00              NOP                            ;125
000064  7828              LDRB     r0,[r5,#0]            ;128
000066  2802              CMP      r0,#2                 ;128
000068  d106              BNE      |L10.120|
00006a  4668              MOV      r0,sp                 ;128
00006c  8880              LDRH     r0,[r0,#4]            ;128
00006e  42b0              CMP      r0,r6                 ;128
000070  dc02              BGT      |L10.120|
000072  2009              MOVS     r0,#9                 ;131
000074  9000              STR      r0,[sp,#0]            ;131
000076  e00b              B        |L10.144|
                  |L10.120|
000078  2008              MOVS     r0,#8                 ;136
00007a  9000              STR      r0,[sp,#0]            ;136
00007c  7828              LDRB     r0,[r5,#0]            ;140
00007e  2801              CMP      r0,#1                 ;140
000080  d105              BNE      |L10.142|
000082  7868              LDRB     r0,[r5,#1]            ;141
000084  42b0              CMP      r0,r6                 ;141
000086  dc02              BGT      |L10.142|
000088  7868              LDRB     r0,[r5,#1]            ;144
00008a  9001              STR      r0,[sp,#4]            ;144
00008c  e000              B        |L10.144|
                  |L10.142|
00008e  9601              STR      r6,[sp,#4]            ;149
                  |L10.144|
000090  4668              MOV      r0,sp                 ;154
000092  8880              LDRH     r0,[r0,#4]            ;154
000094  28fe              CMP      r0,#0xfe              ;154
000096  d901              BLS      |L10.156|
000098  200c              MOVS     r0,#0xc               ;156
00009a  e7bd              B        |L10.24|
                  |L10.156|
00009c  4668              MOV      r0,sp                 ;160
00009e  8880              LDRH     r0,[r0,#4]            ;160
0000a0  1c40              ADDS     r0,r0,#1              ;160
0000a2  8821              LDRH     r1,[r4,#0]            ;160
0000a4  5478              STRB     r0,[r7,r1]            ;160
0000a6  8820              LDRH     r0,[r4,#0]            ;161
0000a8  1c40              ADDS     r0,r0,#1              ;161
0000aa  8020              STRH     r0,[r4,#0]            ;161
0000ac  8821              LDRH     r1,[r4,#0]            ;162
0000ae  9800              LDR      r0,[sp,#0]            ;162
0000b0  5478              STRB     r0,[r7,r1]            ;162
0000b2  8820              LDRH     r0,[r4,#0]            ;163
0000b4  1c40              ADDS     r0,r0,#1              ;163
0000b6  8020              STRH     r0,[r4,#0]            ;163
0000b8  8821              LDRH     r1,[r4,#0]            ;164
0000ba  4668              MOV      r0,sp                 ;164
0000bc  8880              LDRH     r0,[r0,#4]            ;164
0000be  1808              ADDS     r0,r1,r0              ;164
0000c0  8020              STRH     r0,[r4,#0]            ;164
0000c2  2000              MOVS     r0,#0                 ;166
0000c4  e7a8              B        |L10.24|
;;;168    
                          ENDP


                          AREA ||i.service_data_encode||, CODE, READONLY, ALIGN=1

                  service_data_encode PROC
;;;449    // Implemented only for 16-bit UUIDs
;;;450    static uint32_t service_data_encode(const ble_advdata_t * p_advdata,
000000  b5fe              PUSH     {r1-r7,lr}
;;;451                                        uint8_t             * p_encoded_data,
;;;452                                        uint16_t            * p_offset,
;;;453                                        uint16_t              max_size)
;;;454    {
000002  4607              MOV      r7,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;455        uint8_t i;
;;;456    
;;;457        // Check parameter consistency.
;;;458        if (p_advdata->p_service_data_array == NULL)
000008  6ab8              LDR      r0,[r7,#0x28]
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L11.18|
;;;459        {
;;;460            return NRF_ERROR_INVALID_PARAM;
00000e  2007              MOVS     r0,#7
                  |L11.16|
;;;461        }
;;;462    
;;;463        for (i = 0; i < p_advdata->service_data_count; i++)
;;;464        {
;;;465            ble_advdata_service_data_t * p_service_data;
;;;466            uint32_t                     data_size;
;;;467    
;;;468            p_service_data = &p_advdata->p_service_data_array[i];
;;;469            // For now implemented only for 16-bit UUIDs
;;;470            data_size      = AD_TYPE_SERV_DATA_16BIT_UUID_SIZE + p_service_data->data.size;
;;;471    
;;;472            // There is only 1 byte intended to encode length which is (data_size + ADV_AD_TYPE_FIELD_SIZE)
;;;473            if (data_size > (0x00FF - ADV_AD_TYPE_FIELD_SIZE))
;;;474            {
;;;475                return NRF_ERROR_DATA_SIZE;
;;;476            }
;;;477    
;;;478            // Encode Length and AD Type.
;;;479            p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE + data_size);
;;;480            *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;481            p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_SERVICE_DATA;
;;;482            *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;483    
;;;484            // Encode service 16-bit UUID.
;;;485            *p_offset += uint16_encode(p_service_data->service_uuid, &p_encoded_data[*p_offset]);
;;;486    
;;;487            // Encode additional service data.
;;;488            if (p_service_data->data.size > 0)
;;;489            {
;;;490                if (p_service_data->data.p_data == NULL)
;;;491                {
;;;492                    return NRF_ERROR_INVALID_PARAM;
;;;493                }
;;;494                memcpy(&p_encoded_data[*p_offset], p_service_data->data.p_data, p_service_data->data.size);
;;;495                *p_offset += p_service_data->data.size;
;;;496            }
;;;497        }
;;;498    
;;;499        return NRF_SUCCESS;
;;;500    }
000010  bdfe              POP      {r1-r7,pc}
                  |L11.18|
000012  2000              MOVS     r0,#0                 ;463
000014  9001              STR      r0,[sp,#4]            ;463
000016  e037              B        |L11.136|
                  |L11.24|
000018  6ab9              LDR      r1,[r7,#0x28]         ;468
00001a  220c              MOVS     r2,#0xc               ;468
00001c  9801              LDR      r0,[sp,#4]            ;468
00001e  4350              MULS     r0,r2,r0              ;468
000020  180d              ADDS     r5,r1,r0              ;468
000022  88a8              LDRH     r0,[r5,#4]            ;470
000024  1c80              ADDS     r0,r0,#2              ;470
000026  9000              STR      r0,[sp,#0]            ;470
000028  9800              LDR      r0,[sp,#0]            ;473
00002a  28fe              CMP      r0,#0xfe              ;473
00002c  d901              BLS      |L11.50|
00002e  200c              MOVS     r0,#0xc               ;475
000030  e7ee              B        |L11.16|
                  |L11.50|
000032  9800              LDR      r0,[sp,#0]            ;479
000034  1c40              ADDS     r0,r0,#1              ;479
000036  8821              LDRH     r1,[r4,#0]            ;479
000038  5470              STRB     r0,[r6,r1]            ;479
00003a  8820              LDRH     r0,[r4,#0]            ;480
00003c  1c40              ADDS     r0,r0,#1              ;480
00003e  8020              STRH     r0,[r4,#0]            ;480
000040  2016              MOVS     r0,#0x16              ;481
000042  8821              LDRH     r1,[r4,#0]            ;481
000044  5470              STRB     r0,[r6,r1]            ;481
000046  8820              LDRH     r0,[r4,#0]            ;482
000048  1c40              ADDS     r0,r0,#1              ;482
00004a  8020              STRH     r0,[r4,#0]            ;482
00004c  8822              LDRH     r2,[r4,#0]            ;485
00004e  1991              ADDS     r1,r2,r6              ;485
000050  8828              LDRH     r0,[r5,#0]            ;485
000052  f7fffffe          BL       uint16_encode
000056  8821              LDRH     r1,[r4,#0]            ;485
000058  1840              ADDS     r0,r0,r1              ;485
00005a  8020              STRH     r0,[r4,#0]            ;485
00005c  88a8              LDRH     r0,[r5,#4]            ;488
00005e  2800              CMP      r0,#0                 ;488
000060  dd0e              BLE      |L11.128|
000062  68a8              LDR      r0,[r5,#8]            ;490
000064  2800              CMP      r0,#0                 ;490
000066  d101              BNE      |L11.108|
000068  2007              MOVS     r0,#7                 ;492
00006a  e7d1              B        |L11.16|
                  |L11.108|
00006c  88aa              LDRH     r2,[r5,#4]            ;494
00006e  8823              LDRH     r3,[r4,#0]            ;494
000070  1998              ADDS     r0,r3,r6              ;494
000072  68a9              LDR      r1,[r5,#8]            ;494
000074  f7fffffe          BL       __aeabi_memcpy
000078  8820              LDRH     r0,[r4,#0]            ;495
00007a  88a9              LDRH     r1,[r5,#4]            ;495
00007c  1840              ADDS     r0,r0,r1              ;495
00007e  8020              STRH     r0,[r4,#0]            ;495
                  |L11.128|
000080  9801              LDR      r0,[sp,#4]            ;463
000082  1c40              ADDS     r0,r0,#1              ;463
000084  b2c0              UXTB     r0,r0                 ;463
000086  9001              STR      r0,[sp,#4]            ;463
                  |L11.136|
000088  202c              MOVS     r0,#0x2c              ;463
00008a  5dc1              LDRB     r1,[r0,r7]            ;463
00008c  9801              LDR      r0,[sp,#4]            ;463
00008e  4281              CMP      r1,r0                 ;463
000090  dcc2              BGT      |L11.24|
000092  2000              MOVS     r0,#0                 ;499
000094  e7bc              B        |L11.16|
;;;501    
                          ENDP


                          AREA ||i.srdata_check||, CODE, READONLY, ALIGN=1

                  srdata_check PROC
;;;625    
;;;626    static uint32_t srdata_check(const ble_advdata_t * p_srdata)
000000  4601              MOV      r1,r0
;;;627    {
;;;628        // Flags shall not be included in the scan response data.
;;;629        if (p_srdata->flags)
000002  78c8              LDRB     r0,[r1,#3]
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L12.12|
;;;630        {
;;;631            return NRF_ERROR_INVALID_PARAM;
000008  2007              MOVS     r0,#7
                  |L12.10|
;;;632        }
;;;633    
;;;634        return NRF_SUCCESS;
;;;635    }
00000a  4770              BX       lr
                  |L12.12|
00000c  2000              MOVS     r0,#0                 ;634
00000e  e7fc              B        |L12.10|
;;;636    
                          ENDP


                          AREA ||i.tx_power_level_encode||, CODE, READONLY, ALIGN=1

                  tx_power_level_encode PROC
;;;218    
;;;219    static uint32_t tx_power_level_encode(int8_t     tx_power_level,
000000  b530              PUSH     {r4,r5,lr}
;;;220                                          uint8_t  * p_encoded_data,
;;;221                                          uint16_t * p_offset,
;;;222                                          uint16_t   max_size)
;;;223    {
000002  4604              MOV      r4,r0
;;;224        // Check for buffer overflow.
;;;225        if (((*p_offset) + AD_TYPE_TX_POWER_LEVEL_SIZE) > max_size)
000004  8810              LDRH     r0,[r2,#0]
000006  1cc0              ADDS     r0,r0,#3
000008  4298              CMP      r0,r3
00000a  d901              BLS      |L13.16|
;;;226        {
;;;227            return NRF_ERROR_DATA_SIZE;
00000c  200c              MOVS     r0,#0xc
                  |L13.14|
;;;228        }
;;;229    
;;;230        // Encode TX Power Level.
;;;231        p_encoded_data[*p_offset]  = (uint8_t)(ADV_AD_TYPE_FIELD_SIZE +
;;;232                                                      AD_TYPE_TX_POWER_LEVEL_DATA_SIZE);
;;;233        *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;234        p_encoded_data[*p_offset]  = BLE_GAP_AD_TYPE_TX_POWER_LEVEL;
;;;235        *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;236        p_encoded_data[*p_offset]  = tx_power_level;
;;;237        *p_offset                 += AD_TYPE_TX_POWER_LEVEL_DATA_SIZE;
;;;238    
;;;239        return NRF_SUCCESS;
;;;240    }
00000e  bd30              POP      {r4,r5,pc}
                  |L13.16|
000010  2002              MOVS     r0,#2                 ;231
000012  8815              LDRH     r5,[r2,#0]            ;231
000014  5548              STRB     r0,[r1,r5]            ;231
000016  8810              LDRH     r0,[r2,#0]            ;233
000018  1c40              ADDS     r0,r0,#1              ;233
00001a  8010              STRH     r0,[r2,#0]            ;233
00001c  200a              MOVS     r0,#0xa               ;234
00001e  8815              LDRH     r5,[r2,#0]            ;234
000020  5548              STRB     r0,[r1,r5]            ;234
000022  8810              LDRH     r0,[r2,#0]            ;235
000024  1c40              ADDS     r0,r0,#1              ;235
000026  8010              STRH     r0,[r2,#0]            ;235
000028  8815              LDRH     r5,[r2,#0]            ;236
00002a  554c              STRB     r4,[r1,r5]            ;236
00002c  8810              LDRH     r0,[r2,#0]            ;237
00002e  1c40              ADDS     r0,r0,#1              ;237
000030  8010              STRH     r0,[r2,#0]            ;237
000032  2000              MOVS     r0,#0                 ;239
000034  e7eb              B        |L13.14|
;;;241    
                          ENDP


                          AREA ||i.uint16_encode||, CODE, READONLY, ALIGN=1

                  uint16_encode PROC
;;;761     */
;;;762    static __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
000000  4602              MOV      r2,r0
;;;763    {
;;;764        p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
000002  700a              STRB     r2,[r1,#0]
;;;765        p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
000004  20ff              MOVS     r0,#0xff
000006  0200              LSLS     r0,r0,#8
000008  4010              ANDS     r0,r0,r2
00000a  1200              ASRS     r0,r0,#8
00000c  7048              STRB     r0,[r1,#1]
;;;766        return sizeof(uint16_t);
00000e  2002              MOVS     r0,#2
;;;767    }
000010  4770              BX       lr
;;;768    
                          ENDP


                          AREA ||i.uuid_list_encode||, CODE, READONLY, ALIGN=1

                  uuid_list_encode PROC
;;;307    
;;;308    static uint32_t uuid_list_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000000  b5ff              PUSH     {r0-r7,lr}
;;;309                                     uint8_t                         adv_type_16,
;;;310                                     uint8_t                         adv_type_128,
;;;311                                     uint8_t                       * p_encoded_data,
;;;312                                     uint16_t                      * p_offset,
;;;313                                     uint16_t                        max_size)
;;;314    {
000002  b083              SUB      sp,sp,#0xc
000004  4615              MOV      r5,r2
000006  9f0d              LDR      r7,[sp,#0x34]
000008  9e0c              LDR      r6,[sp,#0x30]
;;;315        uint32_t err_code;
;;;316    
;;;317        // Encode 16 bit UUIDs.
;;;318        err_code = uuid_list_sized_encode(p_uuid_list,
00000a  9701              STR      r7,[sp,#4]
00000c  9600              STR      r6,[sp,#0]
00000e  2202              MOVS     r2,#2
000010  9b06              LDR      r3,[sp,#0x18]
000012  9904              LDR      r1,[sp,#0x10]
000014  9803              LDR      r0,[sp,#0xc]
000016  f7fffffe          BL       uuid_list_sized_encode
00001a  4604              MOV      r4,r0
;;;319                                          adv_type_16,
;;;320                                          sizeof(uint16_le_t),
;;;321                                          p_encoded_data,
;;;322                                          p_offset,
;;;323                                          max_size);
;;;324        VERIFY_SUCCESS(err_code);
00001c  bf00              NOP      
00001e  2c00              CMP      r4,#0
000020  d002              BEQ      |L15.40|
000022  4620              MOV      r0,r4
                  |L15.36|
;;;325    
;;;326        // Encode 128 bit UUIDs.
;;;327        err_code = uuid_list_sized_encode(p_uuid_list,
;;;328                                          adv_type_128,
;;;329                                          sizeof(ble_uuid128_t),
;;;330                                          p_encoded_data,
;;;331                                          p_offset,
;;;332                                          max_size);
;;;333        VERIFY_SUCCESS(err_code);
;;;334    
;;;335        return NRF_SUCCESS;
;;;336    }
000024  b007              ADD      sp,sp,#0x1c
000026  bdf0              POP      {r4-r7,pc}
                  |L15.40|
000028  bf00              NOP                            ;324
00002a  9701              STR      r7,[sp,#4]            ;327
00002c  9600              STR      r6,[sp,#0]            ;327
00002e  2210              MOVS     r2,#0x10              ;327
000030  4629              MOV      r1,r5                 ;327
000032  9b06              LDR      r3,[sp,#0x18]         ;327
000034  9803              LDR      r0,[sp,#0xc]          ;327
000036  f7fffffe          BL       uuid_list_sized_encode
00003a  4604              MOV      r4,r0                 ;327
00003c  bf00              NOP                            ;333
00003e  2c00              CMP      r4,#0                 ;333
000040  d001              BEQ      |L15.70|
000042  4620              MOV      r0,r4                 ;333
000044  e7ee              B        |L15.36|
                  |L15.70|
000046  bf00              NOP                            ;333
000048  2000              MOVS     r0,#0                 ;335
00004a  e7eb              B        |L15.36|
;;;337    
                          ENDP


                          AREA ||i.uuid_list_sized_encode||, CODE, READONLY, ALIGN=1

                  uuid_list_sized_encode PROC
;;;242    
;;;243    static uint32_t uuid_list_sized_encode(const ble_advdata_uuid_list_t * p_uuid_list,
000000  b5ff              PUSH     {r0-r7,lr}
;;;244                                           uint8_t                         adv_type,
;;;245                                           uint8_t                         uuid_size,
;;;246                                           uint8_t                       * p_encoded_data,
;;;247                                           uint16_t                      * p_offset,
;;;248                                           uint16_t                        max_size)
;;;249    {
000002  b087              SUB      sp,sp,#0x1c
000004  4606              MOV      r6,r0
000006  461d              MOV      r5,r3
000008  9c10              LDR      r4,[sp,#0x40]
;;;250        int      i;
;;;251        bool     is_heading_written = false;
00000a  2000              MOVS     r0,#0
00000c  9006              STR      r0,[sp,#0x18]
;;;252        uint16_t start_pos          = *p_offset;
00000e  8820              LDRH     r0,[r4,#0]
000010  9005              STR      r0,[sp,#0x14]
;;;253        uint16_t length;
;;;254    
;;;255        for (i = 0; i < p_uuid_list->uuid_cnt; i++)
000012  2700              MOVS     r7,#0
000014  e04d              B        |L16.178|
                  |L16.22|
;;;256        {
;;;257            uint32_t   err_code;
;;;258            uint8_t    encoded_size;
;;;259            ble_uuid_t uuid = p_uuid_list->p_uuids[i];
000016  00b9              LSLS     r1,r7,#2
000018  6870              LDR      r0,[r6,#4]
00001a  1841              ADDS     r1,r0,r1
00001c  880a              LDRH     r2,[r1,#0]
00001e  4668              MOV      r0,sp
000020  8082              STRH     r2,[r0,#4]
000022  8849              LDRH     r1,[r1,#2]
000024  80c1              STRH     r1,[r0,#6]
;;;260    
;;;261            // Find encoded uuid size.
;;;262            err_code = sd_ble_uuid_encode(&uuid, &encoded_size, NULL);
000026  2200              MOVS     r2,#0
000028  a902              ADD      r1,sp,#8
00002a  a801              ADD      r0,sp,#4
00002c  df65              SVC      #0x65
00002e  9003              STR      r0,[sp,#0xc]
;;;263            VERIFY_SUCCESS(err_code);
000030  bf00              NOP      
000032  9803              LDR      r0,[sp,#0xc]
000034  2800              CMP      r0,#0
000036  d002              BEQ      |L16.62|
000038  9803              LDR      r0,[sp,#0xc]
                  |L16.58|
;;;264    
;;;265            // Check size.
;;;266            if (encoded_size == uuid_size)
;;;267            {
;;;268                uint8_t heading_bytes = (is_heading_written) ? 0 : ADV_AD_DATA_OFFSET;
;;;269    
;;;270                // Check for buffer overflow
;;;271                if (((*p_offset) + encoded_size + heading_bytes) > max_size)
;;;272                {
;;;273                    return NRF_ERROR_DATA_SIZE;
;;;274                }
;;;275    
;;;276                if (!is_heading_written)
;;;277                {
;;;278                    // Write AD structure heading.
;;;279                    *p_offset                 += ADV_LENGTH_FIELD_SIZE;
;;;280                    p_encoded_data[*p_offset]  = adv_type;
;;;281                    *p_offset                 += ADV_AD_TYPE_FIELD_SIZE;
;;;282                    is_heading_written         = true;
;;;283                }
;;;284    
;;;285                // Write UUID.
;;;286                err_code = sd_ble_uuid_encode(&uuid, &encoded_size, &p_encoded_data[*p_offset]);
;;;287                VERIFY_SUCCESS(err_code);
;;;288                *p_offset += encoded_size;
;;;289            }
;;;290        }
;;;291    
;;;292        if (is_heading_written)
;;;293        {
;;;294            // Write length.
;;;295            length = (*p_offset) - (start_pos + ADV_LENGTH_FIELD_SIZE);
;;;296            // There is only 1 byte intended to encode length
;;;297            if (length > 0x00FF)
;;;298            {
;;;299                return NRF_ERROR_DATA_SIZE;
;;;300            }
;;;301            p_encoded_data[start_pos] = (uint8_t)length;
;;;302        }
;;;303    
;;;304        return NRF_SUCCESS;
;;;305    }
00003a  b00b              ADD      sp,sp,#0x2c
00003c  bdf0              POP      {r4-r7,pc}
                  |L16.62|
00003e  bf00              NOP                            ;263
000040  4668              MOV      r0,sp                 ;266
000042  7a01              LDRB     r1,[r0,#8]            ;266
000044  9809              LDR      r0,[sp,#0x24]         ;266
000046  4281              CMP      r1,r0                 ;266
000048  d132              BNE      |L16.176|
00004a  9806              LDR      r0,[sp,#0x18]         ;268
00004c  2800              CMP      r0,#0                 ;268
00004e  d001              BEQ      |L16.84|
000050  2000              MOVS     r0,#0                 ;268
000052  e000              B        |L16.86|
                  |L16.84|
000054  2002              MOVS     r0,#2                 ;268
                  |L16.86|
000056  9000              STR      r0,[sp,#0]            ;268
000058  8820              LDRH     r0,[r4,#0]            ;271
00005a  4669              MOV      r1,sp                 ;271
00005c  7a09              LDRB     r1,[r1,#8]            ;271
00005e  1841              ADDS     r1,r0,r1              ;271
000060  9800              LDR      r0,[sp,#0]            ;271
000062  1809              ADDS     r1,r1,r0              ;271
000064  9811              LDR      r0,[sp,#0x44]         ;271
000066  4281              CMP      r1,r0                 ;271
000068  dd01              BLE      |L16.110|
00006a  200c              MOVS     r0,#0xc               ;273
00006c  e7e5              B        |L16.58|
                  |L16.110|
00006e  9806              LDR      r0,[sp,#0x18]         ;276
000070  2800              CMP      r0,#0                 ;276
000072  d10a              BNE      |L16.138|
000074  8820              LDRH     r0,[r4,#0]            ;279
000076  1c40              ADDS     r0,r0,#1              ;279
000078  8020              STRH     r0,[r4,#0]            ;279
00007a  8821              LDRH     r1,[r4,#0]            ;280
00007c  9808              LDR      r0,[sp,#0x20]         ;280
00007e  5468              STRB     r0,[r5,r1]            ;280
000080  8820              LDRH     r0,[r4,#0]            ;281
000082  1c40              ADDS     r0,r0,#1              ;281
000084  8020              STRH     r0,[r4,#0]            ;281
000086  2001              MOVS     r0,#1                 ;282
000088  9006              STR      r0,[sp,#0x18]         ;282
                  |L16.138|
00008a  8820              LDRH     r0,[r4,#0]            ;286
00008c  1942              ADDS     r2,r0,r5              ;286
00008e  a902              ADD      r1,sp,#8              ;286
000090  a801              ADD      r0,sp,#4              ;286
000092  df65              SVC      #0x65                 ;286
000094  9003              STR      r0,[sp,#0xc]          ;286
000096  bf00              NOP                            ;287
000098  9803              LDR      r0,[sp,#0xc]          ;287
00009a  2800              CMP      r0,#0                 ;287
00009c  d001              BEQ      |L16.162|
00009e  9803              LDR      r0,[sp,#0xc]          ;287
0000a0  e7cb              B        |L16.58|
                  |L16.162|
0000a2  bf00              NOP                            ;287
0000a4  8821              LDRH     r1,[r4,#0]            ;288
0000a6  4668              MOV      r0,sp                 ;288
0000a8  7a00              LDRB     r0,[r0,#8]            ;288
0000aa  1808              ADDS     r0,r1,r0              ;288
0000ac  8020              STRH     r0,[r4,#0]            ;288
0000ae  bf00              NOP                            ;289
                  |L16.176|
0000b0  1c7f              ADDS     r7,r7,#1              ;255
                  |L16.178|
0000b2  8830              LDRH     r0,[r6,#0]            ;255
0000b4  42b8              CMP      r0,r7                 ;255
0000b6  dcae              BGT      |L16.22|
0000b8  9806              LDR      r0,[sp,#0x18]         ;292
0000ba  2800              CMP      r0,#0                 ;292
0000bc  d00e              BEQ      |L16.220|
0000be  8821              LDRH     r1,[r4,#0]            ;295
0000c0  9805              LDR      r0,[sp,#0x14]         ;295
0000c2  1c40              ADDS     r0,r0,#1              ;295
0000c4  1a08              SUBS     r0,r1,r0              ;295
0000c6  b280              UXTH     r0,r0                 ;295
0000c8  9004              STR      r0,[sp,#0x10]         ;295
0000ca  9804              LDR      r0,[sp,#0x10]         ;297
0000cc  28ff              CMP      r0,#0xff              ;297
0000ce  dd01              BLE      |L16.212|
0000d0  200c              MOVS     r0,#0xc               ;299
0000d2  e7b2              B        |L16.58|
                  |L16.212|
0000d4  9804              LDR      r0,[sp,#0x10]         ;301
0000d6  b2c1              UXTB     r1,r0                 ;301
0000d8  9805              LDR      r0,[sp,#0x14]         ;301
0000da  5429              STRB     r1,[r5,r0]            ;301
                  |L16.220|
0000dc  2000              MOVS     r0,#0                 ;304
0000de  e7ac              B        |L16.58|
;;;306    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\common\\ble_advdata.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7f4862ed____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_ble_advdata_c_7f4862ed____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_ble_advdata_c_7f4862ed____REVSH|
#line 144
|__asm___13_ble_advdata_c_7f4862ed____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
