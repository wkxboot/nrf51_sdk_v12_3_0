; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\nrf_log_backend_serial.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\nrf_log_backend_serial.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\nrf_log_backend_serial.crf ..\..\..\..\..\..\components\libraries\log\src\nrf_log_backend_serial.c]
                          THUMB

                          AREA ||i.buf_len_update||, CODE, READONLY, ALIGN=1

                  buf_len_update PROC
;;;211    
;;;212    static bool buf_len_update(uint32_t * p_buf_len, int32_t new_len)
000000  4602              MOV      r2,r0
;;;213    {
;;;214        bool ret;
;;;215        if (new_len < 0)
000002  2900              CMP      r1,#0
000004  da01              BGE      |L1.10|
;;;216        {
;;;217            ret = false;
000006  2000              MOVS     r0,#0
000008  e003              B        |L1.18|
                  |L1.10|
;;;218        }
;;;219        else
;;;220        {
;;;221            *p_buf_len += (uint32_t)new_len;
00000a  6813              LDR      r3,[r2,#0]
00000c  185b              ADDS     r3,r3,r1
00000e  6013              STR      r3,[r2,#0]
;;;222            ret = true;
000010  2001              MOVS     r0,#1
                  |L1.18|
;;;223        }
;;;224        return ret;
;;;225    }
000012  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.byte2hex||, CODE, READONLY, ALIGN=1

                  byte2hex PROC
;;;349    
;;;350    static void byte2hex(const uint8_t c, char * p_out)
000000  b530              PUSH     {r4,r5,lr}
;;;351    {
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;352        uint8_t  nibble;
;;;353        uint32_t i = 2;
000006  2102              MOVS     r1,#2
;;;354    
;;;355        while (i-- != 0)
000008  e00e              B        |L2.40|
                  |L2.10|
;;;356        {
;;;357            nibble       = (c >> (4 * i)) & 0x0F;
00000a  008d              LSLS     r5,r1,#2
00000c  4614              MOV      r4,r2
00000e  412c              ASRS     r4,r4,r5
000010  0720              LSLS     r0,r4,#28
000012  0f00              LSRS     r0,r0,#28
;;;358            p_out[1 - i] = (nibble > 9) ? ('A' + nibble - 10) : ('0' + nibble);
000014  2809              CMP      r0,#9
000016  dd02              BLE      |L2.30|
000018  4604              MOV      r4,r0
00001a  3437              ADDS     r4,r4,#0x37
00001c  e001              B        |L2.34|
                  |L2.30|
00001e  4604              MOV      r4,r0
000020  3430              ADDS     r4,r4,#0x30
                  |L2.34|
000022  2501              MOVS     r5,#1
000024  1a6d              SUBS     r5,r5,r1
000026  555c              STRB     r4,[r3,r5]
                  |L2.40|
000028  460c              MOV      r4,r1                 ;355
00002a  1e49              SUBS     r1,r1,#1              ;355
00002c  2c00              CMP      r4,#0                 ;355
00002e  d1ec              BNE      |L2.10|
;;;359        }
;;;360    }
000030  bd30              POP      {r4,r5,pc}
;;;361    
                          ENDP


                          AREA ||i.nrf_log_backend_getchar||, CODE, READONLY, ALIGN=1

                  nrf_log_backend_getchar PROC
;;;490    
;;;491    uint8_t nrf_log_backend_getchar(void)
000000  b510              PUSH     {r4,lr}
;;;492    {
;;;493        return serial_get_byte();
000002  f7fffffe          BL       serial_get_byte
;;;494    }
000006  bd10              POP      {r4,pc}
;;;495    
                          ENDP


                          AREA ||i.nrf_log_backend_hexdump_handler_get||, CODE, READONLY, ALIGN=2

                  nrf_log_backend_hexdump_handler_get PROC
;;;484    
;;;485    nrf_log_hexdump_handler_t nrf_log_backend_hexdump_handler_get(void)
000000  4800              LDR      r0,|L4.4|
;;;486    {
;;;487        return nrf_log_backend_serial_hexdump_handler;
;;;488    }
000002  4770              BX       lr
;;;489    
                          ENDP

                  |L4.4|
                          DCD      nrf_log_backend_serial_hexdump_handler

                          AREA ||i.nrf_log_backend_init||, CODE, READONLY, ALIGN=2

                  nrf_log_backend_init PROC
;;;99     
;;;100    ret_code_t nrf_log_backend_init(bool blocking)
000000  b530              PUSH     {r4,r5,lr}
;;;101    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
;;;102    
;;;103        if (m_initialized && (blocking == m_blocking_mode))
000006  481b              LDR      r0,|L5.116|
000008  7800              LDRB     r0,[r0,#0]  ; m_initialized
00000a  2800              CMP      r0,#0
00000c  d006              BEQ      |L5.28|
00000e  481a              LDR      r0,|L5.120|
000010  7800              LDRB     r0,[r0,#0]  ; m_blocking_mode
000012  4284              CMP      r4,r0
000014  d102              BNE      |L5.28|
;;;104        {
;;;105            return NRF_SUCCESS;
000016  2000              MOVS     r0,#0
                  |L5.24|
;;;106        }
;;;107    #if (NRF_LOG_BACKEND_SERIAL_USES_RTT)
;;;108        SEGGER_RTT_Init();
;;;109    #endif
;;;110        
;;;111    #if (NRF_LOG_BACKEND_SERIAL_USES_UART)
;;;112        uint32_t              ret_code;
;;;113        nrf_drv_uart_config_t uart_config = NRF_DRV_UART_DEFAULT_CONFIG;
;;;114        uart_config.hwfc     =
;;;115                (nrf_uart_hwfc_t)NRF_LOG_BACKEND_SERIAL_UART_FLOW_CONTROL;
;;;116        uart_config.pseltxd  = NRF_LOG_BACKEND_SERIAL_UART_TX_PIN;
;;;117        uart_config.pselrxd  = NRF_LOG_BACKEND_SERIAL_UART_RX_PIN;
;;;118        uart_config.pselrts  = NRF_LOG_BACKEND_SERIAL_UART_RTS_PIN;
;;;119        uart_config.pselcts  = NRF_LOG_BACKEND_SERIAL_UART_CTS_PIN;
;;;120        uart_config.baudrate =
;;;121            (nrf_uart_baudrate_t)NRF_LOG_BACKEND_SERIAL_UART_BAUDRATE;
;;;122        nrf_drv_uart_uninit(&m_uart);
;;;123        ret_code = nrf_drv_uart_init(&m_uart, &uart_config,
;;;124                                     blocking ? NULL : uart_event_handler);
;;;125        if (ret_code != NRF_SUCCESS)
;;;126        {
;;;127            return ret_code;
;;;128        }
;;;129    #endif //NRF_LOG_BACKEND_SERIAL_USES_UART
;;;130    
;;;131        m_initialized   = true;
;;;132        m_blocking_mode = blocking;
;;;133        return NRF_SUCCESS;
;;;134    }
000018  b009              ADD      sp,sp,#0x24
00001a  bd30              POP      {r4,r5,pc}
                  |L5.28|
00001c  2220              MOVS     r2,#0x20              ;113
00001e  4917              LDR      r1,|L5.124|
000020  a801              ADD      r0,sp,#4              ;113
000022  f7fffffe          BL       __aeabi_memcpy4
000026  2000              MOVS     r0,#0                 ;114
000028  4669              MOV      r1,sp                 ;114
00002a  7608              STRB     r0,[r1,#0x18]         ;114
00002c  201e              MOVS     r0,#0x1e              ;116
00002e  9001              STR      r0,[sp,#4]            ;116
000030  200b              MOVS     r0,#0xb               ;117
000032  9002              STR      r0,[sp,#8]            ;117
000034  2008              MOVS     r0,#8                 ;118
000036  9004              STR      r0,[sp,#0x10]         ;118
000038  200a              MOVS     r0,#0xa               ;119
00003a  9003              STR      r0,[sp,#0xc]          ;119
00003c  4810              LDR      r0,|L5.128|
00003e  9007              STR      r0,[sp,#0x1c]         ;120
000040  4810              LDR      r0,|L5.132|
000042  f7fffffe          BL       nrf_drv_uart_uninit
000046  2c00              CMP      r4,#0                 ;123
000048  d001              BEQ      |L5.78|
00004a  2000              MOVS     r0,#0                 ;124
00004c  e000              B        |L5.80|
                  |L5.78|
00004e  480e              LDR      r0,|L5.136|
                  |L5.80|
000050  4602              MOV      r2,r0                 ;124
000052  a901              ADD      r1,sp,#4              ;124
000054  480b              LDR      r0,|L5.132|
000056  f7fffffe          BL       nrf_drv_uart_init
00005a  4605              MOV      r5,r0                 ;124
00005c  2d00              CMP      r5,#0                 ;125
00005e  d001              BEQ      |L5.100|
000060  4628              MOV      r0,r5                 ;127
000062  e7d9              B        |L5.24|
                  |L5.100|
000064  2001              MOVS     r0,#1                 ;131
000066  4903              LDR      r1,|L5.116|
000068  7008              STRB     r0,[r1,#0]            ;131
00006a  4803              LDR      r0,|L5.120|
00006c  7004              STRB     r4,[r0,#0]            ;132
00006e  2000              MOVS     r0,#0                 ;133
000070  e7d2              B        |L5.24|
;;;135    
                          ENDP

000072  0000              DCW      0x0000
                  |L5.116|
                          DCD      m_initialized
                  |L5.120|
                          DCD      m_blocking_mode
                  |L5.124|
                          DCD      ||.constdata||+0x8
                  |L5.128|
                          DCD      0x01d7e000
                  |L5.132|
                          DCD      m_uart
                  |L5.136|
                          DCD      uart_event_handler

                          AREA ||i.nrf_log_backend_serial_hexdump_handler||, CODE, READONLY, ALIGN=2

                  nrf_log_backend_serial_hexdump_handler PROC
;;;362    
;;;363    static uint32_t nrf_log_backend_serial_hexdump_handler(
000000  b5ff              PUSH     {r0-r7,lr}
;;;364        uint8_t                severity_level,
;;;365        const uint32_t * const p_timestamp,
;;;366        const char * const     p_str,
;;;367        uint32_t               offset,
;;;368        const uint8_t * const  p_buf0,
;;;369        uint32_t               buf0_length,
;;;370        const uint8_t * const  p_buf1,
;;;371        uint32_t               buf1_length)
;;;372    {
000002  b0c9              SUB      sp,sp,#0x124
;;;373        char     str[NRF_LOG_BACKEND_MAX_STRING_LENGTH];
;;;374        uint32_t slen;
;;;375        char   * p_hex_part;
;;;376        char   * p_char_part;
;;;377        uint8_t  c;
;;;378        uint32_t byte_in_line;
;;;379        uint32_t buffer_len    = 0;
000004  2000              MOVS     r0,#0
000006  9006              STR      r0,[sp,#0x18]
;;;380        uint32_t byte_cnt      = offset;
000008  9e4c              LDR      r6,[sp,#0x130]
;;;381        uint32_t length        = buf0_length + buf1_length;
00000a  9955              LDR      r1,[sp,#0x154]
00000c  9853              LDR      r0,[sp,#0x14c]
00000e  1840              ADDS     r0,r0,r1
000010  9005              STR      r0,[sp,#0x14]
;;;382        uint32_t timestamp_len = p_timestamp ?
000012  984a              LDR      r0,[sp,#0x128]
000014  2800              CMP      r0,#0
000016  d001              BEQ      |L6.28|
;;;383                NRF_LOG_TIMESTAMP_DIGITS+2 : 0; //+2 since timestamp is in brackets
000018  200a              MOVS     r0,#0xa
00001a  e000              B        |L6.30|
                  |L6.28|
00001c  2000              MOVS     r0,#0
                  |L6.30|
00001e  9004              STR      r0,[sp,#0x10]
;;;384    
;;;385        if (serial_is_busy())
000020  f7fffffe          BL       serial_is_busy
000024  2800              CMP      r0,#0
000026  d002              BEQ      |L6.46|
;;;386        {
;;;387            return offset;
000028  984c              LDR      r0,[sp,#0x130]
                  |L6.42|
;;;388        }
;;;389    
;;;390        // If it is the first part of hexdump print the header
;;;391        if (offset == 0)
;;;392        {
;;;393            if (!timestamp_process(p_timestamp, &str[buffer_len], &buffer_len))
;;;394            {
;;;395                return offset;
;;;396            }
;;;397            slen = strlen(p_str);
;;;398            // Saturate string if it's too long.
;;;399            slen = (slen > HEXDUMP_MAX_STR_LEN) ? HEXDUMP_MAX_STR_LEN : slen;
;;;400            memcpy(&str[buffer_len], p_str, slen);
;;;401            buffer_len += slen;
;;;402        }
;;;403    
;;;404        do
;;;405        {
;;;406    
;;;407            uint32_t  i;
;;;408            uint32_t hex_part_offset  = buffer_len;
;;;409            uint32_t char_part_offset = hex_part_offset +
;;;410                                        (HEXDUMP_BYTES_PER_LINE * HEXDUMP_HEXBYTE_AREA + 1) + // +1 - separator between hexdump and characters.
;;;411                                        timestamp_len;
;;;412    
;;;413            p_hex_part  = &str[hex_part_offset];
;;;414            p_char_part = &str[char_part_offset];
;;;415    
;;;416            // Fill the blanks to align to timestamp print
;;;417            for (i = 0; i < timestamp_len; i++)
;;;418            {
;;;419                *p_hex_part = ' ';
;;;420                ++p_hex_part;
;;;421            }
;;;422    
;;;423            for (byte_in_line = 0; byte_in_line < HEXDUMP_BYTES_PER_LINE; byte_in_line++)
;;;424            {
;;;425                if (byte_cnt >= length)
;;;426                {
;;;427                    // file the blanks
;;;428                    *p_hex_part++  = ' ';
;;;429                    *p_hex_part++  = ' ';
;;;430                    *p_hex_part++  = ' ';
;;;431                    *p_char_part++ = ' ';
;;;432                }
;;;433                else
;;;434                {
;;;435                    if (byte_cnt < buf0_length)
;;;436                    {
;;;437                        c = p_buf0[byte_cnt];
;;;438                    }
;;;439                    else
;;;440                    {
;;;441                        c = p_buf1[byte_cnt - buf0_length];
;;;442                    }
;;;443                    byte2hex(c, p_hex_part);
;;;444                    p_hex_part    += 2; // move the pointer since byte in hex was added.
;;;445                    *p_hex_part++  = ' ';
;;;446                    *p_char_part++ = isprint(c) ? c : '.';
;;;447                    byte_cnt++;
;;;448                }
;;;449            }
;;;450            *p_char_part++ = '\r';
;;;451            *p_char_part++ = '\n';
;;;452            *p_hex_part++  = ' ';
;;;453            buffer_len    += timestamp_len +
;;;454                             (HEXDUMP_BYTES_PER_LINE * HEXDUMP_HEXBYTE_AREA + 1) + // space for hex dump and separator between hexdump and string
;;;455                             HEXDUMP_BYTES_PER_LINE +                              // space for stringS dump
;;;456                             2;                                                    // space for new line
;;;457            if (NRF_LOG_USES_COLORS)
;;;458            {
;;;459                memcpy(&str[buffer_len], m_default_color, sizeof(m_default_color)-1);
;;;460                buffer_len +=  sizeof(m_default_color)-1;
;;;461            }
;;;462    
;;;463            if (!serial_tx((uint8_t *)str, buffer_len))
;;;464            {
;;;465                return byte_cnt;
;;;466            }
;;;467    
;;;468            if (serial_is_busy())
;;;469            {
;;;470                return byte_cnt;
;;;471            }
;;;472            buffer_len = 0;
;;;473        }
;;;474        while (byte_cnt < length);
;;;475        return byte_cnt;
;;;476    }
00002a  b04d              ADD      sp,sp,#0x134
00002c  bdf0              POP      {r4-r7,pc}
                  |L6.46|
00002e  984c              LDR      r0,[sp,#0x130]        ;391
000030  2800              CMP      r0,#0                 ;391
000032  d11e              BNE      |L6.114|
000034  a809              ADD      r0,sp,#0x24           ;393
000036  9a06              LDR      r2,[sp,#0x18]         ;393
000038  1881              ADDS     r1,r0,r2              ;393
00003a  aa06              ADD      r2,sp,#0x18           ;393
00003c  984a              LDR      r0,[sp,#0x128]        ;393
00003e  f7fffffe          BL       timestamp_process
000042  2800              CMP      r0,#0                 ;393
000044  d101              BNE      |L6.74|
000046  984c              LDR      r0,[sp,#0x130]        ;395
000048  e7ef              B        |L6.42|
                  |L6.74|
00004a  984b              LDR      r0,[sp,#0x12c]        ;397
00004c  f7fffffe          BL       strlen
000050  4607              MOV      r7,r0                 ;397
000052  2fc2              CMP      r7,#0xc2              ;399
000054  d901              BLS      |L6.90|
000056  20c2              MOVS     r0,#0xc2              ;399
000058  e000              B        |L6.92|
                  |L6.90|
00005a  4638              MOV      r0,r7                 ;399
                  |L6.92|
00005c  4607              MOV      r7,r0                 ;399
00005e  a909              ADD      r1,sp,#0x24           ;400
000060  9a06              LDR      r2,[sp,#0x18]         ;400
000062  1888              ADDS     r0,r1,r2              ;400
000064  463a              MOV      r2,r7                 ;400
000066  994b              LDR      r1,[sp,#0x12c]        ;400
000068  f7fffffe          BL       __aeabi_memcpy
00006c  9806              LDR      r0,[sp,#0x18]         ;401
00006e  19c0              ADDS     r0,r0,r7              ;401
000070  9006              STR      r0,[sp,#0x18]         ;401
                  |L6.114|
000072  bf00              NOP                            ;404
                  |L6.116|
000074  9806              LDR      r0,[sp,#0x18]         ;408
000076  9002              STR      r0,[sp,#8]            ;408
000078  9802              LDR      r0,[sp,#8]            ;409
00007a  3031              ADDS     r0,r0,#0x31           ;409
00007c  9904              LDR      r1,[sp,#0x10]         ;409
00007e  1840              ADDS     r0,r0,r1              ;409
000080  9001              STR      r0,[sp,#4]            ;409
000082  a909              ADD      r1,sp,#0x24           ;413
000084  9802              LDR      r0,[sp,#8]            ;413
000086  180c              ADDS     r4,r1,r0              ;413
000088  9801              LDR      r0,[sp,#4]            ;414
00008a  180d              ADDS     r5,r1,r0              ;414
00008c  2000              MOVS     r0,#0                 ;417
00008e  9003              STR      r0,[sp,#0xc]          ;417
000090  e005              B        |L6.158|
                  |L6.146|
000092  2020              MOVS     r0,#0x20              ;419
000094  7020              STRB     r0,[r4,#0]            ;419
000096  1c64              ADDS     r4,r4,#1              ;420
000098  9803              LDR      r0,[sp,#0xc]          ;417
00009a  1c40              ADDS     r0,r0,#1              ;417
00009c  9003              STR      r0,[sp,#0xc]          ;417
                  |L6.158|
00009e  9904              LDR      r1,[sp,#0x10]         ;417
0000a0  9803              LDR      r0,[sp,#0xc]          ;417
0000a2  4288              CMP      r0,r1                 ;417
0000a4  d3f5              BCC      |L6.146|
0000a6  2000              MOVS     r0,#0                 ;423
0000a8  9007              STR      r0,[sp,#0x1c]         ;423
0000aa  e032              B        |L6.274|
                  |L6.172|
0000ac  9805              LDR      r0,[sp,#0x14]         ;425
0000ae  4286              CMP      r6,r0                 ;425
0000b0  d309              BCC      |L6.198|
0000b2  2020              MOVS     r0,#0x20              ;428
0000b4  7020              STRB     r0,[r4,#0]            ;428
0000b6  1c64              ADDS     r4,r4,#1              ;428
0000b8  7020              STRB     r0,[r4,#0]            ;429
0000ba  1c64              ADDS     r4,r4,#1              ;429
0000bc  7020              STRB     r0,[r4,#0]            ;430
0000be  1c64              ADDS     r4,r4,#1              ;430
0000c0  7028              STRB     r0,[r5,#0]            ;431
0000c2  1c6d              ADDS     r5,r5,#1              ;431
0000c4  e022              B        |L6.268|
                  |L6.198|
0000c6  9853              LDR      r0,[sp,#0x14c]        ;435
0000c8  4286              CMP      r6,r0                 ;435
0000ca  d203              BCS      |L6.212|
0000cc  9852              LDR      r0,[sp,#0x148]        ;437
0000ce  5d80              LDRB     r0,[r0,r6]            ;437
0000d0  9008              STR      r0,[sp,#0x20]         ;437
0000d2  e004              B        |L6.222|
                  |L6.212|
0000d4  9853              LDR      r0,[sp,#0x14c]        ;441
0000d6  1a31              SUBS     r1,r6,r0              ;441
0000d8  9854              LDR      r0,[sp,#0x150]        ;441
0000da  5c40              LDRB     r0,[r0,r1]            ;441
0000dc  9008              STR      r0,[sp,#0x20]         ;441
                  |L6.222|
0000de  4621              MOV      r1,r4                 ;443
0000e0  9808              LDR      r0,[sp,#0x20]         ;443
0000e2  f7fffffe          BL       byte2hex
0000e6  1ca4              ADDS     r4,r4,#2              ;444
0000e8  2020              MOVS     r0,#0x20              ;445
0000ea  7020              STRB     r0,[r4,#0]            ;445
0000ec  1c64              ADDS     r4,r4,#1              ;445
0000ee  f7fffffe          BL       __rt_ctype_table
0000f2  6801              LDR      r1,[r0,#0]            ;446
0000f4  9808              LDR      r0,[sp,#0x20]         ;446
0000f6  5c08              LDRB     r0,[r1,r0]            ;446
0000f8  213e              MOVS     r1,#0x3e              ;446
0000fa  4008              ANDS     r0,r0,r1              ;446
0000fc  2800              CMP      r0,#0                 ;446
0000fe  d001              BEQ      |L6.260|
000100  9808              LDR      r0,[sp,#0x20]         ;446
000102  e000              B        |L6.262|
                  |L6.260|
000104  202e              MOVS     r0,#0x2e              ;446
                  |L6.262|
000106  7028              STRB     r0,[r5,#0]            ;446
000108  1c6d              ADDS     r5,r5,#1              ;446
00010a  1c76              ADDS     r6,r6,#1              ;447
                  |L6.268|
00010c  9807              LDR      r0,[sp,#0x1c]         ;423
00010e  1c40              ADDS     r0,r0,#1              ;423
000110  9007              STR      r0,[sp,#0x1c]         ;423
                  |L6.274|
000112  9807              LDR      r0,[sp,#0x1c]         ;423
000114  2810              CMP      r0,#0x10              ;423
000116  d3c9              BCC      |L6.172|
000118  200d              MOVS     r0,#0xd               ;450
00011a  7028              STRB     r0,[r5,#0]            ;450
00011c  1c6d              ADDS     r5,r5,#1              ;450
00011e  200a              MOVS     r0,#0xa               ;451
000120  7028              STRB     r0,[r5,#0]            ;451
000122  1c6d              ADDS     r5,r5,#1              ;451
000124  2020              MOVS     r0,#0x20              ;452
000126  7020              STRB     r0,[r4,#0]            ;452
000128  1c64              ADDS     r4,r4,#1              ;452
00012a  9804              LDR      r0,[sp,#0x10]         ;453
00012c  3043              ADDS     r0,r0,#0x43           ;453
00012e  9906              LDR      r1,[sp,#0x18]         ;453
000130  1808              ADDS     r0,r1,r0              ;453
000132  9006              STR      r0,[sp,#0x18]         ;453
000134  a909              ADD      r1,sp,#0x24           ;459
000136  9a06              LDR      r2,[sp,#0x18]         ;459
000138  1888              ADDS     r0,r1,r2              ;459
00013a  2204              MOVS     r2,#4                 ;459
00013c  490d              LDR      r1,|L6.372|
00013e  f7fffffe          BL       __aeabi_memcpy
000142  9806              LDR      r0,[sp,#0x18]         ;460
000144  1d00              ADDS     r0,r0,#4              ;460
000146  9006              STR      r0,[sp,#0x18]         ;460
000148  a809              ADD      r0,sp,#0x24           ;463
00014a  9906              LDR      r1,[sp,#0x18]         ;463
00014c  f7fffffe          BL       serial_tx
000150  2800              CMP      r0,#0                 ;463
000152  d101              BNE      |L6.344|
000154  4630              MOV      r0,r6                 ;465
000156  e768              B        |L6.42|
                  |L6.344|
000158  f7fffffe          BL       serial_is_busy
00015c  2800              CMP      r0,#0                 ;468
00015e  d001              BEQ      |L6.356|
000160  4630              MOV      r0,r6                 ;470
000162  e762              B        |L6.42|
                  |L6.356|
000164  2000              MOVS     r0,#0                 ;472
000166  9006              STR      r0,[sp,#0x18]         ;472
000168  9805              LDR      r0,[sp,#0x14]         ;474
00016a  4286              CMP      r6,r0                 ;474
00016c  d382              BCC      |L6.116|
00016e  4630              MOV      r0,r6                 ;475
000170  e75b              B        |L6.42|
;;;477    
                          ENDP

000172  0000              DCW      0x0000
                  |L6.372|
                          DCD      m_default_color

                          AREA ||i.nrf_log_backend_serial_std_handler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_truncate_unsigned
                          REQUIRE _printf_truncate_signed
                          REQUIRE _printf_sizespec
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_i
                          REQUIRE _printf_u
                          REQUIRE _printf_o
                          REQUIRE _printf_x
                          REQUIRE _printf_c
                          REQUIRE _printf_lc
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_longlong_oct
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                          REQUIRE _printf_str
                          REQUIRE _printf_wctomb
                  nrf_log_backend_serial_std_handler PROC
;;;249    
;;;250    static bool nrf_log_backend_serial_std_handler(
000000  b5ff              PUSH     {r0-r7,lr}
;;;251        uint8_t                severity_level,
;;;252        const uint32_t * const p_timestamp,
;;;253        const char * const     p_str,
;;;254        uint32_t             * p_args,
;;;255        uint32_t               nargs)
;;;256    {
000002  b0c9              SUB      sp,sp,#0x124
000004  4615              MOV      r5,r2
000006  461c              MOV      r4,r3
;;;257        char     str[NRF_LOG_BACKEND_MAX_STRING_LENGTH];
;;;258        int32_t  tmp_str_len     = 0;
000008  2700              MOVS     r7,#0
;;;259        uint32_t buffer_len      = 0;
00000a  2000              MOVS     r0,#0
00000c  9008              STR      r0,[sp,#0x20]
;;;260        bool     status          = true;
00000e  2001              MOVS     r0,#1
000010  9007              STR      r0,[sp,#0x1c]
;;;261    
;;;262        if (serial_is_busy())
000012  f7fffffe          BL       serial_is_busy
000016  2800              CMP      r0,#0
000018  d002              BEQ      |L7.32|
;;;263        {
;;;264            return false;
00001a  2000              MOVS     r0,#0
                  |L7.28|
;;;265        }
;;;266    
;;;267        if (!timestamp_process(p_timestamp, &str[buffer_len], &buffer_len))
;;;268        {
;;;269            return false;
;;;270        }
;;;271    
;;;272        switch (nargs)
;;;273        {
;;;274            case 0:
;;;275            {
;;;276                tmp_str_len = strlen(p_str);
;;;277                if ((tmp_str_len + buffer_len) < NRF_LOG_BACKEND_MAX_STRING_LENGTH)
;;;278                {
;;;279                    memcpy(&str[buffer_len], p_str, tmp_str_len);
;;;280                }
;;;281                break;
;;;282            }
;;;283    
;;;284            case 1:
;;;285                tmp_str_len = snprintf(&str[buffer_len], NRF_LOG_BACKEND_MAX_STRING_LENGTH-buffer_len, p_str, p_args[0]);
;;;286    
;;;287                break;
;;;288    
;;;289            case 2:
;;;290                tmp_str_len = snprintf(&str[buffer_len], NRF_LOG_BACKEND_MAX_STRING_LENGTH-buffer_len, p_str, p_args[0], p_args[1]);
;;;291                break;
;;;292    
;;;293            case 3:
;;;294                tmp_str_len = snprintf(&str[buffer_len], NRF_LOG_BACKEND_MAX_STRING_LENGTH-buffer_len, p_str, p_args[0], p_args[1], p_args[2]);
;;;295                break;
;;;296    
;;;297            case 4:
;;;298                tmp_str_len =
;;;299                    snprintf(&str[buffer_len], NRF_LOG_BACKEND_MAX_STRING_LENGTH-buffer_len, p_str, p_args[0], p_args[1], p_args[2], p_args[3]);
;;;300                break;
;;;301    
;;;302            case 5:
;;;303                tmp_str_len =
;;;304                    snprintf(&str[buffer_len],
;;;305                            NRF_LOG_BACKEND_MAX_STRING_LENGTH-buffer_len,
;;;306                            p_str,
;;;307                            p_args[0],
;;;308                            p_args[1],
;;;309                            p_args[2],
;;;310                            p_args[3],
;;;311                            p_args[4]);
;;;312                break;
;;;313    
;;;314            case 6:
;;;315                tmp_str_len =
;;;316                    snprintf(&str[buffer_len],
;;;317                            NRF_LOG_BACKEND_MAX_STRING_LENGTH-buffer_len,
;;;318                            p_str,
;;;319                            p_args[0],
;;;320                            p_args[1],
;;;321                            p_args[2],
;;;322                            p_args[3],
;;;323                            p_args[4],
;;;324                            p_args[5]);
;;;325                break;
;;;326    
;;;327            default:
;;;328                break;
;;;329        }
;;;330        status = buf_len_update(&buffer_len, tmp_str_len);
;;;331        uint32_t full_buff_len = NRF_LOG_USES_COLORS ?
;;;332                buffer_len + sizeof(m_default_color)-1 : buffer_len;
;;;333        if (status && (full_buff_len <= NRF_LOG_BACKEND_MAX_STRING_LENGTH))
;;;334        {
;;;335            if (NRF_LOG_USES_COLORS)
;;;336            {
;;;337                memcpy(&str[buffer_len], m_default_color, sizeof(m_default_color)-1);
;;;338                buffer_len = full_buff_len;
;;;339            }
;;;340            return serial_tx((uint8_t *)str, buffer_len);
;;;341        }
;;;342        else
;;;343        {
;;;344            // error, snprintf failed.
;;;345            return false;
;;;346        }
;;;347    }
00001c  b04d              ADD      sp,sp,#0x134
00001e  bdf0              POP      {r4-r7,pc}
                  |L7.32|
000020  a809              ADD      r0,sp,#0x24           ;267
000022  9a08              LDR      r2,[sp,#0x20]         ;267
000024  1881              ADDS     r1,r0,r2              ;267
000026  aa08              ADD      r2,sp,#0x20           ;267
000028  984a              LDR      r0,[sp,#0x128]        ;267
00002a  f7fffffe          BL       timestamp_process
00002e  2800              CMP      r0,#0                 ;267
000030  d100              BNE      |L7.52|
000032  e7f3              B        |L7.28|
                  |L7.52|
000034  9852              LDR      r0,[sp,#0x148]        ;272
000036  0003              MOVS     r3,r0                 ;272
000038  f7fffffe          BL       __ARM_common_switch8
00003c  07051525          DCB      0x07,0x05,0x15,0x25
000040  374b6179          DCB      0x37,0x4b,0x61,0x79
000044  9300              DCB      0x93,0x00
000046  4628              MOV      r0,r5                 ;276
000048  f7fffffe          BL       strlen
00004c  4607              MOV      r7,r0                 ;276
00004e  9808              LDR      r0,[sp,#0x20]         ;277
000050  1838              ADDS     r0,r7,r0              ;277
000052  28ff              CMP      r0,#0xff              ;277
000054  d806              BHI      |L7.100|
000056  a909              ADD      r1,sp,#0x24           ;279
000058  9a08              LDR      r2,[sp,#0x20]         ;279
00005a  1888              ADDS     r0,r1,r2              ;279
00005c  463a              MOV      r2,r7                 ;279
00005e  4629              MOV      r1,r5                 ;279
000060  f7fffffe          BL       __aeabi_memcpy
                  |L7.100|
000064  e07e              B        |L7.356|
000066  6823              LDR      r3,[r4,#0]            ;285
000068  21ff              MOVS     r1,#0xff              ;285
00006a  3101              ADDS     r1,#1                 ;285
00006c  9808              LDR      r0,[sp,#0x20]         ;285
00006e  1a08              SUBS     r0,r1,r0              ;285
000070  9006              STR      r0,[sp,#0x18]         ;285
000072  a809              ADD      r0,sp,#0x24           ;285
000074  9908              LDR      r1,[sp,#0x20]         ;285
000076  1840              ADDS     r0,r0,r1              ;285
000078  462a              MOV      r2,r5                 ;285
00007a  9005              STR      r0,[sp,#0x14]         ;285
00007c  9906              LDR      r1,[sp,#0x18]         ;285
00007e  f7fffffe          BL       __2snprintf
000082  4607              MOV      r7,r0                 ;285
000084  e06e              B        |L7.356|
000086  6860              LDR      r0,[r4,#4]            ;290
000088  9000              STR      r0,[sp,#0]            ;290
00008a  6823              LDR      r3,[r4,#0]            ;290
00008c  21ff              MOVS     r1,#0xff              ;290
00008e  3101              ADDS     r1,#1                 ;290
000090  9808              LDR      r0,[sp,#0x20]         ;290
000092  1a08              SUBS     r0,r1,r0              ;290
000094  9006              STR      r0,[sp,#0x18]         ;290
000096  a809              ADD      r0,sp,#0x24           ;290
000098  9908              LDR      r1,[sp,#0x20]         ;290
00009a  1840              ADDS     r0,r0,r1              ;290
00009c  462a              MOV      r2,r5                 ;290
00009e  9005              STR      r0,[sp,#0x14]         ;290
0000a0  9906              LDR      r1,[sp,#0x18]         ;290
0000a2  f7fffffe          BL       __2snprintf
0000a6  4607              MOV      r7,r0                 ;290
0000a8  e05c              B        |L7.356|
0000aa  68a1              LDR      r1,[r4,#8]            ;294
0000ac  6860              LDR      r0,[r4,#4]            ;294
0000ae  9101              STR      r1,[sp,#4]            ;294
0000b0  9000              STR      r0,[sp,#0]            ;294
0000b2  6823              LDR      r3,[r4,#0]            ;294
0000b4  21ff              MOVS     r1,#0xff              ;294
0000b6  3101              ADDS     r1,#1                 ;294
0000b8  9808              LDR      r0,[sp,#0x20]         ;294
0000ba  1a08              SUBS     r0,r1,r0              ;294
0000bc  9006              STR      r0,[sp,#0x18]         ;294
0000be  a809              ADD      r0,sp,#0x24           ;294
0000c0  9908              LDR      r1,[sp,#0x20]         ;294
0000c2  1840              ADDS     r0,r0,r1              ;294
0000c4  462a              MOV      r2,r5                 ;294
0000c6  9005              STR      r0,[sp,#0x14]         ;294
0000c8  9906              LDR      r1,[sp,#0x18]         ;294
0000ca  f7fffffe          BL       __2snprintf
0000ce  4607              MOV      r7,r0                 ;294
0000d0  e048              B        |L7.356|
0000d2  68a2              LDR      r2,[r4,#8]            ;298
0000d4  6861              LDR      r1,[r4,#4]            ;298
0000d6  68e0              LDR      r0,[r4,#0xc]          ;298
0000d8  9201              STR      r2,[sp,#4]            ;298
0000da  9100              STR      r1,[sp,#0]            ;298
0000dc  9002              STR      r0,[sp,#8]            ;298
0000de  6823              LDR      r3,[r4,#0]            ;298
0000e0  21ff              MOVS     r1,#0xff              ;298
0000e2  3101              ADDS     r1,#1                 ;298
0000e4  9808              LDR      r0,[sp,#0x20]         ;298
0000e6  1a08              SUBS     r0,r1,r0              ;298
0000e8  9006              STR      r0,[sp,#0x18]         ;298
0000ea  a809              ADD      r0,sp,#0x24           ;298
0000ec  9908              LDR      r1,[sp,#0x20]         ;298
0000ee  1840              ADDS     r0,r0,r1              ;298
0000f0  462a              MOV      r2,r5                 ;298
0000f2  9005              STR      r0,[sp,#0x14]         ;298
0000f4  9906              LDR      r1,[sp,#0x18]         ;298
0000f6  f7fffffe          BL       __2snprintf
0000fa  4607              MOV      r7,r0                 ;298
0000fc  e032              B        |L7.356|
0000fe  68a3              LDR      r3,[r4,#8]            ;303
000100  6862              LDR      r2,[r4,#4]            ;303
000102  68e1              LDR      r1,[r4,#0xc]          ;303
000104  6920              LDR      r0,[r4,#0x10]         ;303
000106  9301              STR      r3,[sp,#4]            ;303
000108  9200              STR      r2,[sp,#0]            ;303
00010a  9102              STR      r1,[sp,#8]            ;303
00010c  9003              STR      r0,[sp,#0xc]          ;303
00010e  6823              LDR      r3,[r4,#0]            ;303
000110  21ff              MOVS     r1,#0xff              ;303
000112  3101              ADDS     r1,#1                 ;303
000114  9808              LDR      r0,[sp,#0x20]         ;303
000116  1a08              SUBS     r0,r1,r0              ;303
000118  9006              STR      r0,[sp,#0x18]         ;303
00011a  a809              ADD      r0,sp,#0x24           ;303
00011c  9908              LDR      r1,[sp,#0x20]         ;303
00011e  1840              ADDS     r0,r0,r1              ;303
000120  462a              MOV      r2,r5                 ;303
000122  9005              STR      r0,[sp,#0x14]         ;303
000124  9906              LDR      r1,[sp,#0x18]         ;303
000126  f7fffffe          BL       __2snprintf
00012a  4607              MOV      r7,r0                 ;303
00012c  e01a              B        |L7.356|
00012e  68e3              LDR      r3,[r4,#0xc]          ;315
000130  68a2              LDR      r2,[r4,#8]            ;315
000132  6921              LDR      r1,[r4,#0x10]         ;315
000134  6960              LDR      r0,[r4,#0x14]         ;315
000136  9302              STR      r3,[sp,#8]            ;315
000138  9201              STR      r2,[sp,#4]            ;315
00013a  9103              STR      r1,[sp,#0xc]          ;315
00013c  9004              STR      r0,[sp,#0x10]         ;315
00013e  6860              LDR      r0,[r4,#4]            ;315
000140  9000              STR      r0,[sp,#0]            ;315
000142  6823              LDR      r3,[r4,#0]            ;315
000144  21ff              MOVS     r1,#0xff              ;315
000146  3101              ADDS     r1,#1                 ;315
000148  9808              LDR      r0,[sp,#0x20]         ;315
00014a  1a08              SUBS     r0,r1,r0              ;315
00014c  9006              STR      r0,[sp,#0x18]         ;315
00014e  a809              ADD      r0,sp,#0x24           ;315
000150  9908              LDR      r1,[sp,#0x20]         ;315
000152  1840              ADDS     r0,r0,r1              ;315
000154  462a              MOV      r2,r5                 ;315
000156  9005              STR      r0,[sp,#0x14]         ;315
000158  9906              LDR      r1,[sp,#0x18]         ;315
00015a  f7fffffe          BL       __2snprintf
00015e  4607              MOV      r7,r0                 ;315
000160  e000              B        |L7.356|
000162  bf00              NOP                            ;328
                  |L7.356|
000164  bf00              NOP                            ;281
000166  4639              MOV      r1,r7                 ;330
000168  a808              ADD      r0,sp,#0x20           ;330
00016a  f7fffffe          BL       buf_len_update
00016e  9007              STR      r0,[sp,#0x1c]         ;330
000170  9808              LDR      r0,[sp,#0x20]         ;331
000172  1d06              ADDS     r6,r0,#4              ;331
000174  9807              LDR      r0,[sp,#0x1c]         ;333
000176  2800              CMP      r0,#0                 ;333
000178  d010              BEQ      |L7.412|
00017a  20ff              MOVS     r0,#0xff              ;333
00017c  3001              ADDS     r0,#1                 ;333
00017e  4286              CMP      r6,r0                 ;333
000180  d80c              BHI      |L7.412|
000182  a909              ADD      r1,sp,#0x24           ;337
000184  9a08              LDR      r2,[sp,#0x20]         ;337
000186  1888              ADDS     r0,r1,r2              ;337
000188  2204              MOVS     r2,#4                 ;337
00018a  4905              LDR      r1,|L7.416|
00018c  f7fffffe          BL       __aeabi_memcpy
000190  9608              STR      r6,[sp,#0x20]         ;338
000192  a809              ADD      r0,sp,#0x24           ;340
000194  9908              LDR      r1,[sp,#0x20]         ;340
000196  f7fffffe          BL       serial_tx
00019a  e73f              B        |L7.28|
                  |L7.412|
00019c  2000              MOVS     r0,#0                 ;345
00019e  e73d              B        |L7.28|
;;;348    
                          ENDP

                  |L7.416|
                          DCD      m_default_color

                          AREA ||i.nrf_log_backend_std_handler_get||, CODE, READONLY, ALIGN=2

                  nrf_log_backend_std_handler_get PROC
;;;478    
;;;479    nrf_log_std_handler_t nrf_log_backend_std_handler_get(void)
000000  4800              LDR      r0,|L8.4|
;;;480    {
;;;481        return nrf_log_backend_serial_std_handler;
;;;482    }
000002  4770              BX       lr
;;;483    
                          ENDP

                  |L8.4|
                          DCD      nrf_log_backend_serial_std_handler

                          AREA ||i.serial_get_byte||, CODE, READONLY, ALIGN=2

                  serial_get_byte PROC
;;;190    
;;;191    static uint8_t serial_get_byte(void)
000000  b508              PUSH     {r3,lr}
;;;192    {
;;;193        uint8_t data;
;;;194    #if NRF_LOG_BACKEND_SERIAL_USES_UART
;;;195        if (m_blocking_mode)
000002  480d              LDR      r0,|L9.56|
000004  7800              LDRB     r0,[r0,#0]  ; m_blocking_mode
000006  2800              CMP      r0,#0
000008  d005              BEQ      |L9.22|
;;;196        {
;;;197            (void)nrf_drv_uart_rx(&m_uart, &data, 1);
00000a  2201              MOVS     r2,#1
00000c  4669              MOV      r1,sp
00000e  480b              LDR      r0,|L9.60|
000010  f7fffffe          BL       nrf_drv_uart_rx
000014  e00c              B        |L9.48|
                  |L9.22|
;;;198        }
;;;199        else
;;;200        {
;;;201            m_rx_done = false;
000016  2000              MOVS     r0,#0
000018  4909              LDR      r1,|L9.64|
00001a  7008              STRB     r0,[r1,#0]
;;;202            (void)nrf_drv_uart_rx(&m_uart, &data, 1);
00001c  2201              MOVS     r2,#1
00001e  4669              MOV      r1,sp
000020  4806              LDR      r0,|L9.60|
000022  f7fffffe          BL       nrf_drv_uart_rx
;;;203            while(!m_rx_done);
000026  bf00              NOP      
                  |L9.40|
000028  4805              LDR      r0,|L9.64|
00002a  7800              LDRB     r0,[r0,#0]  ; m_rx_done
00002c  2800              CMP      r0,#0
00002e  d0fb              BEQ      |L9.40|
                  |L9.48|
;;;204        }
;;;205    #elif NRF_LOG_BACKEND_SERIAL_USES_RTT
;;;206        data = (uint8_t)SEGGER_RTT_WaitKey();
;;;207    #endif //NRF_LOG_BACKEND_SERIAL_USES_RTT
;;;208        return data;
000030  4668              MOV      r0,sp
000032  7800              LDRB     r0,[r0,#0]
;;;209    }
000034  bd08              POP      {r3,pc}
;;;210    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      m_blocking_mode
                  |L9.60|
                          DCD      m_uart
                  |L9.64|
                          DCD      m_rx_done

                          AREA ||i.serial_is_busy||, CODE, READONLY, ALIGN=2

                  serial_is_busy PROC
;;;136    
;;;137    static bool serial_is_busy(void)
000000  b510              PUSH     {r4,lr}
;;;138    {
;;;139        bool res = false;
000002  2400              MOVS     r4,#0
;;;140    
;;;141    #if (NRF_LOG_BACKEND_SERIAL_USES_UART)
;;;142        res = nrf_drv_uart_tx_in_progress(&m_uart);
000004  4802              LDR      r0,|L10.16|
000006  f7fffffe          BL       nrf_drv_uart_tx_in_progress
00000a  4604              MOV      r4,r0
;;;143    #endif
;;;144    
;;;145    #if (NRF_LOG_BACKEND_SERIAL_USES_RTT)
;;;146    
;;;147    #endif
;;;148    
;;;149        return res;
00000c  4620              MOV      r0,r4
;;;150    }
00000e  bd10              POP      {r4,pc}
;;;151    
                          ENDP

                  |L10.16|
                          DCD      m_uart

                          AREA ||i.serial_tx||, CODE, READONLY, ALIGN=2

                  serial_tx PROC
;;;152    
;;;153    static bool serial_tx(uint8_t * p_buf, uint32_t len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;154    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;155        bool ret = true;
000006  2601              MOVS     r6,#1
;;;156    
;;;157    #if NRF_LOG_BACKEND_SERIAL_USES_UART
;;;158        memcpy(m_uart_buffer, p_buf, len);
000008  4622              MOV      r2,r4
00000a  4629              MOV      r1,r5
00000c  4806              LDR      r0,|L11.40|
00000e  f7fffffe          BL       __aeabi_memcpy
;;;159        uint32_t ret_code = nrf_drv_uart_tx(&m_uart, (uint8_t *)m_uart_buffer, len);
000012  b2e2              UXTB     r2,r4
000014  4904              LDR      r1,|L11.40|
000016  4805              LDR      r0,|L11.44|
000018  f7fffffe          BL       nrf_drv_uart_tx
00001c  4607              MOV      r7,r0
;;;160        if (ret_code != NRF_SUCCESS)
00001e  2f00              CMP      r7,#0
000020  d000              BEQ      |L11.36|
;;;161        {
;;;162            ret = false;
000022  2600              MOVS     r6,#0
                  |L11.36|
;;;163        }
;;;164    #endif //NRF_LOG_BACKEND_SERIAL_USES_UART
;;;165    
;;;166    #if NRF_LOG_BACKEND_SERIAL_USES_RTT
;;;167        uint32_t idx    = 0;
;;;168        uint32_t length = len;
;;;169        uint32_t processed;
;;;170        uint32_t watchdog_counter = RTT_RETRY_COUNTER;
;;;171        do
;;;172        {
;;;173            processed = SEGGER_RTT_WriteNoLock(0, &p_buf[idx], length);
;;;174            idx += processed;
;;;175            length -= processed;
;;;176            if (processed == 0)
;;;177            {
;;;178                // If RTT is not connected then ensure that logger does not block
;;;179                watchdog_counter--;
;;;180                if (watchdog_counter == 0)
;;;181                {
;;;182                    break;
;;;183                }
;;;184            }
;;;185        } while (length);
;;;186    #endif //NRF_LOG_BACKEND_SERIAL_USES_RTT
;;;187        return ret;
000024  4630              MOV      r0,r6
;;;188    }
000026  bdf8              POP      {r3-r7,pc}
;;;189    
                          ENDP

                  |L11.40|
                          DCD      m_uart_buffer
                  |L11.44|
                          DCD      m_uart

                          AREA ||i.timestamp_process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_return_value
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  timestamp_process PROC
;;;227    
;;;228    static bool timestamp_process(const uint32_t * const p_timestamp, char * p_str, uint32_t * p_len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;229    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
;;;230        int32_t len = 0;
000008  2500              MOVS     r5,#0
;;;231        bool    ret = true;
00000a  2001              MOVS     r0,#1
00000c  9000              STR      r0,[sp,#0]
;;;232        if (p_timestamp)
00000e  2e00              CMP      r6,#0
000010  d015              BEQ      |L12.62|
;;;233        {
;;;234    #if NRF_LOG_USES_COLORS
;;;235            len = sizeof(m_default_color) - 1;
000012  2504              MOVS     r5,#4
;;;236            memcpy(p_str, m_default_color, len);
000014  462a              MOV      r2,r5
000016  490c              LDR      r1,|L12.72|
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       __aeabi_memcpy
;;;237            *p_len += len;
00001e  6820              LDR      r0,[r4,#0]
000020  1940              ADDS     r0,r0,r5
000022  6020              STR      r0,[r4,#0]
;;;238    #endif //NRF_LOG_USES_COLORS
;;;239            len = snprintf(&p_str[len],NRF_LOG_BACKEND_MAX_STRING_LENGTH, TIMESTAMP_STR(NRF_LOG_TIMESTAMP_DIGITS), (int)*p_timestamp);
000024  1978              ADDS     r0,r7,r5
000026  a209              ADR      r2,|L12.76|
000028  01a9              LSLS     r1,r5,#6
00002a  6833              LDR      r3,[r6,#0]
00002c  f7fffffe          BL       __2snprintf
000030  4605              MOV      r5,r0
;;;240            ret = buf_len_update(p_len, len);
000032  4629              MOV      r1,r5
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       buf_len_update
00003a  9000              STR      r0,[sp,#0]
00003c  e001              B        |L12.66|
                  |L12.62|
;;;241        }
;;;242        else
;;;243        {
;;;244            *p_len = 0;
00003e  2000              MOVS     r0,#0
000040  6020              STR      r0,[r4,#0]
                  |L12.66|
;;;245        }
;;;246        return ret;
000042  9800              LDR      r0,[sp,#0]
;;;247    }
000044  bdf8              POP      {r3-r7,pc}
;;;248    
                          ENDP

000046  0000              DCW      0x0000
                  |L12.72|
                          DCD      m_default_color
                  |L12.76|
00004c  5b253038          DCB      "[%08d]",0
000050  645d00  
000053  00                DCB      0

                          AREA ||i.uart_event_handler||, CODE, READONLY, ALIGN=2

                  uart_event_handler PROC
;;;88     #if (NRF_LOG_BACKEND_SERIAL_USES_UART)
;;;89     static void uart_event_handler(nrf_drv_uart_event_t * p_event, void * p_context)
000000  7802              LDRB     r2,[r0,#0]
;;;90     {
;;;91         // Dummy handler since is_busy feature is used for determining readiness.
;;;92         if (p_event->type == NRF_DRV_UART_EVT_RX_DONE)
000002  2a01              CMP      r2,#1
000004  d101              BNE      |L13.10|
;;;93         {
;;;94             m_rx_done = true;
000006  4b01              LDR      r3,|L13.12|
000008  701a              STRB     r2,[r3,#0]
                  |L13.10|
;;;95         }
;;;96     }
00000a  4770              BX       lr
;;;97     #endif //NRF_LOG_BACKEND_SERIAL_USES_UART
                          ENDP

                  |L13.12|
                          DCD      m_rx_done

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  m_uart_buffer
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_default_color
000000  1b5b306d          DCB      0x1b,0x5b,0x30,0x6d
000004  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0x00000000
00001c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x01d7e000
000024  03000000          DCB      0x03,0x00,0x00,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  m_uart
                          DCD      0x40002000
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  m_initialized
000008  00                DCB      0x00
                  m_blocking_mode
000009  00                DCB      0x00
                  m_rx_done
00000a  00                DCB      0x00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L80.24|
                  |L80.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L80.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L80.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\log\\src\\nrf_log_backend_serial.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_nrf_log_backend_serial_c_230f8f19____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___24_nrf_log_backend_serial_c_230f8f19____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_nrf_log_backend_serial_c_230f8f19____REVSH|
#line 144
|__asm___24_nrf_log_backend_serial_c_230f8f19____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
