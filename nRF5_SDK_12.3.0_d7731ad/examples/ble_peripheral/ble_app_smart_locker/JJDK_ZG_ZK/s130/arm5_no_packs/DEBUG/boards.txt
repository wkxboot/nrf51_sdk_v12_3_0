; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\boards.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\boards.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\boards.crf ..\..\..\..\..\..\components\boards\boards.c]
                          THUMB

                          AREA ||i.bsp_board_button_idx_to_pin||, CODE, READONLY, ALIGN=2

                  bsp_board_button_idx_to_pin PROC
;;;163    
;;;164    uint32_t bsp_board_button_idx_to_pin(uint32_t button_idx)
000000  4601              MOV      r1,r0
;;;165    {
;;;166        ASSERT(button_idx < BUTTONS_NUMBER);
;;;167        return m_board_btn_list[button_idx];
000002  4801              LDR      r0,|L1.8|
000004  5c40              LDRB     r0,[r0,r1]
;;;168    }
000006  4770              BX       lr
;;;169    #endif //BUTTONS_NUMBER > 0
                          ENDP

                  |L1.8|
                          DCD      m_board_btn_list

                          AREA ||i.bsp_board_button_state_get||, CODE, READONLY, ALIGN=2

                  bsp_board_button_state_get PROC
;;;132    #if BUTTONS_NUMBER > 0
;;;133    bool bsp_board_button_state_get(uint32_t button_idx)
000000  b510              PUSH     {r4,lr}
;;;134    {
000002  4601              MOV      r1,r0
;;;135        ASSERT(button_idx < BUTTONS_NUMBER);
;;;136        bool pin_set = nrf_gpio_pin_read(m_board_btn_list[button_idx]) ? true : false;
000004  4b0a              LDR      r3,|L2.48|
000006  5c58              LDRB     r0,[r3,r1]
000008  bf00              NOP      
00000a  2405              MOVS     r4,#5
00000c  0724              LSLS     r4,r4,#28
00000e  4623              MOV      r3,r4
000010  bf00              NOP      
000012  1524              ASRS     r4,r4,#20
000014  191c              ADDS     r4,r3,r4
000016  6924              LDR      r4,[r4,#0x10]
000018  40c4              LSRS     r4,r4,r0
00001a  07e4              LSLS     r4,r4,#31
00001c  0fe4              LSRS     r4,r4,#31
00001e  2c00              CMP      r4,#0
000020  d001              BEQ      |L2.38|
000022  2001              MOVS     r0,#1
000024  e000              B        |L2.40|
                  |L2.38|
000026  2000              MOVS     r0,#0
                  |L2.40|
000028  4602              MOV      r2,r0
;;;137        return (pin_set == (BUTTONS_ACTIVE_STATE ? true : false));
00002a  2001              MOVS     r0,#1
00002c  4050              EORS     r0,r0,r2
;;;138    }
00002e  bd10              POP      {r4,pc}
;;;139    
                          ENDP

                  |L2.48|
                          DCD      m_board_btn_list

                          AREA ||i.bsp_board_buttons_init||, CODE, READONLY, ALIGN=2

                  bsp_board_buttons_init PROC
;;;139    
;;;140    void bsp_board_buttons_init(void)
000000  b57c              PUSH     {r2-r6,lr}
;;;141    {
;;;142        uint32_t i;
;;;143        for(i = 0; i < BUTTONS_NUMBER; ++i)
000002  2400              MOVS     r4,#0
000004  e00d              B        |L3.34|
                  |L3.6|
;;;144        {
;;;145            nrf_gpio_cfg_input(m_board_btn_list[i], BUTTON_PULL);
000006  4808              LDR      r0,|L3.40|
000008  5d05              LDRB     r5,[r0,r4]
00000a  2603              MOVS     r6,#3
00000c  2000              MOVS     r0,#0
00000e  9000              STR      r0,[sp,#0]
000010  4633              MOV      r3,r6
000012  4602              MOV      r2,r0
000014  4601              MOV      r1,r0
000016  9001              STR      r0,[sp,#4]
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       nrf_gpio_cfg
00001e  bf00              NOP      
000020  1c64              ADDS     r4,r4,#1              ;143
                  |L3.34|
000022  2c03              CMP      r4,#3                 ;143
000024  d3ef              BCC      |L3.6|
;;;146        }
;;;147    }
000026  bd7c              POP      {r2-r6,pc}
;;;148    
                          ENDP

                  |L3.40|
                          DCD      m_board_btn_list

                          AREA ||i.bsp_board_led_idx_to_pin||, CODE, READONLY, ALIGN=2

                  bsp_board_led_idx_to_pin PROC
;;;109    
;;;110    uint32_t bsp_board_led_idx_to_pin(uint32_t led_idx)
000000  4601              MOV      r1,r0
;;;111    {
;;;112        ASSERT(led_idx < LEDS_NUMBER);
;;;113        return m_board_led_list[led_idx];
000002  4801              LDR      r0,|L4.8|
000004  5c40              LDRB     r0,[r0,r1]
;;;114    }
000006  4770              BX       lr
;;;115    
                          ENDP

                  |L4.8|
                          DCD      m_board_led_list

                          AREA ||i.bsp_board_led_invert||, CODE, READONLY, ALIGN=2

                  bsp_board_led_invert PROC
;;;93     
;;;94     void bsp_board_led_invert(uint32_t led_idx)
000000  b510              PUSH     {r4,lr}
;;;95     {
000002  4604              MOV      r4,r0
;;;96         ASSERT(led_idx < LEDS_NUMBER);
;;;97         nrf_gpio_pin_toggle(m_board_led_list[led_idx]);
000004  4902              LDR      r1,|L5.16|
000006  5d08              LDRB     r0,[r1,r4]
000008  f7fffffe          BL       nrf_gpio_pin_toggle
;;;98     }
00000c  bd10              POP      {r4,pc}
;;;99     
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      m_board_led_list

                          AREA ||i.bsp_board_led_off||, CODE, READONLY, ALIGN=2

                  bsp_board_led_off PROC
;;;69     
;;;70     void bsp_board_led_off(uint32_t led_idx)
000000  b510              PUSH     {r4,lr}
;;;71     {
000002  4604              MOV      r4,r0
;;;72         ASSERT(led_idx < LEDS_NUMBER);
;;;73         nrf_gpio_pin_write(m_board_led_list[led_idx], LEDS_ACTIVE_STATE ? 0 : 1);
000004  4902              LDR      r1,|L6.16|
000006  5d08              LDRB     r0,[r1,r4]
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       nrf_gpio_pin_write
;;;74     }
00000e  bd10              POP      {r4,pc}
;;;75     
                          ENDP

                  |L6.16|
                          DCD      m_board_led_list

                          AREA ||i.bsp_board_led_on||, CODE, READONLY, ALIGN=2

                  bsp_board_led_on PROC
;;;63     
;;;64     void bsp_board_led_on(uint32_t led_idx)
000000  b510              PUSH     {r4,lr}
;;;65     {
000002  4604              MOV      r4,r0
;;;66             ASSERT(led_idx < LEDS_NUMBER);
;;;67             nrf_gpio_pin_write(m_board_led_list[led_idx], LEDS_ACTIVE_STATE ? 1 : 0);
000004  4902              LDR      r1,|L7.16|
000006  5d08              LDRB     r0,[r1,r4]
000008  2101              MOVS     r1,#1
00000a  f7fffffe          BL       nrf_gpio_pin_write
;;;68     }
00000e  bd10              POP      {r4,pc}
;;;69     
                          ENDP

                  |L7.16|
                          DCD      m_board_led_list

                          AREA ||i.bsp_board_led_state_get||, CODE, READONLY, ALIGN=2

                  bsp_board_led_state_get PROC
;;;56     #if LEDS_NUMBER > 0
;;;57     bool bsp_board_led_state_get(uint32_t led_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;58     {
000002  4604              MOV      r4,r0
;;;59         ASSERT(led_idx < LEDS_NUMBER);
;;;60         bool pin_set = nrf_gpio_pin_out_read(m_board_led_list[led_idx]) ? true : false;
000004  4907              LDR      r1,|L8.36|
000006  5d08              LDRB     r0,[r1,r4]
000008  f7fffffe          BL       nrf_gpio_pin_out_read
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L8.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L8.22|
                  |L8.20|
000014  2000              MOVS     r0,#0
                  |L8.22|
000016  4605              MOV      r5,r0
;;;61         return (pin_set == (LEDS_ACTIVE_STATE ? true : false));
000018  2001              MOVS     r0,#1
00001a  4068              EORS     r0,r0,r5
00001c  2101              MOVS     r1,#1
00001e  4048              EORS     r0,r0,r1
;;;62     }
000020  bd70              POP      {r4-r6,pc}
;;;63     
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      m_board_led_list

                          AREA ||i.bsp_board_leds_init||, CODE, READONLY, ALIGN=2

                  bsp_board_leds_init PROC
;;;99     
;;;100    void bsp_board_leds_init(void)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102        uint32_t i;
;;;103        for(i = 0; i < LEDS_NUMBER; ++i)
000002  2400              MOVS     r4,#0
000004  e004              B        |L9.16|
                  |L9.6|
;;;104        {
;;;105            nrf_gpio_cfg_output(m_board_led_list[i]);
000006  4905              LDR      r1,|L9.28|
000008  5d08              LDRB     r0,[r1,r4]
00000a  f7fffffe          BL       nrf_gpio_cfg_output
00000e  1c64              ADDS     r4,r4,#1              ;103
                  |L9.16|
000010  2c03              CMP      r4,#3                 ;103
000012  d3f8              BCC      |L9.6|
;;;106        }
;;;107        bsp_board_leds_off();
000014  f7fffffe          BL       bsp_board_leds_off
;;;108    }
000018  bd10              POP      {r4,pc}
;;;109    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      m_board_led_list

                          AREA ||i.bsp_board_leds_off||, CODE, READONLY, ALIGN=1

                  bsp_board_leds_off PROC
;;;75     
;;;76     void bsp_board_leds_off(void)
000000  b510              PUSH     {r4,lr}
;;;77     {
;;;78         uint32_t i;
;;;79         for(i = 0; i < LEDS_NUMBER; ++i)
000002  2400              MOVS     r4,#0
000004  e003              B        |L10.14|
                  |L10.6|
;;;80         {
;;;81             bsp_board_led_off(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_board_led_off
00000c  1c64              ADDS     r4,r4,#1              ;79
                  |L10.14|
00000e  2c03              CMP      r4,#3                 ;79
000010  d3f9              BCC      |L10.6|
;;;82         }
;;;83     }
000012  bd10              POP      {r4,pc}
;;;84     
                          ENDP


                          AREA ||i.bsp_board_leds_on||, CODE, READONLY, ALIGN=1

                  bsp_board_leds_on PROC
;;;84     
;;;85     void bsp_board_leds_on(void)
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87         uint32_t i;
;;;88         for(i = 0; i < LEDS_NUMBER; ++i)
000002  2400              MOVS     r4,#0
000004  e003              B        |L11.14|
                  |L11.6|
;;;89         {
;;;90             bsp_board_led_on(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_board_led_on
00000c  1c64              ADDS     r4,r4,#1              ;88
                  |L11.14|
00000e  2c03              CMP      r4,#3                 ;88
000010  d3f9              BCC      |L11.6|
;;;91         }
;;;92     }
000012  bd10              POP      {r4,pc}
;;;93     
                          ENDP


                          AREA ||i.bsp_board_pin_to_button_idx||, CODE, READONLY, ALIGN=2

                  bsp_board_pin_to_button_idx PROC
;;;148    
;;;149    uint32_t bsp_board_pin_to_button_idx(uint32_t pin_number)
000000  4602              MOV      r2,r0
;;;150    {
;;;151        uint32_t i;
;;;152        uint32_t ret = 0xFFFFFFFF;
000002  2000              MOVS     r0,#0
000004  43c0              MVNS     r0,r0
;;;153        for(i = 0; i < BUTTONS_NUMBER; ++i)
000006  2100              MOVS     r1,#0
000008  e006              B        |L12.24|
                  |L12.10|
;;;154        {
;;;155            if (m_board_btn_list[i] == pin_number)
00000a  4b05              LDR      r3,|L12.32|
00000c  5c5b              LDRB     r3,[r3,r1]
00000e  4293              CMP      r3,r2
000010  d101              BNE      |L12.22|
;;;156            {
;;;157                ret = i;
000012  4608              MOV      r0,r1
;;;158                break;
000014  e002              B        |L12.28|
                  |L12.22|
000016  1c49              ADDS     r1,r1,#1              ;153
                  |L12.24|
000018  2903              CMP      r1,#3                 ;153
00001a  d3f6              BCC      |L12.10|
                  |L12.28|
00001c  bf00              NOP      
;;;159            }
;;;160        }
;;;161        return ret;
;;;162    }
00001e  4770              BX       lr
;;;163    
                          ENDP

                  |L12.32|
                          DCD      m_board_btn_list

                          AREA ||i.bsp_board_pin_to_led_idx||, CODE, READONLY, ALIGN=2

                  bsp_board_pin_to_led_idx PROC
;;;115    
;;;116    uint32_t bsp_board_pin_to_led_idx(uint32_t pin_number)
000000  4602              MOV      r2,r0
;;;117    {
;;;118        uint32_t ret = 0xFFFFFFFF;
000002  2000              MOVS     r0,#0
000004  43c0              MVNS     r0,r0
;;;119        uint32_t i;
;;;120        for(i = 0; i < LEDS_NUMBER; ++i)
000006  2100              MOVS     r1,#0
000008  e006              B        |L13.24|
                  |L13.10|
;;;121        {
;;;122            if (m_board_led_list[i] == pin_number)
00000a  4b05              LDR      r3,|L13.32|
00000c  5c5b              LDRB     r3,[r3,r1]
00000e  4293              CMP      r3,r2
000010  d101              BNE      |L13.22|
;;;123            {
;;;124                ret = i;
000012  4608              MOV      r0,r1
;;;125                break;
000014  e002              B        |L13.28|
                  |L13.22|
000016  1c49              ADDS     r1,r1,#1              ;120
                  |L13.24|
000018  2903              CMP      r1,#3                 ;120
00001a  d3f6              BCC      |L13.10|
                  |L13.28|
00001c  bf00              NOP      
;;;126            }
;;;127        }
;;;128        return ret;
;;;129    }
00001e  4770              BX       lr
;;;130    #endif //LEDS_NUMBER > 0
                          ENDP

                  |L13.32|
                          DCD      m_board_led_list

                          AREA ||i.bsp_board_pin_to_switch_idx||, CODE, READONLY, ALIGN=2

                  bsp_board_pin_to_switch_idx PROC
;;;231    
;;;232    uint32_t bsp_board_pin_to_switch_idx(uint32_t pin_number)
000000  4602              MOV      r2,r0
;;;233    {
;;;234        uint32_t ret = 0xFFFFFFFF;
000002  2000              MOVS     r0,#0
000004  43c0              MVNS     r0,r0
;;;235        uint32_t i;
;;;236        for(i = 0; i < LEDS_NUMBER; ++i)
000006  2100              MOVS     r1,#0
000008  e006              B        |L14.24|
                  |L14.10|
;;;237        {
;;;238            if (m_board_switch_list[i] == pin_number)
00000a  4b05              LDR      r3,|L14.32|
00000c  5c5b              LDRB     r3,[r3,r1]
00000e  4293              CMP      r3,r2
000010  d101              BNE      |L14.22|
;;;239            {
;;;240                ret = i;
000012  4608              MOV      r0,r1
;;;241                break;
000014  e002              B        |L14.28|
                  |L14.22|
000016  1c49              ADDS     r1,r1,#1              ;236
                  |L14.24|
000018  2903              CMP      r1,#3                 ;236
00001a  d3f6              BCC      |L14.10|
                  |L14.28|
00001c  bf00              NOP      
;;;242            }
;;;243        }
;;;244        return ret;
;;;245    }
00001e  4770              BX       lr
;;;246    #endif //SWITCHS_NUMBER > 0
                          ENDP

                  |L14.32|
                          DCD      m_board_switch_list

                          AREA ||i.bsp_board_switch_idx_to_pin||, CODE, READONLY, ALIGN=2

                  bsp_board_switch_idx_to_pin PROC
;;;225    
;;;226    uint32_t bsp_board_switch_idx_to_pin(uint32_t switch_idx)
000000  4601              MOV      r1,r0
;;;227    {
;;;228        ASSERT(switch_idx < LEDS_NUMBER);
;;;229        return m_board_switch_list[switch_idx];
000002  4801              LDR      r0,|L15.8|
000004  5c40              LDRB     r0,[r0,r1]
;;;230    }
000006  4770              BX       lr
;;;231    
                          ENDP

                  |L15.8|
                          DCD      m_board_switch_list

                          AREA ||i.bsp_board_switch_invert||, CODE, READONLY, ALIGN=2

                  bsp_board_switch_invert PROC
;;;209    
;;;210    void bsp_board_switch_invert(uint32_t switch_idx)
000000  b510              PUSH     {r4,lr}
;;;211    {
000002  4604              MOV      r4,r0
;;;212        ASSERT(switch_idx < LEDS_NUMBER);
;;;213        nrf_gpio_pin_toggle(m_board_switch_list[switch_idx]);
000004  4902              LDR      r1,|L16.16|
000006  5d08              LDRB     r0,[r1,r4]
000008  f7fffffe          BL       nrf_gpio_pin_toggle
;;;214    }
00000c  bd10              POP      {r4,pc}
;;;215    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      m_board_switch_list

                          AREA ||i.bsp_board_switch_off||, CODE, READONLY, ALIGN=2

                  bsp_board_switch_off PROC
;;;185    
;;;186    void bsp_board_switch_off(uint32_t switch_idx)
000000  b510              PUSH     {r4,lr}
;;;187    {
000002  4604              MOV      r4,r0
;;;188        ASSERT(switch_idx < LEDS_NUMBER);
;;;189        nrf_gpio_pin_write(m_board_switch_list[switch_idx], LEDS_ACTIVE_STATE ? 0 : 1);
000004  4902              LDR      r1,|L17.16|
000006  5d08              LDRB     r0,[r1,r4]
000008  2100              MOVS     r1,#0
00000a  f7fffffe          BL       nrf_gpio_pin_write
;;;190    }
00000e  bd10              POP      {r4,pc}
;;;191    
                          ENDP

                  |L17.16|
                          DCD      m_board_switch_list

                          AREA ||i.bsp_board_switch_on||, CODE, READONLY, ALIGN=2

                  bsp_board_switch_on PROC
;;;179    
;;;180    void bsp_board_switch_on(uint32_t switch_idx)
000000  b510              PUSH     {r4,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182            ASSERT(switch_idx < LEDS_NUMBER);
;;;183            nrf_gpio_pin_write(m_board_switch_list[switch_idx], LEDS_ACTIVE_STATE ? 1 : 0);
000004  4902              LDR      r1,|L18.16|
000006  5d08              LDRB     r0,[r1,r4]
000008  2101              MOVS     r1,#1
00000a  f7fffffe          BL       nrf_gpio_pin_write
;;;184    }
00000e  bd10              POP      {r4,pc}
;;;185    
                          ENDP

                  |L18.16|
                          DCD      m_board_switch_list

                          AREA ||i.bsp_board_switch_state_get||, CODE, READONLY, ALIGN=2

                  bsp_board_switch_state_get PROC
;;;172    #if SWITCHS_NUMBER > 0
;;;173    bool bsp_board_switch_state_get(uint32_t switch_idx)
000000  b570              PUSH     {r4-r6,lr}
;;;174    {
000002  4604              MOV      r4,r0
;;;175        ASSERT(switch_idx < LEDS_NUMBER);
;;;176        bool pin_set = nrf_gpio_pin_out_read(m_board_switch_list[switch_idx]) ? true : false;
000004  4907              LDR      r1,|L19.36|
000006  5d08              LDRB     r0,[r1,r4]
000008  f7fffffe          BL       nrf_gpio_pin_out_read
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L19.20|
000010  2001              MOVS     r0,#1
000012  e000              B        |L19.22|
                  |L19.20|
000014  2000              MOVS     r0,#0
                  |L19.22|
000016  4605              MOV      r5,r0
;;;177        return (pin_set == (LEDS_ACTIVE_STATE ? true : false));
000018  2001              MOVS     r0,#1
00001a  4068              EORS     r0,r0,r5
00001c  2101              MOVS     r1,#1
00001e  4048              EORS     r0,r0,r1
;;;178    }
000020  bd70              POP      {r4-r6,pc}
;;;179    
                          ENDP

000022  0000              DCW      0x0000
                  |L19.36|
                          DCD      m_board_switch_list

                          AREA ||i.bsp_board_switchs_init||, CODE, READONLY, ALIGN=2

                  bsp_board_switchs_init PROC
;;;215    
;;;216    void bsp_board_switchs_init(void)
000000  b510              PUSH     {r4,lr}
;;;217    {
;;;218        uint32_t i;
;;;219        for(i = 0; i < LEDS_NUMBER; ++i)
000002  2400              MOVS     r4,#0
000004  e004              B        |L20.16|
                  |L20.6|
;;;220        {
;;;221            nrf_gpio_cfg_output(m_board_switch_list[i]);
000006  4905              LDR      r1,|L20.28|
000008  5d08              LDRB     r0,[r1,r4]
00000a  f7fffffe          BL       nrf_gpio_cfg_output
00000e  1c64              ADDS     r4,r4,#1              ;219
                  |L20.16|
000010  2c03              CMP      r4,#3                 ;219
000012  d3f8              BCC      |L20.6|
;;;222        }
;;;223        bsp_board_switchs_off();
000014  f7fffffe          BL       bsp_board_switchs_off
;;;224    }
000018  bd10              POP      {r4,pc}
;;;225    
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      m_board_switch_list

                          AREA ||i.bsp_board_switchs_off||, CODE, READONLY, ALIGN=1

                  bsp_board_switchs_off PROC
;;;191    
;;;192    void bsp_board_switchs_off(void)
000000  b510              PUSH     {r4,lr}
;;;193    {
;;;194        uint32_t i;
;;;195        for(i = 0; i < LEDS_NUMBER; ++i)
000002  2400              MOVS     r4,#0
000004  e003              B        |L21.14|
                  |L21.6|
;;;196        {
;;;197            bsp_board_switch_off(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_board_switch_off
00000c  1c64              ADDS     r4,r4,#1              ;195
                  |L21.14|
00000e  2c03              CMP      r4,#3                 ;195
000010  d3f9              BCC      |L21.6|
;;;198        }
;;;199    }
000012  bd10              POP      {r4,pc}
;;;200    
                          ENDP


                          AREA ||i.bsp_board_switchs_on||, CODE, READONLY, ALIGN=1

                  bsp_board_switchs_on PROC
;;;200    
;;;201    void bsp_board_switchs_on(void)
000000  b510              PUSH     {r4,lr}
;;;202    {
;;;203        uint32_t i;
;;;204        for(i = 0; i < LEDS_NUMBER; ++i)
000002  2400              MOVS     r4,#0
000004  e003              B        |L22.14|
                  |L22.6|
;;;205        {
;;;206            bsp_board_switch_on(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_board_switch_on
00000c  1c64              ADDS     r4,r4,#1              ;204
                  |L22.14|
00000e  2c03              CMP      r4,#3                 ;204
000010  d3f9              BCC      |L22.6|
;;;207        }
;;;208    }
000012  bd10              POP      {r4,pc}
;;;209    
                          ENDP


                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg PROC
;;;503    
;;;504    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;505        uint32_t             pin_number,
;;;506        nrf_gpio_pin_dir_t   dir,
;;;507        nrf_gpio_pin_input_t input,
;;;508        nrf_gpio_pin_pull_t  pull,
;;;509        nrf_gpio_pin_drive_t drive,
;;;510        nrf_gpio_pin_sense_t sense)
;;;511    {
;;;512        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000002  bf00              NOP      
000004  2505              MOVS     r5,#5
000006  072d              LSLS     r5,r5,#28
000008  462c              MOV      r4,r5
;;;513    
;;;514        reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
00000a  0055              LSLS     r5,r2,#1
00000c  430d              ORRS     r5,r5,r1
00000e  009e              LSLS     r6,r3,#2
000010  4335              ORRS     r5,r5,r6
000012  9e05              LDR      r6,[sp,#0x14]
000014  0236              LSLS     r6,r6,#8
000016  4335              ORRS     r5,r5,r6
000018  9e06              LDR      r6,[sp,#0x18]
00001a  0436              LSLS     r6,r6,#16
00001c  4335              ORRS     r5,r5,r6
00001e  0086              LSLS     r6,r0,#2
000020  2707              MOVS     r7,#7
000022  023f              LSLS     r7,r7,#8
000024  19e7              ADDS     r7,r4,r7
000026  51bd              STR      r5,[r7,r6]
;;;515                                   | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;516                                   | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
;;;517                                   | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;518                                   | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;519    }
000028  bdf0              POP      {r4-r7,pc}
;;;520    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_output||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_output PROC
;;;521    
;;;522    __STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4611              MOV      r1,r2
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;525            pin_number,
;;;526            NRF_GPIO_PIN_DIR_OUTPUT,
;;;527            NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;528            NRF_GPIO_PIN_NOPULL,
;;;529            NRF_GPIO_PIN_S0S1,
;;;530            NRF_GPIO_PIN_NOSENSE);
;;;531    }
000016  bd1c              POP      {r2-r4,pc}
;;;532    
                          ENDP


                          AREA ||i.nrf_gpio_pin_out_read||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_out_read PROC
;;;668    
;;;669    __STATIC_INLINE uint32_t nrf_gpio_pin_out_read(uint32_t pin_number)
000000  4601              MOV      r1,r0
;;;670    {
;;;671        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000002  bf00              NOP      
000004  2005              MOVS     r0,#5
000006  0700              LSLS     r0,r0,#28
000008  4602              MOV      r2,r0
;;;672    
;;;673        return ((nrf_gpio_port_out_read(reg) >> pin_number) & 1UL);
00000a  bf00              NOP      
00000c  1500              ASRS     r0,r0,#20
00000e  1810              ADDS     r0,r2,r0
000010  6840              LDR      r0,[r0,#4]
000012  40c8              LSRS     r0,r0,r1
000014  07c0              LSLS     r0,r0,#31
000016  0fc0              LSRS     r0,r0,#31
;;;674    }
000018  4770              BX       lr
;;;675    
                          ENDP


                          AREA ||i.nrf_gpio_pin_toggle||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_toggle PROC
;;;637    
;;;638    __STATIC_INLINE void nrf_gpio_pin_toggle(uint32_t pin_number)
000000  b510              PUSH     {r4,lr}
;;;639    {
;;;640        NRF_GPIO_Type * reg        = nrf_gpio_pin_port_decode(&pin_number);
000002  bf00              NOP      
000004  2305              MOVS     r3,#5
000006  071b              LSLS     r3,r3,#28
000008  4619              MOV      r1,r3
;;;641        uint32_t        pins_state = reg->OUT;
00000a  151b              ASRS     r3,r3,#20
00000c  18cb              ADDS     r3,r1,r3
00000e  685a              LDR      r2,[r3,#4]
;;;642    
;;;643        reg->OUTSET = (~pins_state & (1UL << pin_number));
000010  2301              MOVS     r3,#1
000012  4083              LSLS     r3,r3,r0
000014  4393              BICS     r3,r3,r2
000016  2405              MOVS     r4,#5
000018  0224              LSLS     r4,r4,#8
00001a  190c              ADDS     r4,r1,r4
00001c  60a3              STR      r3,[r4,#8]
;;;644        reg->OUTCLR = (pins_state & (1UL << pin_number));
00001e  2301              MOVS     r3,#1
000020  4083              LSLS     r3,r3,r0
000022  4013              ANDS     r3,r3,r2
000024  2405              MOVS     r4,#5
000026  0224              LSLS     r4,r4,#8
000028  190c              ADDS     r4,r1,r4
00002a  60e3              STR      r3,[r4,#0xc]
;;;645    }
00002c  bd10              POP      {r4,pc}
;;;646    
                          ENDP


                          AREA ||i.nrf_gpio_pin_write||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_write PROC
;;;647    
;;;648    __STATIC_INLINE void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
000000  b510              PUSH     {r4,lr}
;;;649    {
;;;650        if (value == 0)
000002  2900              CMP      r1,#0
000004  d10d              BNE      |L27.34|
;;;651        {
;;;652            nrf_gpio_pin_clear(pin_number);
000006  bf00              NOP      
000008  bf00              NOP      
00000a  2205              MOVS     r2,#5
00000c  0712              LSLS     r2,r2,#28
00000e  4613              MOV      r3,r2
000010  2201              MOVS     r2,#1
000012  4082              LSLS     r2,r2,r0
000014  2405              MOVS     r4,#5
000016  0224              LSLS     r4,r4,#8
000018  191c              ADDS     r4,r3,r4
00001a  60e2              STR      r2,[r4,#0xc]
00001c  bf00              NOP      
00001e  bf00              NOP      
000020  e00d              B        |L27.62|
                  |L27.34|
;;;653        }
;;;654        else
;;;655        {
;;;656            nrf_gpio_pin_set(pin_number);
000022  bf00              NOP      
000024  bf00              NOP      
000026  2205              MOVS     r2,#5
000028  0712              LSLS     r2,r2,#28
00002a  4613              MOV      r3,r2
00002c  2201              MOVS     r2,#1
00002e  4082              LSLS     r2,r2,r0
000030  2405              MOVS     r4,#5
000032  0224              LSLS     r4,r4,#8
000034  191c              ADDS     r4,r3,r4
000036  60a2              STR      r2,[r4,#8]
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  bf00              NOP      
                  |L27.62|
;;;657        }
;;;658    }
00003e  bd10              POP      {r4,pc}
;;;659    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  m_board_led_list
000000  07080c            DCB      0x07,0x08,0x0c
                  m_board_btn_list
000003  02                DCB      0x02
000004  0304              DCB      0x03,0x04
                  m_board_switch_list
000006  0106              DCB      0x01,0x06
000008  070b              DCB      0x07,0x0b

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\boards\\boards.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_boards_c_c0d5286b____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_boards_c_c0d5286b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_boards_c_c0d5286b____REVSH|
#line 144
|__asm___8_boards_c_c0d5286b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
