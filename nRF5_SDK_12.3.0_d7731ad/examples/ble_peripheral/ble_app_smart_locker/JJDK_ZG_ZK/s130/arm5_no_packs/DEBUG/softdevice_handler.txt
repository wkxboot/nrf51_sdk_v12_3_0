; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\softdevice_handler.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\softdevice_handler.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\softdevice_handler.crf ..\..\..\..\..\..\components\softdevice\common\softdevice_handler\softdevice_handler.c]
                          THUMB

                          AREA ||i.NVIC_DisableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_DisableIRQ PROC
;;;555     */
;;;556    __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;557    {
;;;558      NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L1.16|
00000a  6011              STR      r1,[r2,#0]
;;;559    }
00000c  4770              BX       lr
;;;560    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0xe000e180

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;543     */
;;;544    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;545    {
;;;546      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L2.16|
00000a  6011              STR      r1,[r2,#0]
;;;547    }
00000c  4770              BX       lr
;;;548    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe000e100

                          AREA ||i.SWI2_IRQHandler||, CODE, READONLY, ALIGN=2

                  SWI2_IRQHandler PROC
;;;421     */
;;;422    void SOFTDEVICE_EVT_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;423    {
;;;424        if (m_evt_schedule_func != NULL)
000002  480b              LDR      r0,|L3.48|
000004  6800              LDR      r0,[r0,#0]  ; m_evt_schedule_func
000006  2800              CMP      r0,#0
000008  d00e              BEQ      |L3.40|
;;;425        {
;;;426            uint32_t err_code = m_evt_schedule_func();
00000a  4809              LDR      r0,|L3.48|
00000c  6800              LDR      r0,[r0,#0]  ; m_evt_schedule_func
00000e  4780              BLX      r0
000010  4604              MOV      r4,r0
;;;427            APP_ERROR_CHECK(err_code);
000012  bf00              NOP      
000014  4625              MOV      r5,r4
000016  2d00              CMP      r5,#0
000018  d004              BEQ      |L3.36|
00001a  bf00              NOP      
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       app_error_handler_bare
000022  bf00              NOP      
                  |L3.36|
000024  bf00              NOP      
;;;428        }
000026  e001              B        |L3.44|
                  |L3.40|
;;;429        else
;;;430        {
;;;431            intern_softdevice_events_execute();
000028  f7fffffe          BL       intern_softdevice_events_execute
                  |L3.44|
;;;432        }
;;;433    }
00002c  bd70              POP      {r4-r6,pc}
;;;434    
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      m_evt_schedule_func

                          AREA ||i.__sd_nvic_app_accessible_irq||, CODE, READONLY, ALIGN=2

                  __sd_nvic_app_accessible_irq PROC
;;;162     */
;;;163    static inline uint32_t __sd_nvic_app_accessible_irq(IRQn_Type IRQn)
000000  4601              MOV      r1,r0
;;;164    {
;;;165      if (IRQn < 32)
000002  2920              CMP      r1,#0x20
000004  da09              BGE      |L4.26|
;;;166      {
;;;167        return ((1UL<<IRQn) & __NRF_NVIC_APP_IRQS_0) != 0;
000006  2001              MOVS     r0,#1
000008  4088              LSLS     r0,r0,r1
00000a  4a05              LDR      r2,|L4.32|
00000c  4010              ANDS     r0,r0,r2
00000e  2800              CMP      r0,#0
000010  d001              BEQ      |L4.22|
000012  2001              MOVS     r0,#1
                  |L4.20|
;;;168      }
;;;169    #ifdef NRF52
;;;170      else if (IRQn < 64)
;;;171      {
;;;172        return ((1UL<<(IRQn-32)) & __NRF_NVIC_APP_IRQS_1) != 0;
;;;173      }
;;;174    #endif
;;;175      else
;;;176      {
;;;177        return 1;
;;;178      }
;;;179    }
000014  4770              BX       lr
                  |L4.22|
000016  2000              MOVS     r0,#0                 ;167
000018  e7fc              B        |L4.20|
                  |L4.26|
00001a  2001              MOVS     r0,#1                 ;177
00001c  e7fa              B        |L4.20|
;;;180    
                          ENDP

00001e  0000              DCW      0x0000
                  |L4.32|
                          DCD      0xbcff06fc

                          AREA ||i.intern_softdevice_events_execute||, CODE, READONLY, ALIGN=2

                  intern_softdevice_events_execute PROC
;;;120    
;;;121    void intern_softdevice_events_execute(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;122    {
;;;123        if (!m_softdevice_enabled)
000002  482c              LDR      r0,|L5.180|
000004  7800              LDRB     r0,[r0,#0]  ; m_softdevice_enabled
000006  2800              CMP      r0,#0
000008  d100              BNE      |L5.12|
                  |L5.10|
;;;124        {
;;;125            // SoftDevice not enabled. This can be possible if the SoftDevice was enabled by the
;;;126            // application without using this module's API (i.e softdevice_handler_init)
;;;127    
;;;128            return;
;;;129        }
;;;130    #if NRF_MODULE_ENABLED(CLOCK)
;;;131        bool no_more_soc_evts = false;
;;;132    #else
;;;133        bool no_more_soc_evts = (m_sys_evt_handler == NULL);
;;;134    #endif
;;;135    #ifdef BLE_STACK_SUPPORT_REQD
;;;136        bool no_more_ble_evts = (m_ble_evt_handler == NULL);
;;;137    #endif
;;;138    #ifdef ANT_STACK_SUPPORT_REQD
;;;139        bool no_more_ant_evts = (m_ant_evt_handler == NULL);
;;;140    #endif
;;;141    
;;;142        for (;;)
;;;143        {
;;;144            uint32_t err_code;
;;;145    
;;;146            if (!no_more_soc_evts)
;;;147            {
;;;148                if (m_suspended)
;;;149                {
;;;150                    // Cancel pulling next event if event handler was suspended by user.
;;;151                    return;
;;;152                }
;;;153    
;;;154                uint32_t evt_id;
;;;155    
;;;156                // Pull event from SOC.
;;;157                err_code = sd_evt_get(&evt_id);
;;;158    
;;;159                if (err_code == NRF_ERROR_NOT_FOUND)
;;;160                {
;;;161                    no_more_soc_evts = true;
;;;162                }
;;;163                else if (err_code != NRF_SUCCESS)
;;;164                {
;;;165                    APP_ERROR_HANDLER(err_code);
;;;166                }
;;;167                else
;;;168                {
;;;169                    // Call application's SOC event handler.
;;;170    #if (NRF_MODULE_ENABLED(CLOCK) && defined(SOFTDEVICE_PRESENT))
;;;171                    nrf_drv_clock_on_soc_event(evt_id);
;;;172                    if (m_sys_evt_handler)
;;;173                    {
;;;174                        m_sys_evt_handler(evt_id);
;;;175                    }
;;;176    #else
;;;177                    m_sys_evt_handler(evt_id);
;;;178    #endif
;;;179                }
;;;180            }
;;;181    
;;;182    #ifdef BLE_STACK_SUPPORT_REQD
;;;183            // Fetch BLE Events.
;;;184            if (!no_more_ble_evts)
;;;185            {
;;;186                if (m_suspended)
;;;187                {
;;;188                    // Cancel pulling next event if event handler was suspended by user.
;;;189                    return;
;;;190                }
;;;191    
;;;192                // Pull event from stack
;;;193                uint16_t evt_len = m_ble_evt_buffer_size;
;;;194    
;;;195                err_code = sd_ble_evt_get(mp_ble_evt_buffer, &evt_len);
;;;196                if (err_code == NRF_ERROR_NOT_FOUND)
;;;197                {
;;;198                    no_more_ble_evts = true;
;;;199                }
;;;200                else if (err_code != NRF_SUCCESS)
;;;201                {
;;;202                    APP_ERROR_HANDLER(err_code);
;;;203                }
;;;204                else
;;;205                {
;;;206                    // Call application's BLE stack event handler.
;;;207                    m_ble_evt_handler((ble_evt_t *)mp_ble_evt_buffer);
;;;208                }
;;;209            }
;;;210    #endif
;;;211    
;;;212    #ifdef ANT_STACK_SUPPORT_REQD
;;;213            // Fetch ANT Events.
;;;214            if (!no_more_ant_evts)
;;;215            {
;;;216                if (m_suspended)
;;;217                {
;;;218                    // Cancel pulling next event if event handler was suspended by user.
;;;219                    return;
;;;220                }
;;;221    
;;;222                // Pull event from stack
;;;223                err_code = sd_ant_event_get(&m_ant_evt_buffer.channel,
;;;224                                            &m_ant_evt_buffer.event,
;;;225                                            m_ant_evt_buffer.msg.evt_buffer);
;;;226                if (err_code == NRF_ERROR_NOT_FOUND)
;;;227                {
;;;228                    no_more_ant_evts = true;
;;;229                }
;;;230                else if (err_code != NRF_SUCCESS)
;;;231                {
;;;232                    APP_ERROR_HANDLER(err_code);
;;;233                }
;;;234                else
;;;235                {
;;;236                    // Call application's ANT stack event handler.
;;;237                    m_ant_evt_handler(&m_ant_evt_buffer);
;;;238                }
;;;239            }
;;;240    #endif
;;;241    
;;;242            if (no_more_soc_evts)
;;;243            {
;;;244                // There are no remaining System (SOC) events to be fetched from the SoftDevice.
;;;245    #if defined(ANT_STACK_SUPPORT_REQD) && defined(BLE_STACK_SUPPORT_REQD)
;;;246                // Check if there are any remaining BLE and ANT events.
;;;247                if (no_more_ble_evts && no_more_ant_evts)
;;;248                {
;;;249                    break;
;;;250                }
;;;251    #elif defined(BLE_STACK_SUPPORT_REQD)
;;;252                // Check if there are any remaining BLE events.
;;;253                if (no_more_ble_evts)
;;;254                {
;;;255                    break;
;;;256                }
;;;257    #elif defined(ANT_STACK_SUPPORT_REQD)
;;;258                // Check if there are any remaining ANT events.
;;;259                if (no_more_ant_evts)
;;;260                {
;;;261                    break;
;;;262                }
;;;263    #else
;;;264                // No need to check for BLE or ANT events since there is no support for BLE and ANT
;;;265                // required.
;;;266                break;
;;;267    #endif
;;;268            }
;;;269        }
;;;270    }
00000a  bdf8              POP      {r3-r7,pc}
                  |L5.12|
00000c  2500              MOVS     r5,#0                 ;131
00000e  482a              LDR      r0,|L5.184|
000010  6800              LDR      r0,[r0,#0]            ;136  ; m_ble_evt_handler
000012  2800              CMP      r0,#0                 ;136
000014  d101              BNE      |L5.26|
000016  2001              MOVS     r0,#1                 ;136
000018  e000              B        |L5.28|
                  |L5.26|
00001a  2000              MOVS     r0,#0                 ;136
                  |L5.28|
00001c  4606              MOV      r6,r0                 ;136
00001e  bf00              NOP                            ;142
                  |L5.32|
000020  2d00              CMP      r5,#0                 ;146
000022  d11e              BNE      |L5.98|
000024  4825              LDR      r0,|L5.188|
000026  7800              LDRB     r0,[r0,#0]            ;148  ; m_suspended
000028  2800              CMP      r0,#0                 ;148
00002a  d000              BEQ      |L5.46|
00002c  e7ed              B        |L5.10|
                  |L5.46|
00002e  4668              MOV      r0,sp                 ;157
000030  df52              SVC      #0x52                 ;157
000032  4604              MOV      r4,r0                 ;157
000034  2c05              CMP      r4,#5                 ;159
000036  d101              BNE      |L5.60|
000038  2501              MOVS     r5,#1                 ;161
00003a  e011              B        |L5.96|
                  |L5.60|
00003c  2c00              CMP      r4,#0                 ;163
00003e  d004              BEQ      |L5.74|
000040  bf00              NOP                            ;165
000042  4620              MOV      r0,r4                 ;165
000044  f7fffffe          BL       app_error_handler_bare
000048  e00a              B        |L5.96|
                  |L5.74|
00004a  9800              LDR      r0,[sp,#0]            ;171
00004c  f7fffffe          BL       nrf_drv_clock_on_soc_event
000050  481b              LDR      r0,|L5.192|
000052  6800              LDR      r0,[r0,#0]            ;172  ; m_sys_evt_handler
000054  2800              CMP      r0,#0                 ;172
000056  d003              BEQ      |L5.96|
000058  4919              LDR      r1,|L5.192|
00005a  9800              LDR      r0,[sp,#0]            ;174
00005c  6809              LDR      r1,[r1,#0]            ;174  ; m_sys_evt_handler
00005e  4788              BLX      r1                    ;174
                  |L5.96|
000060  bf00              NOP                            ;180
                  |L5.98|
000062  2e00              CMP      r6,#0                 ;184
000064  d11d              BNE      |L5.162|
000066  4815              LDR      r0,|L5.188|
000068  7800              LDRB     r0,[r0,#0]            ;186  ; m_suspended
00006a  2800              CMP      r0,#0                 ;186
00006c  d000              BEQ      |L5.112|
00006e  e7cc              B        |L5.10|
                  |L5.112|
000070  4814              LDR      r0,|L5.196|
000072  8800              LDRH     r0,[r0,#0]            ;193  ; m_ble_evt_buffer_size
000074  9000              STR      r0,[sp,#0]            ;193
000076  4669              MOV      r1,sp                 ;195
000078  4813              LDR      r0,|L5.200|
00007a  6800              LDR      r0,[r0,#0]            ;195  ; mp_ble_evt_buffer
00007c  df61              SVC      #0x61                 ;195
00007e  4604              MOV      r4,r0                 ;195
000080  2c05              CMP      r4,#5                 ;196
000082  d101              BNE      |L5.136|
000084  2601              MOVS     r6,#1                 ;198
000086  e00b              B        |L5.160|
                  |L5.136|
000088  2c00              CMP      r4,#0                 ;200
00008a  d004              BEQ      |L5.150|
00008c  bf00              NOP                            ;202
00008e  4620              MOV      r0,r4                 ;202
000090  f7fffffe          BL       app_error_handler_bare
000094  e004              B        |L5.160|
                  |L5.150|
000096  480c              LDR      r0,|L5.200|
000098  6800              LDR      r0,[r0,#0]            ;207  ; mp_ble_evt_buffer
00009a  4907              LDR      r1,|L5.184|
00009c  6809              LDR      r1,[r1,#0]            ;207  ; m_ble_evt_handler
00009e  4788              BLX      r1                    ;207
                  |L5.160|
0000a0  bf00              NOP                            ;209
                  |L5.162|
0000a2  2d00              CMP      r5,#0                 ;242
0000a4  d002              BEQ      |L5.172|
0000a6  2e00              CMP      r6,#0                 ;253
0000a8  d000              BEQ      |L5.172|
0000aa  e000              B        |L5.174|
                  |L5.172|
0000ac  e7b8              B        |L5.32|
                  |L5.174|
0000ae  bf00              NOP                            ;255
0000b0  bf00              NOP      
0000b2  e7aa              B        |L5.10|
;;;271    
                          ENDP

                  |L5.180|
                          DCD      m_softdevice_enabled
                  |L5.184|
                          DCD      m_ble_evt_handler
                  |L5.188|
                          DCD      m_suspended
                  |L5.192|
                          DCD      m_sys_evt_handler
                  |L5.196|
                          DCD      m_ble_evt_buffer_size
                  |L5.200|
                          DCD      mp_ble_evt_buffer

                          AREA ||i.ram_end_address_get||, CODE, READONLY, ALIGN=1

                  ram_end_address_get PROC
;;;510     */
;;;511    static inline uint32_t ram_end_address_get(void)
000000  2001              MOVS     r0,#1
;;;512    {
;;;513        uint32_t ram_end_address = (uint32_t)RAM_START_ADDRESS;
000002  0740              LSLS     r0,r0,#29
;;;514        ram_end_address+= ram_total_size_get();
000004  bf00              NOP      
000006  1043              ASRS     r3,r0,#1
000008  6b99              LDR      r1,[r3,#0x38]
00000a  460a              MOV      r2,r1
00000c  6b5b              LDR      r3,[r3,#0x34]
00000e  435a              MULS     r2,r3,r2
000010  bf00              NOP      
000012  1810              ADDS     r0,r2,r0
;;;515        return ram_end_address;
;;;516    }
000014  4770              BX       lr
;;;517    /*lint -restore*/
                          ENDP


                          AREA ||i.sd_check_ram_start||, CODE, READONLY, ALIGN=2

                  sd_check_ram_start PROC
;;;519    /*lint --e{10} --e{19} --e{27} --e{40} --e{529} -save suppress Error 27: Illegal character */
;;;520    uint32_t sd_check_ram_start(uint32_t sd_req_ram_start)
000000  b538              PUSH     {r3-r5,lr}
;;;521    {
000002  4604              MOV      r4,r0
;;;522    #if (defined(S130) || defined(S132) || defined(S332))
;;;523    #if defined ( __CC_ARM )
;;;524        extern uint32_t Image$$RW_IRAM1$$Base;
;;;525        const volatile uint32_t ram_start = (uint32_t) &Image$$RW_IRAM1$$Base;
000004  480b              LDR      r0,|L7.52|
000006  9000              STR      r0,[sp,#0]
;;;526    #elif defined ( __ICCARM__ )
;;;527        extern uint32_t __ICFEDIT_region_RAM_start__;
;;;528        volatile uint32_t ram_start = (uint32_t) &__ICFEDIT_region_RAM_start__;
;;;529    #elif defined   ( __GNUC__ )
;;;530        extern uint32_t __data_start__;
;;;531        volatile uint32_t ram_start = (uint32_t) &__data_start__;
;;;532    #endif//__CC_ARM
;;;533        if (ram_start != sd_req_ram_start)
000008  9800              LDR      r0,[sp,#0]
00000a  42a0              CMP      r0,r4
00000c  d00f              BEQ      |L7.46|
;;;534        {
;;;535            NRF_LOG_WARNING("RAM START ADDR 0x%x should be adjusted to 0x%x\r\n",
00000e  4623              MOV      r3,r4
000010  4909              LDR      r1,|L7.56|
000012  2002              MOVS     r0,#2
000014  9a00              LDR      r2,[sp,#0]
000016  f7fffffe          BL       nrf_log_frontend_std_2
;;;536                      ram_start,
;;;537                      sd_req_ram_start);
;;;538            NRF_LOG_WARNING("RAM SIZE should be adjusted to 0x%x \r\n",
00001a  f7fffffe          BL       ram_end_address_get
00001e  1b05              SUBS     r5,r0,r4
000020  462a              MOV      r2,r5
000022  a106              ADR      r1,|L7.60|
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       nrf_log_frontend_std_1
;;;539                    ram_end_address_get() - sd_req_ram_start);
;;;540            return NRF_SUCCESS;
00002a  2000              MOVS     r0,#0
                  |L7.44|
;;;541        }
;;;542    #endif//defined(S130) || defined(S132) || defined(S332)
;;;543        return NRF_SUCCESS;
;;;544    }
00002c  bd38              POP      {r3-r5,pc}
                  |L7.46|
00002e  2000              MOVS     r0,#0                 ;543
000030  e7fc              B        |L7.44|
;;;545    
                          ENDP

000032  0000              DCW      0x0000
                  |L7.52|
                          DCD      ||Image$$RW_IRAM1$$Base||
                  |L7.56|
                          DCD      ||.conststring||
                  |L7.60|
00003c  1b5b313b          DCB      27,"[1;33mSDH:WARNING:RAM SIZE should be adjusted to 0x%"
000040  33336d53
000044  44483a57
000048  41524e49
00004c  4e473a52
000050  414d2053
000054  495a4520
000058  73686f75
00005c  6c642062
000060  65206164
000064  6a757374
000068  65642074
00006c  6f203078
000070  25      
000071  78200d0a          DCB      "x \r\n",0
000075  00      
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.sd_nvic_EnableIRQ||, CODE, READONLY, ALIGN=2

                  sd_nvic_EnableIRQ PROC
;;;228     */
;;;229    static inline uint32_t sd_nvic_EnableIRQ(IRQn_Type IRQn)
000000  b510              PUSH     {r4,lr}
;;;230    {
000002  4604              MOV      r4,r0
;;;231      if (!__sd_nvic_app_accessible_irq(IRQn))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       __sd_nvic_app_accessible_irq
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L8.18|
;;;232      {
;;;233        return NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE;
00000e  4823              LDR      r0,|L8.156|
                  |L8.16|
;;;234      }
;;;235      if (!__sd_nvic_is_app_accessible_priority(NVIC_GetPriority(IRQn)))
;;;236      {
;;;237        return NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED;
;;;238      }
;;;239    
;;;240      if (nrf_nvic_state.__cr_flag)
;;;241      {
;;;242        nrf_nvic_state.__irq_masks[(uint32_t)((int32_t)IRQn) >> 5] |= (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));
;;;243      }
;;;244      else
;;;245      {
;;;246        NVIC_EnableIRQ(IRQn);
;;;247      }
;;;248      return NRF_SUCCESS;
;;;249    }
000010  bd10              POP      {r4,pc}
                  |L8.18|
000012  4620              MOV      r0,r4                 ;235
000014  2800              CMP      r0,#0                 ;235
000016  da0c              BGE      |L8.50|
000018  4a21              LDR      r2,|L8.160|
00001a  0703              LSLS     r3,r0,#28             ;235
00001c  0f1b              LSRS     r3,r3,#28             ;235
00001e  3b08              SUBS     r3,r3,#8              ;235
000020  089b              LSRS     r3,r3,#2              ;235
000022  009b              LSLS     r3,r3,#2              ;235
000024  58d2              LDR      r2,[r2,r3]            ;235
000026  0783              LSLS     r3,r0,#30             ;235
000028  0edb              LSRS     r3,r3,#27             ;235
00002a  40da              LSRS     r2,r2,r3              ;235
00002c  0612              LSLS     r2,r2,#24             ;235
00002e  0f92              LSRS     r2,r2,#30             ;235
000030  e00b              B        |L8.74|
                  |L8.50|
000032  4a1c              LDR      r2,|L8.164|
000034  2303              MOVS     r3,#3                 ;235
000036  021b              LSLS     r3,r3,#8              ;235
000038  18d2              ADDS     r2,r2,r3              ;235
00003a  0883              LSRS     r3,r0,#2              ;235
00003c  009b              LSLS     r3,r3,#2              ;235
00003e  58d2              LDR      r2,[r2,r3]            ;235
000040  0783              LSLS     r3,r0,#30             ;235
000042  0edb              LSRS     r3,r3,#27             ;235
000044  40da              LSRS     r2,r2,r3              ;235
000046  0612              LSLS     r2,r2,#24             ;235
000048  0f92              LSRS     r2,r2,#30             ;235
                  |L8.74|
00004a  4611              MOV      r1,r2                 ;235
00004c  2904              CMP      r1,#4                 ;235
00004e  d301              BCC      |L8.84|
000050  2000              MOVS     r0,#0                 ;235
000052  e006              B        |L8.98|
                  |L8.84|
000054  2900              CMP      r1,#0                 ;235
000056  d001              BEQ      |L8.92|
000058  2902              CMP      r1,#2                 ;235
00005a  d101              BNE      |L8.96|
                  |L8.92|
00005c  2000              MOVS     r0,#0                 ;235
00005e  e000              B        |L8.98|
                  |L8.96|
000060  2001              MOVS     r0,#1                 ;235
                  |L8.98|
000062  2800              CMP      r0,#0                 ;235
000064  d102              BNE      |L8.108|
000066  480d              LDR      r0,|L8.156|
000068  1c40              ADDS     r0,r0,#1              ;237
00006a  e7d1              B        |L8.16|
                  |L8.108|
00006c  480e              LDR      r0,|L8.168|
00006e  6840              LDR      r0,[r0,#4]            ;240  ; nrf_nvic_state
000070  2800              CMP      r0,#0                 ;240
000072  d00d              BEQ      |L8.144|
000074  0960              LSRS     r0,r4,#5              ;242
000076  0080              LSLS     r0,r0,#2              ;242
000078  490b              LDR      r1,|L8.168|
00007a  5808              LDR      r0,[r1,r0]            ;242
00007c  06e2              LSLS     r2,r4,#27             ;242
00007e  0ed2              LSRS     r2,r2,#27             ;242
000080  2101              MOVS     r1,#1                 ;242
000082  4091              LSLS     r1,r1,r2              ;242
000084  4308              ORRS     r0,r0,r1              ;242
000086  0961              LSRS     r1,r4,#5              ;242
000088  0089              LSLS     r1,r1,#2              ;242
00008a  4a07              LDR      r2,|L8.168|
00008c  5050              STR      r0,[r2,r1]            ;242
00008e  e002              B        |L8.150|
                  |L8.144|
000090  4620              MOV      r0,r4                 ;246
000092  f7fffffe          BL       NVIC_EnableIRQ
                  |L8.150|
000096  2000              MOVS     r0,#0                 ;248
000098  e7ba              B        |L8.16|
;;;250    
                          ENDP

00009a  0000              DCW      0x0000
                  |L8.156|
                          DCD      0x00002001
                  |L8.160|
                          DCD      0xe000ed1c
                  |L8.164|
                          DCD      0xe000e100
                  |L8.168|
                          DCD      nrf_nvic_state

                          AREA ||i.softdevice_ble_evt_handler_set||, CODE, READONLY, ALIGN=2

                  softdevice_ble_evt_handler_set PROC
;;;384    #ifdef BLE_STACK_SUPPORT_REQD
;;;385    uint32_t softdevice_ble_evt_handler_set(ble_evt_handler_t ble_evt_handler)
000000  4601              MOV      r1,r0
;;;386    {
;;;387        VERIFY_PARAM_NOT_NULL(ble_evt_handler);
000002  bf00              NOP      
000004  2900              CMP      r1,#0
000006  d101              BNE      |L9.12|
000008  200e              MOVS     r0,#0xe
                  |L9.10|
;;;388    
;;;389        m_ble_evt_handler = ble_evt_handler;
;;;390    
;;;391        return NRF_SUCCESS;
;;;392    }
00000a  4770              BX       lr
                  |L9.12|
00000c  bf00              NOP                            ;387
00000e  4802              LDR      r0,|L9.24|
000010  6001              STR      r1,[r0,#0]            ;389  ; m_ble_evt_handler
000012  2000              MOVS     r0,#0                 ;391
000014  e7f9              B        |L9.10|
;;;393    #endif
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      m_ble_evt_handler

                          AREA ||i.softdevice_enable||, CODE, READONLY, ALIGN=2

                  softdevice_enable PROC
;;;545    
;;;546    uint32_t softdevice_enable(ble_enable_params_t * p_ble_enable_params)
000000  b57c              PUSH     {r2-r6,lr}
;;;547    {
000002  4605              MOV      r5,r0
;;;548    #if (defined(S130) || defined(S132) || defined(S332))
;;;549        uint32_t err_code;
;;;550        uint32_t app_ram_base;
;;;551    
;;;552    #if defined ( __CC_ARM )
;;;553        extern uint32_t Image$$RW_IRAM1$$Base;
;;;554        const volatile uint32_t ram_start = (uint32_t) &Image$$RW_IRAM1$$Base;
000004  4811              LDR      r0,|L10.76|
000006  9000              STR      r0,[sp,#0]
;;;555    #elif defined ( __ICCARM__ )
;;;556        extern uint32_t __ICFEDIT_region_RAM_start__;
;;;557        volatile uint32_t ram_start = (uint32_t) &__ICFEDIT_region_RAM_start__;
;;;558    #elif defined   ( __GNUC__ )
;;;559        extern uint32_t __data_start__;
;;;560        volatile uint32_t ram_start = (uint32_t) &__data_start__;
;;;561    #endif
;;;562    
;;;563        app_ram_base = ram_start;
000008  9800              LDR      r0,[sp,#0]
00000a  9001              STR      r0,[sp,#4]
;;;564        NRF_LOG_DEBUG("sd_ble_enable: RAM start at 0x%x\r\n",
;;;565                        app_ram_base);
;;;566        err_code = sd_ble_enable(p_ble_enable_params, &app_ram_base);
00000c  a901              ADD      r1,sp,#4
00000e  4628              MOV      r0,r5
000010  df60              SVC      #0x60
000012  4604              MOV      r4,r0
;;;567    
;;;568        if (app_ram_base != ram_start)
000014  9900              LDR      r1,[sp,#0]
000016  9801              LDR      r0,[sp,#4]
000018  4288              CMP      r0,r1
00001a  d00e              BEQ      |L10.58|
;;;569        {
;;;570            NRF_LOG_WARNING("sd_ble_enable: RAM start should be adjusted to 0x%x\r\n",
00001c  490c              LDR      r1,|L10.80|
00001e  2002              MOVS     r0,#2
000020  9a01              LDR      r2,[sp,#4]
000022  f7fffffe          BL       nrf_log_frontend_std_1
;;;571                    app_ram_base);
;;;572            NRF_LOG_WARNING("RAM size should be adjusted to 0x%x \r\n",
000026  f7fffffe          BL       ram_end_address_get
00002a  9901              LDR      r1,[sp,#4]
00002c  1a46              SUBS     r6,r0,r1
00002e  4632              MOV      r2,r6
000030  a108              ADR      r1,|L10.84|
000032  2002              MOVS     r0,#2
000034  f7fffffe          BL       nrf_log_frontend_std_1
000038  e006              B        |L10.72|
                  |L10.58|
;;;573                    ram_end_address_get() - app_ram_base);
;;;574        }
;;;575        else if (err_code != NRF_SUCCESS)
00003a  2c00              CMP      r4,#0
00003c  d004              BEQ      |L10.72|
;;;576        {
;;;577            NRF_LOG_ERROR("sd_ble_enable: error 0x%x\r\n", err_code);
00003e  4622              MOV      r2,r4
000040  a113              ADR      r1,|L10.144|
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       nrf_log_frontend_std_1
                  |L10.72|
;;;578        }
;;;579        return err_code;
000048  4620              MOV      r0,r4
;;;580    #else
;;;581        return NRF_SUCCESS;
;;;582    #endif   //defined(S130) || defined(S132) || defined(S332)
;;;583    
;;;584    }
00004a  bd7c              POP      {r2-r6,pc}
;;;585    /*lint -restore*/
                          ENDP

                  |L10.76|
                          DCD      ||Image$$RW_IRAM1$$Base||
                  |L10.80|
                          DCD      ||.conststring||+0x44
                  |L10.84|
000054  1b5b313b          DCB      27,"[1;33mSDH:WARNING:RAM size should be adjusted to 0x%"
000058  33336d53
00005c  44483a57
000060  41524e49
000064  4e473a52
000068  414d2073
00006c  697a6520
000070  73686f75
000074  6c642062
000078  65206164
00007c  6a757374
000080  65642074
000084  6f203078
000088  25      
000089  78200d0a          DCB      "x \r\n",0
00008d  00      
00008e  00                DCB      0
00008f  00                DCB      0
                  |L10.144|
000090  1b5b313b          DCB      27,"[1;31mSDH:ERROR:sd_ble_enable: error 0x%x\r\n",0
000094  33316d53
000098  44483a45
00009c  52524f52
0000a0  3a73645f
0000a4  626c655f
0000a8  656e6162
0000ac  6c653a20
0000b0  6572726f
0000b4  72203078
0000b8  25780d0a
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.softdevice_enable_get_default_config||, CODE, READONLY, ALIGN=1

                  softdevice_enable_get_default_config PROC
;;;474    #if defined(BLE_STACK_SUPPORT_REQD)
;;;475    uint32_t softdevice_enable_get_default_config(uint8_t central_links_count,
000000  b570              PUSH     {r4-r6,lr}
;;;476                                                  uint8_t periph_links_count,
;;;477                                                  ble_enable_params_t * p_ble_enable_params)
;;;478    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;479        memset(p_ble_enable_params, 0, sizeof(ble_enable_params_t));
000008  2114              MOVS     r1,#0x14
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       __aeabi_memclr4
;;;480        p_ble_enable_params->common_enable_params.vs_uuid_count   = 1;
000010  2001              MOVS     r0,#1
000012  8020              STRH     r0,[r4,#0]
;;;481        p_ble_enable_params->gatts_enable_params.attr_tab_size    = SOFTDEVICE_GATTS_ATTR_TAB_SIZE;
000014  2100              MOVS     r1,#0
000016  6121              STR      r1,[r4,#0x10]
;;;482        p_ble_enable_params->gatts_enable_params.service_changed  = SOFTDEVICE_GATTS_SRV_CHANGED;
000018  2000              MOVS     r0,#0
00001a  7320              STRB     r0,[r4,#0xc]
;;;483        p_ble_enable_params->gap_enable_params.periph_conn_count  = periph_links_count;
00001c  7226              STRB     r6,[r4,#8]
;;;484        p_ble_enable_params->gap_enable_params.central_conn_count = central_links_count;
00001e  7265              STRB     r5,[r4,#9]
;;;485        if (p_ble_enable_params->gap_enable_params.central_conn_count != 0)
000020  7a60              LDRB     r0,[r4,#9]
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L11.42|
;;;486        {
;;;487            p_ble_enable_params->gap_enable_params.central_sec_count  = SOFTDEVICE_CENTRAL_SEC_COUNT;
000026  2101              MOVS     r1,#1
000028  72a1              STRB     r1,[r4,#0xa]
                  |L11.42|
;;;488        }
;;;489    
;;;490        return NRF_SUCCESS;
00002a  2000              MOVS     r0,#0
;;;491    }
00002c  bd70              POP      {r4-r6,pc}
;;;492    
                          ENDP


                          AREA ||i.softdevice_fault_handler||, CODE, READONLY, ALIGN=1

                  softdevice_fault_handler PROC
;;;115     */
;;;116    void softdevice_fault_handler(uint32_t id, uint32_t pc, uint32_t info)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;118        app_error_fault_handler(id, pc, info);
000008  4632              MOV      r2,r6
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       app_error_fault_handler
;;;119    }
000012  bd70              POP      {r4-r6,pc}
;;;120    
                          ENDP


                          AREA ||i.softdevice_handler_init||, CODE, READONLY, ALIGN=2

                  softdevice_handler_init PROC
;;;276    
;;;277    uint32_t softdevice_handler_init(nrf_clock_lf_cfg_t *           p_clock_lf_cfg,
000000  b5ff              PUSH     {r0-r7,lr}
;;;278                                     void *                         p_ble_evt_buffer,
;;;279                                     uint16_t                       ble_evt_buffer_size,
;;;280                                     softdevice_evt_schedule_func_t evt_schedule_func)
;;;281    {
000002  b081              SUB      sp,sp,#4
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;282        uint32_t err_code;
;;;283    
;;;284        // Save configuration.
;;;285    #if defined (BLE_STACK_SUPPORT_REQD)
;;;286        // Check that buffer is not NULL.
;;;287        if (p_ble_evt_buffer == NULL)
000008  2c00              CMP      r4,#0
00000a  d102              BNE      |L13.18|
;;;288        {
;;;289            return NRF_ERROR_INVALID_PARAM;
00000c  2007              MOVS     r0,#7
                  |L13.14|
;;;290        }
;;;291    
;;;292        // Check that buffer is correctly aligned.
;;;293        if (!is_word_aligned(p_ble_evt_buffer))
;;;294        {
;;;295            return NRF_ERROR_INVALID_PARAM;
;;;296        }
;;;297    
;;;298        mp_ble_evt_buffer     = (uint8_t *)p_ble_evt_buffer;
;;;299        m_ble_evt_buffer_size = ble_evt_buffer_size;
;;;300    #else
;;;301        // The variables p_ble_evt_buffer and ble_evt_buffer_size is not needed if BLE Stack support
;;;302        // is not required.
;;;303        UNUSED_PARAMETER(p_ble_evt_buffer);
;;;304        UNUSED_PARAMETER(ble_evt_buffer_size);
;;;305    #endif
;;;306    
;;;307        m_evt_schedule_func = evt_schedule_func;
;;;308    
;;;309        // Initialize SoftDevice.
;;;310    #if (NRF_MODULE_ENABLED(CLOCK) && defined(SOFTDEVICE_PRESENT))
;;;311        bool power_clock_isr_enabled = nrf_drv_common_irq_enable_check(POWER_CLOCK_IRQn);
;;;312        if (power_clock_isr_enabled)
;;;313        {
;;;314            NVIC_DisableIRQ(POWER_CLOCK_IRQn);
;;;315        }
;;;316    #endif
;;;317    
;;;318    #if (NRF_MODULE_ENABLED(RNG) && defined(SOFTDEVICE_PRESENT))
;;;319        bool rng_isr_enabled = nrf_drv_common_irq_enable_check(RNG_IRQn);
;;;320        if (rng_isr_enabled)
;;;321        {
;;;322            NVIC_DisableIRQ(RNG_IRQn);
;;;323        }
;;;324    #endif
;;;325    #if defined(S212) || defined(S332)
;;;326        err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler, ANT_LICENSE_KEY);
;;;327    #else
;;;328        err_code = sd_softdevice_enable(p_clock_lf_cfg, softdevice_fault_handler);
;;;329    #endif
;;;330    
;;;331        if (err_code != NRF_SUCCESS)
;;;332        {
;;;333    
;;;334    #if (NRF_MODULE_ENABLED(RNG) && defined(SOFTDEVICE_PRESENT))
;;;335            if (rng_isr_enabled)
;;;336            {
;;;337                NVIC_EnableIRQ(RNG_IRQn);
;;;338            }
;;;339    #endif
;;;340    #if (NRF_MODULE_ENABLED(CLOCK) && defined(SOFTDEVICE_PRESENT))
;;;341            if (power_clock_isr_enabled)
;;;342            {
;;;343                NVIC_EnableIRQ(POWER_CLOCK_IRQn);
;;;344            }
;;;345    #endif
;;;346            return err_code;
;;;347        }
;;;348    
;;;349        m_softdevice_enabled = true;
;;;350    #if (NRF_MODULE_ENABLED(CLOCK) && defined(SOFTDEVICE_PRESENT))
;;;351        nrf_drv_clock_on_sd_enable();
;;;352    #endif
;;;353    
;;;354        // Enable BLE event interrupt (interrupt priority has already been set by the stack).
;;;355    #ifdef SOFTDEVICE_PRESENT
;;;356        return sd_nvic_EnableIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;357    #else
;;;358        //In case of Serialization NVIC must be accessed directly.
;;;359        NVIC_EnableIRQ(SOFTDEVICE_EVT_IRQ);
;;;360        return NRF_SUCCESS;
;;;361    #endif
;;;362    }
00000e  b005              ADD      sp,sp,#0x14
000010  bdf0              POP      {r4-r7,pc}
                  |L13.18|
000012  4620              MOV      r0,r4                 ;293
000014  0781              LSLS     r1,r0,#30             ;293
000016  0f89              LSRS     r1,r1,#30             ;293
000018  2900              CMP      r1,#0                 ;293
00001a  d101              BNE      |L13.32|
00001c  2101              MOVS     r1,#1                 ;293
00001e  e000              B        |L13.34|
                  |L13.32|
000020  2100              MOVS     r1,#0                 ;293
                  |L13.34|
000022  2900              CMP      r1,#0                 ;293
000024  d101              BNE      |L13.42|
000026  2007              MOVS     r0,#7                 ;295
000028  e7f1              B        |L13.14|
                  |L13.42|
00002a  4819              LDR      r0,|L13.144|
00002c  6004              STR      r4,[r0,#0]            ;298  ; mp_ble_evt_buffer
00002e  4819              LDR      r0,|L13.148|
000030  8007              STRH     r7,[r0,#0]            ;299
000032  4919              LDR      r1,|L13.152|
000034  9804              LDR      r0,[sp,#0x10]         ;307
000036  6008              STR      r0,[r1,#0]            ;307  ; m_evt_schedule_func
000038  2000              MOVS     r0,#0                 ;311
00003a  0941              LSRS     r1,r0,#5              ;311
00003c  0089              LSLS     r1,r1,#2              ;311
00003e  4a17              LDR      r2,|L13.156|
000040  1889              ADDS     r1,r1,r2              ;311
000042  6809              LDR      r1,[r1,#0]            ;311
000044  2201              MOVS     r2,#1                 ;311
000046  4082              LSLS     r2,r2,r0              ;311
000048  4011              ANDS     r1,r1,r2              ;311
00004a  2900              CMP      r1,#0                 ;311
00004c  d001              BEQ      |L13.82|
00004e  2101              MOVS     r1,#1                 ;311
000050  e000              B        |L13.84|
                  |L13.82|
000052  2100              MOVS     r1,#0                 ;311
                  |L13.84|
000054  460e              MOV      r6,r1                 ;311
000056  bf00              NOP                            ;311
000058  2e00              CMP      r6,#0                 ;312
00005a  d002              BEQ      |L13.98|
00005c  2000              MOVS     r0,#0                 ;314
00005e  f7fffffe          BL       NVIC_DisableIRQ
                  |L13.98|
000062  490f              LDR      r1,|L13.160|
000064  9801              LDR      r0,[sp,#4]            ;328
000066  df10              SVC      #0x10                 ;328
000068  4605              MOV      r5,r0                 ;328
00006a  2d00              CMP      r5,#0                 ;331
00006c  d006              BEQ      |L13.124|
00006e  2e00              CMP      r6,#0                 ;341
000070  d002              BEQ      |L13.120|
000072  2000              MOVS     r0,#0                 ;343
000074  f7fffffe          BL       NVIC_EnableIRQ
                  |L13.120|
000078  4628              MOV      r0,r5                 ;346
00007a  e7c8              B        |L13.14|
                  |L13.124|
00007c  2001              MOVS     r0,#1                 ;349
00007e  4909              LDR      r1,|L13.164|
000080  7008              STRB     r0,[r1,#0]            ;349
000082  f7fffffe          BL       nrf_drv_clock_on_sd_enable
000086  2016              MOVS     r0,#0x16              ;356
000088  f7fffffe          BL       sd_nvic_EnableIRQ
00008c  e7bf              B        |L13.14|
;;;363    
                          ENDP

00008e  0000              DCW      0x0000
                  |L13.144|
                          DCD      mp_ble_evt_buffer
                  |L13.148|
                          DCD      m_ble_evt_buffer_size
                  |L13.152|
                          DCD      m_evt_schedule_func
                  |L13.156|
                          DCD      0xe000e100
                  |L13.160|
                          DCD      softdevice_fault_handler
                  |L13.164|
                          DCD      m_softdevice_enabled

                          AREA ||i.softdevice_handler_is_enabled||, CODE, READONLY, ALIGN=2

                  softdevice_handler_is_enabled PROC
;;;271    
;;;272    bool softdevice_handler_is_enabled(void)
000000  4801              LDR      r0,|L14.8|
;;;273    {
;;;274        return m_softdevice_enabled;
000002  7800              LDRB     r0,[r0,#0]  ; m_softdevice_enabled
;;;275    }
000004  4770              BX       lr
;;;276    
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      m_softdevice_enabled

                          AREA ||i.softdevice_handler_is_suspended||, CODE, READONLY, ALIGN=2

                  softdevice_handler_is_suspended PROC
;;;468    
;;;469    bool softdevice_handler_is_suspended()
000000  4801              LDR      r0,|L15.8|
;;;470    {
;;;471        return m_suspended;
000002  7800              LDRB     r0,[r0,#0]  ; m_suspended
;;;472    }
000004  4770              BX       lr
;;;473    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      m_suspended

                          AREA ||i.softdevice_handler_resume||, CODE, READONLY, ALIGN=2

                  softdevice_handler_resume PROC
;;;446    
;;;447    void softdevice_handler_resume()
000000  b570              PUSH     {r4-r6,lr}
;;;448    {
;;;449        if (!m_suspended) return;
000002  481a              LDR      r0,|L16.108|
000004  7800              LDRB     r0,[r0,#0]  ; m_suspended
000006  2800              CMP      r0,#0
000008  d100              BNE      |L16.12|
                  |L16.10|
;;;450        m_suspended = false;
;;;451    
;;;452    #ifdef SOFTDEVICE_PRESENT
;;;453        ret_code_t err_code;
;;;454    
;;;455        // Force calling ISR again to make sure that events not pulled previously
;;;456        // has been processed.
;;;457        err_code = sd_nvic_SetPendingIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;458        APP_ERROR_CHECK(err_code);
;;;459        err_code = sd_nvic_EnableIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;460        APP_ERROR_CHECK(err_code);
;;;461    #else
;;;462        NVIC_SetPendingIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
;;;463        NVIC_EnableIRQ(SOFTDEVICE_EVT_IRQ);
;;;464    #endif
;;;465    
;;;466        return;
;;;467    }
00000a  bd70              POP      {r4-r6,pc}
                  |L16.12|
00000c  2000              MOVS     r0,#0                 ;450
00000e  4917              LDR      r1,|L16.108|
000010  7008              STRB     r0,[r1,#0]            ;450
000012  2416              MOVS     r4,#0x16              ;457
000014  4620              MOV      r0,r4                 ;457
000016  f7fffffe          BL       __sd_nvic_app_accessible_irq
00001a  2800              CMP      r0,#0                 ;457
00001c  d009              BEQ      |L16.50|
00001e  bf00              NOP                            ;457
000020  06e1              LSLS     r1,r4,#27             ;457
000022  0ec9              LSRS     r1,r1,#27             ;457
000024  2001              MOVS     r0,#1                 ;457
000026  4088              LSLS     r0,r0,r1              ;457
000028  4911              LDR      r1,|L16.112|
00002a  6008              STR      r0,[r1,#0]            ;457
00002c  bf00              NOP                            ;457
00002e  2000              MOVS     r0,#0                 ;457
000030  e000              B        |L16.52|
                  |L16.50|
000032  4810              LDR      r0,|L16.116|
                  |L16.52|
000034  4605              MOV      r5,r0                 ;457
000036  bf00              NOP                            ;458
000038  462c              MOV      r4,r5                 ;458
00003a  2c00              CMP      r4,#0                 ;458
00003c  d004              BEQ      |L16.72|
00003e  bf00              NOP                            ;458
000040  4620              MOV      r0,r4                 ;458
000042  f7fffffe          BL       app_error_handler_bare
000046  bf00              NOP                            ;458
                  |L16.72|
000048  bf00              NOP                            ;458
00004a  2016              MOVS     r0,#0x16              ;459
00004c  f7fffffe          BL       sd_nvic_EnableIRQ
000050  4605              MOV      r5,r0                 ;459
000052  bf00              NOP                            ;460
000054  462c              MOV      r4,r5                 ;460
000056  2c00              CMP      r4,#0                 ;460
000058  d004              BEQ      |L16.100|
00005a  bf00              NOP                            ;460
00005c  4620              MOV      r0,r4                 ;460
00005e  f7fffffe          BL       app_error_handler_bare
000062  bf00              NOP                            ;460
                  |L16.100|
000064  bf00              NOP                            ;460
000066  bf00              NOP                            ;466
000068  e7cf              B        |L16.10|
;;;468    
                          ENDP

00006a  0000              DCW      0x0000
                  |L16.108|
                          DCD      m_suspended
                  |L16.112|
                          DCD      0xe000e200
                  |L16.116|
                          DCD      0x00002001

                          AREA ||i.softdevice_handler_sd_disable||, CODE, READONLY, ALIGN=2

                  softdevice_handler_sd_disable PROC
;;;364    
;;;365    uint32_t softdevice_handler_sd_disable(void)
000000  b510              PUSH     {r4,lr}
;;;366    {
;;;367        uint32_t err_code = sd_softdevice_disable();
000002  df11              SVC      #0x11
000004  4604              MOV      r4,r0
;;;368        if (err_code == NRF_SUCCESS)
000006  2c00              CMP      r4,#0
000008  d103              BNE      |L17.18|
;;;369        {
;;;370            m_softdevice_enabled = false;
00000a  4903              LDR      r1,|L17.24|
00000c  7008              STRB     r0,[r1,#0]
;;;371    
;;;372    #if (NRF_MODULE_ENABLED(CLOCK) && defined(SOFTDEVICE_PRESENT))
;;;373            nrf_drv_clock_on_sd_disable();
00000e  f7fffffe          BL       nrf_drv_clock_on_sd_disable
                  |L17.18|
;;;374    #endif
;;;375    
;;;376    #if (NRF_MODULE_ENABLED(RNG) && defined(SOFTDEVICE_PRESENT))
;;;377            nrf_drv_rng_on_sd_disable();
;;;378    #endif
;;;379        }
;;;380    
;;;381        return err_code;
000012  4620              MOV      r0,r4
;;;382    }
000014  bd10              POP      {r4,pc}
;;;383    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      m_softdevice_enabled

                          AREA ||i.softdevice_handler_suspend||, CODE, READONLY, ALIGN=2

                  softdevice_handler_suspend PROC
;;;434    
;;;435    void softdevice_handler_suspend()
000000  b570              PUSH     {r4-r6,lr}
;;;436    {
;;;437    #ifdef SOFTDEVICE_PRESENT
;;;438        ret_code_t err_code = sd_nvic_DisableIRQ((IRQn_Type)SOFTDEVICE_EVT_IRQ);
000002  2416              MOVS     r4,#0x16
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       __sd_nvic_app_accessible_irq
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L18.18|
00000e  4813              LDR      r0,|L18.92|
000010  e015              B        |L18.62|
                  |L18.18|
000012  4813              LDR      r0,|L18.96|
000014  6840              LDR      r0,[r0,#4]  ; nrf_nvic_state
000016  2800              CMP      r0,#0
000018  d00d              BEQ      |L18.54|
00001a  0960              LSRS     r0,r4,#5
00001c  0080              LSLS     r0,r0,#2
00001e  4910              LDR      r1,|L18.96|
000020  5808              LDR      r0,[r1,r0]
000022  06e2              LSLS     r2,r4,#27
000024  0ed2              LSRS     r2,r2,#27
000026  2101              MOVS     r1,#1
000028  4091              LSLS     r1,r1,r2
00002a  4388              BICS     r0,r0,r1
00002c  0961              LSRS     r1,r4,#5
00002e  0089              LSLS     r1,r1,#2
000030  4a0b              LDR      r2,|L18.96|
000032  5050              STR      r0,[r2,r1]
000034  e002              B        |L18.60|
                  |L18.54|
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       NVIC_DisableIRQ
                  |L18.60|
00003c  2000              MOVS     r0,#0
                  |L18.62|
00003e  4605              MOV      r5,r0
;;;439        APP_ERROR_CHECK(err_code);
000040  bf00              NOP      
000042  462c              MOV      r4,r5
000044  2c00              CMP      r4,#0
000046  d004              BEQ      |L18.82|
000048  bf00              NOP      
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       app_error_handler_bare
000050  bf00              NOP      
                  |L18.82|
000052  bf00              NOP      
;;;440    #else
;;;441        NVIC_DisableIRQ(SOFTDEVICE_EVT_IRQ);
;;;442    #endif
;;;443        m_suspended = true;
000054  2001              MOVS     r0,#1
000056  4903              LDR      r1,|L18.100|
000058  7008              STRB     r0,[r1,#0]
;;;444        return;
;;;445    }
00005a  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

                  |L18.92|
                          DCD      0x00002001
                  |L18.96|
                          DCD      nrf_nvic_state
                  |L18.100|
                          DCD      m_suspended

                          AREA ||i.softdevice_sys_evt_handler_set||, CODE, READONLY, ALIGN=2

                  softdevice_sys_evt_handler_set PROC
;;;407    
;;;408    uint32_t softdevice_sys_evt_handler_set(sys_evt_handler_t sys_evt_handler)
000000  4601              MOV      r1,r0
;;;409    {
;;;410        VERIFY_PARAM_NOT_NULL(sys_evt_handler);
000002  bf00              NOP      
000004  2900              CMP      r1,#0
000006  d101              BNE      |L19.12|
000008  200e              MOVS     r0,#0xe
                  |L19.10|
;;;411    
;;;412        m_sys_evt_handler = sys_evt_handler;
;;;413    
;;;414        return NRF_SUCCESS;
;;;415    }
00000a  4770              BX       lr
                  |L19.12|
00000c  bf00              NOP                            ;410
00000e  4802              LDR      r0,|L19.24|
000010  6001              STR      r1,[r0,#0]            ;412  ; m_sys_evt_handler
000012  2000              MOVS     r0,#0                 ;414
000014  e7f9              B        |L19.10|
;;;416    
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      m_sys_evt_handler

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  1b5b313b          DCB      27,"[1;33mSDH:WARNING:RAM START ADDR 0x%x should be adju"
000004  33336d53
000008  44483a57
00000c  41524e49
000010  4e473a52
000014  414d2053
000018  54415254
00001c  20414444
000020  52203078
000024  25782073
000028  686f756c
00002c  64206265
000030  2061646a
000034  75      
000035  73746564          DCB      "sted to 0x%x\r\n",0
000039  20746f20
00003d  30782578
000041  0d0a00  
000044  1b5b313b          DCB      27,"[1;33mSDH:WARNING:sd_ble_enable: RAM start should be"
000048  33336d53
00004c  44483a57
000050  41524e49
000054  4e473a73
000058  645f626c
00005c  655f656e
000060  61626c65
000064  3a205241
000068  4d207374
00006c  61727420
000070  73686f75
000074  6c642062
000078  65      
000079  2061646a          DCB      " adjusted to 0x%x\r\n",0
00007d  75737465
000081  6420746f
000085  20307825
000089  780d0a00

                          AREA ||.data||, DATA, ALIGN=2

                  m_evt_schedule_func
                          DCD      0x00000000
                  m_softdevice_enabled
000004  00                DCB      0x00
                  m_suspended
000005  000000            DCB      0x00,0x00,0x00
                  mp_ble_evt_buffer
                          DCD      0x00000000
                  m_ble_evt_buffer_size
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  m_ble_evt_handler
                          DCD      0x00000000
                  m_sys_evt_handler
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\softdevice\\common\\softdevice_handler\\softdevice_handler.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_softdevice_handler_c_a07f8f21____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___20_softdevice_handler_c_a07f8f21____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_softdevice_handler_c_a07f8f21____REVSH|
#line 144
|__asm___20_softdevice_handler_c_a07f8f21____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
