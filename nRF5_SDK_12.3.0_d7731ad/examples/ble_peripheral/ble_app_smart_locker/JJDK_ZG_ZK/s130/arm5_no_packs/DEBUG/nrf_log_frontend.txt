; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\nrf_log_frontend.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\nrf_log_frontend.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\nrf_log_frontend.crf ..\..\..\..\..\..\components\libraries\log\src\nrf_log_frontend.c]
                          THUMB

                          AREA ||i.buf_prealloc||, CODE, READONLY, ALIGN=2

                  buf_prealloc PROC
;;;321     */
;;;322    static inline bool buf_prealloc(uint32_t nargs, uint32_t * p_wr_idx)
000000  b5f0              PUSH     {r4-r7,lr}
;;;323    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;324        nargs += HEADER_SIZE;
000008  1c64              ADDS     r4,r4,#1
;;;325        uint32_t ovflw_tag_size = HEADER_SIZE;
00000a  2701              MOVS     r7,#1
;;;326        bool     ret            = true;
00000c  2001              MOVS     r0,#1
00000e  9003              STR      r0,[sp,#0xc]
;;;327        CRITICAL_REGION_ENTER();
000010  2000              MOVS     r0,#0
000012  9002              STR      r0,[sp,#8]
000014  a802              ADD      r0,sp,#8
000016  f7fffffe          BL       app_util_critical_region_enter
;;;328        *p_wr_idx = m_log_data.wr_idx;
00001a  481f              LDR      r0,|L1.152|
00001c  6800              LDR      r0,[r0,#0]  ; m_log_data
00001e  6028              STR      r0,[r5,#0]
;;;329        uint32_t available_words = (m_log_data.mask + 1) - (m_log_data.wr_idx - m_log_data.rd_idx);
000020  481d              LDR      r0,|L1.152|
000022  6800              LDR      r0,[r0,#0]  ; m_log_data
000024  491c              LDR      r1,|L1.152|
000026  6849              LDR      r1,[r1,#4]  ; m_log_data
000028  1a41              SUBS     r1,r0,r1
00002a  481b              LDR      r0,|L1.152|
00002c  6880              LDR      r0,[r0,#8]  ; m_log_data
00002e  1c40              ADDS     r0,r0,#1
000030  1a46              SUBS     r6,r0,r1
;;;330        uint32_t required_words  = nargs + ovflw_tag_size; // room for current entry and overflow
000032  19e0              ADDS     r0,r4,r7
000034  9001              STR      r0,[sp,#4]
;;;331        if (required_words > available_words)
000036  9801              LDR      r0,[sp,#4]
000038  42b0              CMP      r0,r6
00003a  d921              BLS      |L1.128|
;;;332        {
;;;333            if (available_words >= HEADER_SIZE)
00003c  2e00              CMP      r6,#0
00003e  d01c              BEQ      |L1.122|
;;;334            {
;;;335                // Overflow entry is injected
;;;336                STD_HEADER_DEF(header, m_overflow_info, NRF_LOG_LEVEL_INTERNAL, 0);
000040  4816              LDR      r0,|L1.156|
000042  6800              LDR      r0,[r0,#0]  ; <Data1>
000044  9000              STR      r0,[sp,#0]
000046  9800              LDR      r0,[sp,#0]
000048  0580              LSLS     r0,r0,#22
00004a  0d80              LSRS     r0,r0,#22
00004c  4914              LDR      r1,|L1.160|
00004e  6809              LDR      r1,[r1,#0]  ; m_overflow_info
000050  0289              LSLS     r1,r1,#10
000052  0a89              LSRS     r1,r1,#10
000054  0289              LSLS     r1,r1,#10
000056  4308              ORRS     r0,r0,r1
000058  9000              STR      r0,[sp,#0]
;;;337                m_log_data.buffer[m_log_data.wr_idx++ & m_log_data.mask] =
00005a  480f              LDR      r0,|L1.152|
00005c  9a00              LDR      r2,[sp,#0]
00005e  6800              LDR      r0,[r0,#0]  ; m_log_data
000060  490d              LDR      r1,|L1.152|
000062  6809              LDR      r1,[r1,#0]  ; m_log_data
000064  1c49              ADDS     r1,r1,#1
000066  4b0c              LDR      r3,|L1.152|
000068  6019              STR      r1,[r3,#0]  ; m_log_data
00006a  4619              MOV      r1,r3
00006c  6889              LDR      r1,[r1,#8]  ; m_log_data
00006e  4008              ANDS     r0,r0,r1
000070  0081              LSLS     r1,r0,#2
000072  4618              MOV      r0,r3
000074  300c              ADDS     r0,r0,#0xc
000076  5042              STR      r2,[r0,r1]
;;;338                    header.raw;
;;;339    #if NRF_LOG_USES_TIMESTAMP
;;;340                m_log_data.buffer[m_log_data.wr_idx++ & m_log_data.mask] =
;;;341                    m_log_data.timestamp_func();
;;;342    #endif //NRF_LOG_USES_TIMESTAMP
;;;343            }
000078  bf00              NOP      
                  |L1.122|
;;;344            // overflow case
;;;345            ret = false;
00007a  2000              MOVS     r0,#0
00007c  9003              STR      r0,[sp,#0xc]
00007e  e004              B        |L1.138|
                  |L1.128|
;;;346        }
;;;347        else
;;;348        {
;;;349            m_log_data.wr_idx += nargs;
000080  4805              LDR      r0,|L1.152|
000082  6800              LDR      r0,[r0,#0]  ; m_log_data
000084  1900              ADDS     r0,r0,r4
000086  4904              LDR      r1,|L1.152|
000088  6008              STR      r0,[r1,#0]  ; m_log_data
                  |L1.138|
;;;350        }
;;;351        CRITICAL_REGION_EXIT();
00008a  4668              MOV      r0,sp
00008c  7a00              LDRB     r0,[r0,#8]
00008e  f7fffffe          BL       app_util_critical_region_exit
;;;352        return ret;
000092  9803              LDR      r0,[sp,#0xc]
;;;353    }
000094  b005              ADD      sp,sp,#0x14
000096  bdf0              POP      {r4-r7,pc}
;;;354    
                          ENDP

                  |L1.152|
                          DCD      m_log_data
                  |L1.156|
                          DCD      ||.constdata||
                  |L1.160|
                          DCD      m_overflow_info

                          AREA ||i.buffer_is_empty||, CODE, READONLY, ALIGN=2

                  buffer_is_empty PROC
;;;708    
;;;709    bool buffer_is_empty(void)
000000  4804              LDR      r0,|L2.20|
;;;710    {
;;;711        return (m_log_data.rd_idx == m_log_data.wr_idx);
000002  6840              LDR      r0,[r0,#4]  ; m_log_data
000004  4903              LDR      r1,|L2.20|
000006  6809              LDR      r1,[r1,#0]  ; m_log_data
000008  4288              CMP      r0,r1
00000a  d101              BNE      |L2.16|
00000c  2001              MOVS     r0,#1
                  |L2.14|
;;;712    }
00000e  4770              BX       lr
                  |L2.16|
000010  2000              MOVS     r0,#0                 ;711
000012  e7fc              B        |L2.14|
;;;713    
                          ENDP

                  |L2.20|
                          DCD      m_log_data

                          AREA ||i.cont_buf_prealloc||, CODE, READONLY, ALIGN=2

                  cont_buf_prealloc PROC
;;;369     */
;;;370    static inline uint32_t * cont_buf_prealloc(uint32_t len32,
000000  b5fe              PUSH     {r1-r7,lr}
;;;371                                               uint32_t * p_offset,
;;;372                                               uint32_t * p_wr_idx)
;;;373    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;374        uint32_t * p_buf = NULL;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;375    
;;;376        len32++; // Increment because 32bit header is needed to be stored.
00000c  1c64              ADDS     r4,r4,#1
;;;377    
;;;378        CRITICAL_REGION_ENTER();
00000e  9000              STR      r0,[sp,#0]
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       app_util_critical_region_enter
;;;379        *p_wr_idx = m_log_data.wr_idx;
000016  4823              LDR      r0,|L3.164|
000018  6800              LDR      r0,[r0,#0]  ; m_log_data
00001a  6038              STR      r0,[r7,#0]
;;;380        uint32_t available_words = (m_log_data.mask + 1) -
00001c  4821              LDR      r0,|L3.164|
00001e  6800              LDR      r0,[r0,#0]  ; m_log_data
000020  4920              LDR      r1,|L3.164|
000022  6889              LDR      r1,[r1,#8]  ; m_log_data
000024  4008              ANDS     r0,r0,r1
000026  491f              LDR      r1,|L3.164|
000028  6889              LDR      r1,[r1,#8]  ; m_log_data
00002a  1c49              ADDS     r1,r1,#1
00002c  1a0d              SUBS     r5,r1,r0
;;;381                                   (m_log_data.wr_idx & m_log_data.mask);
;;;382        if (len32 <= available_words)
00002e  42ac              CMP      r4,r5
000030  d812              BHI      |L3.88|
;;;383        {
;;;384            // buffer will fit as is
;;;385            p_buf              = &m_log_data.buffer[(m_log_data.wr_idx + 1) & m_log_data.mask];
000032  481c              LDR      r0,|L3.164|
000034  6800              LDR      r0,[r0,#0]  ; m_log_data
000036  1c40              ADDS     r0,r0,#1
000038  491a              LDR      r1,|L3.164|
00003a  6889              LDR      r1,[r1,#8]  ; m_log_data
00003c  4008              ANDS     r0,r0,r1
00003e  0081              LSLS     r1,r0,#2
000040  4818              LDR      r0,|L3.164|
000042  300c              ADDS     r0,r0,#0xc
000044  1808              ADDS     r0,r1,r0
000046  9001              STR      r0,[sp,#4]
;;;386            m_log_data.wr_idx += len32;
000048  4816              LDR      r0,|L3.164|
00004a  6800              LDR      r0,[r0,#0]  ; m_log_data
00004c  1900              ADDS     r0,r0,r4
00004e  4915              LDR      r1,|L3.164|
000050  6008              STR      r0,[r1,#0]  ; m_log_data
;;;387            *p_offset          = 0;
000052  2000              MOVS     r0,#0
000054  6030              STR      r0,[r6,#0]
000056  e012              B        |L3.126|
                  |L3.88|
;;;388        }
;;;389        else if (len32 < (m_log_data.rd_idx & m_log_data.mask))
000058  4812              LDR      r0,|L3.164|
00005a  6840              LDR      r0,[r0,#4]  ; m_log_data
00005c  4911              LDR      r1,|L3.164|
00005e  6889              LDR      r1,[r1,#8]  ; m_log_data
000060  4008              ANDS     r0,r0,r1
000062  42a0              CMP      r0,r4
000064  d90b              BLS      |L3.126|
;;;390        {
;;;391            // wraping to the begining of the buffer
;;;392            m_log_data.wr_idx += (len32 + available_words - 1);
000066  480f              LDR      r0,|L3.164|
000068  6801              LDR      r1,[r0,#0]  ; m_log_data
00006a  1960              ADDS     r0,r4,r5
00006c  1e40              SUBS     r0,r0,#1
00006e  1808              ADDS     r0,r1,r0
000070  490c              LDR      r1,|L3.164|
000072  6008              STR      r0,[r1,#0]  ; m_log_data
;;;393            *p_offset          = available_words - 1;
000074  1e68              SUBS     r0,r5,#1
000076  6030              STR      r0,[r6,#0]
;;;394            p_buf              = m_log_data.buffer;
000078  4608              MOV      r0,r1
00007a  300c              ADDS     r0,r0,#0xc
00007c  9001              STR      r0,[sp,#4]
                  |L3.126|
;;;395        }
;;;396        available_words = (m_log_data.mask + 1) - (m_log_data.wr_idx - m_log_data.rd_idx);
00007e  4809              LDR      r0,|L3.164|
000080  6800              LDR      r0,[r0,#0]  ; m_log_data
000082  4908              LDR      r1,|L3.164|
000084  6849              LDR      r1,[r1,#4]  ; m_log_data
000086  1a41              SUBS     r1,r0,r1
000088  4806              LDR      r0,|L3.164|
00008a  6880              LDR      r0,[r0,#8]  ; m_log_data
00008c  1c40              ADDS     r0,r0,#1
00008e  1a45              SUBS     r5,r0,r1
;;;397        // If there is no more room for even overflow tag indicate failed allocation.
;;;398        if (available_words < HEADER_SIZE)
000090  2d00              CMP      r5,#0
000092  d101              BNE      |L3.152|
;;;399        {
;;;400            p_buf = NULL;
000094  2000              MOVS     r0,#0
000096  9001              STR      r0,[sp,#4]
                  |L3.152|
;;;401        }
;;;402        CRITICAL_REGION_EXIT();
000098  4668              MOV      r0,sp
00009a  7800              LDRB     r0,[r0,#0]
00009c  f7fffffe          BL       app_util_critical_region_exit
;;;403    
;;;404        return p_buf;
0000a0  9801              LDR      r0,[sp,#4]
;;;405    }
0000a2  bdfe              POP      {r1-r7,pc}
;;;406    #endif //(NRF_LOG_DEFERRED == 1)
                          ENDP

                  |L3.164|
                          DCD      m_log_data

                          AREA ||i.nrf_log_blocking_backend_set||, CODE, READONLY, ALIGN=1

                  nrf_log_blocking_backend_set PROC
;;;279    
;;;280    ret_code_t nrf_log_blocking_backend_set(void)
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282        // Return value is ommited because
;;;283        return nrf_log_backend_init(true);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       nrf_log_backend_init
;;;284    }
000008  bd10              POP      {r4,pc}
;;;285    
                          ENDP


                          AREA ||i.nrf_log_frontend_dequeue||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_dequeue PROC
;;;714    
;;;715    bool nrf_log_frontend_dequeue(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;716    {
000002  b091              SUB      sp,sp,#0x44
;;;717        if (buffer_is_empty())
000004  f7fffffe          BL       buffer_is_empty
000008  2800              CMP      r0,#0
00000a  d002              BEQ      |L5.18|
;;;718        {
;;;719            return false;
00000c  2000              MOVS     r0,#0
                  |L5.14|
;;;720        }
;;;721    
;;;722        uint32_t rd_idx        = m_log_data.rd_idx;
;;;723        uint32_t mask          = m_log_data.mask;
;;;724        uint32_t header_rd_idx = rd_idx;
;;;725        // uint32_t header = m_log_data.buffer[rd_idx++ & mask];
;;;726        nrf_log_header_t header;
;;;727        header.raw = m_log_data.buffer[rd_idx++ & mask];
;;;728    
;;;729        // Skip any string that is pushed to the circular buffer.
;;;730        while (header.generic.type == HEADER_TYPE_PUSHED)
;;;731        {
;;;732            rd_idx       += (header.pushed.len + header.pushed.offset);
;;;733            header_rd_idx = rd_idx;
;;;734            header.raw    = m_log_data.buffer[rd_idx++ & mask];
;;;735        }
;;;736    
;;;737        uint32_t * p_timestamp = NRF_LOG_USES_TIMESTAMP ?
;;;738                                 &m_log_data.buffer[rd_idx++ & mask] : NULL;
;;;739    
;;;740        if (header.generic.raw)
;;;741        {
;;;742            p_timestamp = NULL;
;;;743        }
;;;744    
;;;745        bool ret = false;
;;;746        if (header.generic.type == HEADER_TYPE_HEXDUMP)
;;;747        {
;;;748            // buffer
;;;749            char   * p_str  = (char *)m_log_data.buffer[rd_idx++ & mask];
;;;750            uint32_t length = header.hexdump.len;
;;;751            uint32_t offset = header.hexdump.offset;
;;;752            uint32_t space0 = sizeof(uint32_t) * (mask + 1 - (rd_idx & mask));
;;;753            if (length > space0)
;;;754            {
;;;755                uint8_t * ptr0 = space0 ?
;;;756                                 (uint8_t *)&m_log_data.buffer[rd_idx & mask] :
;;;757                                 (uint8_t *)&m_log_data.buffer[0];
;;;758                uint8_t   len0 = space0 ? space0 : length;
;;;759                uint8_t * ptr1 = space0 ?
;;;760                                 (uint8_t *)&m_log_data.buffer[0] : NULL;
;;;761                uint8_t len1 = space0 ? length - space0 : 0;
;;;762    
;;;763                offset = m_log_data.hexdump_handler(header.hexdump.severity,
;;;764                                                    p_timestamp, p_str,
;;;765                                                    offset,
;;;766                                                    ptr0, len0,
;;;767                                                    ptr1, len1);
;;;768            }
;;;769            else
;;;770            {
;;;771                offset = m_log_data.hexdump_handler(
;;;772                    header.hexdump.severity,
;;;773                    p_timestamp,
;;;774                    p_str,
;;;775                    offset,
;;;776                    (uint8_t *)&m_log_data.buffer[rd_idx & mask],
;;;777                    length,
;;;778                    NULL, 0);
;;;779            }
;;;780    
;;;781            if (offset == length)
;;;782            {
;;;783                rd_idx += CEIL_DIV(length, 4);
;;;784                ret     = true;
;;;785            }
;;;786            else
;;;787            {
;;;788                // If there is more log to process just updated the offset but
;;;789                // do not move rd_idx.
;;;790                header.hexdump.offset                   = offset;
;;;791                m_log_data.buffer[header_rd_idx & mask] = header.raw;
;;;792            }
;;;793        }
;;;794        else // standard entry
;;;795        {
;;;796            uint32_t   args[6];
;;;797            uint32_t * p_arg = args;
;;;798            char     * p_str = (char *)((uint32_t)header.std.addr);
;;;799            uint32_t   nargs = header.std.nargs;
;;;800    
;;;801            uint32_t i;
;;;802    
;;;803            for (i = 0; i < nargs; i++)
;;;804            {
;;;805                *p_arg = m_log_data.buffer[rd_idx++ & mask];
;;;806                p_arg++;
;;;807            }
;;;808    
;;;809            ret = m_log_data.std_handler(header.std.severity,
;;;810                                         p_timestamp,
;;;811                                         p_str, args, nargs);
;;;812        }
;;;813        if (ret)
;;;814        {
;;;815            m_log_data.rd_idx = rd_idx;
;;;816        }
;;;817        return buffer_is_empty() ? false : true;
;;;818    
;;;819    }
00000e  b011              ADD      sp,sp,#0x44
000010  bdf0              POP      {r4-r7,pc}
                  |L5.18|
000012  487a              LDR      r0,|L5.508|
000014  6844              LDR      r4,[r0,#4]            ;722  ; m_log_data
000016  6885              LDR      r5,[r0,#8]            ;723  ; m_log_data
000018  4626              MOV      r6,r4                 ;724
00001a  1c64              ADDS     r4,r4,#1              ;727
00001c  4630              MOV      r0,r6                 ;727
00001e  4028              ANDS     r0,r0,r5              ;727
000020  0081              LSLS     r1,r0,#2              ;727
000022  4876              LDR      r0,|L5.508|
000024  300c              ADDS     r0,r0,#0xc            ;727
000026  5840              LDR      r0,[r0,r1]            ;727
000028  9010              STR      r0,[sp,#0x40]         ;727
00002a  e00f              B        |L5.76|
                  |L5.44|
00002c  9810              LDR      r0,[sp,#0x40]         ;732
00002e  0d80              LSRS     r0,r0,#22             ;732
000030  9910              LDR      r1,[sp,#0x40]         ;732
000032  0409              LSLS     r1,r1,#16             ;732
000034  0d89              LSRS     r1,r1,#22             ;732
000036  1840              ADDS     r0,r0,r1              ;732
000038  1904              ADDS     r4,r0,r4              ;732
00003a  4626              MOV      r6,r4                 ;733
00003c  1c64              ADDS     r4,r4,#1              ;734
00003e  4630              MOV      r0,r6                 ;734
000040  4028              ANDS     r0,r0,r5              ;734
000042  0081              LSLS     r1,r0,#2              ;734
000044  486d              LDR      r0,|L5.508|
000046  300c              ADDS     r0,r0,#0xc            ;734
000048  5840              LDR      r0,[r0,r1]            ;734
00004a  9010              STR      r0,[sp,#0x40]         ;734
                  |L5.76|
00004c  9810              LDR      r0,[sp,#0x40]         ;730
00004e  0780              LSLS     r0,r0,#30             ;730
000050  0f80              LSRS     r0,r0,#30             ;730
000052  2800              CMP      r0,#0                 ;730
000054  d0ea              BEQ      |L5.44|
000056  2000              MOVS     r0,#0                 ;737
000058  900f              STR      r0,[sp,#0x3c]         ;737
00005a  9810              LDR      r0,[sp,#0x40]         ;740
00005c  0740              LSLS     r0,r0,#29             ;740
00005e  0fc0              LSRS     r0,r0,#31             ;740
000060  2800              CMP      r0,#0                 ;740
000062  d001              BEQ      |L5.104|
000064  2000              MOVS     r0,#0                 ;742
000066  900f              STR      r0,[sp,#0x3c]         ;742
                  |L5.104|
000068  2000              MOVS     r0,#0                 ;745
00006a  900e              STR      r0,[sp,#0x38]         ;745
00006c  9810              LDR      r0,[sp,#0x40]         ;746
00006e  0780              LSLS     r0,r0,#30             ;746
000070  0f80              LSRS     r0,r0,#30             ;746
000072  2802              CMP      r0,#2                 ;746
000074  d176              BNE      |L5.356|
000076  4620              MOV      r0,r4                 ;749
000078  1c64              ADDS     r4,r4,#1              ;749
00007a  4028              ANDS     r0,r0,r5              ;749
00007c  0081              LSLS     r1,r0,#2              ;749
00007e  485f              LDR      r0,|L5.508|
000080  300c              ADDS     r0,r0,#0xc            ;749
000082  5840              LDR      r0,[r0,r1]            ;749
000084  900d              STR      r0,[sp,#0x34]         ;749
000086  9810              LDR      r0,[sp,#0x40]         ;750
000088  0d80              LSRS     r0,r0,#22             ;750
00008a  900c              STR      r0,[sp,#0x30]         ;750
00008c  9810              LDR      r0,[sp,#0x40]         ;751
00008e  0400              LSLS     r0,r0,#16             ;751
000090  0d80              LSRS     r0,r0,#22             ;751
000092  900b              STR      r0,[sp,#0x2c]         ;751
000094  4620              MOV      r0,r4                 ;752
000096  4028              ANDS     r0,r0,r5              ;752
000098  1c69              ADDS     r1,r5,#1              ;752
00009a  1a08              SUBS     r0,r1,r0              ;752
00009c  0080              LSLS     r0,r0,#2              ;752
00009e  900a              STR      r0,[sp,#0x28]         ;752
0000a0  990a              LDR      r1,[sp,#0x28]         ;753
0000a2  980c              LDR      r0,[sp,#0x30]         ;753
0000a4  4288              CMP      r0,r1                 ;753
0000a6  d93a              BLS      |L5.286|
0000a8  980a              LDR      r0,[sp,#0x28]         ;755
0000aa  2800              CMP      r0,#0                 ;755
0000ac  d006              BEQ      |L5.188|
0000ae  4620              MOV      r0,r4                 ;756
0000b0  4028              ANDS     r0,r0,r5              ;756
0000b2  0081              LSLS     r1,r0,#2              ;756
0000b4  4851              LDR      r0,|L5.508|
0000b6  300c              ADDS     r0,r0,#0xc            ;756
0000b8  1808              ADDS     r0,r1,r0              ;756
0000ba  e001              B        |L5.192|
                  |L5.188|
0000bc  484f              LDR      r0,|L5.508|
0000be  300c              ADDS     r0,r0,#0xc            ;757
                  |L5.192|
0000c0  9009              STR      r0,[sp,#0x24]         ;757
0000c2  980a              LDR      r0,[sp,#0x28]         ;758
0000c4  2800              CMP      r0,#0                 ;758
0000c6  d001              BEQ      |L5.204|
0000c8  980a              LDR      r0,[sp,#0x28]         ;758
0000ca  e000              B        |L5.206|
                  |L5.204|
0000cc  980c              LDR      r0,[sp,#0x30]         ;758
                  |L5.206|
0000ce  b2c0              UXTB     r0,r0                 ;758
0000d0  9008              STR      r0,[sp,#0x20]         ;758
0000d2  980a              LDR      r0,[sp,#0x28]         ;759
0000d4  2800              CMP      r0,#0                 ;759
0000d6  d002              BEQ      |L5.222|
0000d8  4848              LDR      r0,|L5.508|
0000da  300c              ADDS     r0,r0,#0xc            ;760
0000dc  e000              B        |L5.224|
                  |L5.222|
0000de  2000              MOVS     r0,#0                 ;760
                  |L5.224|
0000e0  9007              STR      r0,[sp,#0x1c]         ;760
0000e2  980a              LDR      r0,[sp,#0x28]         ;761
0000e4  2800              CMP      r0,#0                 ;761
0000e6  d003              BEQ      |L5.240|
0000e8  990a              LDR      r1,[sp,#0x28]         ;761
0000ea  980c              LDR      r0,[sp,#0x30]         ;761
0000ec  1a40              SUBS     r0,r0,r1              ;761
0000ee  e000              B        |L5.242|
                  |L5.240|
0000f0  2000              MOVS     r0,#0                 ;761
                  |L5.242|
0000f2  b2c0              UXTB     r0,r0                 ;761
0000f4  9006              STR      r0,[sp,#0x18]         ;761
0000f6  a806              ADD      r0,sp,#0x18           ;763
0000f8  c80b              LDM      r0,{r0,r1,r3}         ;763
0000fa  9a09              LDR      r2,[sp,#0x24]         ;763
0000fc  9301              STR      r3,[sp,#4]            ;763
0000fe  9200              STR      r2,[sp,#0]            ;763
000100  9102              STR      r1,[sp,#8]            ;763
000102  9003              STR      r0,[sp,#0xc]          ;763
000104  9810              LDR      r0,[sp,#0x40]         ;763
000106  0680              LSLS     r0,r0,#26             ;763
000108  0f40              LSRS     r0,r0,#29             ;763
00010a  9005              STR      r0,[sp,#0x14]         ;763
00010c  483c              LDR      r0,|L5.512|
00010e  6947              LDR      r7,[r0,#0x14]         ;763  ; m_log_data
000110  9b0b              LDR      r3,[sp,#0x2c]         ;763
000112  9a0d              LDR      r2,[sp,#0x34]         ;763
000114  990f              LDR      r1,[sp,#0x3c]         ;763
000116  9805              LDR      r0,[sp,#0x14]         ;763
000118  47b8              BLX      r7                    ;763
00011a  900b              STR      r0,[sp,#0x2c]         ;763
00011c  e017              B        |L5.334|
                  |L5.286|
00011e  2200              MOVS     r2,#0                 ;771
000120  4621              MOV      r1,r4                 ;771
000122  4029              ANDS     r1,r1,r5              ;771
000124  008f              LSLS     r7,r1,#2              ;771
000126  4935              LDR      r1,|L5.508|
000128  310c              ADDS     r1,r1,#0xc            ;771
00012a  1879              ADDS     r1,r7,r1              ;771
00012c  980c              LDR      r0,[sp,#0x30]         ;771
00012e  9202              STR      r2,[sp,#8]            ;771
000130  9203              STR      r2,[sp,#0xc]          ;771
000132  9100              STR      r1,[sp,#0]            ;771
000134  9001              STR      r0,[sp,#4]            ;771
000136  9810              LDR      r0,[sp,#0x40]         ;771
000138  0680              LSLS     r0,r0,#26             ;771
00013a  0f40              LSRS     r0,r0,#29             ;771
00013c  9009              STR      r0,[sp,#0x24]         ;771
00013e  4830              LDR      r0,|L5.512|
000140  6947              LDR      r7,[r0,#0x14]         ;771  ; m_log_data
000142  9b0b              LDR      r3,[sp,#0x2c]         ;771
000144  9a0d              LDR      r2,[sp,#0x34]         ;771
000146  990f              LDR      r1,[sp,#0x3c]         ;771
000148  9809              LDR      r0,[sp,#0x24]         ;771
00014a  47b8              BLX      r7                    ;771
00014c  900b              STR      r0,[sp,#0x2c]         ;771
                  |L5.334|
00014e  990c              LDR      r1,[sp,#0x30]         ;781
000150  980b              LDR      r0,[sp,#0x2c]         ;781
000152  4288              CMP      r0,r1                 ;781
000154  d107              BNE      |L5.358|
000156  980c              LDR      r0,[sp,#0x30]         ;783
000158  1cc0              ADDS     r0,r0,#3              ;783
00015a  0880              LSRS     r0,r0,#2              ;783
00015c  1904              ADDS     r4,r0,r4              ;783
00015e  2001              MOVS     r0,#1                 ;784
000160  900e              STR      r0,[sp,#0x38]         ;784
000162  e011              B        |L5.392|
                  |L5.356|
000164  e011              B        |L5.394|
                  |L5.358|
000166  4927              LDR      r1,|L5.516|
000168  9810              LDR      r0,[sp,#0x40]         ;790
00016a  4008              ANDS     r0,r0,r1              ;790
00016c  990b              LDR      r1,[sp,#0x2c]         ;790
00016e  0189              LSLS     r1,r1,#6              ;790
000170  4a24              LDR      r2,|L5.516|
000172  43d2              MVNS     r2,r2                 ;790
000174  4011              ANDS     r1,r1,r2              ;790
000176  4308              ORRS     r0,r0,r1              ;790
000178  9010              STR      r0,[sp,#0x40]         ;790
00017a  4630              MOV      r0,r6                 ;791
00017c  4028              ANDS     r0,r0,r5              ;791
00017e  0082              LSLS     r2,r0,#2              ;791
000180  481e              LDR      r0,|L5.508|
000182  300c              ADDS     r0,r0,#0xc            ;791
000184  9910              LDR      r1,[sp,#0x40]         ;791
000186  5081              STR      r1,[r0,r2]            ;791
                  |L5.392|
000188  e02d              B        |L5.486|
                  |L5.394|
00018a  a808              ADD      r0,sp,#0x20           ;797
00018c  9007              STR      r0,[sp,#0x1c]         ;797
00018e  9810              LDR      r0,[sp,#0x40]         ;798
000190  0a80              LSRS     r0,r0,#10             ;798
000192  9006              STR      r0,[sp,#0x18]         ;798
000194  9810              LDR      r0,[sp,#0x40]         ;799
000196  0580              LSLS     r0,r0,#22             ;799
000198  0f00              LSRS     r0,r0,#28             ;799
00019a  9005              STR      r0,[sp,#0x14]         ;799
00019c  2000              MOVS     r0,#0                 ;803
00019e  9004              STR      r0,[sp,#0x10]         ;803
0001a0  e00e              B        |L5.448|
                  |L5.418|
0001a2  4620              MOV      r0,r4                 ;805
0001a4  1c64              ADDS     r4,r4,#1              ;805
0001a6  4028              ANDS     r0,r0,r5              ;805
0001a8  0081              LSLS     r1,r0,#2              ;805
0001aa  4814              LDR      r0,|L5.508|
0001ac  300c              ADDS     r0,r0,#0xc            ;805
0001ae  5841              LDR      r1,[r0,r1]            ;805
0001b0  9807              LDR      r0,[sp,#0x1c]         ;805
0001b2  6001              STR      r1,[r0,#0]            ;805
0001b4  9807              LDR      r0,[sp,#0x1c]         ;806
0001b6  1d00              ADDS     r0,r0,#4              ;806
0001b8  9007              STR      r0,[sp,#0x1c]         ;806
0001ba  9804              LDR      r0,[sp,#0x10]         ;803
0001bc  1c40              ADDS     r0,r0,#1              ;803
0001be  9004              STR      r0,[sp,#0x10]         ;803
                  |L5.448|
0001c0  9905              LDR      r1,[sp,#0x14]         ;803
0001c2  9804              LDR      r0,[sp,#0x10]         ;803
0001c4  4288              CMP      r0,r1                 ;803
0001c6  d3ec              BCC      |L5.418|
0001c8  9805              LDR      r0,[sp,#0x14]         ;809
0001ca  9000              STR      r0,[sp,#0]            ;809
0001cc  9810              LDR      r0,[sp,#0x40]         ;809
0001ce  0680              LSLS     r0,r0,#26             ;809
0001d0  0f40              LSRS     r0,r0,#29             ;809
0001d2  9003              STR      r0,[sp,#0xc]          ;809
0001d4  480a              LDR      r0,|L5.512|
0001d6  ab08              ADD      r3,sp,#0x20           ;809
0001d8  6907              LDR      r7,[r0,#0x10]         ;809  ; m_log_data
0001da  9a06              LDR      r2,[sp,#0x18]         ;809
0001dc  990f              LDR      r1,[sp,#0x3c]         ;809
0001de  9803              LDR      r0,[sp,#0xc]          ;809
0001e0  47b8              BLX      r7                    ;809
0001e2  900e              STR      r0,[sp,#0x38]         ;809
0001e4  bf00              NOP                            ;812
                  |L5.486|
0001e6  980e              LDR      r0,[sp,#0x38]         ;813
0001e8  2800              CMP      r0,#0                 ;813
0001ea  d001              BEQ      |L5.496|
0001ec  4803              LDR      r0,|L5.508|
0001ee  6044              STR      r4,[r0,#4]            ;815  ; m_log_data
                  |L5.496|
0001f0  f7fffffe          BL       buffer_is_empty
0001f4  2101              MOVS     r1,#1                 ;817
0001f6  4048              EORS     r0,r0,r1              ;817
0001f8  e709              B        |L5.14|
;;;820    
                          ENDP

0001fa  0000              DCW      0x0000
                  |L5.508|
                          DCD      m_log_data
                  |L5.512|
                          DCD      m_log_data+0x400
                  |L5.516|
                          DCD      0xffff003f

                          AREA ||i.nrf_log_frontend_hexdump||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_hexdump PROC
;;;653    
;;;654    void nrf_log_frontend_hexdump(uint8_t            severity,
000000  b5ff              PUSH     {r0-r7,lr}
;;;655                                  char const * const p_str,
;;;656                                  const void * const p_data,
;;;657                                  uint16_t           length)
;;;658    {
000002  b083              SUB      sp,sp,#0xc
000004  4607              MOV      r7,r0
000006  461c              MOV      r4,r3
;;;659    #if (NRF_LOG_DEFERRED == 0)
;;;660        uint32_t timestamp = 0;
;;;661    #if NRF_LOG_USES_TIMESTAMP
;;;662        timestamp = m_log_data.timestamp_func();
;;;663    #else //NRF_LOG_USES_TIMESTAMP
;;;664        (void) timestamp;
;;;665    #endif //NRF_LOG_USES_TIMESTAMP
;;;666    
;;;667        uint32_t curr_offset = 0;
;;;668    
;;;669        do
;;;670        {
;;;671            curr_offset = m_log_data.hexdump_handler(severity,
;;;672                                                     NRF_LOG_USES_TIMESTAMP ? &timestamp : NULL,
;;;673                                                     p_str,
;;;674                                                     curr_offset,
;;;675                                                     p_data,
;;;676                                                     length,
;;;677                                                     NULL,
;;;678                                                     0);
;;;679        }
;;;680        while (curr_offset < length);
;;;681    #else //(NRF_LOG_DEFERRED == 0)
;;;682        uint32_t mask   = m_log_data.mask;
000008  4832              LDR      r0,|L6.212|
00000a  6885              LDR      r5,[r0,#8]  ; m_log_data
;;;683    
;;;684        uint32_t wr_idx;
;;;685        if (buf_prealloc(CEIL_DIV(length, 4) + 1, &wr_idx))
00000c  1ce6              ADDS     r6,r4,#3
00000e  17f1              ASRS     r1,r6,#31
000010  0f89              LSRS     r1,r1,#30
000012  1989              ADDS     r1,r1,r6
000014  1089              ASRS     r1,r1,#2
000016  1c48              ADDS     r0,r1,#1
000018  a902              ADD      r1,sp,#8
00001a  f7fffffe          BL       buf_prealloc
00001e  2800              CMP      r0,#0
000020  d056              BEQ      |L6.208|
;;;686        {
;;;687            HEXDUMP_HEADER_DEF(header, severity, length);
000022  482d              LDR      r0,|L6.216|
000024  6800              LDR      r0,[r0,#0]  ; <Data9>
000026  9001              STR      r0,[sp,#4]
000028  2104              MOVS     r1,#4
00002a  9801              LDR      r0,[sp,#4]
00002c  4388              BICS     r0,r0,r1
00002e  2110              MOVS     r1,#0x10
000030  4039              ANDS     r1,r1,r7
000032  0089              LSLS     r1,r1,#2
000034  2204              MOVS     r2,#4
000036  4011              ANDS     r1,r1,r2
000038  4308              ORRS     r0,r0,r1
00003a  9001              STR      r0,[sp,#4]
00003c  2138              MOVS     r1,#0x38
00003e  9801              LDR      r0,[sp,#4]
000040  4388              BICS     r0,r0,r1
000042  00f9              LSLS     r1,r7,#3
000044  2238              MOVS     r2,#0x38
000046  4011              ANDS     r1,r1,r2
000048  4308              ORRS     r0,r0,r1
00004a  9001              STR      r0,[sp,#4]
00004c  9801              LDR      r0,[sp,#4]
00004e  0280              LSLS     r0,r0,#10
000050  0a80              LSRS     r0,r0,#10
000052  05a1              LSLS     r1,r4,#22
000054  0d89              LSRS     r1,r1,#22
000056  0589              LSLS     r1,r1,#22
000058  4308              ORRS     r0,r0,r1
00005a  9001              STR      r0,[sp,#4]
;;;688            m_log_data.buffer[wr_idx++ & mask] = header.raw;
00005c  9802              LDR      r0,[sp,#8]
00005e  1c41              ADDS     r1,r0,#1
000060  9a01              LDR      r2,[sp,#4]
000062  4028              ANDS     r0,r0,r5
000064  9102              STR      r1,[sp,#8]
000066  0081              LSLS     r1,r0,#2
000068  481a              LDR      r0,|L6.212|
00006a  300c              ADDS     r0,r0,#0xc
00006c  5042              STR      r2,[r0,r1]
;;;689    #if NRF_LOG_USES_TIMESTAMP
;;;690            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;691    #endif //NRF_LOG_USES_TIMESTAMP
;;;692            m_log_data.buffer[wr_idx++ & mask] = (uint32_t)p_str;
00006e  9802              LDR      r0,[sp,#8]
000070  1c42              ADDS     r2,r0,#1
000072  9904              LDR      r1,[sp,#0x10]
000074  4028              ANDS     r0,r0,r5
000076  9202              STR      r2,[sp,#8]
000078  0082              LSLS     r2,r0,#2
00007a  4816              LDR      r0,|L6.212|
00007c  300c              ADDS     r0,r0,#0xc
00007e  5081              STR      r1,[r0,r2]
;;;693            uint32_t space0 = sizeof(uint32_t) * (m_log_data.mask + 1 - (wr_idx & mask));
000080  380c              SUBS     r0,r0,#0xc
000082  6880              LDR      r0,[r0,#8]  ; m_log_data
000084  1c40              ADDS     r0,r0,#1
000086  9902              LDR      r1,[sp,#8]
000088  4029              ANDS     r1,r1,r5
00008a  1a40              SUBS     r0,r0,r1
00008c  0086              LSLS     r6,r0,#2
;;;694            if (length <= space0)
00008e  42b4              CMP      r4,r6
000090  d80a              BHI      |L6.168|
;;;695            {
;;;696                memcpy(&m_log_data.buffer[wr_idx & mask], p_data, length);
000092  9902              LDR      r1,[sp,#8]
000094  4029              ANDS     r1,r1,r5
000096  008a              LSLS     r2,r1,#2
000098  490e              LDR      r1,|L6.212|
00009a  310c              ADDS     r1,r1,#0xc
00009c  1850              ADDS     r0,r2,r1
00009e  4622              MOV      r2,r4
0000a0  9905              LDR      r1,[sp,#0x14]
0000a2  f7fffffe          BL       __aeabi_memcpy
0000a6  e012              B        |L6.206|
                  |L6.168|
;;;697            }
;;;698            else
;;;699            {
;;;700                memcpy(&m_log_data.buffer[wr_idx & mask], p_data, space0);
0000a8  9902              LDR      r1,[sp,#8]
0000aa  4029              ANDS     r1,r1,r5
0000ac  008a              LSLS     r2,r1,#2
0000ae  4909              LDR      r1,|L6.212|
0000b0  310c              ADDS     r1,r1,#0xc
0000b2  1850              ADDS     r0,r2,r1
0000b4  4632              MOV      r2,r6
0000b6  9905              LDR      r1,[sp,#0x14]
0000b8  f7fffffe          BL       __aeabi_memcpy
;;;701                length -= space0;
0000bc  1ba0              SUBS     r0,r4,r6
0000be  b284              UXTH     r4,r0
;;;702                memcpy(&m_log_data.buffer[0], &((uint8_t *)p_data)[space0], length);
0000c0  9805              LDR      r0,[sp,#0x14]
0000c2  1981              ADDS     r1,r0,r6
0000c4  4622              MOV      r2,r4
0000c6  4803              LDR      r0,|L6.212|
0000c8  300c              ADDS     r0,r0,#0xc
0000ca  f7fffffe          BL       __aeabi_memcpy
                  |L6.206|
;;;703            }
;;;704        }
0000ce  bf00              NOP      
                  |L6.208|
;;;705    #endif //(NRF_LOG_DEFERRED == 0)
;;;706    }
0000d0  b007              ADD      sp,sp,#0x1c
0000d2  bdf0              POP      {r4-r7,pc}
;;;707    
                          ENDP

                  |L6.212|
                          DCD      m_log_data
                  |L6.216|
                          DCD      ||.constdata||+0x20

                          AREA ||i.nrf_log_frontend_init||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_init PROC
;;;286    
;;;287    void nrf_log_frontend_init(nrf_log_std_handler_t     std_handler,
000000  b570              PUSH     {r4-r6,lr}
;;;288                               nrf_log_hexdump_handler_t hexdump_handler,
;;;289                               nrf_log_timestamp_func_t  timestamp_func)
;;;290    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;291    #if NRF_LOG_DEFERRED
;;;292        m_log_data.mask   = NRF_LOG_DEFERRED_BUFSIZE - 1;
000008  20ff              MOVS     r0,#0xff
00000a  4905              LDR      r1,|L7.32|
00000c  6088              STR      r0,[r1,#8]  ; m_log_data
;;;293        m_log_data.wr_idx = 0;
00000e  2000              MOVS     r0,#0
000010  6008              STR      r0,[r1,#0]  ; m_log_data
;;;294        m_log_data.rd_idx = 0;
000012  6048              STR      r0,[r1,#4]  ; m_log_data
;;;295    #endif //NRF_LOG_DEFERRED
;;;296    #if NRF_LOG_USES_TIMESTAMP
;;;297        m_log_data.timestamp_func = timestamp_func;
;;;298    #endif //NRF_LOG_USES_TIMESTAMP
;;;299        nrf_log_handlers_set(std_handler, hexdump_handler);
000014  4629              MOV      r1,r5
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       nrf_log_handlers_set
;;;300    }
00001c  bd70              POP      {r4-r6,pc}
;;;301    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      m_log_data

                          AREA ||i.nrf_log_frontend_std_0||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_std_0 PROC
;;;452    
;;;453    void nrf_log_frontend_std_0(uint8_t severity, char const * const p_str)
000000  b5fe              PUSH     {r1-r7,lr}
;;;454    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;455    #if (NRF_LOG_DEFERRED == 0)
;;;456        nrf_log_direct_feed(severity, p_str, NULL, 0);
;;;457    #else //(NRF_LOG_DEFERRED == 0)
;;;458        uint32_t nargs  = 0;
000006  2600              MOVS     r6,#0
;;;459        uint32_t mask   = m_log_data.mask;
000008  481c              LDR      r0,|L8.124|
00000a  6887              LDR      r7,[r0,#8]  ; m_log_data
;;;460        uint32_t wr_idx;
;;;461        if (buf_prealloc(nargs, &wr_idx))
00000c  a901              ADD      r1,sp,#4
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       buf_prealloc
000014  2800              CMP      r0,#0
000016  d030              BEQ      |L8.122|
;;;462        {
;;;463            // Proceed only if buffer was successfully preallocated.
;;;464            STD_HEADER_DEF(header, p_str, severity, nargs);
000018  4819              LDR      r0,|L8.128|
00001a  6800              LDR      r0,[r0,#0]  ; <Data2>
00001c  9000              STR      r0,[sp,#0]
00001e  2104              MOVS     r1,#4
000020  9800              LDR      r0,[sp,#0]
000022  4388              BICS     r0,r0,r1
000024  2110              MOVS     r1,#0x10
000026  4021              ANDS     r1,r1,r4
000028  0089              LSLS     r1,r1,#2
00002a  2204              MOVS     r2,#4
00002c  4011              ANDS     r1,r1,r2
00002e  4308              ORRS     r0,r0,r1
000030  9000              STR      r0,[sp,#0]
000032  2138              MOVS     r1,#0x38
000034  9800              LDR      r0,[sp,#0]
000036  4388              BICS     r0,r0,r1
000038  00e1              LSLS     r1,r4,#3
00003a  2238              MOVS     r2,#0x38
00003c  4011              ANDS     r1,r1,r2
00003e  4308              ORRS     r0,r0,r1
000040  9000              STR      r0,[sp,#0]
000042  210f              MOVS     r1,#0xf
000044  0189              LSLS     r1,r1,#6
000046  9800              LDR      r0,[sp,#0]
000048  4388              BICS     r0,r0,r1
00004a  01b1              LSLS     r1,r6,#6
00004c  220f              MOVS     r2,#0xf
00004e  0192              LSLS     r2,r2,#6
000050  4011              ANDS     r1,r1,r2
000052  4308              ORRS     r0,r0,r1
000054  9000              STR      r0,[sp,#0]
000056  9800              LDR      r0,[sp,#0]
000058  0580              LSLS     r0,r0,#22
00005a  0d80              LSRS     r0,r0,#22
00005c  02a9              LSLS     r1,r5,#10
00005e  0a89              LSRS     r1,r1,#10
000060  0289              LSLS     r1,r1,#10
000062  4308              ORRS     r0,r0,r1
000064  9000              STR      r0,[sp,#0]
;;;465            m_log_data.buffer[wr_idx++ & mask] = header.raw;
000066  9901              LDR      r1,[sp,#4]
000068  1c48              ADDS     r0,r1,#1
00006a  9a00              LDR      r2,[sp,#0]
00006c  4039              ANDS     r1,r1,r7
00006e  0089              LSLS     r1,r1,#2
000070  9001              STR      r0,[sp,#4]
000072  4802              LDR      r0,|L8.124|
000074  300c              ADDS     r0,r0,#0xc
000076  5042              STR      r2,[r0,r1]
;;;466    #if NRF_LOG_USES_TIMESTAMP
;;;467            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;468    #endif //NRF_LOG_USES_TIMESTAMP
;;;469        }
000078  bf00              NOP      
                  |L8.122|
;;;470    #endif //(NRF_LOG_DEFERRED == 0)
;;;471    }
00007a  bdfe              POP      {r1-r7,pc}
;;;472    
                          ENDP

                  |L8.124|
                          DCD      m_log_data
                  |L8.128|
                          DCD      ||.constdata||+0x4

                          AREA ||i.nrf_log_frontend_std_1||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_std_1 PROC
;;;473    
;;;474    void nrf_log_frontend_std_1(uint8_t            severity,
000000  b5fe              PUSH     {r1-r7,lr}
;;;475                                char const * const p_str,
;;;476                                uint32_t           val0)
;;;477    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;478    #if (NRF_LOG_DEFERRED == 0)
;;;479        uint32_t args[] = {val0};
;;;480        nrf_log_direct_feed(severity, p_str, args, ARRAY_SIZE(args));
;;;481    #else //(NRF_LOG_DEFERRED == 0)
;;;482        uint32_t nargs  = 1;
000008  2001              MOVS     r0,#1
00000a  9002              STR      r0,[sp,#8]
;;;483        uint32_t mask   = m_log_data.mask;
00000c  4820              LDR      r0,|L9.144|
00000e  6887              LDR      r7,[r0,#8]  ; m_log_data
;;;484        uint32_t wr_idx;
;;;485        if (buf_prealloc(nargs, &wr_idx))
000010  a901              ADD      r1,sp,#4
000012  9802              LDR      r0,[sp,#8]
000014  f7fffffe          BL       buf_prealloc
000018  2800              CMP      r0,#0
00001a  d037              BEQ      |L9.140|
;;;486        {
;;;487            // Proceed only if buffer was successfully preallocated.
;;;488            STD_HEADER_DEF(header, p_str, severity, nargs);
00001c  481d              LDR      r0,|L9.148|
00001e  6800              LDR      r0,[r0,#0]  ; <Data3>
000020  9000              STR      r0,[sp,#0]
000022  2104              MOVS     r1,#4
000024  9800              LDR      r0,[sp,#0]
000026  4388              BICS     r0,r0,r1
000028  2110              MOVS     r1,#0x10
00002a  4021              ANDS     r1,r1,r4
00002c  0089              LSLS     r1,r1,#2
00002e  2204              MOVS     r2,#4
000030  4011              ANDS     r1,r1,r2
000032  4308              ORRS     r0,r0,r1
000034  9000              STR      r0,[sp,#0]
000036  2138              MOVS     r1,#0x38
000038  9800              LDR      r0,[sp,#0]
00003a  4388              BICS     r0,r0,r1
00003c  00e1              LSLS     r1,r4,#3
00003e  2238              MOVS     r2,#0x38
000040  4011              ANDS     r1,r1,r2
000042  4308              ORRS     r0,r0,r1
000044  9000              STR      r0,[sp,#0]
000046  210f              MOVS     r1,#0xf
000048  0189              LSLS     r1,r1,#6
00004a  9800              LDR      r0,[sp,#0]
00004c  4388              BICS     r0,r0,r1
00004e  9902              LDR      r1,[sp,#8]
000050  0189              LSLS     r1,r1,#6
000052  220f              MOVS     r2,#0xf
000054  0192              LSLS     r2,r2,#6
000056  4011              ANDS     r1,r1,r2
000058  4308              ORRS     r0,r0,r1
00005a  9000              STR      r0,[sp,#0]
00005c  9800              LDR      r0,[sp,#0]
00005e  0580              LSLS     r0,r0,#22
000060  0d80              LSRS     r0,r0,#22
000062  02a9              LSLS     r1,r5,#10
000064  0a89              LSRS     r1,r1,#10
000066  0289              LSLS     r1,r1,#10
000068  4308              ORRS     r0,r0,r1
00006a  9000              STR      r0,[sp,#0]
;;;489            m_log_data.buffer[wr_idx++ & mask] = header.raw;
00006c  9801              LDR      r0,[sp,#4]
00006e  1c41              ADDS     r1,r0,#1
000070  9a00              LDR      r2,[sp,#0]
000072  4038              ANDS     r0,r0,r7
000074  9101              STR      r1,[sp,#4]
000076  0081              LSLS     r1,r0,#2
000078  4805              LDR      r0,|L9.144|
00007a  300c              ADDS     r0,r0,#0xc
00007c  5042              STR      r2,[r0,r1]
;;;490    #if NRF_LOG_USES_TIMESTAMP
;;;491            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;492    #endif //NRF_LOG_USES_TIMESTAMP
;;;493            m_log_data.buffer[wr_idx & mask] = val0;
00007e  9801              LDR      r0,[sp,#4]
000080  4038              ANDS     r0,r0,r7
000082  0081              LSLS     r1,r0,#2
000084  4802              LDR      r0,|L9.144|
000086  300c              ADDS     r0,r0,#0xc
000088  5046              STR      r6,[r0,r1]
;;;494        }
00008a  bf00              NOP      
                  |L9.140|
;;;495    #endif //(NRF_LOG_DEFERRED == 0)
;;;496    }
00008c  bdfe              POP      {r1-r7,pc}
;;;497    
                          ENDP

00008e  0000              DCW      0x0000
                  |L9.144|
                          DCD      m_log_data
                  |L9.148|
                          DCD      ||.constdata||+0x8

                          AREA ||i.nrf_log_frontend_std_2||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_std_2 PROC
;;;498    
;;;499    void nrf_log_frontend_std_2(uint8_t            severity,
000000  b5ff              PUSH     {r0-r7,lr}
;;;500                                char const * const p_str,
;;;501                                uint32_t           val0,
;;;502                                uint32_t           val1)
;;;503    {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;504    #if (NRF_LOG_DEFERRED == 0)
;;;505        uint32_t args[] = {val0, val1};
;;;506        nrf_log_direct_feed(severity, p_str, args, ARRAY_SIZE(args));
;;;507    #else //(NRF_LOG_DEFERRED == 0)
;;;508        uint32_t nargs  = 2;
00000a  2002              MOVS     r0,#2
00000c  9002              STR      r0,[sp,#8]
;;;509        uint32_t mask   = m_log_data.mask;
00000e  4825              LDR      r0,|L10.164|
000010  6885              LDR      r5,[r0,#8]  ; m_log_data
;;;510        uint32_t wr_idx;
;;;511        if (buf_prealloc(nargs, &wr_idx))
000012  a901              ADD      r1,sp,#4
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       buf_prealloc
00001a  2800              CMP      r0,#0
00001c  d040              BEQ      |L10.160|
;;;512        {
;;;513            // Proceed only if buffer was successfully preallocated.
;;;514            STD_HEADER_DEF(header, p_str, severity, nargs);
00001e  4822              LDR      r0,|L10.168|
000020  6800              LDR      r0,[r0,#0]  ; <Data4>
000022  9000              STR      r0,[sp,#0]
000024  2104              MOVS     r1,#4
000026  9800              LDR      r0,[sp,#0]
000028  4388              BICS     r0,r0,r1
00002a  2110              MOVS     r1,#0x10
00002c  4021              ANDS     r1,r1,r4
00002e  0089              LSLS     r1,r1,#2
000030  2204              MOVS     r2,#4
000032  4011              ANDS     r1,r1,r2
000034  4308              ORRS     r0,r0,r1
000036  9000              STR      r0,[sp,#0]
000038  2138              MOVS     r1,#0x38
00003a  9800              LDR      r0,[sp,#0]
00003c  4388              BICS     r0,r0,r1
00003e  00e1              LSLS     r1,r4,#3
000040  2238              MOVS     r2,#0x38
000042  4011              ANDS     r1,r1,r2
000044  4308              ORRS     r0,r0,r1
000046  9000              STR      r0,[sp,#0]
000048  210f              MOVS     r1,#0xf
00004a  0189              LSLS     r1,r1,#6
00004c  9800              LDR      r0,[sp,#0]
00004e  4388              BICS     r0,r0,r1
000050  9902              LDR      r1,[sp,#8]
000052  0189              LSLS     r1,r1,#6
000054  220f              MOVS     r2,#0xf
000056  0192              LSLS     r2,r2,#6
000058  4011              ANDS     r1,r1,r2
00005a  4308              ORRS     r0,r0,r1
00005c  9000              STR      r0,[sp,#0]
00005e  9800              LDR      r0,[sp,#0]
000060  0580              LSLS     r0,r0,#22
000062  0d80              LSRS     r0,r0,#22
000064  9904              LDR      r1,[sp,#0x10]
000066  0289              LSLS     r1,r1,#10
000068  0a89              LSRS     r1,r1,#10
00006a  0289              LSLS     r1,r1,#10
00006c  4308              ORRS     r0,r0,r1
00006e  9000              STR      r0,[sp,#0]
;;;515            m_log_data.buffer[wr_idx++ & mask] = header.raw;
000070  9901              LDR      r1,[sp,#4]
000072  1c48              ADDS     r0,r1,#1
000074  9a00              LDR      r2,[sp,#0]
000076  4029              ANDS     r1,r1,r5
000078  0089              LSLS     r1,r1,#2
00007a  9001              STR      r0,[sp,#4]
00007c  4809              LDR      r0,|L10.164|
00007e  300c              ADDS     r0,r0,#0xc
000080  5042              STR      r2,[r0,r1]
;;;516    #if NRF_LOG_USES_TIMESTAMP
;;;517            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;518    #endif //NRF_LOG_USES_TIMESTAMP
;;;519            m_log_data.buffer[wr_idx++ & mask] = val0;
000082  9801              LDR      r0,[sp,#4]
000084  1c41              ADDS     r1,r0,#1
000086  4028              ANDS     r0,r0,r5
000088  9101              STR      r1,[sp,#4]
00008a  0081              LSLS     r1,r0,#2
00008c  4805              LDR      r0,|L10.164|
00008e  300c              ADDS     r0,r0,#0xc
000090  5046              STR      r6,[r0,r1]
;;;520            m_log_data.buffer[wr_idx & mask]   = val1;
000092  9801              LDR      r0,[sp,#4]
000094  4028              ANDS     r0,r0,r5
000096  0081              LSLS     r1,r0,#2
000098  4802              LDR      r0,|L10.164|
00009a  300c              ADDS     r0,r0,#0xc
00009c  5047              STR      r7,[r0,r1]
;;;521        }
00009e  bf00              NOP      
                  |L10.160|
;;;522    #endif //(NRF_LOG_DEFERRED == 0)
;;;523    }
0000a0  b007              ADD      sp,sp,#0x1c
0000a2  bdf0              POP      {r4-r7,pc}
;;;524    
                          ENDP

                  |L10.164|
                          DCD      m_log_data
                  |L10.168|
                          DCD      ||.constdata||+0xc

                          AREA ||i.nrf_log_frontend_std_3||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_std_3 PROC
;;;525    
;;;526    void nrf_log_frontend_std_3(uint8_t            severity,
000000  b5ff              PUSH     {r0-r7,lr}
;;;527                                char const * const p_str,
;;;528                                uint32_t           val0,
;;;529                                uint32_t           val1,
;;;530                                uint32_t           val2)
;;;531    {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;532    #if (NRF_LOG_DEFERRED == 0)
;;;533        uint32_t args[] = {val0, val1, val2};
;;;534        nrf_log_direct_feed(severity, p_str, args, ARRAY_SIZE(args));
;;;535    #else //(NRF_LOG_DEFERRED == 0)
;;;536        uint32_t nargs  = 3;
00000a  2003              MOVS     r0,#3
00000c  9002              STR      r0,[sp,#8]
;;;537        uint32_t mask   = m_log_data.mask;
00000e  482a              LDR      r0,|L11.184|
000010  6884              LDR      r4,[r0,#8]  ; m_log_data
;;;538        uint32_t wr_idx;
;;;539        if (buf_prealloc(nargs, &wr_idx))
000012  a901              ADD      r1,sp,#4
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       buf_prealloc
00001a  2800              CMP      r0,#0
00001c  d049              BEQ      |L11.178|
;;;540        {
;;;541            // Proceed only if buffer was successfully preallocated.
;;;542            STD_HEADER_DEF(header, p_str, severity, nargs);
00001e  4827              LDR      r0,|L11.188|
000020  6800              LDR      r0,[r0,#0]  ; <Data5>
000022  9000              STR      r0,[sp,#0]
000024  2104              MOVS     r1,#4
000026  9800              LDR      r0,[sp,#0]
000028  4388              BICS     r0,r0,r1
00002a  2110              MOVS     r1,#0x10
00002c  4029              ANDS     r1,r1,r5
00002e  0089              LSLS     r1,r1,#2
000030  2204              MOVS     r2,#4
000032  4011              ANDS     r1,r1,r2
000034  4308              ORRS     r0,r0,r1
000036  9000              STR      r0,[sp,#0]
000038  2138              MOVS     r1,#0x38
00003a  9800              LDR      r0,[sp,#0]
00003c  4388              BICS     r0,r0,r1
00003e  00e9              LSLS     r1,r5,#3
000040  2238              MOVS     r2,#0x38
000042  4011              ANDS     r1,r1,r2
000044  4308              ORRS     r0,r0,r1
000046  9000              STR      r0,[sp,#0]
000048  210f              MOVS     r1,#0xf
00004a  0189              LSLS     r1,r1,#6
00004c  9800              LDR      r0,[sp,#0]
00004e  4388              BICS     r0,r0,r1
000050  9902              LDR      r1,[sp,#8]
000052  0189              LSLS     r1,r1,#6
000054  220f              MOVS     r2,#0xf
000056  0192              LSLS     r2,r2,#6
000058  4011              ANDS     r1,r1,r2
00005a  4308              ORRS     r0,r0,r1
00005c  9000              STR      r0,[sp,#0]
00005e  9800              LDR      r0,[sp,#0]
000060  0580              LSLS     r0,r0,#22
000062  0d80              LSRS     r0,r0,#22
000064  9904              LDR      r1,[sp,#0x10]
000066  0289              LSLS     r1,r1,#10
000068  0a89              LSRS     r1,r1,#10
00006a  0289              LSLS     r1,r1,#10
00006c  4308              ORRS     r0,r0,r1
00006e  9000              STR      r0,[sp,#0]
;;;543            m_log_data.buffer[wr_idx++ & mask] = header.raw;
000070  9801              LDR      r0,[sp,#4]
000072  1c41              ADDS     r1,r0,#1
000074  9a00              LDR      r2,[sp,#0]
000076  4020              ANDS     r0,r0,r4
000078  9101              STR      r1,[sp,#4]
00007a  0081              LSLS     r1,r0,#2
00007c  480e              LDR      r0,|L11.184|
00007e  300c              ADDS     r0,r0,#0xc
000080  5042              STR      r2,[r0,r1]
;;;544    #if NRF_LOG_USES_TIMESTAMP
;;;545            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;546    #endif //NRF_LOG_USES_TIMESTAMP
;;;547            m_log_data.buffer[wr_idx++ & mask] = val0;
000082  9801              LDR      r0,[sp,#4]
000084  1c41              ADDS     r1,r0,#1
000086  4020              ANDS     r0,r0,r4
000088  9101              STR      r1,[sp,#4]
00008a  0081              LSLS     r1,r0,#2
00008c  480a              LDR      r0,|L11.184|
00008e  300c              ADDS     r0,r0,#0xc
000090  5046              STR      r6,[r0,r1]
;;;548            m_log_data.buffer[wr_idx++ & mask] = val1;
000092  9801              LDR      r0,[sp,#4]
000094  1c41              ADDS     r1,r0,#1
000096  4020              ANDS     r0,r0,r4
000098  9101              STR      r1,[sp,#4]
00009a  0081              LSLS     r1,r0,#2
00009c  4806              LDR      r0,|L11.184|
00009e  300c              ADDS     r0,r0,#0xc
0000a0  5047              STR      r7,[r0,r1]
;;;549            m_log_data.buffer[wr_idx & mask]   = val2;
0000a2  9901              LDR      r1,[sp,#4]
0000a4  4021              ANDS     r1,r1,r4
0000a6  008a              LSLS     r2,r1,#2
0000a8  4903              LDR      r1,|L11.184|
0000aa  310c              ADDS     r1,r1,#0xc
0000ac  980c              LDR      r0,[sp,#0x30]
0000ae  5088              STR      r0,[r1,r2]
;;;550        }
0000b0  bf00              NOP      
                  |L11.178|
;;;551    #endif //(NRF_LOG_DEFERRED == 0)
;;;552    }
0000b2  b007              ADD      sp,sp,#0x1c
0000b4  bdf0              POP      {r4-r7,pc}
;;;553    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L11.184|
                          DCD      m_log_data
                  |L11.188|
                          DCD      ||.constdata||+0x10

                          AREA ||i.nrf_log_frontend_std_4||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_std_4 PROC
;;;554    
;;;555    void nrf_log_frontend_std_4(uint8_t            severity,
000000  b5ff              PUSH     {r0-r7,lr}
;;;556                                char const * const p_str,
;;;557                                uint32_t           val0,
;;;558                                uint32_t           val1,
;;;559                                uint32_t           val2,
;;;560                                uint32_t           val3)
;;;561    {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;562    #if (NRF_LOG_DEFERRED == 0)
;;;563        uint32_t args[] = {val0, val1, val2, val3};
;;;564        nrf_log_direct_feed(severity, p_str, args, ARRAY_SIZE(args));
;;;565    #else //(NRF_LOG_DEFERRED == 0)
;;;566        uint32_t nargs  = 4;
00000a  2004              MOVS     r0,#4
00000c  9002              STR      r0,[sp,#8]
;;;567        uint32_t mask   = m_log_data.mask;
00000e  482e              LDR      r0,|L12.200|
000010  6884              LDR      r4,[r0,#8]  ; m_log_data
;;;568        uint32_t wr_idx;
;;;569        if (buf_prealloc(nargs, &wr_idx))
000012  a901              ADD      r1,sp,#4
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       buf_prealloc
00001a  2800              CMP      r0,#0
00001c  d052              BEQ      |L12.196|
;;;570        {
;;;571            // Proceed only if buffer was successfully preallocated.
;;;572            STD_HEADER_DEF(header, p_str, severity, nargs);
00001e  482b              LDR      r0,|L12.204|
000020  6800              LDR      r0,[r0,#0]  ; <Data6>
000022  9000              STR      r0,[sp,#0]
000024  2104              MOVS     r1,#4
000026  9800              LDR      r0,[sp,#0]
000028  4388              BICS     r0,r0,r1
00002a  2110              MOVS     r1,#0x10
00002c  4029              ANDS     r1,r1,r5
00002e  0089              LSLS     r1,r1,#2
000030  2204              MOVS     r2,#4
000032  4011              ANDS     r1,r1,r2
000034  4308              ORRS     r0,r0,r1
000036  9000              STR      r0,[sp,#0]
000038  2138              MOVS     r1,#0x38
00003a  9800              LDR      r0,[sp,#0]
00003c  4388              BICS     r0,r0,r1
00003e  00e9              LSLS     r1,r5,#3
000040  2238              MOVS     r2,#0x38
000042  4011              ANDS     r1,r1,r2
000044  4308              ORRS     r0,r0,r1
000046  9000              STR      r0,[sp,#0]
000048  210f              MOVS     r1,#0xf
00004a  0189              LSLS     r1,r1,#6
00004c  9800              LDR      r0,[sp,#0]
00004e  4388              BICS     r0,r0,r1
000050  9902              LDR      r1,[sp,#8]
000052  0189              LSLS     r1,r1,#6
000054  220f              MOVS     r2,#0xf
000056  0192              LSLS     r2,r2,#6
000058  4011              ANDS     r1,r1,r2
00005a  4308              ORRS     r0,r0,r1
00005c  9000              STR      r0,[sp,#0]
00005e  9800              LDR      r0,[sp,#0]
000060  0580              LSLS     r0,r0,#22
000062  0d80              LSRS     r0,r0,#22
000064  9904              LDR      r1,[sp,#0x10]
000066  0289              LSLS     r1,r1,#10
000068  0a89              LSRS     r1,r1,#10
00006a  0289              LSLS     r1,r1,#10
00006c  4308              ORRS     r0,r0,r1
00006e  9000              STR      r0,[sp,#0]
;;;573            m_log_data.buffer[wr_idx++ & mask] = header.raw;
000070  9901              LDR      r1,[sp,#4]
000072  1c48              ADDS     r0,r1,#1
000074  9a00              LDR      r2,[sp,#0]
000076  4021              ANDS     r1,r1,r4
000078  0089              LSLS     r1,r1,#2
00007a  9001              STR      r0,[sp,#4]
00007c  4812              LDR      r0,|L12.200|
00007e  300c              ADDS     r0,r0,#0xc
000080  5042              STR      r2,[r0,r1]
;;;574    #if NRF_LOG_USES_TIMESTAMP
;;;575            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;576    #endif //NRF_LOG_USES_TIMESTAMP
;;;577            m_log_data.buffer[wr_idx++ & mask] = val0;
000082  9801              LDR      r0,[sp,#4]
000084  1c41              ADDS     r1,r0,#1
000086  4020              ANDS     r0,r0,r4
000088  9101              STR      r1,[sp,#4]
00008a  0081              LSLS     r1,r0,#2
00008c  480e              LDR      r0,|L12.200|
00008e  300c              ADDS     r0,r0,#0xc
000090  5046              STR      r6,[r0,r1]
;;;578            m_log_data.buffer[wr_idx++ & mask] = val1;
000092  9801              LDR      r0,[sp,#4]
000094  1c41              ADDS     r1,r0,#1
000096  4020              ANDS     r0,r0,r4
000098  9101              STR      r1,[sp,#4]
00009a  0081              LSLS     r1,r0,#2
00009c  480a              LDR      r0,|L12.200|
00009e  300c              ADDS     r0,r0,#0xc
0000a0  5047              STR      r7,[r0,r1]
;;;579            m_log_data.buffer[wr_idx++ & mask] = val2;
0000a2  9901              LDR      r1,[sp,#4]
0000a4  1c4a              ADDS     r2,r1,#1
0000a6  980c              LDR      r0,[sp,#0x30]
0000a8  4021              ANDS     r1,r1,r4
0000aa  9201              STR      r2,[sp,#4]
0000ac  008a              LSLS     r2,r1,#2
0000ae  4906              LDR      r1,|L12.200|
0000b0  310c              ADDS     r1,r1,#0xc
0000b2  5088              STR      r0,[r1,r2]
;;;580            m_log_data.buffer[wr_idx & mask]   = val3;
0000b4  9901              LDR      r1,[sp,#4]
0000b6  4021              ANDS     r1,r1,r4
0000b8  008a              LSLS     r2,r1,#2
0000ba  4903              LDR      r1,|L12.200|
0000bc  310c              ADDS     r1,r1,#0xc
0000be  980d              LDR      r0,[sp,#0x34]
0000c0  5088              STR      r0,[r1,r2]
;;;581        }
0000c2  bf00              NOP      
                  |L12.196|
;;;582    #endif //(NRF_LOG_DEFERRED == 0)
;;;583    }
0000c4  b007              ADD      sp,sp,#0x1c
0000c6  bdf0              POP      {r4-r7,pc}
;;;584    
                          ENDP

                  |L12.200|
                          DCD      m_log_data
                  |L12.204|
                          DCD      ||.constdata||+0x14

                          AREA ||i.nrf_log_frontend_std_5||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_std_5 PROC
;;;585    
;;;586    void nrf_log_frontend_std_5(uint8_t            severity,
000000  b5ff              PUSH     {r0-r7,lr}
;;;587                                char const * const p_str,
;;;588                                uint32_t           val0,
;;;589                                uint32_t           val1,
;;;590                                uint32_t           val2,
;;;591                                uint32_t           val3,
;;;592                                uint32_t           val4)
;;;593    {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;594    #if (NRF_LOG_DEFERRED == 0)
;;;595        uint32_t args[] = {val0, val1, val2, val3, val4};
;;;596        nrf_log_direct_feed(severity, p_str, args, ARRAY_SIZE(args));
;;;597    #else //(NRF_LOG_DEFERRED == 0)
;;;598        uint32_t nargs  = 5;
00000a  2005              MOVS     r0,#5
00000c  9002              STR      r0,[sp,#8]
;;;599        uint32_t mask   = m_log_data.mask;
00000e  4833              LDR      r0,|L13.220|
000010  6884              LDR      r4,[r0,#8]  ; m_log_data
;;;600        uint32_t wr_idx;
;;;601        if (buf_prealloc(nargs, &wr_idx))
000012  a901              ADD      r1,sp,#4
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       buf_prealloc
00001a  2800              CMP      r0,#0
00001c  d05b              BEQ      |L13.214|
;;;602        {
;;;603            // Proceed only if buffer was successfully preallocated.
;;;604            STD_HEADER_DEF(header, p_str, severity, nargs);
00001e  4830              LDR      r0,|L13.224|
000020  6800              LDR      r0,[r0,#0]  ; <Data7>
000022  9000              STR      r0,[sp,#0]
000024  2104              MOVS     r1,#4
000026  9800              LDR      r0,[sp,#0]
000028  4388              BICS     r0,r0,r1
00002a  2110              MOVS     r1,#0x10
00002c  4029              ANDS     r1,r1,r5
00002e  0089              LSLS     r1,r1,#2
000030  2204              MOVS     r2,#4
000032  4011              ANDS     r1,r1,r2
000034  4308              ORRS     r0,r0,r1
000036  9000              STR      r0,[sp,#0]
000038  2138              MOVS     r1,#0x38
00003a  9800              LDR      r0,[sp,#0]
00003c  4388              BICS     r0,r0,r1
00003e  00e9              LSLS     r1,r5,#3
000040  2238              MOVS     r2,#0x38
000042  4011              ANDS     r1,r1,r2
000044  4308              ORRS     r0,r0,r1
000046  9000              STR      r0,[sp,#0]
000048  210f              MOVS     r1,#0xf
00004a  0189              LSLS     r1,r1,#6
00004c  9800              LDR      r0,[sp,#0]
00004e  4388              BICS     r0,r0,r1
000050  9902              LDR      r1,[sp,#8]
000052  0189              LSLS     r1,r1,#6
000054  220f              MOVS     r2,#0xf
000056  0192              LSLS     r2,r2,#6
000058  4011              ANDS     r1,r1,r2
00005a  4308              ORRS     r0,r0,r1
00005c  9000              STR      r0,[sp,#0]
00005e  9800              LDR      r0,[sp,#0]
000060  0580              LSLS     r0,r0,#22
000062  0d80              LSRS     r0,r0,#22
000064  9904              LDR      r1,[sp,#0x10]
000066  0289              LSLS     r1,r1,#10
000068  0a89              LSRS     r1,r1,#10
00006a  0289              LSLS     r1,r1,#10
00006c  4308              ORRS     r0,r0,r1
00006e  9000              STR      r0,[sp,#0]
;;;605            m_log_data.buffer[wr_idx++ & mask] = header.raw;
000070  9801              LDR      r0,[sp,#4]
000072  1c41              ADDS     r1,r0,#1
000074  9a00              LDR      r2,[sp,#0]
000076  4020              ANDS     r0,r0,r4
000078  9101              STR      r1,[sp,#4]
00007a  0081              LSLS     r1,r0,#2
00007c  4817              LDR      r0,|L13.220|
00007e  300c              ADDS     r0,r0,#0xc
000080  5042              STR      r2,[r0,r1]
;;;606    #if NRF_LOG_USES_TIMESTAMP
;;;607            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;608    #endif //NRF_LOG_USES_TIMESTAMP
;;;609            m_log_data.buffer[wr_idx++ & mask] = val0;
000082  9801              LDR      r0,[sp,#4]
000084  1c41              ADDS     r1,r0,#1
000086  4020              ANDS     r0,r0,r4
000088  9101              STR      r1,[sp,#4]
00008a  0081              LSLS     r1,r0,#2
00008c  4813              LDR      r0,|L13.220|
00008e  300c              ADDS     r0,r0,#0xc
000090  5046              STR      r6,[r0,r1]
;;;610            m_log_data.buffer[wr_idx++ & mask] = val1;
000092  9801              LDR      r0,[sp,#4]
000094  1c41              ADDS     r1,r0,#1
000096  4020              ANDS     r0,r0,r4
000098  9101              STR      r1,[sp,#4]
00009a  0081              LSLS     r1,r0,#2
00009c  480f              LDR      r0,|L13.220|
00009e  300c              ADDS     r0,r0,#0xc
0000a0  5047              STR      r7,[r0,r1]
;;;611            m_log_data.buffer[wr_idx++ & mask] = val2;
0000a2  9901              LDR      r1,[sp,#4]
0000a4  1c4a              ADDS     r2,r1,#1
0000a6  980c              LDR      r0,[sp,#0x30]
0000a8  4021              ANDS     r1,r1,r4
0000aa  9201              STR      r2,[sp,#4]
0000ac  008a              LSLS     r2,r1,#2
0000ae  490b              LDR      r1,|L13.220|
0000b0  310c              ADDS     r1,r1,#0xc
0000b2  5088              STR      r0,[r1,r2]
;;;612            m_log_data.buffer[wr_idx++ & mask] = val3;
0000b4  9901              LDR      r1,[sp,#4]
0000b6  1c4a              ADDS     r2,r1,#1
0000b8  980d              LDR      r0,[sp,#0x34]
0000ba  4021              ANDS     r1,r1,r4
0000bc  9201              STR      r2,[sp,#4]
0000be  008a              LSLS     r2,r1,#2
0000c0  4906              LDR      r1,|L13.220|
0000c2  310c              ADDS     r1,r1,#0xc
0000c4  5088              STR      r0,[r1,r2]
;;;613            m_log_data.buffer[wr_idx & mask]   = val4;
0000c6  9901              LDR      r1,[sp,#4]
0000c8  4021              ANDS     r1,r1,r4
0000ca  008a              LSLS     r2,r1,#2
0000cc  4903              LDR      r1,|L13.220|
0000ce  310c              ADDS     r1,r1,#0xc
0000d0  980e              LDR      r0,[sp,#0x38]
0000d2  5088              STR      r0,[r1,r2]
;;;614        }
0000d4  bf00              NOP      
                  |L13.214|
;;;615    #endif //(NRF_LOG_DEFERRED == 0)
;;;616    }
0000d6  b007              ADD      sp,sp,#0x1c
0000d8  bdf0              POP      {r4-r7,pc}
;;;617    
                          ENDP

0000da  0000              DCW      0x0000
                  |L13.220|
                          DCD      m_log_data
                  |L13.224|
                          DCD      ||.constdata||+0x18

                          AREA ||i.nrf_log_frontend_std_6||, CODE, READONLY, ALIGN=2

                  nrf_log_frontend_std_6 PROC
;;;618    
;;;619    void nrf_log_frontend_std_6(uint8_t            severity,
000000  b5ff              PUSH     {r0-r7,lr}
;;;620                                char const * const p_str,
;;;621                                uint32_t           val0,
;;;622                                uint32_t           val1,
;;;623                                uint32_t           val2,
;;;624                                uint32_t           val3,
;;;625                                uint32_t           val4,
;;;626                                uint32_t           val5)
;;;627    {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;628    #if (NRF_LOG_DEFERRED == 0)
;;;629        uint32_t args[] = {val0, val1, val2, val3, val4, val5};
;;;630        nrf_log_direct_feed(severity, p_str, args, ARRAY_SIZE(args));
;;;631    #else //(NRF_LOG_DEFERRED == 0)
;;;632        uint32_t nargs  = 6;
00000a  2006              MOVS     r0,#6
00000c  9002              STR      r0,[sp,#8]
;;;633        uint32_t mask   = m_log_data.mask;
00000e  4837              LDR      r0,|L14.236|
000010  6884              LDR      r4,[r0,#8]  ; m_log_data
;;;634        uint32_t wr_idx;
;;;635        if (buf_prealloc(nargs, &wr_idx))
000012  a901              ADD      r1,sp,#4
000014  9802              LDR      r0,[sp,#8]
000016  f7fffffe          BL       buf_prealloc
00001a  2800              CMP      r0,#0
00001c  d064              BEQ      |L14.232|
;;;636        {
;;;637            // Proceed only if buffer was successfully preallocated.
;;;638            STD_HEADER_DEF(header, p_str, severity, nargs);
00001e  4834              LDR      r0,|L14.240|
000020  6800              LDR      r0,[r0,#0]  ; <Data8>
000022  9000              STR      r0,[sp,#0]
000024  2104              MOVS     r1,#4
000026  9800              LDR      r0,[sp,#0]
000028  4388              BICS     r0,r0,r1
00002a  2110              MOVS     r1,#0x10
00002c  4029              ANDS     r1,r1,r5
00002e  0089              LSLS     r1,r1,#2
000030  2204              MOVS     r2,#4
000032  4011              ANDS     r1,r1,r2
000034  4308              ORRS     r0,r0,r1
000036  9000              STR      r0,[sp,#0]
000038  2138              MOVS     r1,#0x38
00003a  9800              LDR      r0,[sp,#0]
00003c  4388              BICS     r0,r0,r1
00003e  00e9              LSLS     r1,r5,#3
000040  2238              MOVS     r2,#0x38
000042  4011              ANDS     r1,r1,r2
000044  4308              ORRS     r0,r0,r1
000046  9000              STR      r0,[sp,#0]
000048  210f              MOVS     r1,#0xf
00004a  0189              LSLS     r1,r1,#6
00004c  9800              LDR      r0,[sp,#0]
00004e  4388              BICS     r0,r0,r1
000050  9902              LDR      r1,[sp,#8]
000052  0189              LSLS     r1,r1,#6
000054  220f              MOVS     r2,#0xf
000056  0192              LSLS     r2,r2,#6
000058  4011              ANDS     r1,r1,r2
00005a  4308              ORRS     r0,r0,r1
00005c  9000              STR      r0,[sp,#0]
00005e  9800              LDR      r0,[sp,#0]
000060  0580              LSLS     r0,r0,#22
000062  0d80              LSRS     r0,r0,#22
000064  9904              LDR      r1,[sp,#0x10]
000066  0289              LSLS     r1,r1,#10
000068  0a89              LSRS     r1,r1,#10
00006a  0289              LSLS     r1,r1,#10
00006c  4308              ORRS     r0,r0,r1
00006e  9000              STR      r0,[sp,#0]
;;;639            m_log_data.buffer[wr_idx++ & mask] = header.raw;
000070  9901              LDR      r1,[sp,#4]
000072  1c48              ADDS     r0,r1,#1
000074  9a00              LDR      r2,[sp,#0]
000076  4021              ANDS     r1,r1,r4
000078  0089              LSLS     r1,r1,#2
00007a  9001              STR      r0,[sp,#4]
00007c  481b              LDR      r0,|L14.236|
00007e  300c              ADDS     r0,r0,#0xc
000080  5042              STR      r2,[r0,r1]
;;;640    #if NRF_LOG_USES_TIMESTAMP
;;;641            m_log_data.buffer[wr_idx++ & mask] = m_log_data.timestamp_func();
;;;642    #endif //NRF_LOG_USES_TIMESTAMP
;;;643            m_log_data.buffer[wr_idx++ & mask] = val0;
000082  9801              LDR      r0,[sp,#4]
000084  1c41              ADDS     r1,r0,#1
000086  4020              ANDS     r0,r0,r4
000088  9101              STR      r1,[sp,#4]
00008a  0081              LSLS     r1,r0,#2
00008c  4817              LDR      r0,|L14.236|
00008e  300c              ADDS     r0,r0,#0xc
000090  5046              STR      r6,[r0,r1]
;;;644            m_log_data.buffer[wr_idx++ & mask] = val1;
000092  9801              LDR      r0,[sp,#4]
000094  1c41              ADDS     r1,r0,#1
000096  4020              ANDS     r0,r0,r4
000098  9101              STR      r1,[sp,#4]
00009a  0081              LSLS     r1,r0,#2
00009c  4813              LDR      r0,|L14.236|
00009e  300c              ADDS     r0,r0,#0xc
0000a0  5047              STR      r7,[r0,r1]
;;;645            m_log_data.buffer[wr_idx++ & mask] = val2;
0000a2  9901              LDR      r1,[sp,#4]
0000a4  1c4a              ADDS     r2,r1,#1
0000a6  980c              LDR      r0,[sp,#0x30]
0000a8  4021              ANDS     r1,r1,r4
0000aa  9201              STR      r2,[sp,#4]
0000ac  008a              LSLS     r2,r1,#2
0000ae  490f              LDR      r1,|L14.236|
0000b0  310c              ADDS     r1,r1,#0xc
0000b2  5088              STR      r0,[r1,r2]
;;;646            m_log_data.buffer[wr_idx++ & mask] = val3;
0000b4  9901              LDR      r1,[sp,#4]
0000b6  1c4a              ADDS     r2,r1,#1
0000b8  980d              LDR      r0,[sp,#0x34]
0000ba  4021              ANDS     r1,r1,r4
0000bc  9201              STR      r2,[sp,#4]
0000be  008a              LSLS     r2,r1,#2
0000c0  490a              LDR      r1,|L14.236|
0000c2  310c              ADDS     r1,r1,#0xc
0000c4  5088              STR      r0,[r1,r2]
;;;647            m_log_data.buffer[wr_idx++ & mask] = val4;
0000c6  9801              LDR      r0,[sp,#4]
0000c8  1c42              ADDS     r2,r0,#1
0000ca  990e              LDR      r1,[sp,#0x38]
0000cc  4020              ANDS     r0,r0,r4
0000ce  9201              STR      r2,[sp,#4]
0000d0  0082              LSLS     r2,r0,#2
0000d2  4806              LDR      r0,|L14.236|
0000d4  300c              ADDS     r0,r0,#0xc
0000d6  5081              STR      r1,[r0,r2]
;;;648            m_log_data.buffer[wr_idx & mask]   = val5;
0000d8  9801              LDR      r0,[sp,#4]
0000da  4020              ANDS     r0,r0,r4
0000dc  0082              LSLS     r2,r0,#2
0000de  4803              LDR      r0,|L14.236|
0000e0  300c              ADDS     r0,r0,#0xc
0000e2  990f              LDR      r1,[sp,#0x3c]
0000e4  5081              STR      r1,[r0,r2]
;;;649        }
0000e6  bf00              NOP      
                  |L14.232|
;;;650    #endif //(NRF_LOG_DEFERRED == 0)
;;;651    }
0000e8  b007              ADD      sp,sp,#0x1c
0000ea  bdf0              POP      {r4-r7,pc}
;;;652    
                          ENDP

                  |L14.236|
                          DCD      m_log_data
                  |L14.240|
                          DCD      ||.constdata||+0x1c

                          AREA ||i.nrf_log_getchar||, CODE, READONLY, ALIGN=1

                  nrf_log_getchar PROC
;;;820    
;;;821    uint8_t nrf_log_getchar(void)
000000  b510              PUSH     {r4,lr}
;;;822    {
;;;823        return nrf_log_backend_getchar();
000002  f7fffffe          BL       nrf_log_backend_getchar
;;;824    }
000006  bd10              POP      {r4,pc}
;;;825    
                          ENDP


                          AREA ||i.nrf_log_handlers_set||, CODE, READONLY, ALIGN=2

                  nrf_log_handlers_set PROC
;;;302    
;;;303    void nrf_log_handlers_set(nrf_log_std_handler_t     std_handler,
000000  4a01              LDR      r2,|L16.8|
;;;304                              nrf_log_hexdump_handler_t hexdump_handler)
;;;305    {
;;;306        m_log_data.std_handler     = std_handler;
000002  6110              STR      r0,[r2,#0x10]  ; m_log_data
;;;307        m_log_data.hexdump_handler = hexdump_handler;
000004  6151              STR      r1,[r2,#0x14]  ; m_log_data
;;;308    }
000006  4770              BX       lr
;;;309    
                          ENDP

                  |L16.8|
                          DCD      m_log_data+0x400

                          AREA ||i.nrf_log_init||, CODE, READONLY, ALIGN=1

                  nrf_log_init PROC
;;;260    
;;;261    ret_code_t nrf_log_init(nrf_log_timestamp_func_t timestamp_func)
000000  b5f8              PUSH     {r3-r7,lr}
;;;262    {
000002  4605              MOV      r5,r0
;;;263        if (NRF_LOG_USES_TIMESTAMP && (timestamp_func == NULL))
000004  bf00              NOP      
;;;264        {
;;;265            return NRF_ERROR_INVALID_PARAM;
;;;266        }
;;;267    
;;;268        ret_code_t err_code = nrf_log_backend_init(NRF_LOG_DEFERRED ? false : true);
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       nrf_log_backend_init
00000c  4604              MOV      r4,r0
;;;269    
;;;270        if (err_code == NRF_SUCCESS)
00000e  2c00              CMP      r4,#0
000010  d109              BNE      |L17.38|
;;;271        {
;;;272            nrf_log_frontend_init(nrf_log_backend_std_handler_get(),
000012  f7fffffe          BL       nrf_log_backend_hexdump_handler_get
000016  4606              MOV      r6,r0
000018  f7fffffe          BL       nrf_log_backend_std_handler_get
00001c  4607              MOV      r7,r0
00001e  462a              MOV      r2,r5
000020  4631              MOV      r1,r6
000022  f7fffffe          BL       nrf_log_frontend_init
                  |L17.38|
;;;273                                  nrf_log_backend_hexdump_handler_get(),
;;;274                                  timestamp_func);
;;;275        }
;;;276        return err_code;
000026  4620              MOV      r0,r4
;;;277    }
000028  bdf8              POP      {r3-r7,pc}
;;;278    
                          ENDP


                          AREA ||i.nrf_log_push||, CODE, READONLY, ALIGN=2

                  nrf_log_push PROC
;;;430    
;;;431    uint32_t nrf_log_push(char * const p_str)
000000  b5f0              PUSH     {r4-r7,lr}
;;;432    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;433    #if (NRF_LOG_DEFERRED == 0)
;;;434        return (uint32_t)p_str;
;;;435    #else //(NRF_LOG_DEFERRED == 0)
;;;436        uint32_t mask      = m_log_data.mask;
000006  481d              LDR      r0,|L18.124|
000008  6880              LDR      r0,[r0,#8]  ; m_log_data
00000a  9003              STR      r0,[sp,#0xc]
;;;437        uint32_t slen      = strlen(p_str) + 1;
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       strlen
000012  1c45              ADDS     r5,r0,#1
;;;438        uint32_t buflen    = CEIL_DIV(slen, 4);
000014  1ce8              ADDS     r0,r5,#3
000016  0886              LSRS     r6,r0,#2
;;;439        uint32_t offset    = 0;
000018  2000              MOVS     r0,#0
00001a  9002              STR      r0,[sp,#8]
;;;440        uint32_t wr_idx;
;;;441        char   * p_dst_str = (char *)cont_buf_prealloc(buflen, &offset, &wr_idx);
00001c  aa01              ADD      r2,sp,#4
00001e  a902              ADD      r1,sp,#8
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       cont_buf_prealloc
000026  4607              MOV      r7,r0
;;;442        if (p_dst_str)
000028  2f00              CMP      r7,#0
00002a  d023              BEQ      |L18.116|
;;;443        {
;;;444            PUSHED_HEADER_DEF(header, offset, buflen);
00002c  2000              MOVS     r0,#0
00002e  9000              STR      r0,[sp,#0]
000030  4913              LDR      r1,|L18.128|
000032  9800              LDR      r0,[sp,#0]
000034  4008              ANDS     r0,r0,r1
000036  9902              LDR      r1,[sp,#8]
000038  0189              LSLS     r1,r1,#6
00003a  4a11              LDR      r2,|L18.128|
00003c  43d2              MVNS     r2,r2
00003e  4011              ANDS     r1,r1,r2
000040  4308              ORRS     r0,r0,r1
000042  9000              STR      r0,[sp,#0]
000044  9800              LDR      r0,[sp,#0]
000046  0280              LSLS     r0,r0,#10
000048  0a80              LSRS     r0,r0,#10
00004a  05b1              LSLS     r1,r6,#22
00004c  0d89              LSRS     r1,r1,#22
00004e  0589              LSLS     r1,r1,#22
000050  4308              ORRS     r0,r0,r1
000052  9000              STR      r0,[sp,#0]
;;;445            m_log_data.buffer[wr_idx++ & mask] = header.raw;
000054  9801              LDR      r0,[sp,#4]
000056  1c41              ADDS     r1,r0,#1
000058  9a00              LDR      r2,[sp,#0]
00005a  9101              STR      r1,[sp,#4]
00005c  9903              LDR      r1,[sp,#0xc]
00005e  4008              ANDS     r0,r0,r1
000060  0081              LSLS     r1,r0,#2
000062  4806              LDR      r0,|L18.124|
000064  300c              ADDS     r0,r0,#0xc
000066  5042              STR      r2,[r0,r1]
;;;446            memcpy(p_dst_str, p_str, slen);
000068  462a              MOV      r2,r5
00006a  4621              MOV      r1,r4
00006c  4638              MOV      r0,r7
00006e  f7fffffe          BL       __aeabi_memcpy
;;;447        }
000072  bf00              NOP      
                  |L18.116|
;;;448        return (uint32_t)p_dst_str;
000074  4638              MOV      r0,r7
;;;449    #endif //(NRF_LOG_DEFERRED == 0)
;;;450    }
000076  b005              ADD      sp,sp,#0x14
000078  bdf0              POP      {r4-r7,pc}
;;;451    
                          ENDP

00007a  0000              DCW      0x0000
                  |L18.124|
                          DCD      m_log_data
                  |L18.128|
                          DCD      0xffff003f

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_log_data
                          %        1048

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  29000000          DCB      0x29,0x00,0x00,0x00
000004  01000000          DCB      0x01,0x00,0x00,0x00
000008  01000000          DCB      0x01,0x00,0x00,0x00
00000c  01000000          DCB      0x01,0x00,0x00,0x00
000010  01000000          DCB      0x01,0x00,0x00,0x00
000014  01000000          DCB      0x01,0x00,0x00,0x00
000018  01000000          DCB      0x01,0x00,0x00,0x00
00001c  01000000          DCB      0x01,0x00,0x00,0x00
000020  02000000          DCB      0x02,0x00,0x00,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  1b5b313b          DCB      27,"[1;31mOverflow\r\n",0
000004  33316d4f
000008  76657266
00000c  6c6f770d
000010  0a00    

                          AREA ||.data||, DATA, ALIGN=2

                  m_overflow_info
                          DCD      ||.conststring||

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\log\\src\\nrf_log_frontend.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_dfd2bdb3____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_nrf_log_frontend_c_dfd2bdb3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_nrf_log_frontend_c_dfd2bdb3____REVSH|
#line 144
|__asm___18_nrf_log_frontend_c_dfd2bdb3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
