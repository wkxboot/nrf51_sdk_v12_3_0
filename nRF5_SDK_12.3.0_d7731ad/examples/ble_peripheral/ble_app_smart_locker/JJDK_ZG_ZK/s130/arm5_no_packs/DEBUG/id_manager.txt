; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\id_manager.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\id_manager.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\id_manager.crf ..\..\..\..\..\..\components\ble\peer_manager\id_manager.c]
                          THUMB

                          AREA ||i.addr_compare||, CODE, READONLY, ALIGN=1

                  addr_compare PROC
;;;234     */
;;;235    bool addr_compare(ble_gap_addr_t const * p_addr1, ble_gap_addr_t const * p_addr2)
000000  b570              PUSH     {r4-r6,lr}
;;;236    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;237        // @note emdi: use NRF_PM_DEBUG_CHECK ?
;;;238        if ((p_addr1 == NULL) || (p_addr2 == NULL))
000006  2d00              CMP      r5,#0
000008  d001              BEQ      |L1.14|
00000a  2c00              CMP      r4,#0
00000c  d101              BNE      |L1.18|
                  |L1.14|
;;;239        {
;;;240            return false;
00000e  2000              MOVS     r0,#0
                  |L1.16|
;;;241        }
;;;242    
;;;243        // Check that the addr type is identical, return false if it is not
;;;244        if (p_addr1->addr_type != p_addr2->addr_type)
;;;245        {
;;;246            return false;
;;;247        }
;;;248        // Check if the addr bytes are is identical
;;;249        return (memcmp(p_addr1->addr, p_addr2->addr, BLE_GAP_ADDR_LEN) == 0);
;;;250    }
000010  bd70              POP      {r4-r6,pc}
                  |L1.18|
000012  7828              LDRB     r0,[r5,#0]            ;244
000014  7821              LDRB     r1,[r4,#0]            ;244
000016  4288              CMP      r0,r1                 ;244
000018  d001              BEQ      |L1.30|
00001a  2000              MOVS     r0,#0                 ;246
00001c  e7f8              B        |L1.16|
                  |L1.30|
00001e  2206              MOVS     r2,#6                 ;249
000020  1c61              ADDS     r1,r4,#1              ;249
000022  1c68              ADDS     r0,r5,#1              ;249
000024  f7fffffe          BL       memcmp
000028  2800              CMP      r0,#0                 ;249
00002a  d101              BNE      |L1.48|
00002c  2001              MOVS     r0,#1                 ;249
00002e  e7ef              B        |L1.16|
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;249
000032  e7ed              B        |L1.16|
;;;251    
                          ENDP


                          AREA ||i.address_set_v2||, CODE, READONLY, ALIGN=2

                  address_set_v2 PROC
;;;763    
;;;764    static ret_code_t address_set_v2(uint8_t cycle_mode, ble_gap_addr_t * p_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;765    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;766        NRF_PM_DEBUG_CHECK(p_addr != NULL);
;;;767    
;;;768        ret_code_t ret = sd_ble_gap_address_set(cycle_mode, p_addr);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  df70              SVC      #0x70
00000c  4604              MOV      r4,r0
;;;769    
;;;770        switch (ret)
00000e  2c08              CMP      r4,#8
000010  d00e              BEQ      |L2.48|
000012  dc04              BGT      |L2.30|
000014  2c00              CMP      r4,#0
000016  d009              BEQ      |L2.44|
000018  2c07              CMP      r4,#7
00001a  d10d              BNE      |L2.56|
00001c  e009              B        |L2.50|
                  |L2.30|
00001e  2c11              CMP      r4,#0x11
000020  d005              BEQ      |L2.46|
000022  4806              LDR      r0,|L2.60|
000024  1820              ADDS     r0,r4,r0
000026  2800              CMP      r0,#0
000028  d106              BNE      |L2.56|
00002a  e003              B        |L2.52|
                  |L2.44|
;;;771        {
;;;772            case NRF_SUCCESS:
;;;773            case NRF_ERROR_BUSY:
00002c  bf00              NOP      
                  |L2.46|
;;;774            case NRF_ERROR_INVALID_STATE:
00002e  bf00              NOP      
                  |L2.48|
;;;775            case NRF_ERROR_INVALID_PARAM:           // If cycle_mode is not AUTO or NONE.
000030  bf00              NOP      
                  |L2.50|
;;;776            case BLE_ERROR_GAP_INVALID_BLE_ADDR:    // If the GAP address is not valid.
000032  bf00              NOP      
                  |L2.52|
;;;777                return ret;
000034  4620              MOV      r0,r4
                  |L2.54|
;;;778    
;;;779            default:
;;;780                return NRF_ERROR_INTERNAL;
;;;781        }
;;;782    }
000036  bd70              POP      {r4-r6,pc}
                  |L2.56|
000038  2003              MOVS     r0,#3                 ;780
00003a  e7fc              B        |L2.54|
;;;783    
                          ENDP

                  |L2.60|
                          DCD      0xffffcdfe

                          AREA ||i.ah||, CODE, READONLY, ALIGN=1

                  ||ah|| PROC
;;;1049    */
;;;1050   void ah(uint8_t const * p_k, uint8_t const * p_r, uint8_t * p_local_hash)
000000  b570              PUSH     {r4-r6,lr}
;;;1051   {
000002  b08c              SUB      sp,sp,#0x30
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;1052       nrf_ecb_hal_data_t ecb_hal_data;
;;;1053   
;;;1054       for (uint32_t i = 0; i < SOC_ECB_KEY_LENGTH; i++)
00000a  2000              MOVS     r0,#0
00000c  e005              B        |L3.26|
                  |L3.14|
;;;1055       {
;;;1056           ecb_hal_data.key[i] = p_k[SOC_ECB_KEY_LENGTH - 1 - i];
00000e  210f              MOVS     r1,#0xf
000010  1a09              SUBS     r1,r1,r0
000012  5c61              LDRB     r1,[r4,r1]
000014  466a              MOV      r2,sp
000016  5411              STRB     r1,[r2,r0]
000018  1c40              ADDS     r0,r0,#1              ;1054
                  |L3.26|
00001a  2810              CMP      r0,#0x10              ;1054
00001c  d3f7              BCC      |L3.14|
;;;1057       }
;;;1058   
;;;1059       memset(ecb_hal_data.cleartext, 0, SOC_ECB_KEY_LENGTH - IM_ADDR_CLEARTEXT_LENGTH);
00001e  210d              MOVS     r1,#0xd
000020  a804              ADD      r0,sp,#0x10
000022  f7fffffe          BL       __aeabi_memclr4
;;;1060   
;;;1061       for (uint32_t i = 0; i < IM_ADDR_CLEARTEXT_LENGTH; i++)
000026  2000              MOVS     r0,#0
000028  e005              B        |L3.54|
                  |L3.42|
;;;1062       {
;;;1063           ecb_hal_data.cleartext[SOC_ECB_KEY_LENGTH - 1 - i] = p_r[i];
00002a  5c2a              LDRB     r2,[r5,r0]
00002c  210f              MOVS     r1,#0xf
00002e  1a0b              SUBS     r3,r1,r0
000030  a904              ADD      r1,sp,#0x10
000032  54ca              STRB     r2,[r1,r3]
000034  1c40              ADDS     r0,r0,#1              ;1061
                  |L3.54|
000036  2803              CMP      r0,#3                 ;1061
000038  d3f7              BCC      |L3.42|
;;;1064       }
;;;1065   
;;;1066       // Can only return NRF_SUCCESS.
;;;1067       (void) sd_ecb_block_encrypt(&ecb_hal_data);
00003a  4668              MOV      r0,sp
00003c  df4d              SVC      #0x4d
;;;1068   
;;;1069       for (uint32_t i = 0; i < IM_ADDR_CIPHERTEXT_LENGTH; i++)
00003e  2000              MOVS     r0,#0
000040  e005              B        |L3.78|
                  |L3.66|
;;;1070       {
;;;1071           p_local_hash[i] = ecb_hal_data.ciphertext[SOC_ECB_KEY_LENGTH - 1 - i];
000042  210f              MOVS     r1,#0xf
000044  1a0a              SUBS     r2,r1,r0
000046  a908              ADD      r1,sp,#0x20
000048  5c89              LDRB     r1,[r1,r2]
00004a  5431              STRB     r1,[r6,r0]
00004c  1c40              ADDS     r0,r0,#1              ;1069
                  |L3.78|
00004e  2803              CMP      r0,#3                 ;1069
000050  d3f7              BCC      |L3.66|
;;;1072       }
;;;1073   }
000052  b00c              ADD      sp,sp,#0x30
000054  bd70              POP      {r4-r6,pc}
;;;1074   
                          ENDP


                          AREA ||i.evt_send||, CODE, READONLY, ALIGN=2

                  evt_send PROC
;;;110     */
;;;111    static void evt_send(im_evt_t * p_event)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4605              MOV      r5,r0
;;;113        for (uint32_t i = 0; i < IM_EVENT_HANDLERS_CNT; i++)
000004  2400              MOVS     r4,#0
000006  e005              B        |L4.20|
                  |L4.8|
;;;114        {
;;;115            m_evt_handlers[i](p_event);
000008  00a0              LSLS     r0,r4,#2
00000a  4a04              LDR      r2,|L4.28|
00000c  5811              LDR      r1,[r2,r0]
00000e  4628              MOV      r0,r5
000010  4788              BLX      r1
000012  1c64              ADDS     r4,r4,#1              ;113
                  |L4.20|
000014  2c02              CMP      r4,#2                 ;113
000016  d3f7              BCC      |L4.8|
;;;116        }
;;;117    }
000018  bd70              POP      {r4-r6,pc}
;;;118    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      m_evt_handlers

                          AREA ||i.get_connection_by_conn_handle||, CODE, READONLY, ALIGN=2

                  get_connection_by_conn_handle PROC
;;;150     */
;;;151    uint8_t get_connection_by_conn_handle(uint16_t conn_handle)
000000  b510              PUSH     {r4,lr}
;;;152    {
000002  4604              MOV      r4,r0
;;;153        if (ble_conn_state_user_flag_get(conn_handle, m_conn_state_user_flag_id))
000004  480b              LDR      r0,|L5.52|
000006  7801              LDRB     r1,[r0,#0]  ; m_conn_state_user_flag_id
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       ble_conn_state_user_flag_get
00000e  2800              CMP      r0,#0
000010  d00d              BEQ      |L5.46|
;;;154        {
;;;155            for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000012  2100              MOVS     r1,#0
000014  e009              B        |L5.42|
                  |L5.22|
;;;156            {
;;;157                if (m_connections[i].conn_handle == conn_handle)
000016  200c              MOVS     r0,#0xc
000018  4348              MULS     r0,r1,r0
00001a  4a07              LDR      r2,|L5.56|
00001c  1880              ADDS     r0,r0,r2
00001e  8840              LDRH     r0,[r0,#2]
000020  42a0              CMP      r0,r4
000022  d101              BNE      |L5.40|
;;;158                {
;;;159                    return i;
000024  b2c8              UXTB     r0,r1
                  |L5.38|
;;;160                }
;;;161            }
;;;162        }
;;;163        // If all connection handles belong to a valid connection, return IM_NO_INVALID_CONN_HANDLES.
;;;164        return IM_NO_INVALID_CONN_HANDLES;
;;;165    }
000026  bd10              POP      {r4,pc}
                  |L5.40|
000028  1c49              ADDS     r1,r1,#1              ;155
                  |L5.42|
00002a  2908              CMP      r1,#8                 ;155
00002c  d3f3              BCC      |L5.22|
                  |L5.46|
00002e  20ff              MOVS     r0,#0xff              ;164
000030  e7f9              B        |L5.38|
;;;166    
                          ENDP

000032  0000              DCW      0x0000
                  |L5.52|
                          DCD      m_conn_state_user_flag_id
                  |L5.56|
                          DCD      m_connections

                          AREA ||i.get_free_connection||, CODE, READONLY, ALIGN=2

                  get_free_connection PROC
;;;127     */
;;;128    uint8_t get_free_connection()
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130        for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000002  2400              MOVS     r4,#0
000004  e00d              B        |L6.34|
                  |L6.6|
;;;131        {
;;;132            // Query the connection state module to check if the
;;;133            // connection handle does not belong to a valid connection.
;;;134            if (!ble_conn_state_user_flag_get(m_connections[i].conn_handle, m_conn_state_user_flag_id))
000006  210c              MOVS     r1,#0xc
000008  4361              MULS     r1,r4,r1
00000a  4a08              LDR      r2,|L6.44|
00000c  1889              ADDS     r1,r1,r2
00000e  8848              LDRH     r0,[r1,#2]
000010  4907              LDR      r1,|L6.48|
000012  7809              LDRB     r1,[r1,#0]  ; m_conn_state_user_flag_id
000014  f7fffffe          BL       ble_conn_state_user_flag_get
000018  2800              CMP      r0,#0
00001a  d101              BNE      |L6.32|
;;;135            {
;;;136                return i;
00001c  b2e0              UXTB     r0,r4
                  |L6.30|
;;;137            }
;;;138        }
;;;139        // If all connection handles belong to a valid connection, return IM_NO_INVALID_CONN_HANDLES.
;;;140        return IM_NO_INVALID_CONN_HANDLES;
;;;141    }
00001e  bd10              POP      {r4,pc}
                  |L6.32|
000020  1c64              ADDS     r4,r4,#1              ;130
                  |L6.34|
000022  2c08              CMP      r4,#8                 ;130
000024  d3ef              BCC      |L6.6|
000026  20ff              MOVS     r0,#0xff              ;140
000028  e7f9              B        |L6.30|
;;;142    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      m_connections
                  |L6.48|
                          DCD      m_conn_state_user_flag_id

                          AREA ||i.im_address_resolve||, CODE, READONLY, ALIGN=1

                  im_address_resolve PROC
;;;1075   
;;;1076   bool im_address_resolve(ble_gap_addr_t const * p_addr, ble_gap_irk_t const * p_irk)
000000  b53e              PUSH     {r1-r5,lr}
;;;1077   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1078       NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;1079   
;;;1080       uint8_t hash[IM_ADDR_CIPHERTEXT_LENGTH];
;;;1081       uint8_t local_hash[IM_ADDR_CIPHERTEXT_LENGTH];
;;;1082       uint8_t prand[IM_ADDR_CLEARTEXT_LENGTH];
;;;1083   
;;;1084       if (p_addr->addr_type != BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE)
000006  7820              LDRB     r0,[r4,#0]
000008  2802              CMP      r0,#2
00000a  d001              BEQ      |L7.16|
;;;1085       {
;;;1086           return false;
00000c  2000              MOVS     r0,#0
                  |L7.14|
;;;1087       }
;;;1088   
;;;1089       memcpy(hash, p_addr->addr, IM_ADDR_CIPHERTEXT_LENGTH);
;;;1090       memcpy(prand, &p_addr->addr[IM_ADDR_CIPHERTEXT_LENGTH], IM_ADDR_CLEARTEXT_LENGTH);
;;;1091       ah(p_irk->irk, prand, local_hash);
;;;1092   
;;;1093       return (memcmp(hash, local_hash, IM_ADDR_CIPHERTEXT_LENGTH) == 0);
;;;1094   }
00000e  bd3e              POP      {r1-r5,pc}
                  |L7.16|
000010  2203              MOVS     r2,#3                 ;1089
000012  1c61              ADDS     r1,r4,#1              ;1089
000014  a802              ADD      r0,sp,#8              ;1089
000016  f7fffffe          BL       __aeabi_memcpy
00001a  2203              MOVS     r2,#3                 ;1090
00001c  1d21              ADDS     r1,r4,#4              ;1090
00001e  4668              MOV      r0,sp                 ;1090
000020  f7fffffe          BL       __aeabi_memcpy
000024  aa01              ADD      r2,sp,#4              ;1091
000026  4669              MOV      r1,sp                 ;1091
000028  4628              MOV      r0,r5                 ;1091
00002a  f7fffffe          BL       ||ah||
00002e  2203              MOVS     r2,#3                 ;1093
000030  a901              ADD      r1,sp,#4              ;1093
000032  a802              ADD      r0,sp,#8              ;1093
000034  f7fffffe          BL       memcmp
000038  2800              CMP      r0,#0                 ;1093
00003a  d101              BNE      |L7.64|
00003c  2001              MOVS     r0,#1                 ;1093
00003e  e7e6              B        |L7.14|
                  |L7.64|
000040  2000              MOVS     r0,#0                 ;1093
000042  e7e4              B        |L7.14|
;;;1095   #endif // NRF_MODULE_ENABLED(PEER_MANAGER)
                          ENDP


                          AREA ||i.im_ble_addr_get||, CODE, READONLY, ALIGN=2

                  im_ble_addr_get PROC
;;;468    
;;;469    ret_code_t im_ble_addr_get(uint16_t conn_handle, ble_gap_addr_t * p_ble_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;470    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;471        uint8_t conn_index;
;;;472    
;;;473        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;474        NRF_PM_DEBUG_CHECK(p_ble_addr != NULL);
;;;475    
;;;476        conn_index = get_connection_by_conn_handle(conn_handle);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       get_connection_by_conn_handle
00000c  4605              MOV      r5,r0
;;;477    
;;;478        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000e  2dff              CMP      r5,#0xff
000010  d00a              BEQ      |L8.40|
;;;479        {
;;;480            *p_ble_addr = m_connections[conn_index].peer_address;
000012  200c              MOVS     r0,#0xc
000014  4368              MULS     r0,r5,r0
000016  4a05              LDR      r2,|L8.44|
000018  1880              ADDS     r0,r0,r2
00001a  1d01              ADDS     r1,r0,#4
00001c  2207              MOVS     r2,#7
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       __aeabi_memcpy
;;;481            return NRF_SUCCESS;
000024  2000              MOVS     r0,#0
                  |L8.38|
;;;482        }
;;;483    
;;;484        return NRF_ERROR_NOT_FOUND;
;;;485    }
000026  bd70              POP      {r4-r6,pc}
                  |L8.40|
000028  2005              MOVS     r0,#5                 ;484
00002a  e7fc              B        |L8.38|
;;;486    
                          ENDP

                  |L8.44|
                          DCD      m_connections

                          AREA ||i.im_ble_evt_handler||, CODE, READONLY, ALIGN=2

                  im_ble_evt_handler PROC
;;;252    
;;;253    void im_ble_evt_handler(ble_evt_t * ble_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  b08e              SUB      sp,sp,#0x38
000004  4604              MOV      r4,r0
;;;255        ble_gap_evt_t gap_evt;
;;;256        pm_peer_id_t  bonded_matching_peer_id;
;;;257    
;;;258        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;259    
;;;260        if (ble_evt->header.evt_id != BLE_GAP_EVT_CONNECTED)
000006  8820              LDRH     r0,[r4,#0]
000008  2810              CMP      r0,#0x10
00000a  d001              BEQ      |L9.16|
                  |L9.12|
;;;261        {
;;;262            // Nothing to do.
;;;263            return;
;;;264        }
;;;265    
;;;266        gap_evt                 = ble_evt->evt.gap_evt;
;;;267        bonded_matching_peer_id = PM_PEER_ID_INVALID;
;;;268    
;;;269        if (   gap_evt.params.connected.peer_addr.addr_type
;;;270            != BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;271        {
;;;272            /* Search the database for bonding data matching the one that triggered the event.
;;;273             * Public and static addresses can be matched on address alone, while resolvable
;;;274             * random addresses can be resolved agains known IRKs. Non-resolvable random addresses
;;;275             * are never matching because they are not longterm form of identification.
;;;276             */
;;;277    
;;;278            pm_peer_id_t         peer_id;
;;;279            pm_peer_data_flash_t peer_data;
;;;280    
;;;281            pds_peer_data_iterate_prepare();
;;;282    
;;;283            switch (gap_evt.params.connected.peer_addr.addr_type)
;;;284            {
;;;285                case BLE_GAP_ADDR_TYPE_PUBLIC:
;;;286                case BLE_GAP_ADDR_TYPE_RANDOM_STATIC:
;;;287                {
;;;288                    while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
;;;289                    {
;;;290                        if (addr_compare(&gap_evt.params.connected.peer_addr,
;;;291                                         &peer_data.p_bonding_data->peer_ble_id.id_addr_info))
;;;292                        {
;;;293                            bonded_matching_peer_id = peer_id;
;;;294                            break;
;;;295                        }
;;;296                    }
;;;297                }
;;;298                break;
;;;299    
;;;300                case BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE:
;;;301                {
;;;302                    while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
;;;303                    {
;;;304                        if (im_address_resolve(&gap_evt.params.connected.peer_addr,
;;;305                                               &peer_data.p_bonding_data->peer_ble_id.id_info))
;;;306                        {
;;;307                            bonded_matching_peer_id = peer_id;
;;;308                            break;
;;;309                        }
;;;310                    }
;;;311                }
;;;312                break;
;;;313    
;;;314                default:
;;;315                    NRF_PM_DEBUG_CHECK(false);
;;;316                    break;
;;;317            }
;;;318        }
;;;319    
;;;320        uint8_t new_index = new_connection(gap_evt.conn_handle,
;;;321                                           &gap_evt.params.connected.peer_addr);
;;;322        UNUSED_VARIABLE(new_index);
;;;323    
;;;324        if (bonded_matching_peer_id != PM_PEER_ID_INVALID)
;;;325        {
;;;326            im_new_peer_id(gap_evt.conn_handle, bonded_matching_peer_id);
;;;327    
;;;328            // Send a bonded peer event
;;;329            im_evt_t im_evt;
;;;330            im_evt.conn_handle = gap_evt.conn_handle;
;;;331            im_evt.evt_id      = IM_EVT_BONDED_PEER_CONNECTED;
;;;332            evt_send(&im_evt);
;;;333        }
;;;334    }
00000c  b00e              ADD      sp,sp,#0x38
00000e  bd70              POP      {r4-r6,pc}
                  |L9.16|
000010  222c              MOVS     r2,#0x2c              ;266
000012  1d21              ADDS     r1,r4,#4              ;266
000014  a803              ADD      r0,sp,#0xc            ;266
000016  f7fffffe          BL       __aeabi_memcpy4
00001a  4d2b              LDR      r5,|L9.200|
00001c  4668              MOV      r0,sp                 ;269
00001e  7c00              LDRB     r0,[r0,#0x10]         ;269
000020  2803              CMP      r0,#3                 ;269
000022  d037              BEQ      |L9.148|
000024  f7fffffe          BL       pds_peer_data_iterate_prepare
000028  4668              MOV      r0,sp                 ;283
00002a  7c00              LDRB     r0,[r0,#0x10]         ;283
00002c  2800              CMP      r0,#0                 ;283
00002e  d004              BEQ      |L9.58|
000030  2801              CMP      r0,#1                 ;283
000032  d003              BEQ      |L9.60|
000034  2802              CMP      r0,#2                 ;283
000036  d12a              BNE      |L9.142|
000038  e015              B        |L9.102|
                  |L9.58|
00003a  bf00              NOP                            ;286
                  |L9.60|
00003c  e00a              B        |L9.84|
                  |L9.62|
00003e  9801              LDR      r0,[sp,#4]            ;290
000040  4601              MOV      r1,r0                 ;290
000042  3111              ADDS     r1,r1,#0x11           ;290
000044  a804              ADD      r0,sp,#0x10           ;290
000046  f7fffffe          BL       addr_compare
00004a  2800              CMP      r0,#0                 ;290
00004c  d002              BEQ      |L9.84|
00004e  4668              MOV      r0,sp                 ;293
000050  8905              LDRH     r5,[r0,#8]            ;293
000052  e006              B        |L9.98|
                  |L9.84|
000054  466a              MOV      r2,sp                 ;288
000056  a902              ADD      r1,sp,#8              ;288
000058  2007              MOVS     r0,#7                 ;288
00005a  f7fffffe          BL       pds_peer_data_iterate
00005e  2800              CMP      r0,#0                 ;288
000060  d1ed              BNE      |L9.62|
                  |L9.98|
000062  bf00              NOP                            ;294
000064  e014              B        |L9.144|
                  |L9.102|
000066  e009              B        |L9.124|
                  |L9.104|
000068  9801              LDR      r0,[sp,#4]            ;304
00006a  1c41              ADDS     r1,r0,#1              ;304
00006c  a804              ADD      r0,sp,#0x10           ;304
00006e  f7fffffe          BL       im_address_resolve
000072  2800              CMP      r0,#0                 ;304
000074  d002              BEQ      |L9.124|
000076  4668              MOV      r0,sp                 ;307
000078  8905              LDRH     r5,[r0,#8]            ;307
00007a  e006              B        |L9.138|
                  |L9.124|
00007c  466a              MOV      r2,sp                 ;302
00007e  a902              ADD      r1,sp,#8              ;302
000080  2007              MOVS     r0,#7                 ;302
000082  f7fffffe          BL       pds_peer_data_iterate
000086  2800              CMP      r0,#0                 ;302
000088  d1ee              BNE      |L9.104|
                  |L9.138|
00008a  bf00              NOP                            ;308
00008c  e000              B        |L9.144|
                  |L9.142|
00008e  bf00              NOP                            ;316
                  |L9.144|
000090  bf00              NOP                            ;298
000092  bf00              NOP                            ;318
                  |L9.148|
000094  4669              MOV      r1,sp                 ;320
000096  8988              LDRH     r0,[r1,#0xc]          ;320
000098  a904              ADD      r1,sp,#0x10           ;320
00009a  f7fffffe          BL       new_connection
00009e  4606              MOV      r6,r0                 ;320
0000a0  4809              LDR      r0,|L9.200|
0000a2  4285              CMP      r5,r0                 ;324
0000a4  d00d              BEQ      |L9.194|
0000a6  4669              MOV      r1,sp                 ;326
0000a8  8988              LDRH     r0,[r1,#0xc]          ;326
0000aa  4629              MOV      r1,r5                 ;326
0000ac  f7fffffe          BL       im_new_peer_id
0000b0  4668              MOV      r0,sp                 ;330
0000b2  8981              LDRH     r1,[r0,#0xc]          ;330
0000b4  80c1              STRH     r1,[r0,#6]            ;330
0000b6  2101              MOVS     r1,#1                 ;331
0000b8  7101              STRB     r1,[r0,#4]            ;331
0000ba  a801              ADD      r0,sp,#4              ;332
0000bc  f7fffffe          BL       evt_send
0000c0  bf00              NOP                            ;333
                  |L9.194|
0000c2  bf00              NOP      
0000c4  e7a2              B        |L9.12|
;;;335    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L9.200|
                          DCD      0x0000ffff

                          AREA ||i.im_conn_handle_get||, CODE, READONLY, ALIGN=2

                  im_conn_handle_get PROC
;;;534    
;;;535    uint16_t im_conn_handle_get(pm_peer_id_t peer_id)
000000  4602              MOV      r2,r0
;;;536    {
;;;537        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;538    
;;;539        for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000002  2100              MOVS     r1,#0
000004  e00b              B        |L10.30|
                  |L10.6|
;;;540        {
;;;541            if (peer_id == m_connections[i].peer_id)
000006  200c              MOVS     r0,#0xc
000008  4348              MULS     r0,r1,r0
00000a  4b07              LDR      r3,|L10.40|
00000c  5a18              LDRH     r0,[r3,r0]
00000e  4290              CMP      r0,r2
000010  d104              BNE      |L10.28|
;;;542            {
;;;543                return m_connections[i].conn_handle;
000012  200c              MOVS     r0,#0xc
000014  4348              MULS     r0,r1,r0
000016  18c0              ADDS     r0,r0,r3
000018  8840              LDRH     r0,[r0,#2]
                  |L10.26|
;;;544            }
;;;545        }
;;;546        return BLE_CONN_HANDLE_INVALID;
;;;547    }
00001a  4770              BX       lr
                  |L10.28|
00001c  1c49              ADDS     r1,r1,#1              ;539
                  |L10.30|
00001e  2908              CMP      r1,#8                 ;539
000020  d3f1              BCC      |L10.6|
000022  4802              LDR      r0,|L10.44|
000024  e7f9              B        |L10.26|
;;;548    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      m_connections
                  |L10.44|
                          DCD      0x0000ffff

                          AREA ||i.im_device_identities_list_set||, CODE, READONLY, ALIGN=1

                  im_device_identities_list_set PROC
;;;697    
;;;698    ret_code_t im_device_identities_list_set(pm_peer_id_t const * p_peers,
000000  4602              MOV      r2,r0
;;;699                                             uint32_t             peer_cnt)
;;;700    {
;;;701        #if (NRF_SD_BLE_API_VERSION == 3)
;;;702    
;;;703            ret_code_t             ret;
;;;704            pm_peer_data_t         peer_data;
;;;705            pm_peer_data_bonding_t bond_data;
;;;706    
;;;707            ble_gap_id_key_t         keys[BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT];
;;;708            ble_gap_id_key_t const * key_ptrs[BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT];
;;;709    
;;;710            if ((p_peers == NULL) || (peer_cnt == 0))
;;;711            {
;;;712                // Clear the device identities list.
;;;713                return sd_ble_gap_device_identities_set(NULL, NULL, 0);
;;;714            }
;;;715    
;;;716            peer_data.p_bonding_data = &bond_data;
;;;717            uint32_t const buf_size  = sizeof(bond_data);
;;;718    
;;;719            memset(keys, 0x00, sizeof(keys));
;;;720            for (uint32_t i = 0; i < BLE_GAP_DEVICE_IDENTITIES_MAX_COUNT; i++)
;;;721            {
;;;722                key_ptrs[i] = &keys[i];
;;;723            }
;;;724    
;;;725            for (uint32_t i = 0; i < peer_cnt; i++)
;;;726            {
;;;727                memset(&bond_data, 0x00, sizeof(bond_data));
;;;728    
;;;729                // Read peer data from flash.
;;;730                ret = pds_peer_data_read(p_peers[i], PM_PEER_DATA_ID_BONDING,
;;;731                                         &peer_data, &buf_size);
;;;732    
;;;733                if ((ret == NRF_ERROR_NOT_FOUND) || (ret == NRF_ERROR_INVALID_PARAM))
;;;734                {
;;;735                    // Peer data coulnd't be found in flash or peer ID is not valid.
;;;736                    return NRF_ERROR_NOT_FOUND;
;;;737                }
;;;738    
;;;739                uint8_t const addr_type = bond_data.peer_ble_id.id_addr_info.addr_type;
;;;740    
;;;741                if ((addr_type != BLE_GAP_ADDR_TYPE_PUBLIC) &&
;;;742                    (addr_type != BLE_GAP_ADDR_TYPE_RANDOM_STATIC))
;;;743                {
;;;744                    // The address shared by the peer during bonding can't be whitelisted.
;;;745                    return BLE_ERROR_GAP_INVALID_BLE_ADDR;
;;;746                }
;;;747    
;;;748                // Copy data to the buffer.
;;;749                memcpy(&keys[i], &bond_data.peer_ble_id, sizeof(ble_gap_id_key_t));
;;;750            }
;;;751    
;;;752            return sd_ble_gap_device_identities_set(key_ptrs, NULL, peer_cnt);
;;;753    
;;;754        #else
;;;755    
;;;756            return NRF_ERROR_NOT_SUPPORTED;
000002  2006              MOVS     r0,#6
;;;757    
;;;758        #endif
;;;759    }
000004  4770              BX       lr
;;;760    
                          ENDP


                          AREA ||i.im_id_addr_get||, CODE, READONLY, ALIGN=2

                  im_id_addr_get PROC
;;;827    
;;;828    ret_code_t im_id_addr_get(ble_gap_addr_t * p_addr)
000000  b510              PUSH     {r4,lr}
;;;829    {
000002  4604              MOV      r4,r0
;;;830        NRF_PM_DEBUG_CHECK(p_addr != NULL);
;;;831    
;;;832        #if (NRF_SD_BLE_API_VERSION == 2)
;;;833            memcpy(p_addr, &m_current_id_addr, sizeof(ble_gap_addr_t));
000004  2207              MOVS     r2,#7
000006  4903              LDR      r1,|L12.20|
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       __aeabi_memcpy
;;;834            return NRF_SUCCESS;
00000e  2000              MOVS     r0,#0
;;;835        #else
;;;836            return sd_ble_gap_addr_get(p_addr);
;;;837        #endif
;;;838    }
000010  bd10              POP      {r4,pc}
;;;839    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      m_current_id_addr

                          AREA ||i.im_id_addr_set||, CODE, READONLY, ALIGN=2

                  im_id_addr_set PROC
;;;786    
;;;787    ret_code_t im_id_addr_set(ble_gap_addr_t const * p_addr)
000000  b57c              PUSH     {r2-r6,lr}
;;;788    {
000002  4605              MOV      r5,r0
;;;789        #if (NRF_SD_BLE_API_VERSION == 2)
;;;790    
;;;791            ret_code_t     ret;
;;;792            ble_gap_addr_t current_addr;
;;;793    
;;;794            NRF_PM_DEBUG_CHECK(p_addr != NULL);
;;;795    
;;;796            (void) sd_ble_gap_address_get(&current_addr);
000004  4668              MOV      r0,sp
000006  df71              SVC      #0x71
;;;797    
;;;798            ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_NONE, (ble_gap_addr_t *)p_addr);
000008  4629              MOV      r1,r5
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       address_set_v2
000010  4604              MOV      r4,r0
;;;799            if (ret != NRF_SUCCESS)
000012  2c00              CMP      r4,#0
000014  d001              BEQ      |L13.26|
;;;800            {
;;;801                return ret;
000016  4620              MOV      r0,r4
                  |L13.24|
;;;802            }
;;;803    
;;;804            if (   current_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
;;;805                || current_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
;;;806            {
;;;807                // If currently using privacy, it must be re-enabled.
;;;808                // We force AUTO when privacy is enabled.
;;;809                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_AUTO, &current_addr);
;;;810                if (ret != NRF_SUCCESS)
;;;811                {
;;;812                    return ret;
;;;813                }
;;;814            }
;;;815    
;;;816            memcpy(&m_current_id_addr, p_addr, sizeof(ble_gap_addr_t));
;;;817    
;;;818            return NRF_SUCCESS;
;;;819    
;;;820        #else
;;;821    
;;;822            return sd_ble_gap_addr_set(p_addr);
;;;823    
;;;824        #endif
;;;825    }
000018  bd7c              POP      {r2-r6,pc}
                  |L13.26|
00001a  4668              MOV      r0,sp                 ;804
00001c  7800              LDRB     r0,[r0,#0]            ;804
00001e  2802              CMP      r0,#2                 ;804
000020  d003              BEQ      |L13.42|
000022  4668              MOV      r0,sp                 ;805
000024  7800              LDRB     r0,[r0,#0]            ;805
000026  2803              CMP      r0,#3                 ;805
000028  d108              BNE      |L13.60|
                  |L13.42|
00002a  4669              MOV      r1,sp                 ;809
00002c  2001              MOVS     r0,#1                 ;809
00002e  f7fffffe          BL       address_set_v2
000032  4604              MOV      r4,r0                 ;809
000034  2c00              CMP      r4,#0                 ;810
000036  d001              BEQ      |L13.60|
000038  4620              MOV      r0,r4                 ;812
00003a  e7ed              B        |L13.24|
                  |L13.60|
00003c  2207              MOVS     r2,#7                 ;816
00003e  4629              MOV      r1,r5                 ;816
000040  4802              LDR      r0,|L13.76|
000042  f7fffffe          BL       __aeabi_memcpy
000046  2000              MOVS     r0,#0                 ;818
000048  e7e6              B        |L13.24|
;;;826    
                          ENDP

00004a  0000              DCW      0x0000
                  |L13.76|
                          DCD      m_current_id_addr

                          AREA ||i.im_init||, CODE, READONLY, ALIGN=2

                  im_init PROC
;;;425    
;;;426    ret_code_t im_init(void)
000000  b510              PUSH     {r4,lr}
;;;427    {
;;;428        NRF_PM_DEBUG_CHECK(!m_module_initialized);
;;;429    
;;;430        internal_state_reset();
000002  f7fffffe          BL       internal_state_reset
;;;431    
;;;432        m_conn_state_user_flag_id = ble_conn_state_user_flag_acquire();
000006  f7fffffe          BL       ble_conn_state_user_flag_acquire
00000a  490a              LDR      r1,|L14.52|
00000c  7008              STRB     r0,[r1,#0]
;;;433        if (m_conn_state_user_flag_id == BLE_CONN_STATE_USER_FLAG_INVALID)
00000e  4608              MOV      r0,r1
000010  7800              LDRB     r0,[r0,#0]  ; m_conn_state_user_flag_id
000012  2818              CMP      r0,#0x18
000014  d101              BNE      |L14.26|
;;;434        {
;;;435            return NRF_ERROR_INTERNAL;
000016  2003              MOVS     r0,#3
                  |L14.24|
;;;436        }
;;;437    
;;;438        #if (NRF_SD_BLE_API_VERSION == 2)
;;;439            ret_code_t ret_code = sd_ble_gap_address_get(&m_current_id_addr);
;;;440            if (ret_code != NRF_SUCCESS)
;;;441            {
;;;442                return NRF_ERROR_INTERNAL;
;;;443            }
;;;444        #endif
;;;445    
;;;446        m_module_initialized = true;
;;;447    
;;;448        return NRF_SUCCESS;
;;;449    }
000018  bd10              POP      {r4,pc}
                  |L14.26|
00001a  4807              LDR      r0,|L14.56|
00001c  df71              SVC      #0x71                 ;439
00001e  4604              MOV      r4,r0                 ;439
000020  2c00              CMP      r4,#0                 ;440
000022  d001              BEQ      |L14.40|
000024  2003              MOVS     r0,#3                 ;442
000026  e7f7              B        |L14.24|
                  |L14.40|
000028  2001              MOVS     r0,#1                 ;446
00002a  4904              LDR      r1,|L14.60|
00002c  7008              STRB     r0,[r1,#0]            ;446
00002e  2000              MOVS     r0,#0                 ;448
000030  e7f2              B        |L14.24|
;;;450    
                          ENDP

000032  0000              DCW      0x0000
                  |L14.52|
                          DCD      m_conn_state_user_flag_id
                  |L14.56|
                          DCD      m_current_id_addr
                  |L14.60|
                          DCD      m_module_initialized

                          AREA ||i.im_is_duplicate_bonding_data||, CODE, READONLY, ALIGN=1

                  im_is_duplicate_bonding_data PROC
;;;344     */
;;;345    bool im_is_duplicate_bonding_data(pm_peer_data_bonding_t const * p_bonding_data1,
000000  b5f8              PUSH     {r3-r7,lr}
;;;346                                      pm_peer_data_bonding_t const * p_bonding_data2)
;;;347    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;348        NRF_PM_DEBUG_CHECK(p_bonding_data1 != NULL);
;;;349        NRF_PM_DEBUG_CHECK(p_bonding_data2 != NULL);
;;;350    
;;;351        if (!is_valid_irk(&p_bonding_data1->peer_ble_id.id_info))
000006  1c60              ADDS     r0,r4,#1
000008  f7fffffe          BL       is_valid_irk
00000c  2800              CMP      r0,#0
00000e  d100              BNE      |L15.18|
                  |L15.16|
;;;352        {
;;;353            return false;
;;;354        }
;;;355    
;;;356        bool duplicate_irk = (memcmp(p_bonding_data1->peer_ble_id.id_info.irk,
;;;357                                     p_bonding_data2->peer_ble_id.id_info.irk,
;;;358                                     BLE_GAP_SEC_KEY_LEN) == 0);
;;;359    
;;;360        bool duplicate_addr = addr_compare(&p_bonding_data1->peer_ble_id.id_addr_info,
;;;361                                           &p_bonding_data2->peer_ble_id.id_addr_info);
;;;362    
;;;363        return duplicate_irk || duplicate_addr;
;;;364    }
000010  bdf8              POP      {r3-r7,pc}
                  |L15.18|
000012  2210              MOVS     r2,#0x10              ;356
000014  1c69              ADDS     r1,r5,#1              ;356
000016  1c60              ADDS     r0,r4,#1              ;356
000018  f7fffffe          BL       memcmp
00001c  2800              CMP      r0,#0                 ;356
00001e  d101              BNE      |L15.36|
000020  2001              MOVS     r0,#1                 ;356
000022  e000              B        |L15.38|
                  |L15.36|
000024  2000              MOVS     r0,#0                 ;356
                  |L15.38|
000026  4607              MOV      r7,r0                 ;356
000028  4629              MOV      r1,r5                 ;360
00002a  3111              ADDS     r1,r1,#0x11           ;360
00002c  4620              MOV      r0,r4                 ;360
00002e  3011              ADDS     r0,r0,#0x11           ;360
000030  f7fffffe          BL       addr_compare
000034  4606              MOV      r6,r0                 ;360
000036  2f00              CMP      r7,#0                 ;363
000038  d101              BNE      |L15.62|
00003a  2e00              CMP      r6,#0                 ;363
00003c  d001              BEQ      |L15.66|
                  |L15.62|
00003e  2001              MOVS     r0,#1                 ;363
000040  e7e6              B        |L15.16|
                  |L15.66|
000042  2000              MOVS     r0,#0                 ;363
000044  e7e4              B        |L15.16|
;;;365    
                          ENDP


                          AREA ||i.im_master_id_is_valid||, CODE, READONLY, ALIGN=1

                  im_master_id_is_valid PROC
;;;549    
;;;550    bool im_master_id_is_valid(ble_gap_master_id_t const * p_master_id)
000000  4602              MOV      r2,r0
;;;551    {
;;;552        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;553    
;;;554        if (p_master_id->ediv != 0)
000002  8810              LDRH     r0,[r2,#0]
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L16.12|
;;;555        {
;;;556            return true;
000008  2001              MOVS     r0,#1
                  |L16.10|
;;;557        }
;;;558    
;;;559        for (uint32_t i = 0; i < BLE_GAP_SEC_RAND_LEN; i++)
;;;560        {
;;;561            if (p_master_id->rand[i] != 0)
;;;562            {
;;;563                return true;
;;;564            }
;;;565        }
;;;566        return false;
;;;567    }
00000a  4770              BX       lr
                  |L16.12|
00000c  2100              MOVS     r1,#0                 ;559
00000e  e006              B        |L16.30|
                  |L16.16|
000010  1c90              ADDS     r0,r2,#2              ;561
000012  5c40              LDRB     r0,[r0,r1]            ;561
000014  2800              CMP      r0,#0                 ;561
000016  d001              BEQ      |L16.28|
000018  2001              MOVS     r0,#1                 ;563
00001a  e7f6              B        |L16.10|
                  |L16.28|
00001c  1c49              ADDS     r1,r1,#1              ;559
                  |L16.30|
00001e  2908              CMP      r1,#8                 ;559
000020  d3f6              BCC      |L16.16|
000022  2000              MOVS     r0,#0                 ;566
000024  e7f1              B        |L16.10|
;;;568    
                          ENDP


                          AREA ||i.im_master_ids_compare||, CODE, READONLY, ALIGN=1

                  im_master_ids_compare PROC
;;;487    
;;;488    bool im_master_ids_compare(ble_gap_master_id_t const * p_master_id1,
000000  b570              PUSH     {r4-r6,lr}
;;;489                               ble_gap_master_id_t const * p_master_id2)
;;;490    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;491        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;492        NRF_PM_DEBUG_CHECK(p_master_id1 != NULL);
;;;493        NRF_PM_DEBUG_CHECK(p_master_id2 != NULL);
;;;494    
;;;495        if (!im_master_id_is_valid(p_master_id1))
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       im_master_id_is_valid
00000c  2800              CMP      r0,#0
00000e  d100              BNE      |L17.18|
                  |L17.16|
;;;496        {
;;;497            return false;
;;;498        }
;;;499    
;;;500        if (p_master_id1->ediv != p_master_id2->ediv)
;;;501        {
;;;502            return false;
;;;503        }
;;;504    
;;;505        return (memcmp(p_master_id1->rand, p_master_id2->rand, BLE_GAP_SEC_RAND_LEN) == 0);
;;;506    }
000010  bd70              POP      {r4-r6,pc}
                  |L17.18|
000012  8828              LDRH     r0,[r5,#0]            ;500
000014  8821              LDRH     r1,[r4,#0]            ;500
000016  4288              CMP      r0,r1                 ;500
000018  d001              BEQ      |L17.30|
00001a  2000              MOVS     r0,#0                 ;502
00001c  e7f8              B        |L17.16|
                  |L17.30|
00001e  2208              MOVS     r2,#8                 ;505
000020  1ca1              ADDS     r1,r4,#2              ;505
000022  1ca8              ADDS     r0,r5,#2              ;505
000024  f7fffffe          BL       memcmp
000028  2800              CMP      r0,#0                 ;505
00002a  d101              BNE      |L17.48|
00002c  2001              MOVS     r0,#1                 ;505
00002e  e7ef              B        |L17.16|
                  |L17.48|
000030  2000              MOVS     r0,#0                 ;505
000032  e7ed              B        |L17.16|
;;;507    
                          ENDP


                          AREA ||i.im_new_peer_id||, CODE, READONLY, ALIGN=1

                  im_new_peer_id PROC
;;;584    
;;;585    void im_new_peer_id(uint16_t conn_handle, pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;586    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;587        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;588    
;;;589        peer_id_set(conn_handle, peer_id);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       peer_id_set
;;;590    }
00000e  bd70              POP      {r4-r6,pc}
;;;591    
                          ENDP


                          AREA ||i.im_pdb_evt_handler||, CODE, READONLY, ALIGN=1

                  im_pdb_evt_handler PROC
;;;371     */
;;;372    void im_pdb_evt_handler(pdb_evt_t const * p_event)
000000  b530              PUSH     {r4,r5,lr}
;;;373    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;374        ret_code_t           ret;
;;;375        pm_peer_id_t         peer_id;
;;;376        pm_peer_data_flash_t peer_data;
;;;377        pm_peer_data_flash_t peer_data_duplicate;
;;;378    
;;;379        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;380        NRF_PM_DEBUG_CHECK(p_event != NULL);
;;;381    
;;;382        if ((p_event->evt_id  != PDB_EVT_WRITE_BUF_STORED) ||
000006  7820              LDRB     r0,[r4,#0]
000008  2800              CMP      r0,#0
00000a  d102              BNE      |L19.18|
;;;383            (p_event->data_id != PM_PEER_DATA_ID_BONDING))
00000c  7920              LDRB     r0,[r4,#4]
00000e  2807              CMP      r0,#7
000010  d001              BEQ      |L19.22|
                  |L19.18|
;;;384        {
;;;385            return;
;;;386        }
;;;387    
;;;388        // If new data about peer id has been stored it is compared to other peers peer ids in
;;;389        // search of duplicates.
;;;390    
;;;391        ret = pdb_peer_data_ptr_get(p_event->peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
;;;392    
;;;393        if (ret != NRF_SUCCESS)
;;;394        {
;;;395            // @note emdi: this shouldn't happen, since the data was just stored, right?
;;;396            NRF_PM_DEBUG_CHECK(false);
;;;397            return;
;;;398        }
;;;399    
;;;400        pds_peer_data_iterate_prepare();
;;;401    
;;;402        while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data_duplicate))
;;;403        {
;;;404            if (p_event->peer_id == peer_id)
;;;405            {
;;;406                // Skip the iteration if the bonding data retrieved is for a peer
;;;407                // with the same ID as the one contained in the event.
;;;408                continue;
;;;409            }
;;;410    
;;;411            if (im_is_duplicate_bonding_data(peer_data.p_bonding_data,
;;;412                                             peer_data_duplicate.p_bonding_data))
;;;413            {
;;;414                im_evt_t im_evt;
;;;415                im_evt.conn_handle                   = im_conn_handle_get(p_event->peer_id);
;;;416                im_evt.evt_id                        = IM_EVT_DUPLICATE_ID;
;;;417                im_evt.params.duplicate_id.peer_id_1 = p_event->peer_id;
;;;418                im_evt.params.duplicate_id.peer_id_2 = peer_id;
;;;419                evt_send(&im_evt);
;;;420                break;
;;;421            }
;;;422        }
;;;423    }
000012  b007              ADD      sp,sp,#0x1c
000014  bd30              POP      {r4,r5,pc}
                  |L19.22|
000016  8860              LDRH     r0,[r4,#2]            ;391
000018  aa04              ADD      r2,sp,#0x10           ;391
00001a  2107              MOVS     r1,#7                 ;391
00001c  f7fffffe          BL       pdb_peer_data_ptr_get
000020  4605              MOV      r5,r0                 ;391
000022  2d00              CMP      r5,#0                 ;393
000024  d000              BEQ      |L19.40|
000026  e7f4              B        |L19.18|
                  |L19.40|
000028  f7fffffe          BL       pds_peer_data_iterate_prepare
00002c  e01b              B        |L19.102|
                  |L19.46|
00002e  8860              LDRH     r0,[r4,#2]            ;404
000030  4669              MOV      r1,sp                 ;404
000032  8b09              LDRH     r1,[r1,#0x18]         ;404
000034  4288              CMP      r0,r1                 ;404
000036  d100              BNE      |L19.58|
000038  e015              B        |L19.102|
                  |L19.58|
00003a  9903              LDR      r1,[sp,#0xc]          ;411
00003c  9805              LDR      r0,[sp,#0x14]         ;411
00003e  f7fffffe          BL       im_is_duplicate_bonding_data
000042  2800              CMP      r0,#0                 ;411
000044  d00e              BEQ      |L19.100|
000046  8860              LDRH     r0,[r4,#2]            ;415
000048  f7fffffe          BL       im_conn_handle_get
00004c  4669              MOV      r1,sp                 ;415
00004e  8048              STRH     r0,[r1,#2]            ;415
000050  2100              MOVS     r1,#0                 ;416
000052  4668              MOV      r0,sp                 ;416
000054  7001              STRB     r1,[r0,#0]            ;416
000056  8861              LDRH     r1,[r4,#2]            ;417
000058  8081              STRH     r1,[r0,#4]            ;417
00005a  8b01              LDRH     r1,[r0,#0x18]         ;418
00005c  80c1              STRH     r1,[r0,#6]            ;418
00005e  f7fffffe          BL       evt_send
000062  e007              B        |L19.116|
                  |L19.100|
000064  bf00              NOP                            ;408
                  |L19.102|
000066  aa02              ADD      r2,sp,#8              ;402
000068  a906              ADD      r1,sp,#0x18           ;402
00006a  2007              MOVS     r0,#7                 ;402
00006c  f7fffffe          BL       pds_peer_data_iterate
000070  2800              CMP      r0,#0                 ;402
000072  d1dc              BNE      |L19.46|
                  |L19.116|
000074  bf00              NOP                            ;420
000076  bf00              NOP      
000078  e7cb              B        |L19.18|
;;;424    
                          ENDP


                          AREA ||i.im_peer_free||, CODE, READONLY, ALIGN=2

                  im_peer_free PROC
;;;592    
;;;593    ret_code_t im_peer_free(pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;594    {
000002  4606              MOV      r6,r0
;;;595        uint16_t   conn_handle;
;;;596        ret_code_t ret;
;;;597    
;;;598        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;599    
;;;600        conn_handle = im_conn_handle_get(peer_id);
000004  4630              MOV      r0,r6
000006  f7fffffe          BL       im_conn_handle_get
00000a  4604              MOV      r4,r0
;;;601        ret         = pdb_peer_free(peer_id);
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       pdb_peer_free
000012  4605              MOV      r5,r0
;;;602    
;;;603        if ((conn_handle != BLE_CONN_HANDLE_INVALID) && (ret == NRF_SUCCESS))
000014  4805              LDR      r0,|L20.44|
000016  4284              CMP      r4,r0
000018  d005              BEQ      |L20.38|
00001a  2d00              CMP      r5,#0
00001c  d103              BNE      |L20.38|
;;;604        {
;;;605            peer_id_set(conn_handle, PM_PEER_ID_INVALID);
00001e  4601              MOV      r1,r0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       peer_id_set
                  |L20.38|
;;;606        }
;;;607        return ret;
000026  4628              MOV      r0,r5
;;;608    }
000028  bd70              POP      {r4-r6,pc}
;;;609    
                          ENDP

00002a  0000              DCW      0x0000
                  |L20.44|
                          DCD      0x0000ffff

                          AREA ||i.im_peer_id_get_by_conn_handle||, CODE, READONLY, ALIGN=2

                  im_peer_id_get_by_conn_handle PROC
;;;451    
;;;452    pm_peer_id_t im_peer_id_get_by_conn_handle(uint16_t conn_handle)
000000  b570              PUSH     {r4-r6,lr}
;;;453    {
000002  4605              MOV      r5,r0
;;;454        uint8_t conn_index;
;;;455    
;;;456        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;457    
;;;458        conn_index = get_connection_by_conn_handle(conn_handle);
000004  4628              MOV      r0,r5
000006  f7fffffe          BL       get_connection_by_conn_handle
00000a  4604              MOV      r4,r0
;;;459    
;;;460        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000c  2cff              CMP      r4,#0xff
00000e  d004              BEQ      |L21.26|
;;;461        {
;;;462            return m_connections[conn_index].peer_id;
000010  200c              MOVS     r0,#0xc
000012  4360              MULS     r0,r4,r0
000014  4902              LDR      r1,|L21.32|
000016  5a08              LDRH     r0,[r1,r0]
                  |L21.24|
;;;463        }
;;;464    
;;;465        return PM_PEER_ID_INVALID;
;;;466    }
000018  bd70              POP      {r4-r6,pc}
                  |L21.26|
00001a  4802              LDR      r0,|L21.36|
00001c  e7fc              B        |L21.24|
;;;467    
                          ENDP

00001e  0000              DCW      0x0000
                  |L21.32|
                          DCD      m_connections
                  |L21.36|
                          DCD      0x0000ffff

                          AREA ||i.im_peer_id_get_by_master_id||, CODE, READONLY, ALIGN=2

                  im_peer_id_get_by_master_id PROC
;;;508    
;;;509    pm_peer_id_t im_peer_id_get_by_master_id(ble_gap_master_id_t * p_master_id)
000000  b53e              PUSH     {r1-r5,lr}
;;;510    {
000002  4604              MOV      r4,r0
;;;511        pm_peer_id_t         peer_id;
;;;512        pm_peer_data_flash_t peer_data;
;;;513    
;;;514        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;515        NRF_PM_DEBUG_CHECK(p_master_id != NULL);
;;;516    
;;;517        pds_peer_data_iterate_prepare();
000004  f7fffffe          BL       pds_peer_data_iterate_prepare
;;;518    
;;;519        // For each stored peer, check if the master_id matches p_master_id
;;;520        while (pds_peer_data_iterate(PM_PEER_DATA_ID_BONDING, &peer_id, &peer_data))
000008  e012              B        |L22.48|
                  |L22.10|
;;;521        {
;;;522            if (im_master_ids_compare(p_master_id, &peer_data.p_bonding_data->own_ltk.master_id) ||
00000a  9801              LDR      r0,[sp,#4]
00000c  4601              MOV      r1,r0
00000e  3146              ADDS     r1,r1,#0x46
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       im_master_ids_compare
000016  2800              CMP      r0,#0
000018  d107              BNE      |L22.42|
;;;523                im_master_ids_compare(p_master_id, &peer_data.p_bonding_data->peer_ltk.master_id))
00001a  9801              LDR      r0,[sp,#4]
00001c  4601              MOV      r1,r0
00001e  312a              ADDS     r1,r1,#0x2a
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       im_master_ids_compare
000026  2800              CMP      r0,#0
000028  d002              BEQ      |L22.48|
                  |L22.42|
;;;524            {
;;;525                // If a matching master ID is found then return the peer ID.
;;;526                return peer_id;
00002a  4668              MOV      r0,sp
00002c  8900              LDRH     r0,[r0,#8]
                  |L22.46|
;;;527            }
;;;528        }
;;;529    
;;;530        // If no matching master ID is found return PM_PEER_ID_INVALID.
;;;531        return PM_PEER_ID_INVALID;
;;;532    }
00002e  bd3e              POP      {r1-r5,pc}
                  |L22.48|
000030  466a              MOV      r2,sp                 ;520
000032  a902              ADD      r1,sp,#8              ;520
000034  2007              MOVS     r0,#7                 ;520
000036  f7fffffe          BL       pds_peer_data_iterate
00003a  2800              CMP      r0,#0                 ;520
00003c  d1e5              BNE      |L22.10|
00003e  4801              LDR      r0,|L22.68|
000040  e7f5              B        |L22.46|
;;;533    
                          ENDP

000042  0000              DCW      0x0000
                  |L22.68|
                          DCD      0x0000ffff

                          AREA ||i.im_privacy_get||, CODE, READONLY, ALIGN=1

                  im_privacy_get PROC
;;;889    
;;;890    ret_code_t im_privacy_get(pm_privacy_params_t * p_privacy_params)
000000  b51f              PUSH     {r0-r4,lr}
;;;891    {
000002  4604              MOV      r4,r0
;;;892        #if (NRF_SD_BLE_API_VERSION == 2)
;;;893    
;;;894            ble_gap_addr_t cur_addr;
;;;895            ble_opt_t      cur_privacy_opt;
;;;896    
;;;897            NRF_PM_DEBUG_CHECK(p_privacy_params               != NULL);
;;;898            NRF_PM_DEBUG_CHECK(p_privacy_params->p_device_irk != NULL);
;;;899    
;;;900            cur_privacy_opt.gap_opt.privacy.p_irk = p_privacy_params->p_device_irk;
000004  6860              LDR      r0,[r4,#4]
000006  9000              STR      r0,[sp,#0]
;;;901    
;;;902            // Can not fail.
;;;903            (void) sd_ble_gap_address_get(&cur_addr);
000008  a802              ADD      r0,sp,#8
00000a  df71              SVC      #0x71
;;;904    
;;;905            if (   cur_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE
00000c  4668              MOV      r0,sp
00000e  7a00              LDRB     r0,[r0,#8]
000010  2802              CMP      r0,#2
000012  d003              BEQ      |L23.28|
;;;906                || cur_addr.addr_type == BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE)
000014  4668              MOV      r0,sp
000016  7a00              LDRB     r0,[r0,#8]
000018  2803              CMP      r0,#3
00001a  d105              BNE      |L23.40|
                  |L23.28|
;;;907            {
;;;908                p_privacy_params->privacy_mode      = BLE_GAP_PRIVACY_MODE_DEVICE_PRIVACY;
00001c  2001              MOVS     r0,#1
00001e  7020              STRB     r0,[r4,#0]
;;;909                p_privacy_params->private_addr_type = cur_addr.addr_type;
000020  4668              MOV      r0,sp
000022  7a00              LDRB     r0,[r0,#8]
000024  7060              STRB     r0,[r4,#1]
000026  e001              B        |L23.44|
                  |L23.40|
;;;910            }
;;;911            else
;;;912            {
;;;913                p_privacy_params->privacy_mode = BLE_GAP_PRIVACY_MODE_OFF;
000028  2000              MOVS     r0,#0
00002a  7020              STRB     r0,[r4,#0]
                  |L23.44|
;;;914            }
;;;915    
;;;916            // Can not fail.
;;;917            (void) sd_ble_opt_get(BLE_GAP_OPT_PRIVACY, &cur_privacy_opt);
00002c  4669              MOV      r1,sp
00002e  2023              MOVS     r0,#0x23
000030  df69              SVC      #0x69
;;;918    
;;;919            p_privacy_params->private_addr_cycle_s = cur_privacy_opt.gap_opt.privacy.interval_s;
000032  4668              MOV      r0,sp
000034  8880              LDRH     r0,[r0,#4]
000036  8060              STRH     r0,[r4,#2]
;;;920    
;;;921            return NRF_SUCCESS;
000038  2000              MOVS     r0,#0
;;;922    
;;;923        #else
;;;924    
;;;925            return sd_ble_gap_privacy_get(p_privacy_params);
;;;926    
;;;927        #endif
;;;928    }
00003a  b004              ADD      sp,sp,#0x10
00003c  bd10              POP      {r4,pc}
;;;929    
                          ENDP


                          AREA ||i.im_privacy_set||, CODE, READONLY, ALIGN=2

                  im_privacy_set PROC
;;;840    
;;;841    ret_code_t im_privacy_set(pm_privacy_params_t const * p_privacy_params)
000000  b530              PUSH     {r4,r5,lr}
;;;842    {
000002  b08b              SUB      sp,sp,#0x2c
000004  4604              MOV      r4,r0
;;;843        #if (NRF_SD_BLE_API_VERSION == 2)
;;;844    
;;;845            ret_code_t     ret;
;;;846            ble_gap_addr_t privacy_addr;
;;;847            ble_gap_irk_t  current_irk;
;;;848            ble_opt_t      privacy_options;
;;;849            ble_opt_t      current_privacy_options;
;;;850    
;;;851            NRF_PM_DEBUG_CHECK(p_privacy_params != NULL);
;;;852    
;;;853            privacy_addr.addr_type                        = p_privacy_params->private_addr_type;
000006  7861              LDRB     r1,[r4,#1]
000008  a808              ADD      r0,sp,#0x20
00000a  7101              STRB     r1,[r0,#4]
;;;854            privacy_options.gap_opt.privacy.p_irk         = p_privacy_params->p_device_irk;
00000c  6860              LDR      r0,[r4,#4]
00000e  9003              STR      r0,[sp,#0xc]
;;;855            privacy_options.gap_opt.privacy.interval_s    = p_privacy_params->private_addr_cycle_s;
000010  8861              LDRH     r1,[r4,#2]
000012  4668              MOV      r0,sp
000014  8201              STRH     r1,[r0,#0x10]
;;;856            current_privacy_options.gap_opt.privacy.p_irk = &current_irk;
000016  a805              ADD      r0,sp,#0x14
000018  9001              STR      r0,[sp,#4]
;;;857    
;;;858            // Can not fail.
;;;859            (void) sd_ble_opt_get(BLE_GAP_OPT_PRIVACY, &current_privacy_options);
00001a  a901              ADD      r1,sp,#4
00001c  2023              MOVS     r0,#0x23
00001e  df69              SVC      #0x69
;;;860            (void) sd_ble_opt_set(BLE_GAP_OPT_PRIVACY, &privacy_options);
000020  a903              ADD      r1,sp,#0xc
000022  2023              MOVS     r0,#0x23
000024  df68              SVC      #0x68
;;;861    
;;;862            if (p_privacy_params->privacy_mode == BLE_GAP_PRIVACY_MODE_OFF)
000026  7820              LDRB     r0,[r4,#0]
000028  2800              CMP      r0,#0
00002a  d104              BNE      |L24.54|
;;;863            {
;;;864                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_NONE, &m_current_id_addr);
00002c  4908              LDR      r1,|L24.80|
00002e  f7fffffe          BL       address_set_v2
000032  4605              MOV      r5,r0
000034  e004              B        |L24.64|
                  |L24.54|
;;;865            }
;;;866            else
;;;867            {
;;;868                ret = address_set_v2(BLE_GAP_ADDR_CYCLE_MODE_AUTO, &privacy_addr);
000036  a909              ADD      r1,sp,#0x24
000038  2001              MOVS     r0,#1
00003a  f7fffffe          BL       address_set_v2
00003e  4605              MOV      r5,r0
                  |L24.64|
;;;869            }
;;;870    
;;;871            if (ret != NRF_SUCCESS)
000040  2d00              CMP      r5,#0
000042  d002              BEQ      |L24.74|
;;;872            {
;;;873                // Restore previous settings.
;;;874                (void) sd_ble_opt_set(BLE_GAP_OPT_PRIVACY, &current_privacy_options);
000044  a901              ADD      r1,sp,#4
000046  2023              MOVS     r0,#0x23
000048  df68              SVC      #0x68
                  |L24.74|
;;;875            }
;;;876    
;;;877            // NRF_ERROR_BUSY,
;;;878            // NRF_ERROR_INVALID_STATE,
;;;879            // NRF_ERROR_INVALID_PARAM, if address type is not valid.
;;;880            return ret;
00004a  4628              MOV      r0,r5
;;;881    
;;;882        #else
;;;883    
;;;884            return sd_ble_gap_privacy_set(p_privacy_params);
;;;885    
;;;886        #endif
;;;887    }
00004c  b00b              ADD      sp,sp,#0x2c
00004e  bd30              POP      {r4,r5,pc}
;;;888    
                          ENDP

                  |L24.80|
                          DCD      m_current_id_addr

                          AREA ||i.im_whitelist_get||, CODE, READONLY, ALIGN=2

                  im_whitelist_get PROC
;;;933     */
;;;934    ret_code_t im_whitelist_get(ble_gap_addr_t * p_addrs,
000000  b5fe              PUSH     {r1-r7,lr}
;;;935                                uint32_t       * p_addr_cnt,
;;;936                                ble_gap_irk_t  * p_irks,
;;;937                                uint32_t       * p_irk_cnt)
;;;938    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
000008  461d              MOV      r5,r3
;;;939        // One of the two buffers has to be provided.
;;;940        NRF_PM_DEBUG_CHECK((p_addrs    != NULL) || (p_irks    != NULL));
;;;941        NRF_PM_DEBUG_CHECK((p_addr_cnt != NULL) || (p_irk_cnt != NULL));
;;;942    
;;;943        if (((p_addr_cnt != NULL) && (m_wlisted_peer_cnt > *p_addr_cnt)) ||
00000a  2c00              CMP      r4,#0
00000c  d004              BEQ      |L25.24|
00000e  490c              LDR      r1,|L25.64|
000010  7809              LDRB     r1,[r1,#0]  ; m_wlisted_peer_cnt
000012  6820              LDR      r0,[r4,#0]
000014  4288              CMP      r0,r1
000016  d306              BCC      |L25.38|
                  |L25.24|
;;;944            ((p_irk_cnt  != NULL) && (m_wlisted_peer_cnt > *p_irk_cnt)))
000018  2d00              CMP      r5,#0
00001a  d006              BEQ      |L25.42|
00001c  4908              LDR      r1,|L25.64|
00001e  7809              LDRB     r1,[r1,#0]  ; m_wlisted_peer_cnt
000020  6828              LDR      r0,[r5,#0]
000022  4288              CMP      r0,r1
000024  d201              BCS      |L25.42|
                  |L25.38|
;;;945        {
;;;946            // The size of the cached list of peers is larger than the provided buffers.
;;;947            return NRF_ERROR_NO_MEM;
000026  2004              MOVS     r0,#4
                  |L25.40|
;;;948        }
;;;949    
;;;950        // NRF_SUCCESS or
;;;951        // NRF_ERROR_NOT_FOUND,            if a peer or its data were not found.
;;;952        // BLE_ERROR_GAP_INVALID_BLE_ADDR, if a peer address can not be used for whitelisting.
;;;953        return peers_id_keys_get(m_wlisted_peers, m_wlisted_peer_cnt,
;;;954                                 p_addrs, p_addr_cnt,
;;;955                                 p_irks,  p_irk_cnt);
;;;956    }
000028  bdfe              POP      {r1-r7,pc}
                  |L25.42|
00002a  4623              MOV      r3,r4                 ;953
00002c  4632              MOV      r2,r6                 ;953
00002e  4804              LDR      r0,|L25.64|
000030  9700              STR      r7,[sp,#0]            ;953
000032  9501              STR      r5,[sp,#4]            ;953
000034  7801              LDRB     r1,[r0,#0]            ;953  ; m_wlisted_peer_cnt
000036  4803              LDR      r0,|L25.68|
000038  f7fffffe          BL       peers_id_keys_get
00003c  e7f4              B        |L25.40|
;;;957    
                          ENDP

00003e  0000              DCW      0x0000
                  |L25.64|
                          DCD      m_wlisted_peer_cnt
                  |L25.68|
                          DCD      m_wlisted_peers

                          AREA ||i.im_whitelist_set||, CODE, READONLY, ALIGN=2

                  im_whitelist_set PROC
;;;963     */
;;;964    ret_code_t im_whitelist_set(pm_peer_id_t const * p_peers,
000000  b570              PUSH     {r4-r6,lr}
;;;965                                uint32_t             peer_cnt)
;;;966    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;967        // Clear the cache of whitelisted peers.
;;;968        memset(m_wlisted_peers, 0x00, sizeof(m_wlisted_peers));
000006  2110              MOVS     r1,#0x10
000008  4809              LDR      r0,|L26.48|
00000a  f7fffffe          BL       __aeabi_memclr
;;;969    
;;;970        if ((p_peers == NULL) || (peer_cnt == 0))
00000e  2d00              CMP      r5,#0
000010  d001              BEQ      |L26.22|
000012  2c00              CMP      r4,#0
000014  d103              BNE      |L26.30|
                  |L26.22|
;;;971        {
;;;972            // Clear the current whitelist.
;;;973            m_wlisted_peer_cnt = 0;
000016  2000              MOVS     r0,#0
000018  4906              LDR      r1,|L26.52|
00001a  7008              STRB     r0,[r1,#0]
                  |L26.28|
;;;974            #if (NRF_SD_BLE_API_VERSION == 3)
;;;975                // NRF_SUCCESS, or
;;;976                // BLE_GAP_ERROR_WHITELIST_IN_USE
;;;977                return sd_ble_gap_whitelist_set(NULL, 0);
;;;978            #else
;;;979                // The cached list of whitelisted peers is already cleared; nothing to do.
;;;980                return NRF_SUCCESS;
;;;981            #endif
;;;982        }
;;;983    
;;;984        // @todo emdi: should not ever cache more than BLE_GAP_WHITELIST_ADDR_MAX_COUNT...
;;;985    
;;;986        // Copy the new whitelisted peers.
;;;987        m_wlisted_peer_cnt = peer_cnt;
;;;988        memcpy(m_wlisted_peers, p_peers, sizeof(pm_peer_id_t) * peer_cnt);
;;;989    
;;;990        #if (NRF_SD_BLE_API_VERSION == 3)
;;;991    
;;;992            ret_code_t ret;
;;;993            uint32_t   wlist_addr_cnt = 0;
;;;994    
;;;995            ble_gap_addr_t const * addr_ptrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
;;;996            ble_gap_addr_t         addrs[BLE_GAP_WHITELIST_ADDR_MAX_COUNT];
;;;997    
;;;998            memset(addrs, 0x00, sizeof(addrs));
;;;999    
;;;1000           // Fetch GAP addresses for these peers, but don't fetch IRKs.
;;;1001           ret = peers_id_keys_get(p_peers, peer_cnt, addrs, &wlist_addr_cnt, NULL, NULL);
;;;1002   
;;;1003           if (ret != NRF_SUCCESS)
;;;1004           {
;;;1005               // NRF_ERROR_NOT_FOUND,            if a peer or its data were not found.
;;;1006               // BLE_ERROR_GAP_INVALID_BLE_ADDR, if a peer address can not be used for whitelisting.
;;;1007               return ret;
;;;1008           }
;;;1009   
;;;1010           for (uint32_t i = 0; i < BLE_GAP_WHITELIST_ADDR_MAX_COUNT; i++)
;;;1011           {
;;;1012               addr_ptrs[i] = &addrs[i];
;;;1013           }
;;;1014   
;;;1015           // NRF_ERROR_DATA_SIZE,             if peer_cnt > BLE_GAP_WHITELIST_ADDR_MAX_COUNT.
;;;1016           // BLE_ERROR_GAP_WHITELIST_IN_USE,  if a whitelist is in use.
;;;1017           return sd_ble_gap_whitelist_set(addr_ptrs, peer_cnt);
;;;1018   
;;;1019       #else
;;;1020   
;;;1021           return NRF_SUCCESS;
;;;1022   
;;;1023       #endif
;;;1024   }
00001c  bd70              POP      {r4-r6,pc}
                  |L26.30|
00001e  4905              LDR      r1,|L26.52|
000020  700c              STRB     r4,[r1,#0]            ;987
000022  0062              LSLS     r2,r4,#1              ;988
000024  4629              MOV      r1,r5                 ;988
000026  4802              LDR      r0,|L26.48|
000028  f7fffffe          BL       __aeabi_memcpy
00002c  2000              MOVS     r0,#0                 ;1021
00002e  e7f5              B        |L26.28|
;;;1025   
                          ENDP

                  |L26.48|
                          DCD      m_wlisted_peers
                  |L26.52|
                          DCD      m_wlisted_peer_cnt

                          AREA ||i.internal_state_reset||, CODE, READONLY, ALIGN=2

                  internal_state_reset PROC
;;;95     
;;;96     static void internal_state_reset()
000000  2018              MOVS     r0,#0x18
;;;97     {
;;;98         m_conn_state_user_flag_id = BLE_CONN_STATE_USER_FLAG_INVALID;
000002  4907              LDR      r1,|L27.32|
000004  7008              STRB     r0,[r1,#0]
;;;99     
;;;100        for (uint32_t i = 0; i < IM_MAX_CONN_HANDLES; i++)
000006  2000              MOVS     r0,#0
000008  e007              B        |L27.26|
                  |L27.10|
;;;101        {
;;;102            m_connections[i].conn_handle = BLE_CONN_HANDLE_INVALID;
00000a  2200              MOVS     r2,#0
00000c  43d2              MVNS     r2,r2
00000e  210c              MOVS     r1,#0xc
000010  4341              MULS     r1,r0,r1
000012  4b04              LDR      r3,|L27.36|
000014  18c9              ADDS     r1,r1,r3
000016  804a              STRH     r2,[r1,#2]
000018  1c40              ADDS     r0,r0,#1              ;100
                  |L27.26|
00001a  2808              CMP      r0,#8                 ;100
00001c  d3f5              BCC      |L27.10|
;;;103        }
;;;104    }
00001e  4770              BX       lr
;;;105    
                          ENDP

                  |L27.32|
                          DCD      m_conn_state_user_flag_id
                  |L27.36|
                          DCD      m_connections

                          AREA ||i.is_valid_irk||, CODE, READONLY, ALIGN=1

                  is_valid_irk PROC
;;;209     */
;;;210    bool is_valid_irk(ble_gap_irk_t const * p_irk)
000000  4602              MOV      r2,r0
;;;211    {
;;;212        NRF_PM_DEBUG_CHECK(p_irk != NULL);
;;;213    
;;;214        for (uint32_t i = 0; i < BLE_GAP_SEC_KEY_LEN; i++)
000002  2100              MOVS     r1,#0
000004  e005              B        |L28.18|
                  |L28.6|
;;;215        {
;;;216            if (p_irk->irk[i] != 0)
000006  5c50              LDRB     r0,[r2,r1]
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L28.16|
;;;217            {
;;;218                return true;
00000c  2001              MOVS     r0,#1
                  |L28.14|
;;;219            }
;;;220        }
;;;221        return false;
;;;222    }
00000e  4770              BX       lr
                  |L28.16|
000010  1c49              ADDS     r1,r1,#1              ;214
                  |L28.18|
000012  2910              CMP      r1,#0x10              ;214
000014  d3f7              BCC      |L28.6|
000016  2000              MOVS     r0,#0                 ;221
000018  e7f9              B        |L28.14|
;;;223    
                          ENDP


                          AREA ||i.new_connection||, CODE, READONLY, ALIGN=2

                  new_connection PROC
;;;175     */
;;;176    uint8_t new_connection(uint16_t conn_handle, ble_gap_addr_t * p_ble_addr)
000000  b570              PUSH     {r4-r6,lr}
;;;177    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;178        uint8_t conn_index = IM_NO_INVALID_CONN_HANDLES;
000006  24ff              MOVS     r4,#0xff
;;;179    
;;;180        if ((p_ble_addr != NULL) && (conn_handle != BLE_CONN_HANDLE_INVALID))
000008  2e00              CMP      r6,#0
00000a  d026              BEQ      |L29.90|
00000c  4814              LDR      r0,|L29.96|
00000e  4285              CMP      r5,r0
000010  d023              BEQ      |L29.90|
;;;181        {
;;;182            ble_conn_state_user_flag_set(conn_handle, m_conn_state_user_flag_id, true);
000012  2201              MOVS     r2,#1
000014  4813              LDR      r0,|L29.100|
000016  7801              LDRB     r1,[r0,#0]  ; m_conn_state_user_flag_id
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       ble_conn_state_user_flag_set
;;;183    
;;;184            conn_index = get_connection_by_conn_handle(conn_handle);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       get_connection_by_conn_handle
000024  4604              MOV      r4,r0
;;;185            if (conn_index == IM_NO_INVALID_CONN_HANDLES)
000026  2cff              CMP      r4,#0xff
000028  d102              BNE      |L29.48|
;;;186            {
;;;187                conn_index = get_free_connection();
00002a  f7fffffe          BL       get_free_connection
00002e  4604              MOV      r4,r0
                  |L29.48|
;;;188            }
;;;189    
;;;190            if (conn_index != IM_NO_INVALID_CONN_HANDLES)
000030  2cff              CMP      r4,#0xff
000032  d012              BEQ      |L29.90|
;;;191            {
;;;192                m_connections[conn_index].conn_handle  = conn_handle;
000034  200c              MOVS     r0,#0xc
000036  4360              MULS     r0,r4,r0
000038  490b              LDR      r1,|L29.104|
00003a  1840              ADDS     r0,r0,r1
00003c  8045              STRH     r5,[r0,#2]
;;;193                m_connections[conn_index].peer_id      = PM_PEER_ID_INVALID;
00003e  2100              MOVS     r1,#0
000040  43c9              MVNS     r1,r1
000042  200c              MOVS     r0,#0xc
000044  4360              MULS     r0,r4,r0
000046  4a08              LDR      r2,|L29.104|
000048  5211              STRH     r1,[r2,r0]
;;;194                m_connections[conn_index].peer_address = *p_ble_addr;
00004a  210c              MOVS     r1,#0xc
00004c  4361              MULS     r1,r4,r1
00004e  1889              ADDS     r1,r1,r2
000050  1d08              ADDS     r0,r1,#4
000052  2207              MOVS     r2,#7
000054  4631              MOV      r1,r6
000056  f7fffffe          BL       __aeabi_memcpy
                  |L29.90|
;;;195            }
;;;196        }
;;;197        return conn_index;
00005a  4620              MOV      r0,r4
;;;198    }
00005c  bd70              POP      {r4-r6,pc}
;;;199    
                          ENDP

00005e  0000              DCW      0x0000
                  |L29.96|
                          DCD      0x0000ffff
                  |L29.100|
                          DCD      m_conn_state_user_flag_id
                  |L29.104|
                          DCD      m_connections

                          AREA ||i.peer_id_set||, CODE, READONLY, ALIGN=2

                  peer_id_set PROC
;;;574     */
;;;575    static void peer_id_set(uint16_t conn_handle, pm_peer_id_t peer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;576    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;577        uint8_t conn_index = get_connection_by_conn_handle(conn_handle);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       get_connection_by_conn_handle
00000c  4605              MOV      r5,r0
;;;578        if (conn_index != IM_NO_INVALID_CONN_HANDLES)
00000e  2dff              CMP      r5,#0xff
000010  d003              BEQ      |L30.26|
;;;579        {
;;;580            m_connections[conn_index].peer_id = peer_id;
000012  200c              MOVS     r0,#0xc
000014  4368              MULS     r0,r5,r0
000016  4901              LDR      r1,|L30.28|
000018  520c              STRH     r4,[r1,r0]
                  |L30.26|
;;;581        }
;;;582    }
00001a  bd70              POP      {r4-r6,pc}
;;;583    
                          ENDP

                  |L30.28|
                          DCD      m_connections

                          AREA ||i.peers_id_keys_get||, CODE, READONLY, ALIGN=2

                  peers_id_keys_get PROC
;;;612     */
;;;613    static ret_code_t peers_id_keys_get(pm_peer_id_t   const * p_peers,
000000  b5ff              PUSH     {r0-r7,lr}
;;;614                                        uint32_t               peer_cnt,
;;;615                                        ble_gap_addr_t       * p_gap_addrs,
;;;616                                        uint32_t             * p_addr_cnt,
;;;617                                        ble_gap_irk_t        * p_gap_irks,
;;;618                                        uint32_t             * p_irk_cnt)
;;;619    {
000002  b09b              SUB      sp,sp,#0x6c
000004  461c              MOV      r4,r3
000006  9e25              LDR      r6,[sp,#0x94]
;;;620        ret_code_t ret;
;;;621    
;;;622        pm_peer_data_bonding_t bond_data;
;;;623        pm_peer_data_t         peer_data;
;;;624    
;;;625        uint32_t const buf_size = sizeof(bond_data);
000008  2050              MOVS     r0,#0x50
00000a  9004              STR      r0,[sp,#0x10]
;;;626    
;;;627        bool copy_addrs = false;
00000c  2000              MOVS     r0,#0
00000e  9003              STR      r0,[sp,#0xc]
;;;628        bool copy_irks  = false;
000010  9002              STR      r0,[sp,#8]
;;;629    
;;;630        NRF_PM_DEBUG_CHECK(p_peers != NULL);
;;;631    
;;;632        // One of these two has to be provided.
;;;633        NRF_PM_DEBUG_CHECK((p_gap_addrs != NULL) || (p_gap_irks != NULL));
;;;634    
;;;635        if ((p_gap_addrs != NULL) && (p_addr_cnt != NULL))
000012  981d              LDR      r0,[sp,#0x74]
000014  2800              CMP      r0,#0
000016  d005              BEQ      |L31.36|
000018  2c00              CMP      r4,#0
00001a  d003              BEQ      |L31.36|
;;;636        {
;;;637            NRF_PM_DEBUG_CHECK((*p_addr_cnt) >= peer_cnt);
;;;638    
;;;639            copy_addrs  = true;
00001c  2001              MOVS     r0,#1
00001e  9003              STR      r0,[sp,#0xc]
;;;640            *p_addr_cnt = 0;
000020  2000              MOVS     r0,#0
000022  6020              STR      r0,[r4,#0]
                  |L31.36|
;;;641        }
;;;642    
;;;643        if ((p_gap_irks != NULL) && (p_irk_cnt != NULL))
000024  9824              LDR      r0,[sp,#0x90]
000026  2800              CMP      r0,#0
000028  d005              BEQ      |L31.54|
00002a  2e00              CMP      r6,#0
00002c  d003              BEQ      |L31.54|
;;;644        {
;;;645            NRF_PM_DEBUG_CHECK((*p_irk_cnt) >= peer_cnt);
;;;646    
;;;647            copy_irks  = true;
00002e  2001              MOVS     r0,#1
000030  9002              STR      r0,[sp,#8]
;;;648            *p_irk_cnt = 0;
000032  2000              MOVS     r0,#0
000034  6030              STR      r0,[r6,#0]
                  |L31.54|
;;;649        }
;;;650    
;;;651        memset(&peer_data, 0x00, sizeof(peer_data));
000036  2000              MOVS     r0,#0
000038  9005              STR      r0,[sp,#0x14]
00003a  9006              STR      r0,[sp,#0x18]
;;;652        peer_data.p_bonding_data = &bond_data;
00003c  a807              ADD      r0,sp,#0x1c
00003e  9006              STR      r0,[sp,#0x18]
;;;653    
;;;654        // Read through flash memory and look for peers ID keys.
;;;655    
;;;656        for (uint32_t i = 0; i < peer_cnt; i++)
000040  2500              MOVS     r5,#0
000042  e03d              B        |L31.192|
                  |L31.68|
;;;657        {
;;;658            memset(&bond_data, 0x00, sizeof(bond_data));
000044  2150              MOVS     r1,#0x50
000046  a807              ADD      r0,sp,#0x1c
000048  f7fffffe          BL       __aeabi_memclr4
;;;659    
;;;660            // Read peer data from flash.
;;;661            ret = pds_peer_data_read(p_peers[i], PM_PEER_DATA_ID_BONDING,
00004c  0069              LSLS     r1,r5,#1
00004e  981b              LDR      r0,[sp,#0x6c]
000050  5a40              LDRH     r0,[r0,r1]
000052  ab04              ADD      r3,sp,#0x10
000054  aa05              ADD      r2,sp,#0x14
000056  2107              MOVS     r1,#7
000058  9000              STR      r0,[sp,#0]
00005a  f7fffffe          BL       pds_peer_data_read
00005e  4607              MOV      r7,r0
;;;662                                     &peer_data, &buf_size);
;;;663    
;;;664            if ((ret == NRF_ERROR_NOT_FOUND) || (ret == NRF_ERROR_INVALID_PARAM))
000060  2f05              CMP      r7,#5
000062  d001              BEQ      |L31.104|
000064  2f07              CMP      r7,#7
000066  d102              BNE      |L31.110|
                  |L31.104|
;;;665            {
;;;666                // Peer data coulnd't be found in flash or peer ID is not valid.
;;;667                return NRF_ERROR_NOT_FOUND;
000068  2005              MOVS     r0,#5
                  |L31.106|
;;;668            }
;;;669    
;;;670            uint8_t const addr_type = bond_data.peer_ble_id.id_addr_info.addr_type;
;;;671    
;;;672            if ((addr_type != BLE_GAP_ADDR_TYPE_PUBLIC) &&
;;;673                (addr_type != BLE_GAP_ADDR_TYPE_RANDOM_STATIC))
;;;674            {
;;;675                // The address shared by the peer during bonding can't be used for whitelisting.
;;;676                return BLE_ERROR_GAP_INVALID_BLE_ADDR;
;;;677            }
;;;678    
;;;679            // Copy the GAP address.
;;;680            if (copy_addrs)
;;;681            {
;;;682                memcpy(&p_gap_addrs[i], &bond_data.peer_ble_id.id_addr_info, sizeof(ble_gap_addr_t));
;;;683                (*p_addr_cnt)++;
;;;684            }
;;;685    
;;;686            // Copy the IRK.
;;;687            if (copy_irks)
;;;688            {
;;;689                memcpy(&p_gap_irks[i], bond_data.peer_ble_id.id_info.irk, BLE_GAP_SEC_KEY_LEN);
;;;690                (*p_irk_cnt)++;
;;;691            }
;;;692        }
;;;693    
;;;694        return NRF_SUCCESS;
;;;695    }
00006a  b01f              ADD      sp,sp,#0x7c
00006c  bdf0              POP      {r4-r7,pc}
                  |L31.110|
00006e  a807              ADD      r0,sp,#0x1c           ;670
000070  7c40              LDRB     r0,[r0,#0x11]         ;670
000072  9001              STR      r0,[sp,#4]            ;670
000074  9801              LDR      r0,[sp,#4]            ;672
000076  2800              CMP      r0,#0                 ;672
000078  d004              BEQ      |L31.132|
00007a  9801              LDR      r0,[sp,#4]            ;673
00007c  2801              CMP      r0,#1                 ;673
00007e  d001              BEQ      |L31.132|
000080  4812              LDR      r0,|L31.204|
000082  e7f2              B        |L31.106|
                  |L31.132|
000084  9803              LDR      r0,[sp,#0xc]          ;680
000086  2800              CMP      r0,#0                 ;680
000088  d00b              BEQ      |L31.162|
00008a  00e9              LSLS     r1,r5,#3              ;682
00008c  1b4a              SUBS     r2,r1,r5              ;682
00008e  991d              LDR      r1,[sp,#0x74]         ;682
000090  1850              ADDS     r0,r2,r1              ;682
000092  2207              MOVS     r2,#7                 ;682
000094  a90b              ADD      r1,sp,#0x2c           ;682
000096  3101              ADDS     r1,#1                 ;682
000098  f7fffffe          BL       __aeabi_memcpy
00009c  6820              LDR      r0,[r4,#0]            ;683
00009e  1c40              ADDS     r0,r0,#1              ;683
0000a0  6020              STR      r0,[r4,#0]            ;683
                  |L31.162|
0000a2  9802              LDR      r0,[sp,#8]            ;687
0000a4  2800              CMP      r0,#0                 ;687
0000a6  d00a              BEQ      |L31.190|
0000a8  012a              LSLS     r2,r5,#4              ;689
0000aa  9924              LDR      r1,[sp,#0x90]         ;689
0000ac  1850              ADDS     r0,r2,r1              ;689
0000ae  2210              MOVS     r2,#0x10              ;689
0000b0  a907              ADD      r1,sp,#0x1c           ;689
0000b2  3101              ADDS     r1,#1                 ;689
0000b4  f7fffffe          BL       __aeabi_memcpy
0000b8  6830              LDR      r0,[r6,#0]            ;690
0000ba  1c40              ADDS     r0,r0,#1              ;690
0000bc  6030              STR      r0,[r6,#0]            ;690
                  |L31.190|
0000be  1c6d              ADDS     r5,r5,#1              ;656
                  |L31.192|
0000c0  981c              LDR      r0,[sp,#0x70]         ;656
0000c2  4285              CMP      r5,r0                 ;656
0000c4  d3be              BCC      |L31.68|
0000c6  2000              MOVS     r0,#0                 ;694
0000c8  e7cf              B        |L31.106|
;;;696    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L31.204|
                          DCD      0x00003202

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  m_connections
                          %        96
                  m_wlisted_peers
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_evt_handlers
                          DCD      pm_im_evt_handler
                          DCD      gcm_im_evt_handler

                          AREA ||.data||, DATA, ALIGN=0

                  m_module_initialized
000000  00                DCB      0x00
                  m_conn_state_user_flag_id
000001  00                DCB      0x00
                  m_wlisted_peer_cnt
000002  00                DCB      0x00
                  m_current_id_addr
000003  00                DCB      0x00
                          DCDU     0x00000000
000008  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\peer_manager\\id_manager.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_id_manager_c_40579113____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_id_manager_c_40579113____REVSH|
#line 144
|__asm___12_id_manager_c_40579113____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
