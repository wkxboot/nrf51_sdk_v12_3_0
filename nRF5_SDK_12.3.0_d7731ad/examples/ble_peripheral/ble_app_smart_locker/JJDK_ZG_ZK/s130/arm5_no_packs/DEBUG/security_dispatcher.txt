; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\security_dispatcher.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\security_dispatcher.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\security_dispatcher.crf ..\..\..\..\..\..\components\ble\peer_manager\security_dispatcher.c]
                          THUMB

                          AREA ||i.auth_status_failure_process||, CODE, READONLY, ALIGN=1

                  auth_status_failure_process PROC
;;;460     */
;;;461    static void auth_status_failure_process(ble_gap_evt_t * p_gap_evt)
000000  b510              PUSH     {r4,lr}
;;;462    {
000002  4604              MOV      r4,r0
;;;463        link_secure_failure(p_gap_evt->conn_handle,
000004  7963              LDRB     r3,[r4,#5]
000006  079a              LSLS     r2,r3,#30
000008  0f92              LSRS     r2,r2,#30
00000a  7921              LDRB     r1,[r4,#4]
00000c  8820              LDRH     r0,[r4,#0]
00000e  f7fffffe          BL       link_secure_failure
;;;464                            p_gap_evt->params.auth_status.auth_status,
;;;465                            p_gap_evt->params.auth_status.error_src);
;;;466    }
000012  bd10              POP      {r4,pc}
;;;467    
                          ENDP


                          AREA ||i.auth_status_process||, CODE, READONLY, ALIGN=1

                  auth_status_process PROC
;;;472     */
;;;473    static void auth_status_process(ble_gap_evt_t * p_gap_evt)
000000  b510              PUSH     {r4,lr}
;;;474    {
000002  4604              MOV      r4,r0
;;;475        switch (p_gap_evt->params.auth_status.auth_status)
000004  7920              LDRB     r0,[r4,#4]
000006  2800              CMP      r0,#0
000008  d103              BNE      |L2.18|
;;;476        {
;;;477            case BLE_GAP_SEC_STATUS_SUCCESS:
;;;478                auth_status_success_process(p_gap_evt);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       auth_status_success_process
;;;479                break;
000010  e003              B        |L2.26|
                  |L2.18|
;;;480    
;;;481            default:
;;;482                auth_status_failure_process(p_gap_evt);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       auth_status_failure_process
;;;483                break;
000018  bf00              NOP      
                  |L2.26|
00001a  bf00              NOP                            ;479
;;;484        }
;;;485    }
00001c  bd10              POP      {r4,pc}
;;;486    
                          ENDP


                          AREA ||i.auth_status_success_process||, CODE, READONLY, ALIGN=2

                  auth_status_success_process PROC
;;;271     */
;;;272    static void auth_status_success_process(ble_gap_evt_t * p_gap_evt)
000000  b5f0              PUSH     {r4-r7,lr}
;;;273    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
;;;274        ret_code_t           err_code   = NRF_SUCCESS;
000006  2500              MOVS     r5,#0
;;;275        uint8_t              role       = ble_conn_state_role(p_gap_evt->conn_handle);
000008  8820              LDRH     r0,[r4,#0]
00000a  f7fffffe          BL       ble_conn_state_role
00000e  4607              MOV      r7,r0
;;;276        pm_peer_id_t         peer_id    = im_peer_id_get_by_conn_handle(p_gap_evt->conn_handle);
000010  8820              LDRH     r0,[r4,#0]
000012  f7fffffe          BL       im_peer_id_get_by_conn_handle
000016  4606              MOV      r6,r0
;;;277        ble_gap_sec_kdist_t  kdist_own  = p_gap_evt->params.auth_status.kdist_own;
000018  68a0              LDR      r0,[r4,#8]
00001a  9008              STR      r0,[sp,#0x20]
;;;278        ble_gap_sec_kdist_t  kdist_peer = p_gap_evt->params.auth_status.kdist_peer;
00001c  7a60              LDRB     r0,[r4,#9]
00001e  9007              STR      r0,[sp,#0x1c]
;;;279    
;;;280        ble_conn_state_user_flag_set(p_gap_evt->conn_handle, m_flag_sec_proc, false);
000020  8820              LDRH     r0,[r4,#0]
000022  2200              MOVS     r2,#0
000024  4922              LDR      r1,|L3.176|
000026  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc
000028  f7fffffe          BL       ble_conn_state_user_flag_set
;;;281    
;;;282        if (role == BLE_GAP_ROLE_INVALID)
00002c  2f00              CMP      r7,#0
00002e  d101              BNE      |L3.52|
                  |L3.48|
;;;283        {
;;;284            /* Unlikely, but maybe possible? */
;;;285            return;
;;;286        }
;;;287    
;;;288        if (p_gap_evt->params.auth_status.bonded)
;;;289        {
;;;290    
;;;291            err_code = pdb_write_buf_store(peer_id, PM_PEER_DATA_ID_BONDING);
;;;292            if (err_code != NRF_SUCCESS)
;;;293            {
;;;294                /* Unexpected */
;;;295                smd_evt_t error_evt;
;;;296    
;;;297                error_evt.evt_id                            = SMD_EVT_ERROR_BONDING_INFO;
;;;298                error_evt.conn_handle                       = p_gap_evt->conn_handle;
;;;299                error_evt.params.error_bonding_info.peer_id = peer_id;
;;;300                error_evt.params.error_bonding_info.error   = err_code;
;;;301    
;;;302                evt_send(&error_evt);
;;;303            }
;;;304    
;;;305        }
;;;306        else if (ble_conn_state_user_flag_get(p_gap_evt->conn_handle, m_flag_sec_proc_new_peer))
;;;307        {
;;;308            ret_code_t err_code_free = im_peer_free(peer_id);
;;;309            UNUSED_VARIABLE(err_code_free); // Errors can be safely ignored.
;;;310        }
;;;311    
;;;312        smd_evt_t pairing_success_evt;
;;;313    
;;;314        pairing_success_evt.evt_id                            = SMD_EVT_PAIRING_SUCCESS;
;;;315        pairing_success_evt.conn_handle                       = p_gap_evt->conn_handle;
;;;316        pairing_success_evt.params.pairing_success.bonded     = p_gap_evt->params.auth_status.bonded;
;;;317        pairing_success_evt.params.pairing_success.mitm       = p_gap_evt->params.auth_status.sm1_levels.lv3;
;;;318        pairing_success_evt.params.pairing_success.kdist_own  = kdist_own;
;;;319        pairing_success_evt.params.pairing_success.kdist_peer = kdist_peer;
;;;320    
;;;321        evt_send(&pairing_success_evt);
;;;322        return;
;;;323    }
000030  b009              ADD      sp,sp,#0x24
000032  bdf0              POP      {r4-r7,pc}
                  |L3.52|
000034  7960              LDRB     r0,[r4,#5]            ;288
000036  0740              LSLS     r0,r0,#29             ;288
000038  0fc0              LSRS     r0,r0,#31             ;288
00003a  2800              CMP      r0,#0                 ;288
00003c  d011              BEQ      |L3.98|
00003e  2107              MOVS     r1,#7                 ;291
000040  4630              MOV      r0,r6                 ;291
000042  f7fffffe          BL       pdb_write_buf_store
000046  4605              MOV      r5,r0                 ;291
000048  2d00              CMP      r5,#0                 ;292
00004a  d016              BEQ      |L3.122|
00004c  2108              MOVS     r1,#8                 ;297
00004e  4668              MOV      r0,sp                 ;297
000050  7101              STRB     r1,[r0,#4]            ;297
000052  8821              LDRH     r1,[r4,#0]            ;298
000054  80c1              STRH     r1,[r0,#6]            ;298
000056  8106              STRH     r6,[r0,#8]            ;299
000058  9503              STR      r5,[sp,#0xc]          ;300
00005a  a801              ADD      r0,sp,#4              ;302
00005c  f7fffffe          BL       evt_send
000060  e00b              B        |L3.122|
                  |L3.98|
000062  8820              LDRH     r0,[r4,#0]            ;306
000064  4913              LDR      r1,|L3.180|
000066  7809              LDRB     r1,[r1,#0]            ;306  ; m_flag_sec_proc_new_peer
000068  f7fffffe          BL       ble_conn_state_user_flag_get
00006c  2800              CMP      r0,#0                 ;306
00006e  d004              BEQ      |L3.122|
000070  4630              MOV      r0,r6                 ;308
000072  f7fffffe          BL       im_peer_free
000076  9003              STR      r0,[sp,#0xc]          ;308
000078  bf00              NOP                            ;310
                  |L3.122|
00007a  2103              MOVS     r1,#3                 ;314
00007c  4668              MOV      r0,sp                 ;314
00007e  7401              STRB     r1,[r0,#0x10]         ;314
000080  8821              LDRH     r1,[r4,#0]            ;315
000082  8241              STRH     r1,[r0,#0x12]         ;315
000084  7960              LDRB     r0,[r4,#5]            ;316
000086  0740              LSLS     r0,r0,#29             ;316
000088  0fc1              LSRS     r1,r0,#31             ;316
00008a  4668              MOV      r0,sp                 ;316
00008c  7501              STRB     r1,[r0,#0x14]         ;316
00008e  79a0              LDRB     r0,[r4,#6]            ;317
000090  0740              LSLS     r0,r0,#29             ;317
000092  0fc1              LSRS     r1,r0,#31             ;317
000094  a804              ADD      r0,sp,#0x10           ;317
000096  7141              STRB     r1,[r0,#5]            ;317
000098  1d81              ADDS     r1,r0,#6              ;318
00009a  a808              ADD      r0,sp,#0x20           ;318
00009c  7800              LDRB     r0,[r0,#0]            ;318
00009e  7008              STRB     r0,[r1,#0]            ;318
0000a0  a804              ADD      r0,sp,#0x10           ;319
0000a2  4669              MOV      r1,sp                 ;319
0000a4  7f09              LDRB     r1,[r1,#0x1c]         ;319
0000a6  71c1              STRB     r1,[r0,#7]            ;319
0000a8  f7fffffe          BL       evt_send
0000ac  bf00              NOP                            ;322
0000ae  e7bf              B        |L3.48|
;;;324    
                          ENDP

                  |L3.176|
                          DCD      m_flag_sec_proc
                  |L3.180|
                          DCD      m_flag_sec_proc_new_peer

                          AREA ||i.conn_sec_update_process||, CODE, READONLY, ALIGN=2

                  conn_sec_update_process PROC
;;;491     */
;;;492    static void conn_sec_update_process(ble_gap_evt_t * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;493    {
000002  4604              MOV      r4,r0
;;;494        if (ble_conn_state_encrypted(p_gap_evt->conn_handle))
000004  8820              LDRH     r0,[r4,#0]
000006  f7fffffe          BL       ble_conn_state_encrypted
00000a  2800              CMP      r0,#0
00000c  d01a              BEQ      |L4.68|
;;;495        {
;;;496            if (!ble_conn_state_user_flag_get(p_gap_evt->conn_handle, m_flag_sec_proc_pairing))
00000e  8820              LDRH     r0,[r4,#0]
000010  490f              LDR      r1,|L4.80|
000012  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc_pairing
000014  f7fffffe          BL       ble_conn_state_user_flag_get
000018  2800              CMP      r0,#0
00001a  d105              BNE      |L4.40|
;;;497            {
;;;498                ble_conn_state_user_flag_set(p_gap_evt->conn_handle, m_flag_sec_proc, false);
00001c  8820              LDRH     r0,[r4,#0]
00001e  2200              MOVS     r2,#0
000020  490c              LDR      r1,|L4.84|
000022  7809              LDRB     r1,[r1,#0]  ; m_flag_sec_proc
000024  f7fffffe          BL       ble_conn_state_user_flag_set
                  |L4.40|
;;;499            }
;;;500    
;;;501            smd_evt_t evt;
;;;502    
;;;503            evt.conn_handle = p_gap_evt->conn_handle;
000028  8821              LDRH     r1,[r4,#0]
00002a  4668              MOV      r0,sp
00002c  8041              STRH     r1,[r0,#2]
;;;504            evt.evt_id = SMD_EVT_LINK_ENCRYPTION_UPDATE;
00002e  2105              MOVS     r1,#5
000030  7001              STRB     r1,[r0,#0]
;;;505            evt.params.link_encryption_update.mitm_protected
000032  8820              LDRH     r0,[r4,#0]
000034  f7fffffe          BL       ble_conn_state_mitm_protected
000038  4669              MOV      r1,sp
00003a  7108              STRB     r0,[r1,#4]
;;;506                                    = ble_conn_state_mitm_protected(p_gap_evt->conn_handle);
;;;507            evt_send(&evt);
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       evt_send
;;;508        }
000042  e004              B        |L4.78|
                  |L4.68|
;;;509        else
;;;510        {
;;;511            encryption_failure(p_gap_evt->conn_handle,
000044  8820              LDRH     r0,[r4,#0]
000046  2201              MOVS     r2,#1
000048  4903              LDR      r1,|L4.88|
00004a  f7fffffe          BL       encryption_failure
                  |L4.78|
;;;512                               PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING,
;;;513                               BLE_GAP_SEC_STATUS_SOURCE_REMOTE);
;;;514        }
;;;515    }
00004e  bd3e              POP      {r1-r5,pc}
;;;516    
                          ENDP

                  |L4.80|
                          DCD      m_flag_sec_proc_pairing
                  |L4.84|
                          DCD      m_flag_sec_proc
                  |L4.88|
                          DCD      0x00001006

                          AREA ||i.disconnect_process||, CODE, READONLY, ALIGN=2

                  disconnect_process PROC
;;;445     */
;;;446    static void disconnect_process(ble_gap_evt_t * p_gap_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;447    {
000002  4604              MOV      r4,r0
;;;448        pm_sec_error_code_t error = (p_gap_evt->params.disconnected.reason
000004  7920              LDRB     r0,[r4,#4]
000006  283d              CMP      r0,#0x3d
000008  d101              BNE      |L5.14|
;;;449                                            == BLE_HCI_CONN_TERMINATED_DUE_TO_MIC_FAILURE)
;;;450                                    ? PM_CONN_SEC_ERROR_MIC_FAILURE : PM_CONN_SEC_ERROR_DISCONNECT;
00000a  4805              LDR      r0,|L5.32|
00000c  e001              B        |L5.18|
                  |L5.14|
00000e  2011              MOVS     r0,#0x11
000010  0200              LSLS     r0,r0,#8
                  |L5.18|
000012  4605              MOV      r5,r0
;;;451    
;;;452        link_secure_failure(p_gap_evt->conn_handle, error, BLE_GAP_SEC_STATUS_SOURCE_LOCAL);
000014  8820              LDRH     r0,[r4,#0]
000016  2200              MOVS     r2,#0
000018  4629              MOV      r1,r5
00001a  f7fffffe          BL       link_secure_failure
;;;453    }
00001e  bd70              POP      {r4-r6,pc}
;;;454    
                          ENDP

                  |L5.32|
                          DCD      0x0000103d

                          AREA ||i.encryption_failure||, CODE, READONLY, ALIGN=2

                  encryption_failure PROC
;;;386     */
;;;387    static void encryption_failure(uint16_t            conn_handle,
000000  b5fe              PUSH     {r1-r7,lr}
;;;388                                   pm_sec_error_code_t error,
;;;389                                   uint8_t             error_src)
;;;390    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;391        smd_evt_t evt =
000008  4a08              LDR      r2,|L6.44|
00000a  ca07              LDM      r2,{r0-r2}
00000c  466b              MOV      r3,sp
00000e  c307              STM      r3!,{r0-r2}
000010  4668              MOV      r0,sp
000012  8044              STRH     r4,[r0,#2]
000014  8085              STRH     r5,[r0,#4]
000016  7186              STRB     r6,[r0,#6]
;;;392        {
;;;393            .evt_id = SMD_EVT_LINK_ENCRYPTION_FAILED,
;;;394            .conn_handle = conn_handle,
;;;395            .params =
;;;396            {
;;;397                .link_encryption_failed =
;;;398                {
;;;399                    .error     = error,
;;;400                    .error_src = error_src,
;;;401                }
;;;402            }
;;;403        };
;;;404    
;;;405        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, false);
000018  2200              MOVS     r2,#0
00001a  4805              LDR      r0,|L6.48|
00001c  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       ble_conn_state_user_flag_set
;;;406    
;;;407        evt_send(&evt);
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       evt_send
;;;408        return;
;;;409    }
00002a  bdfe              POP      {r1-r7,pc}
;;;410    
                          ENDP

                  |L6.44|
                          DCD      ||.constdata||+0x38
                  |L6.48|
                          DCD      m_flag_sec_proc

                          AREA ||i.evt_send||, CODE, READONLY, ALIGN=2

                  evt_send PROC
;;;78     
;;;79     static void evt_send(smd_evt_t * p_event)
000000  b570              PUSH     {r4-r6,lr}
;;;80     {
000002  4605              MOV      r5,r0
;;;81         for (uint32_t i = 0; i < SMD_EVENT_HANDLERS_CNT; i++)
000004  2400              MOVS     r4,#0
000006  e005              B        |L7.20|
                  |L7.8|
;;;82         {
;;;83             m_evt_handlers[i](p_event);
000008  00a0              LSLS     r0,r4,#2
00000a  4a04              LDR      r2,|L7.28|
00000c  5811              LDR      r1,[r2,r0]
00000e  4628              MOV      r0,r5
000010  4788              BLX      r1
000012  1c64              ADDS     r4,r4,#1              ;81
                  |L7.20|
000014  2c02              CMP      r4,#2                 ;81
000016  d3f7              BCC      |L7.8|
;;;84         }
;;;85     }
000018  bd70              POP      {r4-r6,pc}
;;;86     
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      m_evt_handlers

                          AREA ||i.flag_id_init||, CODE, READONLY, ALIGN=1

                  flag_id_init PROC
;;;521     */
;;;522    static void flag_id_init(ble_conn_state_user_flag_id_t * p_flag_id)
000000  b510              PUSH     {r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524        if (*p_flag_id == BLE_CONN_STATE_USER_FLAG_INVALID)
000004  7820              LDRB     r0,[r4,#0]
000006  2818              CMP      r0,#0x18
000008  d102              BNE      |L8.16|
;;;525        {
;;;526            *p_flag_id = ble_conn_state_user_flag_acquire();
00000a  f7fffffe          BL       ble_conn_state_user_flag_acquire
00000e  7020              STRB     r0,[r4,#0]
                  |L8.16|
;;;527        }
;;;528    }
000010  bd10              POP      {r4,pc}
;;;529    
                          ENDP


                          AREA ||i.link_secure_central||, CODE, READONLY, ALIGN=2

                  link_secure_central PROC
;;;783    
;;;784    static ret_code_t link_secure_central(uint16_t               conn_handle,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;785                                          ble_gap_sec_params_t * p_sec_params,
;;;786                                          bool                   force_repairing)
;;;787    {
000002  b082              SUB      sp,sp,#8
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;788        ret_code_t           err_code;
;;;789        pm_peer_id_t         peer_id;
;;;790    
;;;791        if (p_sec_params == NULL)
000008  2e00              CMP      r6,#0
00000a  d103              BNE      |L9.20|
;;;792        {
;;;793            return sd_ble_gap_authenticate(conn_handle, NULL);
00000c  4638              MOV      r0,r7
00000e  df7e              SVC      #0x7e
                  |L9.16|
;;;794        }
;;;795    
;;;796        pm_conn_sec_procedure_t procedure = p_sec_params->bond ? PM_LINK_SECURED_PROCEDURE_BONDING
;;;797                                                               : PM_LINK_SECURED_PROCEDURE_PAIRING;
;;;798    
;;;799        peer_id = im_peer_id_get_by_conn_handle(conn_handle);
;;;800    
;;;801        if (peer_id != PM_PEER_ID_INVALID)
;;;802        {
;;;803            // There is already data in flash for this peer.
;;;804            err_code = link_secure_central_existing_peer(conn_handle,
;;;805                                                         p_sec_params,
;;;806                                                         force_repairing,
;;;807                                                         peer_id,
;;;808                                                         &procedure);
;;;809        }
;;;810        else if (p_sec_params->bond)
;;;811        {
;;;812            // New peer is required.
;;;813            err_code = link_secure_central_new_peer(conn_handle, p_sec_params);
;;;814        }
;;;815        else
;;;816        {
;;;817            // No bonding, only pairing.
;;;818            err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
;;;819    
;;;820            sec_proc_start(conn_handle, peer_id, err_code == NRF_SUCCESS, true, false);
;;;821        }
;;;822    
;;;823        if (err_code == NRF_SUCCESS)
;;;824        {
;;;825            sec_start_send(conn_handle, procedure);
;;;826        }
;;;827    
;;;828        return err_code;
;;;829    }
000010  b005              ADD      sp,sp,#0x14
000012  bdf0              POP      {r4-r7,pc}
                  |L9.20|
000014  7830              LDRB     r0,[r6,#0]            ;796
000016  07c0              LSLS     r0,r0,#31             ;796
000018  0fc0              LSRS     r0,r0,#31             ;796
00001a  2800              CMP      r0,#0                 ;796
00001c  d001              BEQ      |L9.34|
00001e  2001              MOVS     r0,#1                 ;796
000020  e000              B        |L9.36|
                  |L9.34|
000022  2002              MOVS     r0,#2                 ;797
                  |L9.36|
000024  9001              STR      r0,[sp,#4]            ;797
000026  4638              MOV      r0,r7                 ;799
000028  f7fffffe          BL       im_peer_id_get_by_conn_handle
00002c  4605              MOV      r5,r0                 ;799
00002e  4919              LDR      r1,|L9.148|
000030  428d              CMP      r5,r1                 ;801
000032  d009              BEQ      |L9.72|
000034  a801              ADD      r0,sp,#4              ;804
000036  462b              MOV      r3,r5                 ;804
000038  9000              STR      r0,[sp,#0]            ;804
00003a  4631              MOV      r1,r6                 ;804
00003c  4638              MOV      r0,r7                 ;804
00003e  9a04              LDR      r2,[sp,#0x10]         ;804
000040  f7fffffe          BL       link_secure_central_existing_peer
000044  4604              MOV      r4,r0                 ;804
000046  e01b              B        |L9.128|
                  |L9.72|
000048  7830              LDRB     r0,[r6,#0]            ;810
00004a  07c0              LSLS     r0,r0,#31             ;810
00004c  0fc0              LSRS     r0,r0,#31             ;810
00004e  2800              CMP      r0,#0                 ;810
000050  d005              BEQ      |L9.94|
000052  4631              MOV      r1,r6                 ;813
000054  4638              MOV      r0,r7                 ;813
000056  f7fffffe          BL       link_secure_central_new_peer
00005a  4604              MOV      r4,r0                 ;813
00005c  e010              B        |L9.128|
                  |L9.94|
00005e  4631              MOV      r1,r6                 ;818
000060  4638              MOV      r0,r7                 ;818
000062  df7e              SVC      #0x7e                 ;818
000064  4604              MOV      r4,r0                 ;818
000066  2000              MOVS     r0,#0                 ;820
000068  9000              STR      r0,[sp,#0]            ;820
00006a  2c00              CMP      r4,#0                 ;820
00006c  d101              BNE      |L9.114|
00006e  2001              MOVS     r0,#1                 ;820
000070  e000              B        |L9.116|
                  |L9.114|
000072  2000              MOVS     r0,#0                 ;820
                  |L9.116|
000074  4602              MOV      r2,r0                 ;820
000076  2301              MOVS     r3,#1                 ;820
000078  4629              MOV      r1,r5                 ;820
00007a  4638              MOV      r0,r7                 ;820
00007c  f7fffffe          BL       sec_proc_start
                  |L9.128|
000080  2c00              CMP      r4,#0                 ;823
000082  d104              BNE      |L9.142|
000084  4668              MOV      r0,sp                 ;825
000086  7901              LDRB     r1,[r0,#4]            ;825
000088  4638              MOV      r0,r7                 ;825
00008a  f7fffffe          BL       sec_start_send
                  |L9.142|
00008e  4620              MOV      r0,r4                 ;828
000090  e7be              B        |L9.16|
;;;830    
                          ENDP

000092  0000              DCW      0x0000
                  |L9.148|
                          DCD      0x0000ffff

                          AREA ||i.link_secure_central_existing_peer||, CODE, READONLY, ALIGN=1

                  link_secure_central_existing_peer PROC
;;;661    
;;;662    static ret_code_t link_secure_central_existing_peer(uint16_t                  conn_handle,
000000  b5ff              PUSH     {r0-r7,lr}
;;;663                                                        ble_gap_sec_params_t    * p_sec_params,
;;;664                                                        bool                      force_repairing,
;;;665                                                        pm_peer_id_t              peer_id,
;;;666                                                        pm_conn_sec_procedure_t * procedure)
;;;667    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
000006  461e              MOV      r6,r3
;;;668        pm_peer_data_flash_t      peer_data;
;;;669        pm_peer_data_t            dummy_peer_data;
;;;670        ret_code_t                err_code;
;;;671        ble_gap_enc_key_t const * p_existing_key = NULL;
000008  2500              MOVS     r5,#0
;;;672        bool                      lesc = false;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;673    
;;;674        err_code = pdb_peer_data_ptr_get(peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
00000e  aa05              ADD      r2,sp,#0x14
000010  2107              MOVS     r1,#7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       pdb_peer_data_ptr_get
000018  4604              MOV      r4,r0
;;;675    
;;;676        if (err_code == NRF_SUCCESS)
00001a  2c00              CMP      r4,#0
00001c  d10e              BNE      |L10.60|
;;;677        {
;;;678            // Use peer's key since they are peripheral.
;;;679            p_existing_key = &(peer_data.p_bonding_data->peer_ltk);
00001e  9806              LDR      r0,[sp,#0x18]
000020  4605              MOV      r5,r0
000022  3518              ADDS     r5,r5,#0x18
;;;680    
;;;681            lesc = peer_data.p_bonding_data->own_ltk.enc_info.lesc;
000024  9806              LDR      r0,[sp,#0x18]
000026  3034              ADDS     r0,r0,#0x34
000028  7c00              LDRB     r0,[r0,#0x10]
00002a  07c0              LSLS     r0,r0,#31
00002c  0fc0              LSRS     r0,r0,#31
00002e  9002              STR      r0,[sp,#8]
;;;682            if  (lesc) // LESC was used during bonding.
000030  9802              LDR      r0,[sp,#8]
000032  2800              CMP      r0,#0
000034  d002              BEQ      |L10.60|
;;;683            {
;;;684                // For LESC, always use own key.
;;;685                p_existing_key = &(peer_data.p_bonding_data->own_ltk);
000036  9806              LDR      r0,[sp,#0x18]
000038  4605              MOV      r5,r0
00003a  3534              ADDS     r5,r5,#0x34
                  |L10.60|
;;;686            }
;;;687        }
;;;688    
;;;689        if     (!force_repairing
00003c  9809              LDR      r0,[sp,#0x24]
00003e  2800              CMP      r0,#0
000040  d116              BNE      |L10.112|
;;;690             && (err_code == NRF_SUCCESS)
000042  2c00              CMP      r4,#0
000044  d114              BNE      |L10.112|
;;;691             && (p_existing_key != NULL)
000046  2d00              CMP      r5,#0
000048  d012              BEQ      |L10.112|
;;;692             && (lesc || im_master_id_is_valid(&(p_existing_key->master_id)))) /* There is a valid LTK stored. */
00004a  9802              LDR      r0,[sp,#8]
00004c  2800              CMP      r0,#0
00004e  d105              BNE      |L10.92|
000050  4628              MOV      r0,r5
000052  3012              ADDS     r0,r0,#0x12
000054  f7fffffe          BL       im_master_id_is_valid
000058  2800              CMP      r0,#0
00005a  d009              BEQ      |L10.112|
                  |L10.92|
;;;693             //&& (p_existing_key->enc_info.auth >= p_sec_params->mitm)          /* The requested MITM security is at or below the existing level. */
;;;694             //&& (!p_sec_params->mitm || (lesc >= p_sec_params->lesc)))         /* The requested LESC security is at or below the existing level. We only care about LESC if MITM is required. */
;;;695        {
;;;696            err_code = sd_ble_gap_encrypt(conn_handle, &(p_existing_key->master_id), &(p_existing_key->enc_info));
00005c  462a              MOV      r2,r5
00005e  4629              MOV      r1,r5
000060  3112              ADDS     r1,r1,#0x12
000062  9807              LDR      r0,[sp,#0x1c]
000064  df85              SVC      #0x85
000066  4604              MOV      r4,r0
;;;697    
;;;698            *procedure = PM_LINK_SECURED_PROCEDURE_ENCRYPTION;
000068  2100              MOVS     r1,#0
00006a  9810              LDR      r0,[sp,#0x40]
00006c  7001              STRB     r1,[r0,#0]
00006e  e02c              B        |L10.202|
                  |L10.112|
;;;699        }
;;;700        else if ((err_code == NRF_SUCCESS) || (err_code == NRF_ERROR_NOT_FOUND))
000070  2c00              CMP      r4,#0
000072  d001              BEQ      |L10.120|
000074  2c05              CMP      r4,#5
000076  d128              BNE      |L10.202|
                  |L10.120|
;;;701        {
;;;702            /* Re-pairing is needed, because there is no LTK available or the existing key is not
;;;703               secure enough */
;;;704            err_code = NRF_SUCCESS;
000078  2400              MOVS     r4,#0
;;;705    
;;;706            if (p_sec_params->bond)
00007a  7838              LDRB     r0,[r7,#0]
00007c  07c0              LSLS     r0,r0,#31
00007e  0fc0              LSRS     r0,r0,#31
000080  2800              CMP      r0,#0
000082  d00d              BEQ      |L10.160|
;;;707            {
;;;708                err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &dummy_peer_data);
000084  ab03              ADD      r3,sp,#0xc
000086  2201              MOVS     r2,#1
000088  2107              MOVS     r1,#7
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       pdb_write_buf_get
000090  4604              MOV      r4,r0
;;;709                if (err_code == NRF_SUCCESS)
000092  2c00              CMP      r4,#0
000094  d104              BNE      |L10.160|
;;;710                {
;;;711                    err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
000096  2107              MOVS     r1,#7
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       pdb_write_buf_store_prepare
00009e  4604              MOV      r4,r0
                  |L10.160|
;;;712                }
;;;713            }
;;;714    
;;;715            if (err_code == NRF_SUCCESS)
0000a0  2c00              CMP      r4,#0
0000a2  d103              BNE      |L10.172|
;;;716            {
;;;717                err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
0000a4  4639              MOV      r1,r7
0000a6  9807              LDR      r0,[sp,#0x1c]
0000a8  df7e              SVC      #0x7e
0000aa  4604              MOV      r4,r0
                  |L10.172|
;;;718            }
;;;719    
;;;720            if (err_code != NRF_SUCCESS)
0000ac  2c00              CMP      r4,#0
0000ae  d00c              BEQ      |L10.202|
;;;721            {
;;;722                ret_code_t err_code_release = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
0000b0  2107              MOVS     r1,#7
0000b2  4630              MOV      r0,r6
0000b4  f7fffffe          BL       pdb_write_buf_release
0000b8  9001              STR      r0,[sp,#4]
;;;723                if ((err_code_release != NRF_SUCCESS) && (err_code_release != NRF_ERROR_NOT_FOUND))
0000ba  9801              LDR      r0,[sp,#4]
0000bc  2800              CMP      r0,#0
0000be  d003              BEQ      |L10.200|
0000c0  9801              LDR      r0,[sp,#4]
0000c2  2805              CMP      r0,#5
0000c4  d000              BEQ      |L10.200|
;;;724                {
;;;725                    err_code = NRF_ERROR_INTERNAL;
0000c6  2403              MOVS     r4,#3
                  |L10.200|
;;;726                }
;;;727            }
0000c8  bf00              NOP      
                  |L10.202|
;;;728        }
;;;729    
;;;730        sec_proc_start(conn_handle,
0000ca  2000              MOVS     r0,#0
0000cc  9000              STR      r0,[sp,#0]
0000ce  9810              LDR      r0,[sp,#0x40]
0000d0  7800              LDRB     r0,[r0,#0]
0000d2  2800              CMP      r0,#0
0000d4  d001              BEQ      |L10.218|
0000d6  2001              MOVS     r0,#1
0000d8  e000              B        |L10.220|
                  |L10.218|
0000da  2000              MOVS     r0,#0
                  |L10.220|
0000dc  4603              MOV      r3,r0
0000de  2c00              CMP      r4,#0
0000e0  d101              BNE      |L10.230|
0000e2  2001              MOVS     r0,#1
0000e4  e000              B        |L10.232|
                  |L10.230|
0000e6  2000              MOVS     r0,#0
                  |L10.232|
0000e8  4602              MOV      r2,r0
0000ea  4631              MOV      r1,r6
0000ec  9807              LDR      r0,[sp,#0x1c]
0000ee  f7fffffe          BL       sec_proc_start
;;;731                       peer_id,
;;;732                       err_code == NRF_SUCCESS,
;;;733                       *procedure != PM_LINK_SECURED_PROCEDURE_ENCRYPTION,
;;;734                       false);
;;;735    
;;;736        return err_code;
0000f2  4620              MOV      r0,r4
;;;737    }
0000f4  b00b              ADD      sp,sp,#0x2c
0000f6  bdf0              POP      {r4-r7,pc}
;;;738    
                          ENDP


                          AREA ||i.link_secure_central_new_peer||, CODE, READONLY, ALIGN=2

                  link_secure_central_new_peer PROC
;;;739    
;;;740    static ret_code_t link_secure_central_new_peer(uint16_t               conn_handle,
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;741                                                   ble_gap_sec_params_t * p_sec_params)
;;;742    {
000002  b083              SUB      sp,sp,#0xc
000004  4607              MOV      r7,r0
;;;743        pm_peer_id_t    peer_id = pdb_peer_allocate();
000006  f7fffffe          BL       pdb_peer_allocate
00000a  4605              MOV      r5,r0
;;;744        pm_peer_data_t  dummy_peer_data;
;;;745        ret_code_t      err_code;
;;;746    
;;;747        if (peer_id != PM_PEER_ID_INVALID)
00000c  481c              LDR      r0,|L11.128|
00000e  4285              CMP      r5,r0
000010  d020              BEQ      |L11.84|
;;;748        {
;;;749            err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &dummy_peer_data);
000012  ab01              ADD      r3,sp,#4
000014  2201              MOVS     r2,#1
000016  2107              MOVS     r1,#7
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       pdb_write_buf_get
00001e  4604              MOV      r4,r0
;;;750            if (err_code == NRF_SUCCESS)
000020  2c00              CMP      r4,#0
000022  d104              BNE      |L11.46|
;;;751            {
;;;752                err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
000024  2107              MOVS     r1,#7
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       pdb_write_buf_store_prepare
00002c  4604              MOV      r4,r0
                  |L11.46|
;;;753            }
;;;754    
;;;755            if (err_code == NRF_SUCCESS)
00002e  2c00              CMP      r4,#0
000030  d103              BNE      |L11.58|
;;;756            {
;;;757                err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000032  4638              MOV      r0,r7
000034  9904              LDR      r1,[sp,#0x10]
000036  df7e              SVC      #0x7e
000038  4604              MOV      r4,r0
                  |L11.58|
;;;758            }
;;;759    
;;;760            if (err_code != NRF_SUCCESS)
00003a  2c00              CMP      r4,#0
00003c  d00b              BEQ      |L11.86|
;;;761            {
;;;762                ret_code_t err_code_free = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
00003e  2107              MOVS     r1,#7
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       pdb_write_buf_release
000046  4606              MOV      r6,r0
;;;763                if ((err_code_free != NRF_SUCCESS) && (err_code_free != NRF_ERROR_NOT_FOUND))
000048  2e00              CMP      r6,#0
00004a  d002              BEQ      |L11.82|
00004c  2e05              CMP      r6,#5
00004e  d000              BEQ      |L11.82|
;;;764                {
;;;765                    err_code = NRF_ERROR_INTERNAL;
000050  2403              MOVS     r4,#3
                  |L11.82|
;;;766                }
;;;767            }
000052  e000              B        |L11.86|
                  |L11.84|
;;;768        }
;;;769        else
;;;770        {
;;;771            err_code = NRF_ERROR_INTERNAL;
000054  2403              MOVS     r4,#3
                  |L11.86|
;;;772        }
;;;773    
;;;774        sec_proc_start(conn_handle,
000056  480a              LDR      r0,|L11.128|
000058  4285              CMP      r5,r0
00005a  d001              BEQ      |L11.96|
00005c  2001              MOVS     r0,#1
00005e  e000              B        |L11.98|
                  |L11.96|
000060  2000              MOVS     r0,#0
                  |L11.98|
000062  9000              STR      r0,[sp,#0]
000064  2c00              CMP      r4,#0
000066  d101              BNE      |L11.108|
000068  2001              MOVS     r0,#1
00006a  e000              B        |L11.110|
                  |L11.108|
00006c  2000              MOVS     r0,#0
                  |L11.110|
00006e  4602              MOV      r2,r0
000070  2301              MOVS     r3,#1
000072  4629              MOV      r1,r5
000074  4638              MOV      r0,r7
000076  f7fffffe          BL       sec_proc_start
;;;775                       peer_id,
;;;776                       err_code == NRF_SUCCESS,
;;;777                       true,
;;;778                       peer_id != PM_PEER_ID_INVALID);
;;;779    
;;;780        return err_code;
00007a  4620              MOV      r0,r4
;;;781    }
00007c  b005              ADD      sp,sp,#0x14
00007e  bdf0              POP      {r4-r7,pc}
;;;782    
                          ENDP

                  |L11.128|
                          DCD      0x0000ffff

                          AREA ||i.link_secure_failure||, CODE, READONLY, ALIGN=2

                  link_secure_failure PROC
;;;418     */
;;;419    static void link_secure_failure(uint16_t            conn_handle,
000000  b5f8              PUSH     {r3-r7,lr}
;;;420                                    pm_sec_error_code_t error,
;;;421                                    uint8_t             error_src)
;;;422    {
000002  4607              MOV      r7,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;423        if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc))
000008  4811              LDR      r0,|L12.80|
00000a  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       ble_conn_state_user_flag_get
000012  2800              CMP      r0,#0
000014  d01a              BEQ      |L12.76|
;;;424        {
;;;425            pm_peer_id_t  peer_id = im_peer_id_get_by_conn_handle(conn_handle);
000016  4638              MOV      r0,r7
000018  f7fffffe          BL       im_peer_id_get_by_conn_handle
00001c  4606              MOV      r6,r0
;;;426    
;;;427            if (peer_id != PM_PEER_ID_INVALID)
00001e  480d              LDR      r0,|L12.84|
000020  4286              CMP      r6,r0
000022  d012              BEQ      |L12.74|
;;;428            {
;;;429                if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc_pairing))
000024  480c              LDR      r0,|L12.88|
000026  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_pairing
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       ble_conn_state_user_flag_get
00002e  2800              CMP      r0,#0
000030  d006              BEQ      |L12.64|
;;;430                {
;;;431                    pairing_failure(conn_handle, peer_id, error, error_src);
000032  462b              MOV      r3,r5
000034  4622              MOV      r2,r4
000036  4631              MOV      r1,r6
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       pairing_failure
00003e  e004              B        |L12.74|
                  |L12.64|
;;;432                }
;;;433                else
;;;434                {
;;;435                    encryption_failure(conn_handle, error, error_src);
000040  462a              MOV      r2,r5
000042  4621              MOV      r1,r4
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       encryption_failure
                  |L12.74|
;;;436                }
;;;437            }
;;;438        }
00004a  bf00              NOP      
                  |L12.76|
;;;439    }
00004c  bdf8              POP      {r3-r7,pc}
;;;440    
                          ENDP

00004e  0000              DCW      0x0000
                  |L12.80|
                          DCD      m_flag_sec_proc
                  |L12.84|
                          DCD      0x0000ffff
                  |L12.88|
                          DCD      m_flag_sec_proc_pairing

                          AREA ||i.link_secure_peripheral||, CODE, READONLY, ALIGN=1

                  link_secure_peripheral PROC
;;;831    
;;;832    static ret_code_t link_secure_peripheral(uint16_t conn_handle, ble_gap_sec_params_t * p_sec_params)
000000  b570              PUSH     {r4-r6,lr}
;;;833    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;834        // This should never happen for a peripheral.
;;;835        NRF_PM_DEBUG_CHECK(p_sec_params != NULL);
;;;836    
;;;837        // VERIFY_PARAM_NOT_NULL(p_sec_params);
;;;838    
;;;839        ret_code_t err_code = sd_ble_gap_authenticate(conn_handle, p_sec_params);
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  df7e              SVC      #0x7e
00000c  4606              MOV      r6,r0
;;;840    
;;;841        return err_code;
00000e  4630              MOV      r0,r6
;;;842    }
000010  bd70              POP      {r4-r6,pc}
;;;843    
                          ENDP


                          AREA ||i.pairing_failure||, CODE, READONLY, ALIGN=2

                  pairing_failure PROC
;;;332     */
;;;333    static void pairing_failure(uint16_t            conn_handle,
000000  b5ff              PUSH     {r0-r7,lr}
;;;334                                pm_peer_id_t        peer_id,
;;;335                                pm_sec_error_code_t error,
;;;336                                uint8_t             error_src)
;;;337    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
;;;338        ret_code_t err_code = NRF_SUCCESS;
00000a  2500              MOVS     r5,#0
;;;339    
;;;340        smd_evt_t evt =
00000c  4a18              LDR      r2,|L14.112|
00000e  ca07              LDM      r2,{r0-r2}
000010  ab04              ADD      r3,sp,#0x10
000012  c307              STM      r3!,{r0-r2}
000014  4668              MOV      r0,sp
000016  8244              STRH     r4,[r0,#0x12]
000018  8286              STRH     r6,[r0,#0x14]
00001a  a804              ADD      r0,sp,#0x10
00001c  7187              STRB     r7,[r0,#6]
;;;341        {
;;;342            .evt_id      = SMD_EVT_PAIRING_FAIL,
;;;343            .conn_handle = conn_handle,
;;;344            .params =
;;;345            {
;;;346                .pairing_failed =
;;;347                {
;;;348                    .error     = error,
;;;349                    .error_src = error_src,
;;;350                }
;;;351            }
;;;352        };
;;;353    
;;;354        if (ble_conn_state_user_flag_get(conn_handle, m_flag_sec_proc_new_peer))
00001e  4815              LDR      r0,|L14.116|
000020  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_new_peer
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       ble_conn_state_user_flag_get
000028  2800              CMP      r0,#0
00002a  d004              BEQ      |L14.54|
;;;355        {
;;;356            // The peer_id was created during the procedure, and should be freed, because no data is
;;;357            // stored under it.
;;;358            err_code = im_peer_free(peer_id);  // Attempt to free allocated peer.
00002c  9808              LDR      r0,[sp,#0x20]
00002e  f7fffffe          BL       im_peer_free
000032  4605              MOV      r5,r0
;;;359            UNUSED_VARIABLE(err_code);
000034  e011              B        |L14.90|
                  |L14.54|
;;;360        }
;;;361        else
;;;362        {
;;;363            err_code = pdb_write_buf_release(peer_id, PM_PEER_DATA_ID_BONDING);
000036  2107              MOVS     r1,#7
000038  9808              LDR      r0,[sp,#0x20]
00003a  f7fffffe          BL       pdb_write_buf_release
00003e  4605              MOV      r5,r0
;;;364            if ((err_code != NRF_SUCCESS) && (err_code == NRF_ERROR_NOT_FOUND /* No buffer was allocated */))
000040  2d00              CMP      r5,#0
000042  d00a              BEQ      |L14.90|
000044  2d05              CMP      r5,#5
000046  d108              BNE      |L14.90|
;;;365            {
;;;366                smd_evt_t error_evt;
;;;367                error_evt.evt_id = SMD_EVT_ERROR_UNEXPECTED;
000048  2109              MOVS     r1,#9
00004a  4668              MOV      r0,sp
00004c  7101              STRB     r1,[r0,#4]
;;;368                error_evt.conn_handle = conn_handle;
00004e  80c4              STRH     r4,[r0,#6]
;;;369                error_evt.params.error_unexpected.error = err_code;
000050  9502              STR      r5,[sp,#8]
;;;370                evt_send(&error_evt);
000052  a801              ADD      r0,sp,#4
000054  f7fffffe          BL       evt_send
;;;371            }
000058  bf00              NOP      
                  |L14.90|
;;;372        }
;;;373    
;;;374        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, false);
00005a  2200              MOVS     r2,#0
00005c  4806              LDR      r0,|L14.120|
00005e  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       ble_conn_state_user_flag_set
;;;375    
;;;376        evt_send(&evt);
000066  a804              ADD      r0,sp,#0x10
000068  f7fffffe          BL       evt_send
;;;377        return;
;;;378    }
00006c  b00b              ADD      sp,sp,#0x2c
00006e  bdf0              POP      {r4-r7,pc}
;;;379    
                          ENDP

                  |L14.112|
                          DCD      ||.constdata||+0x2c
                  |L14.116|
                          DCD      m_flag_sec_proc_new_peer
                  |L14.120|
                          DCD      m_flag_sec_proc

                          AREA ||i.sec_info_request_process||, CODE, READONLY, ALIGN=2

                  sec_info_request_process PROC
;;;177     */
;;;178    static void sec_info_request_process(ble_gap_evt_t * p_gap_evt)
000000  b5f0              PUSH     {r4-r7,lr}
;;;179    {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
;;;180        ret_code_t                 err_code;
;;;181        ble_gap_enc_info_t const * p_enc_info = NULL;
000006  2000              MOVS     r0,#0
000008  9006              STR      r0,[sp,#0x18]
;;;182        pm_peer_data_flash_t       peer_data;
;;;183        pm_peer_id_t               peer_id = im_peer_id_get_by_master_id(&p_gap_evt->params.sec_info_request.master_id);
00000a  4620              MOV      r0,r4
00000c  300c              ADDS     r0,r0,#0xc
00000e  f7fffffe          BL       im_peer_id_get_by_master_id
000012  4606              MOV      r6,r0
;;;184        smd_evt_t evt;
;;;185    
;;;186        evt.conn_handle = p_gap_evt->conn_handle;
000014  8820              LDRH     r0,[r4,#0]
000016  4669              MOV      r1,sp
000018  80c8              STRH     r0,[r1,#6]
;;;187    
;;;188        if (peer_id == PM_PEER_ID_INVALID)
00001a  482e              LDR      r0,|L15.212|
00001c  4286              CMP      r6,r0
00001e  d103              BNE      |L15.40|
;;;189        {
;;;190            peer_id = im_peer_id_get_by_conn_handle(p_gap_evt->conn_handle);
000020  8820              LDRH     r0,[r4,#0]
000022  f7fffffe          BL       im_peer_id_get_by_conn_handle
000026  4606              MOV      r6,r0
                  |L15.40|
;;;191        }
;;;192    
;;;193        if (peer_id != PM_PEER_ID_INVALID)
000028  482a              LDR      r0,|L15.212|
00002a  4286              CMP      r6,r0
00002c  d019              BEQ      |L15.98|
;;;194        {
;;;195            err_code = pdb_peer_data_ptr_get(peer_id, PM_PEER_DATA_ID_BONDING, &peer_data);
00002e  aa04              ADD      r2,sp,#0x10
000030  2107              MOVS     r1,#7
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       pdb_peer_data_ptr_get
000038  4605              MOV      r5,r0
;;;196    
;;;197            if (err_code == NRF_SUCCESS)
00003a  2d00              CMP      r5,#0
00003c  d111              BNE      |L15.98|
;;;198            {
;;;199                // There is stored bonding data for this peer.
;;;200                ble_gap_enc_key_t const * p_existing_key = &peer_data.p_bonding_data->own_ltk;
00003e  9805              LDR      r0,[sp,#0x14]
000040  4607              MOV      r7,r0
000042  3734              ADDS     r7,r7,#0x34
;;;201    
;;;202                if (   p_existing_key->enc_info.lesc
000044  7c38              LDRB     r0,[r7,#0x10]
000046  07c0              LSLS     r0,r0,#31
000048  0fc0              LSRS     r0,r0,#31
00004a  2800              CMP      r0,#0
00004c  d107              BNE      |L15.94|
;;;203                    || (im_master_ids_compare(&p_existing_key->master_id,
00004e  4621              MOV      r1,r4
000050  310c              ADDS     r1,r1,#0xc
000052  4638              MOV      r0,r7
000054  3012              ADDS     r0,r0,#0x12
000056  f7fffffe          BL       im_master_ids_compare
00005a  2800              CMP      r0,#0
00005c  d000              BEQ      |L15.96|
                  |L15.94|
;;;204                                              &p_gap_evt->params.sec_info_request.master_id)))
;;;205                {
;;;206                    p_enc_info = &p_existing_key->enc_info;
00005e  9706              STR      r7,[sp,#0x18]
                  |L15.96|
;;;207                }
;;;208            }
000060  bf00              NOP      
                  |L15.98|
;;;209        }
;;;210    
;;;211        // All return values from the following can be safely ignored.
;;;212        err_code = sd_ble_gap_sec_info_reply(p_gap_evt->conn_handle, p_enc_info, NULL, NULL);
000062  8820              LDRH     r0,[r4,#0]
000064  2300              MOVS     r3,#0
000066  461a              MOV      r2,r3
000068  9906              LDR      r1,[sp,#0x18]
00006a  df86              SVC      #0x86
00006c  4605              MOV      r5,r0
;;;213    
;;;214        if (err_code != NRF_SUCCESS)
00006e  2d00              CMP      r5,#0
000070  d007              BEQ      |L15.130|
;;;215        {
;;;216            evt.evt_id                        = SMD_EVT_ERROR_UNEXPECTED;
000072  2009              MOVS     r0,#9
000074  4669              MOV      r1,sp
000076  7108              STRB     r0,[r1,#4]
;;;217            evt.params.error_unexpected.error = err_code;
000078  9502              STR      r5,[sp,#8]
;;;218    
;;;219            evt_send(&evt);
00007a  a801              ADD      r0,sp,#4
00007c  f7fffffe          BL       evt_send
000080  e026              B        |L15.208|
                  |L15.130|
;;;220        }
;;;221        else if (p_enc_info == NULL)
000082  9806              LDR      r0,[sp,#0x18]
000084  2800              CMP      r0,#0
000086  d112              BNE      |L15.174|
;;;222        {
;;;223            evt.evt_id                                  = SMD_EVT_LINK_ENCRYPTION_FAILED;
000088  2106              MOVS     r1,#6
00008a  4668              MOV      r0,sp
00008c  7101              STRB     r1,[r0,#4]
;;;224            evt.params.link_encryption_failed.error     = PM_CONN_SEC_ERROR_PIN_OR_KEY_MISSING;
00008e  4912              LDR      r1,|L15.216|
000090  8101              STRH     r1,[r0,#8]
;;;225            evt.params.link_encryption_failed.error_src = BLE_GAP_SEC_STATUS_SOURCE_LOCAL;
000092  2100              MOVS     r1,#0
000094  a801              ADD      r0,sp,#4
000096  7181              STRB     r1,[r0,#6]
;;;226    
;;;227            evt_send(&evt);
000098  f7fffffe          BL       evt_send
;;;228    
;;;229            sec_proc_start(p_gap_evt->conn_handle, peer_id, false, false, false);
00009c  2000              MOVS     r0,#0
00009e  9000              STR      r0,[sp,#0]
0000a0  8820              LDRH     r0,[r4,#0]
0000a2  2300              MOVS     r3,#0
0000a4  461a              MOV      r2,r3
0000a6  4631              MOV      r1,r6
0000a8  f7fffffe          BL       sec_proc_start
0000ac  e010              B        |L15.208|
                  |L15.174|
;;;230        }
;;;231        else
;;;232        {
;;;233            sec_start_send(p_gap_evt->conn_handle, PM_LINK_SECURED_PROCEDURE_ENCRYPTION);
0000ae  8820              LDRH     r0,[r4,#0]
0000b0  2100              MOVS     r1,#0
0000b2  f7fffffe          BL       sec_start_send
;;;234    
;;;235            sec_proc_start(p_gap_evt->conn_handle, peer_id, err_code == NRF_SUCCESS, false, false);
0000b6  2000              MOVS     r0,#0
0000b8  9000              STR      r0,[sp,#0]
0000ba  2d00              CMP      r5,#0
0000bc  d101              BNE      |L15.194|
0000be  2101              MOVS     r1,#1
0000c0  e000              B        |L15.196|
                  |L15.194|
0000c2  2100              MOVS     r1,#0
                  |L15.196|
0000c4  460a              MOV      r2,r1
0000c6  8820              LDRH     r0,[r4,#0]
0000c8  2300              MOVS     r3,#0
0000ca  4631              MOV      r1,r6
0000cc  f7fffffe          BL       sec_proc_start
                  |L15.208|
;;;236        }
;;;237    
;;;238    
;;;239        return;
;;;240    }
0000d0  b007              ADD      sp,sp,#0x1c
0000d2  bdf0              POP      {r4-r7,pc}
;;;241    
                          ENDP

                  |L15.212|
                          DCD      0x0000ffff
                  |L15.216|
                          DCD      0x00001006

                          AREA ||i.sec_params_request_process||, CODE, READONLY, ALIGN=1

                  sec_params_request_process PROC
;;;123     */
;;;124    static void sec_params_request_process(ble_gap_evt_t * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;125    {
000002  4604              MOV      r4,r0
;;;126        smd_evt_t evt =
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  8820              LDRH     r0,[r4,#0]
00000e  4669              MOV      r1,sp
000010  8048              STRH     r0,[r1,#2]
;;;127        {
;;;128            .evt_id      = SMD_EVT_PARAMS_REQ,
;;;129            .conn_handle = p_gap_evt->conn_handle
;;;130        };
;;;131        evt_send(&evt);
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       evt_send
;;;132        return;
;;;133    }
000018  bd3e              POP      {r1-r5,pc}
;;;134    
                          ENDP


                          AREA ||i.sec_proc_start||, CODE, READONLY, ALIGN=2

                  sec_proc_start PROC
;;;143     */
;;;144    static void sec_proc_start(uint16_t     conn_handle,
000000  b5ff              PUSH     {r0-r7,lr}
;;;145                               pm_peer_id_t peer_id,
;;;146                               bool         success,
;;;147                               bool         pairing,
;;;148                               bool         new_peer_created)
;;;149    {
000002  b081              SUB      sp,sp,#4
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
00000a  9c0a              LDR      r4,[sp,#0x28]
;;;150        ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc, success);
00000c  4632              MOV      r2,r6
00000e  4811              LDR      r0,|L17.84|
000010  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc
000012  9801              LDR      r0,[sp,#4]
000014  f7fffffe          BL       ble_conn_state_user_flag_set
;;;151    
;;;152        if (success)
000018  2e00              CMP      r6,#0
00001a  d012              BEQ      |L17.66|
;;;153        {
;;;154            ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc_pairing, pairing);
00001c  463a              MOV      r2,r7
00001e  480e              LDR      r0,|L17.88|
000020  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_pairing
000022  9801              LDR      r0,[sp,#4]
000024  f7fffffe          BL       ble_conn_state_user_flag_set
;;;155            ble_conn_state_user_flag_set(conn_handle, m_flag_sec_proc_new_peer, new_peer_created);
000028  4622              MOV      r2,r4
00002a  480c              LDR      r0,|L17.92|
00002c  7801              LDRB     r1,[r0,#0]  ; m_flag_sec_proc_new_peer
00002e  9801              LDR      r0,[sp,#4]
000030  f7fffffe          BL       ble_conn_state_user_flag_set
;;;156    
;;;157            if (new_peer_created)
000034  2c00              CMP      r4,#0
000036  d00b              BEQ      |L17.80|
;;;158            {
;;;159                im_new_peer_id(conn_handle, peer_id);
000038  4629              MOV      r1,r5
00003a  9801              LDR      r0,[sp,#4]
00003c  f7fffffe          BL       im_new_peer_id
000040  e006              B        |L17.80|
                  |L17.66|
;;;160            }
;;;161        }
;;;162        else
;;;163        {
;;;164            if (new_peer_created)
000042  2c00              CMP      r4,#0
000044  d004              BEQ      |L17.80|
;;;165            {
;;;166                ret_code_t err_code = im_peer_free(peer_id); // Attempt to free allocated peer.
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       im_peer_free
00004c  9000              STR      r0,[sp,#0]
;;;167                UNUSED_VARIABLE(err_code);
;;;168            }
00004e  bf00              NOP      
                  |L17.80|
;;;169        }
;;;170    }
000050  b005              ADD      sp,sp,#0x14
000052  bdf0              POP      {r4-r7,pc}
;;;171    
                          ENDP

                  |L17.84|
                          DCD      m_flag_sec_proc
                  |L17.88|
                          DCD      m_flag_sec_proc_pairing
                  |L17.92|
                          DCD      m_flag_sec_proc_new_peer

                          AREA ||i.sec_request_process||, CODE, READONLY, ALIGN=2

                  sec_request_process PROC
;;;246     */
;;;247    static void sec_request_process(ble_gap_evt_t * p_gap_evt)
000000  b53e              PUSH     {r1-r5,lr}
;;;248    {
000002  4604              MOV      r4,r0
;;;249        smd_evt_t evt =
000004  4a09              LDR      r2,|L18.44|
000006  ca07              LDM      r2,{r0-r2}
000008  466b              MOV      r3,sp
00000a  c307              STM      r3!,{r0-r2}
00000c  8821              LDRH     r1,[r4,#0]
00000e  4668              MOV      r0,sp
000010  8041              STRH     r1,[r0,#2]
000012  7920              LDRB     r0,[r4,#4]
000014  07c1              LSLS     r1,r0,#31
000016  0fc9              LSRS     r1,r1,#31
000018  4668              MOV      r0,sp
00001a  7101              STRB     r1,[r0,#4]
00001c  7920              LDRB     r0,[r4,#4]
00001e  0780              LSLS     r0,r0,#30
000020  0fc1              LSRS     r1,r0,#31
000022  4668              MOV      r0,sp
000024  7141              STRB     r1,[r0,#5]
;;;250        {
;;;251            .evt_id = SMD_EVT_SLAVE_SECURITY_REQ,
;;;252            .conn_handle = p_gap_evt->conn_handle,
;;;253            .params =
;;;254            {
;;;255                .slave_security_req =
;;;256                {
;;;257                    .bond = p_gap_evt->params.sec_request.bond,
;;;258                    .mitm = p_gap_evt->params.sec_request.mitm,
;;;259                }
;;;260            }
;;;261        };
;;;262        evt_send(&evt);
000026  f7fffffe          BL       evt_send
;;;263        return;
;;;264    }
00002a  bd3e              POP      {r1-r5,pc}
;;;265    
                          ENDP

                  |L18.44|
                          DCD      ||.constdata||+0x20

                          AREA ||i.sec_start_send||, CODE, READONLY, ALIGN=2

                  sec_start_send PROC
;;;87     
;;;88     static void sec_start_send(uint16_t conn_handle, pm_conn_sec_procedure_t procedure)
000000  b53e              PUSH     {r1-r5,lr}
;;;89     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;90         smd_evt_t evt =
000006  4a05              LDR      r2,|L19.28|
000008  ca07              LDM      r2,{r0-r2}
00000a  466b              MOV      r3,sp
00000c  c307              STM      r3!,{r0-r2}
00000e  4668              MOV      r0,sp
000010  8044              STRH     r4,[r0,#2]
000012  7105              STRB     r5,[r0,#4]
;;;91         {
;;;92             .evt_id      = SMD_EVT_SEC_PROCEDURE_START,
;;;93             .conn_handle = conn_handle,
;;;94             .params      = {.sec_procedure_start = {.procedure = procedure}}
;;;95         };
;;;96         evt_send(&evt);
000014  f7fffffe          BL       evt_send
;;;97     }
000018  bd3e              POP      {r1-r5,pc}
;;;98     
                          ENDP

00001a  0000              DCW      0x0000
                  |L19.28|
                          DCD      ||.constdata||+0x8

                          AREA ||i.smd_ble_evt_handler||, CODE, READONLY, ALIGN=1

                  smd_ble_evt_handler PROC
;;;866    
;;;867    void smd_ble_evt_handler(ble_evt_t * p_ble_evt)
000000  b510              PUSH     {r4,lr}
;;;868    {
000002  4604              MOV      r4,r0
;;;869        switch (p_ble_evt->header.evt_id)
000004  8820              LDRH     r0,[r4,#0]
000006  2819              CMP      r0,#0x19
000008  d01c              BEQ      |L20.68|
00000a  dc06              BGT      |L20.26|
00000c  2811              CMP      r0,#0x11
00000e  d009              BEQ      |L20.36|
000010  2813              CMP      r0,#0x13
000012  d00b              BEQ      |L20.44|
000014  2814              CMP      r0,#0x14
000016  d11d              BNE      |L20.84|
000018  e00c              B        |L20.52|
                  |L20.26|
00001a  281a              CMP      r0,#0x1a
00001c  d016              BEQ      |L20.76|
00001e  281e              CMP      r0,#0x1e
000020  d118              BNE      |L20.84|
000022  e00b              B        |L20.60|
                  |L20.36|
;;;870        {
;;;871            case BLE_GAP_EVT_DISCONNECTED:
;;;872                disconnect_process(&(p_ble_evt->evt.gap_evt));
000024  1d20              ADDS     r0,r4,#4
000026  f7fffffe          BL       disconnect_process
;;;873                break;
00002a  e013              B        |L20.84|
                  |L20.44|
;;;874    
;;;875            case BLE_GAP_EVT_SEC_PARAMS_REQUEST:
;;;876                sec_params_request_process(&(p_ble_evt->evt.gap_evt));
00002c  1d20              ADDS     r0,r4,#4
00002e  f7fffffe          BL       sec_params_request_process
;;;877                break;
000032  e00f              B        |L20.84|
                  |L20.52|
;;;878    
;;;879            case BLE_GAP_EVT_SEC_INFO_REQUEST:
;;;880                sec_info_request_process(&(p_ble_evt->evt.gap_evt));
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       sec_info_request_process
;;;881                break;
00003a  e00b              B        |L20.84|
                  |L20.60|
;;;882    
;;;883            case BLE_GAP_EVT_SEC_REQUEST:
;;;884                sec_request_process(&(p_ble_evt->evt.gap_evt));
00003c  1d20              ADDS     r0,r4,#4
00003e  f7fffffe          BL       sec_request_process
;;;885                break;
000042  e007              B        |L20.84|
                  |L20.68|
;;;886    
;;;887            case BLE_GAP_EVT_AUTH_STATUS:
;;;888                auth_status_process(&(p_ble_evt->evt.gap_evt));
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       auth_status_process
;;;889                break;
00004a  e003              B        |L20.84|
                  |L20.76|
;;;890    
;;;891            case BLE_GAP_EVT_CONN_SEC_UPDATE:
;;;892                conn_sec_update_process(&(p_ble_evt->evt.gap_evt));
00004c  1d20              ADDS     r0,r4,#4
00004e  f7fffffe          BL       conn_sec_update_process
;;;893                break;
000052  bf00              NOP      
                  |L20.84|
000054  bf00              NOP                            ;873
;;;894        };
;;;895    }
000056  bd10              POP      {r4,pc}
;;;896    #endif //NRF_MODULE_ENABLED(PEER_MANAGER)
                          ENDP


                          AREA ||i.smd_init||, CODE, READONLY, ALIGN=2

                  smd_init PROC
;;;530    
;;;531    ret_code_t smd_init(void)
000000  b510              PUSH     {r4,lr}
;;;532    {
;;;533        NRF_PM_DEBUG_CHECK(!m_module_initialized);
;;;534    
;;;535        flag_id_init(&m_flag_sec_proc);
000002  480e              LDR      r0,|L21.60|
000004  f7fffffe          BL       flag_id_init
;;;536        flag_id_init(&m_flag_sec_proc_pairing);
000008  480d              LDR      r0,|L21.64|
00000a  f7fffffe          BL       flag_id_init
;;;537        flag_id_init(&m_flag_sec_proc_new_peer);
00000e  480d              LDR      r0,|L21.68|
000010  f7fffffe          BL       flag_id_init
;;;538    
;;;539        if ((m_flag_sec_proc          == BLE_CONN_STATE_USER_FLAG_INVALID) ||
000014  4809              LDR      r0,|L21.60|
000016  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc
000018  2818              CMP      r0,#0x18
00001a  d007              BEQ      |L21.44|
;;;540            (m_flag_sec_proc_pairing  == BLE_CONN_STATE_USER_FLAG_INVALID) ||
00001c  4808              LDR      r0,|L21.64|
00001e  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc_pairing
000020  2818              CMP      r0,#0x18
000022  d003              BEQ      |L21.44|
;;;541            (m_flag_sec_proc_new_peer == BLE_CONN_STATE_USER_FLAG_INVALID))
000024  4807              LDR      r0,|L21.68|
000026  7800              LDRB     r0,[r0,#0]  ; m_flag_sec_proc_new_peer
000028  2818              CMP      r0,#0x18
00002a  d101              BNE      |L21.48|
                  |L21.44|
;;;542        {
;;;543            return NRF_ERROR_INTERNAL;
00002c  2003              MOVS     r0,#3
                  |L21.46|
;;;544        }
;;;545    
;;;546        m_module_initialized = true;
;;;547    
;;;548        return NRF_SUCCESS;
;;;549    }
00002e  bd10              POP      {r4,pc}
                  |L21.48|
000030  2001              MOVS     r0,#1                 ;546
000032  4905              LDR      r1,|L21.72|
000034  7008              STRB     r0,[r1,#0]            ;546
000036  2000              MOVS     r0,#0                 ;548
000038  e7f9              B        |L21.46|
;;;550    
                          ENDP

00003a  0000              DCW      0x0000
                  |L21.60|
                          DCD      m_flag_sec_proc
                  |L21.64|
                          DCD      m_flag_sec_proc_pairing
                  |L21.68|
                          DCD      m_flag_sec_proc_new_peer
                  |L21.72|
                          DCD      m_module_initialized

                          AREA ||i.smd_link_secure||, CODE, READONLY, ALIGN=2

                  smd_link_secure PROC
;;;844    
;;;845    ret_code_t smd_link_secure(uint16_t               conn_handle,
000000  b5f8              PUSH     {r3-r7,lr}
;;;846                               ble_gap_sec_params_t * p_sec_params,
;;;847                               bool                   force_repairing)
;;;848    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;849        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;850    
;;;851        uint8_t role = ble_conn_state_role(conn_handle);
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       ble_conn_state_role
00000e  4607              MOV      r7,r0
;;;852    
;;;853        switch (role)
000010  2f01              CMP      r7,#1
000012  d007              BEQ      |L22.36|
000014  2f02              CMP      r7,#2
000016  d10a              BNE      |L22.46|
;;;854        {
;;;855            case BLE_GAP_ROLE_CENTRAL:
;;;856                return link_secure_central(conn_handle, p_sec_params, force_repairing);
000018  4632              MOV      r2,r6
00001a  4629              MOV      r1,r5
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       link_secure_central
                  |L22.34|
;;;857    
;;;858            case BLE_GAP_ROLE_PERIPH:
;;;859                return link_secure_peripheral(conn_handle, p_sec_params);
;;;860    
;;;861            default:
;;;862                return BLE_ERROR_INVALID_CONN_HANDLE;
;;;863        }
;;;864    }
000022  bdf8              POP      {r3-r7,pc}
                  |L22.36|
000024  4629              MOV      r1,r5                 ;859
000026  4620              MOV      r0,r4                 ;859
000028  f7fffffe          BL       link_secure_peripheral
00002c  e7f9              B        |L22.34|
                  |L22.46|
00002e  4801              LDR      r0,|L22.52|
000030  e7f7              B        |L22.34|
;;;865    
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
                          DCD      0x00003002

                          AREA ||i.smd_params_reply||, CODE, READONLY, ALIGN=2

                  smd_params_reply PROC
;;;551    
;;;552    ret_code_t smd_params_reply(uint16_t                 conn_handle,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;553                                ble_gap_sec_params_t   * p_sec_params,
;;;554                                ble_gap_lesc_p256_pk_t * p_public_key)
;;;555    {
000002  b08e              SUB      sp,sp,#0x38
000004  460c              MOV      r4,r1
;;;556        NRF_PM_DEBUG_CHECK(m_module_initialized);
;;;557    
;;;558        uint8_t              role = ble_conn_state_role(conn_handle);
000006  980e              LDR      r0,[sp,#0x38]
000008  f7fffffe          BL       ble_conn_state_role
00000c  4607              MOV      r7,r0
;;;559        pm_peer_id_t         peer_id = PM_PEER_ID_INVALID;
00000e  4e45              LDR      r6,|L23.292|
;;;560        ret_code_t           err_code = NRF_SUCCESS;
000010  2500              MOVS     r5,#0
;;;561        uint8_t              sec_status = BLE_GAP_SEC_STATUS_SUCCESS;
000012  2000              MOVS     r0,#0
000014  900d              STR      r0,[sp,#0x34]
;;;562        ble_gap_sec_keyset_t sec_keyset;
;;;563        bool                 new_peer_created = false;
000016  9004              STR      r0,[sp,#0x10]
;;;564    
;;;565        memset(&sec_keyset, 0, sizeof(ble_gap_sec_keyset_t));
000018  2120              MOVS     r1,#0x20
00001a  a805              ADD      r0,sp,#0x14
00001c  f7fffffe          BL       __aeabi_memclr4
;;;566    
;;;567        if (role == BLE_GAP_ROLE_INVALID)
000020  2f00              CMP      r7,#0
000022  d102              BNE      |L23.42|
;;;568        {
;;;569            return BLE_ERROR_INVALID_CONN_HANDLE;
000024  4840              LDR      r0,|L23.296|
                  |L23.38|
;;;570        }
;;;571    
;;;572        if (p_sec_params == NULL)
;;;573        {
;;;574            // NULL params means reject pairing.
;;;575            sec_status = BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP;
;;;576        }
;;;577        else if (p_sec_params->bond)
;;;578        {
;;;579            // Bonding is to be performed, prepare to receive bonding data.
;;;580            pm_peer_data_t       peer_data;
;;;581    
;;;582            peer_id = im_peer_id_get_by_conn_handle(conn_handle);
;;;583    
;;;584            if (peer_id == PM_PEER_ID_INVALID)
;;;585            {
;;;586                // Peer is unknown to us, allocate a new peer ID for it.
;;;587                peer_id = pdb_peer_allocate();
;;;588                if (peer_id != PM_PEER_ID_INVALID)
;;;589                {
;;;590                    new_peer_created = true;
;;;591                }
;;;592                else
;;;593                {
;;;594                    err_code = NRF_ERROR_INTERNAL;
;;;595                }
;;;596            }
;;;597    
;;;598            if (err_code == NRF_SUCCESS)
;;;599            {
;;;600                // Peer ID is ready, acquire a memory buffer to receive bonding data into.
;;;601                err_code = pdb_write_buf_get(peer_id, PM_PEER_DATA_ID_BONDING, 1, &peer_data);
;;;602                if (err_code == NRF_SUCCESS)
;;;603                {
;;;604                    memset(peer_data.p_bonding_data, 0, sizeof(pm_peer_data_bonding_t));
;;;605    
;;;606                    peer_data.p_bonding_data->own_role = role;
;;;607    
;;;608                    sec_keyset.keys_own.p_enc_key  = &peer_data.p_bonding_data->own_ltk;
;;;609                    sec_keyset.keys_own.p_pk       = p_public_key;
;;;610                    sec_keyset.keys_peer.p_enc_key = &peer_data.p_bonding_data->peer_ltk;
;;;611                    sec_keyset.keys_peer.p_id_key  = &peer_data.p_bonding_data->peer_ble_id;
;;;612                    sec_keyset.keys_peer.p_pk      = &m_peer_pk;
;;;613    
;;;614                    // Retrieve the address the peer used during connection establishment.
;;;615                    // This address will be overwritten if ID is shared. Should not fail.
;;;616                    ret_code_t err_code_addr = im_ble_addr_get(conn_handle,
;;;617                        &peer_data.p_bonding_data->peer_ble_id.id_addr_info);
;;;618                    UNUSED_VARIABLE(err_code_addr);
;;;619    
;;;620                    // Buffer is OK, reserve room in flash for the data.
;;;621                    err_code = pdb_write_buf_store_prepare(peer_id, PM_PEER_DATA_ID_BONDING);
;;;622                }
;;;623            }
;;;624        }
;;;625        else
;;;626        {
;;;627            // Pairing only, no action needed.
;;;628        }
;;;629    
;;;630        if (err_code == NRF_SUCCESS)
;;;631        {
;;;632            // Everything OK, reply to SoftDevice. If an error happened, the user is given an
;;;633            // opportunity to change the parameters and retry the call.
;;;634            if (role == BLE_GAP_ROLE_CENTRAL)
;;;635            {
;;;636                err_code = sd_ble_gap_sec_params_reply(conn_handle, sec_status, NULL, &sec_keyset);
;;;637            }
;;;638            else
;;;639            {
;;;640                err_code = sd_ble_gap_sec_params_reply(conn_handle, sec_status, p_sec_params, &sec_keyset);
;;;641    
;;;642                if ((p_sec_params != NULL) && (err_code == NRF_SUCCESS))
;;;643                {
;;;644                    pm_conn_sec_procedure_t procedure = p_sec_params->bond
;;;645                                                   ? PM_LINK_SECURED_PROCEDURE_BONDING
;;;646                                                   : PM_LINK_SECURED_PROCEDURE_PAIRING;
;;;647                    sec_start_send(conn_handle, procedure);
;;;648                }
;;;649            }
;;;650        }
;;;651    
;;;652        sec_proc_start(conn_handle,
;;;653                       peer_id,
;;;654                       (err_code == NRF_SUCCESS) && (sec_status != BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP),
;;;655                       true,
;;;656                       new_peer_created);
;;;657    
;;;658        return err_code;
;;;659    }
000026  b011              ADD      sp,sp,#0x44
000028  bdf0              POP      {r4-r7,pc}
                  |L23.42|
00002a  2c00              CMP      r4,#0                 ;572
00002c  d102              BNE      |L23.52|
00002e  2085              MOVS     r0,#0x85              ;575
000030  900d              STR      r0,[sp,#0x34]         ;575
000032  e041              B        |L23.184|
                  |L23.52|
000034  7820              LDRB     r0,[r4,#0]            ;577
000036  07c0              LSLS     r0,r0,#31             ;577
000038  0fc0              LSRS     r0,r0,#31             ;577
00003a  2800              CMP      r0,#0                 ;577
00003c  d03c              BEQ      |L23.184|
00003e  980e              LDR      r0,[sp,#0x38]         ;582
000040  f7fffffe          BL       im_peer_id_get_by_conn_handle
000044  4606              MOV      r6,r0                 ;582
000046  4837              LDR      r0,|L23.292|
000048  4286              CMP      r6,r0                 ;584
00004a  d109              BNE      |L23.96|
00004c  f7fffffe          BL       pdb_peer_allocate
000050  4606              MOV      r6,r0                 ;587
000052  4834              LDR      r0,|L23.292|
000054  4286              CMP      r6,r0                 ;588
000056  d002              BEQ      |L23.94|
000058  2001              MOVS     r0,#1                 ;590
00005a  9004              STR      r0,[sp,#0x10]         ;590
00005c  e000              B        |L23.96|
                  |L23.94|
00005e  2503              MOVS     r5,#3                 ;594
                  |L23.96|
000060  2d00              CMP      r5,#0                 ;598
000062  d128              BNE      |L23.182|
000064  ab02              ADD      r3,sp,#8              ;601
000066  2201              MOVS     r2,#1                 ;601
000068  2107              MOVS     r1,#7                 ;601
00006a  4630              MOV      r0,r6                 ;601
00006c  f7fffffe          BL       pdb_write_buf_get
000070  4605              MOV      r5,r0                 ;601
000072  2d00              CMP      r5,#0                 ;602
000074  d11f              BNE      |L23.182|
000076  2150              MOVS     r1,#0x50              ;604
000078  9803              LDR      r0,[sp,#0xc]          ;604
00007a  f7fffffe          BL       __aeabi_memclr
00007e  9803              LDR      r0,[sp,#0xc]          ;606
000080  7007              STRB     r7,[r0,#0]            ;606
000082  9803              LDR      r0,[sp,#0xc]          ;608
000084  3034              ADDS     r0,r0,#0x34           ;608
000086  9005              STR      r0,[sp,#0x14]         ;608
000088  9810              LDR      r0,[sp,#0x40]         ;609
00008a  9008              STR      r0,[sp,#0x20]         ;609
00008c  9803              LDR      r0,[sp,#0xc]          ;610
00008e  3018              ADDS     r0,r0,#0x18           ;610
000090  9009              STR      r0,[sp,#0x24]         ;610
000092  9803              LDR      r0,[sp,#0xc]          ;611
000094  1c40              ADDS     r0,r0,#1              ;611
000096  900a              STR      r0,[sp,#0x28]         ;611
000098  4924              LDR      r1,|L23.300|
00009a  910c              STR      r1,[sp,#0x30]         ;612
00009c  9803              LDR      r0,[sp,#0xc]          ;616
00009e  4601              MOV      r1,r0                 ;616
0000a0  3111              ADDS     r1,r1,#0x11           ;616
0000a2  980e              LDR      r0,[sp,#0x38]         ;616
0000a4  f7fffffe          BL       im_ble_addr_get
0000a8  9001              STR      r0,[sp,#4]            ;616
0000aa  2107              MOVS     r1,#7                 ;621
0000ac  4630              MOV      r0,r6                 ;621
0000ae  f7fffffe          BL       pdb_write_buf_store_prepare
0000b2  4605              MOV      r5,r0                 ;621
0000b4  bf00              NOP                            ;622
                  |L23.182|
0000b6  bf00              NOP                            ;624
                  |L23.184|
0000b8  2d00              CMP      r5,#0                 ;630
0000ba  d120              BNE      |L23.254|
0000bc  2f02              CMP      r7,#2                 ;634
0000be  d106              BNE      |L23.206|
0000c0  ab05              ADD      r3,sp,#0x14           ;636
0000c2  2200              MOVS     r2,#0                 ;636
0000c4  990d              LDR      r1,[sp,#0x34]         ;636
0000c6  980e              LDR      r0,[sp,#0x38]         ;636
0000c8  df7f              SVC      #0x7f                 ;636
0000ca  4605              MOV      r5,r0                 ;636
0000cc  e017              B        |L23.254|
                  |L23.206|
0000ce  ab05              ADD      r3,sp,#0x14           ;640
0000d0  4622              MOV      r2,r4                 ;640
0000d2  990d              LDR      r1,[sp,#0x34]         ;640
0000d4  980e              LDR      r0,[sp,#0x38]         ;640
0000d6  df7f              SVC      #0x7f                 ;640
0000d8  4605              MOV      r5,r0                 ;640
0000da  2c00              CMP      r4,#0                 ;642
0000dc  d00f              BEQ      |L23.254|
0000de  2d00              CMP      r5,#0                 ;642
0000e0  d10d              BNE      |L23.254|
0000e2  7820              LDRB     r0,[r4,#0]            ;644
0000e4  07c0              LSLS     r0,r0,#31             ;644
0000e6  0fc0              LSRS     r0,r0,#31             ;644
0000e8  2800              CMP      r0,#0                 ;644
0000ea  d001              BEQ      |L23.240|
0000ec  2001              MOVS     r0,#1                 ;645
0000ee  e000              B        |L23.242|
                  |L23.240|
0000f0  2002              MOVS     r0,#2                 ;646
                  |L23.242|
0000f2  9003              STR      r0,[sp,#0xc]          ;646
0000f4  9903              LDR      r1,[sp,#0xc]          ;647
0000f6  980e              LDR      r0,[sp,#0x38]         ;647
0000f8  f7fffffe          BL       sec_start_send
0000fc  bf00              NOP                            ;648
                  |L23.254|
0000fe  9804              LDR      r0,[sp,#0x10]         ;652
000100  9000              STR      r0,[sp,#0]            ;652
000102  2d00              CMP      r5,#0                 ;652
000104  d104              BNE      |L23.272|
000106  980d              LDR      r0,[sp,#0x34]         ;654
000108  2885              CMP      r0,#0x85              ;654
00010a  d001              BEQ      |L23.272|
00010c  2001              MOVS     r0,#1                 ;654
00010e  e000              B        |L23.274|
                  |L23.272|
000110  2000              MOVS     r0,#0                 ;654
                  |L23.274|
000112  4602              MOV      r2,r0                 ;654
000114  2301              MOVS     r3,#1                 ;654
000116  4631              MOV      r1,r6                 ;654
000118  980e              LDR      r0,[sp,#0x38]         ;654
00011a  f7fffffe          BL       sec_proc_start
00011e  4628              MOV      r0,r5                 ;658
000120  e781              B        |L23.38|
;;;660    
                          ENDP

000122  0000              DCW      0x0000
                  |L23.292|
                          DCD      0x0000ffff
                  |L23.296|
                          DCD      0x00003002
                  |L23.300|
                          DCD      m_peer_pk

                          AREA ||i.smd_pdb_evt_handler||, CODE, READONLY, ALIGN=2

                  smd_pdb_evt_handler PROC
;;;104     */
;;;105    void smd_pdb_evt_handler(pdb_evt_t const * p_event)
000000  b53e              PUSH     {r1-r5,lr}
;;;106    {
000002  4604              MOV      r4,r0
;;;107        if ((p_event->evt_id == PDB_EVT_WRITE_BUF_STORED) && (p_event->data_id == PM_PEER_DATA_ID_BONDING))
000004  7820              LDRB     r0,[r4,#0]
000006  2800              CMP      r0,#0
000008  d111              BNE      |L24.46|
00000a  7920              LDRB     r0,[r4,#4]
00000c  2807              CMP      r0,#7
00000e  d10e              BNE      |L24.46|
;;;108        {
;;;109            smd_evt_t evt =
000010  4a07              LDR      r2,|L24.48|
000012  ca07              LDM      r2,{r0-r2}
000014  466b              MOV      r3,sp
000016  c307              STM      r3!,{r0-r2}
000018  8860              LDRH     r0,[r4,#2]
00001a  f7fffffe          BL       im_conn_handle_get
00001e  4669              MOV      r1,sp
000020  8048              STRH     r0,[r1,#2]
000022  8860              LDRH     r0,[r4,#2]
000024  8088              STRH     r0,[r1,#4]
;;;110            {
;;;111                .evt_id      = SMD_EVT_BONDING_INFO_STORED,
;;;112                .conn_handle = im_conn_handle_get(p_event->peer_id),
;;;113                .params      = {.bonding_info_stored = {.peer_id = p_event->peer_id}}
;;;114            };
;;;115            evt_send(&evt);
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       evt_send
;;;116        }
00002c  bf00              NOP      
                  |L24.46|
;;;117    }
00002e  bd3e              POP      {r1-r5,pc}
;;;118    
                          ENDP

                  |L24.48|
                          DCD      ||.constdata||+0x14

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  m_peer_pk
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_evt_handlers
                          DCD      sm_smd_evt_handler
                          DCD      gcm_smd_evt_handler
000008  0200              DCB      0x02,0x00
00000a  0000              DCW      0x0000
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
000014  0700              DCB      0x07,0x00
000016  0000              DCW      0x0000
000018  0000              DCW      0x0000
00001a  0000              DCB      0x00,0x00
                          DCD      0x00000000
000020  0100              DCB      0x01,0x00
000022  0000              DCW      0x0000
000024  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
00002c  0400              DCB      0x04,0x00
00002e  0000              DCW      0x0000
000030  0000              DCW      0x0000
000032  0000              DCB      0x00,0x00
                          DCD      0x00000000
000038  0600              DCB      0x06,0x00
00003a  0000              DCW      0x0000
00003c  0000              DCW      0x0000
00003e  0000              DCB      0x00,0x00
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=0

                  m_module_initialized
000000  00                DCB      0x00
                  m_flag_sec_proc
000001  18                DCB      0x18
                  m_flag_sec_proc_pairing
000002  18                DCB      0x18
                  m_flag_sec_proc_new_peer
000003  18                DCB      0x18

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\ble\\peer_manager\\security_dispatcher.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___21_security_dispatcher_c_15a53087____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_security_dispatcher_c_15a53087____REVSH|
#line 144
|__asm___21_security_dispatcher_c_15a53087____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
