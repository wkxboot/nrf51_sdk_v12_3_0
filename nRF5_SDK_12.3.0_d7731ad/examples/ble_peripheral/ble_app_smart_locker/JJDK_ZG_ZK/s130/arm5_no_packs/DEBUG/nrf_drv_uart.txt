; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\nrf_drv_uart.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\nrf_drv_uart.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\nrf_drv_uart.crf ..\..\..\..\..\..\components\drivers_nrf\uart\nrf_drv_uart.c]
                          THUMB

                          AREA ||i.UART0_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART0_IRQHandler PROC
;;;945    #if UART0_ENABLED
;;;946    void UART0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;947    {
;;;948        CODE_FOR_UARTE_INT
;;;949        (
;;;950            UART0_INSTANCE_INDEX,
;;;951            uarte_irq_handler(NRF_UARTE0, &m_cb[UART0_INSTANCE_INDEX]);
;;;952        )
;;;953        CODE_FOR_UART
000002  4902              LDR      r1,|L1.12|
000004  4802              LDR      r0,|L1.16|
000006  f7fffffe          BL       uart_irq_handler
;;;954        (
;;;955            uart_irq_handler(NRF_UART0, &m_cb[UART0_INSTANCE_INDEX]);
;;;956        )
;;;957    }
00000a  bd10              POP      {r4,pc}
;;;958    #endif
                          ENDP

                  |L1.12|
                          DCD      m_cb
                  |L1.16|
                          DCD      0x40002000

                          AREA ||i.apply_config||, CODE, READONLY, ALIGN=1

                  apply_config PROC
;;;103    
;;;104    __STATIC_INLINE void apply_config(nrf_drv_uart_t const * p_instance, nrf_drv_uart_config_t const * p_config)
000000  b570              PUSH     {r4-r6,lr}
;;;105    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;106        if (p_config->pseltxd != NRF_UART_PSEL_DISCONNECTED)
000006  6820              LDR      r0,[r4,#0]
000008  1c40              ADDS     r0,r0,#1
00000a  2800              CMP      r0,#0
00000c  d005              BEQ      |L2.26|
;;;107        {
;;;108            nrf_gpio_pin_set(p_config->pseltxd);
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       nrf_gpio_pin_set
;;;109            nrf_gpio_cfg_output(p_config->pseltxd);
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       nrf_gpio_cfg_output
                  |L2.26|
;;;110        }
;;;111        if (p_config->pselrxd != NRF_UART_PSEL_DISCONNECTED)
00001a  6860              LDR      r0,[r4,#4]
00001c  1c40              ADDS     r0,r0,#1
00001e  2800              CMP      r0,#0
000020  d003              BEQ      |L2.42|
;;;112        {
;;;113            nrf_gpio_cfg_input(p_config->pselrxd, NRF_GPIO_PIN_NOPULL);
000022  2100              MOVS     r1,#0
000024  6860              LDR      r0,[r4,#4]
000026  f7fffffe          BL       nrf_gpio_cfg_input
                  |L2.42|
;;;114        }
;;;115    
;;;116        CODE_FOR_UARTE
;;;117        (
;;;118            nrf_uarte_baudrate_set(p_instance->reg.p_uarte, (nrf_uarte_baudrate_t)p_config->baudrate);
;;;119            nrf_uarte_configure(p_instance->reg.p_uarte, (nrf_uarte_parity_t)p_config->parity,
;;;120                                (nrf_uarte_hwfc_t)p_config->hwfc);
;;;121            nrf_uarte_txrx_pins_set(p_instance->reg.p_uarte, p_config->pseltxd, p_config->pselrxd);
;;;122            if (p_config->hwfc == NRF_UART_HWFC_ENABLED)
;;;123            {
;;;124                if (p_config->pselcts != NRF_UART_PSEL_DISCONNECTED)
;;;125                {
;;;126                    nrf_gpio_cfg_input(p_config->pselcts, NRF_GPIO_PIN_NOPULL);
;;;127                }
;;;128                if (p_config->pselrts != NRF_UART_PSEL_DISCONNECTED)
;;;129                {
;;;130                    nrf_gpio_pin_set(p_config->pselrts);
;;;131                    nrf_gpio_cfg_output(p_config->pselrts);
;;;132                }
;;;133                nrf_uarte_hwfc_pins_set(p_instance->reg.p_uarte, p_config->pselrts, p_config->pselcts);
;;;134            }
;;;135        )
;;;136        CODE_FOR_UART
00002a  6828              LDR      r0,[r5,#0]
00002c  69a1              LDR      r1,[r4,#0x18]
00002e  2205              MOVS     r2,#5
000030  0212              LSLS     r2,r2,#8
000032  1882              ADDS     r2,r0,r2
000034  6251              STR      r1,[r2,#0x24]
000036  bf00              NOP      
000038  7d61              LDRB     r1,[r4,#0x15]
00003a  7d22              LDRB     r2,[r4,#0x14]
00003c  6828              LDR      r0,[r5,#0]
00003e  460b              MOV      r3,r1
000040  4313              ORRS     r3,r3,r2
000042  2605              MOVS     r6,#5
000044  0236              LSLS     r6,r6,#8
000046  1986              ADDS     r6,r0,r6
000048  66f3              STR      r3,[r6,#0x6c]
00004a  bf00              NOP      
00004c  6862              LDR      r2,[r4,#4]
00004e  6821              LDR      r1,[r4,#0]
000050  6828              LDR      r0,[r5,#0]
000052  f7fffffe          BL       nrf_uart_txrx_pins_set
000056  7d20              LDRB     r0,[r4,#0x14]
000058  2801              CMP      r0,#1
00005a  d116              BNE      |L2.138|
00005c  68a0              LDR      r0,[r4,#8]
00005e  1c40              ADDS     r0,r0,#1
000060  2800              CMP      r0,#0
000062  d003              BEQ      |L2.108|
000064  2100              MOVS     r1,#0
000066  68a0              LDR      r0,[r4,#8]
000068  f7fffffe          BL       nrf_gpio_cfg_input
                  |L2.108|
00006c  68e0              LDR      r0,[r4,#0xc]
00006e  1c40              ADDS     r0,r0,#1
000070  2800              CMP      r0,#0
000072  d005              BEQ      |L2.128|
000074  68e0              LDR      r0,[r4,#0xc]
000076  f7fffffe          BL       nrf_gpio_pin_set
00007a  68e0              LDR      r0,[r4,#0xc]
00007c  f7fffffe          BL       nrf_gpio_cfg_output
                  |L2.128|
000080  68a2              LDR      r2,[r4,#8]
000082  68e1              LDR      r1,[r4,#0xc]
000084  6828              LDR      r0,[r5,#0]
000086  f7fffffe          BL       nrf_uart_hwfc_pins_set
                  |L2.138|
;;;137        (
;;;138            nrf_uart_baudrate_set(p_instance->reg.p_uart, p_config->baudrate);
;;;139            nrf_uart_configure(p_instance->reg.p_uart, p_config->parity, p_config->hwfc);
;;;140            nrf_uart_txrx_pins_set(p_instance->reg.p_uart, p_config->pseltxd, p_config->pselrxd);
;;;141            if (p_config->hwfc == NRF_UART_HWFC_ENABLED)
;;;142            {
;;;143                if (p_config->pselcts != NRF_UART_PSEL_DISCONNECTED)
;;;144                {
;;;145                    nrf_gpio_cfg_input(p_config->pselcts, NRF_GPIO_PIN_NOPULL);
;;;146                }
;;;147                if (p_config->pselrts != NRF_UART_PSEL_DISCONNECTED)
;;;148                {
;;;149                    nrf_gpio_pin_set(p_config->pselrts);
;;;150                    nrf_gpio_cfg_output(p_config->pselrts);
;;;151                }
;;;152                nrf_uart_hwfc_pins_set(p_instance->reg.p_uart, p_config->pselrts, p_config->pselcts);
;;;153            }
;;;154        )
;;;155    }
00008a  bd70              POP      {r4-r6,pc}
;;;156    
                          ENDP


                          AREA ||i.nrf_drv_get_IRQn||, CODE, READONLY, ALIGN=1

                  nrf_drv_get_IRQn PROC
;;;315    
;;;316    __STATIC_INLINE IRQn_Type nrf_drv_get_IRQn(void const * const pinst)
000000  4601              MOV      r1,r0
;;;317    {
;;;318        uint8_t ret = (uint8_t)((uint32_t)pinst>>12U);
000002  0308              LSLS     r0,r1,#12
000004  0e02              LSRS     r2,r0,#24
;;;319        return (IRQn_Type) ret;
000006  b250              SXTB     r0,r2
;;;320    }
000008  4770              BX       lr
;;;321    
                          ENDP


                          AREA ||i.nrf_drv_uart_errorsrc_get||, CODE, READONLY, ALIGN=1

                  nrf_drv_uart_errorsrc_get PROC
;;;705    
;;;706    uint32_t nrf_drv_uart_errorsrc_get(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;707    {
000002  4604              MOV      r4,r0
;;;708        uint32_t errsrc;
;;;709        CODE_FOR_UARTE
;;;710        (
;;;711            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_ERROR);
;;;712            errsrc = nrf_uarte_errorsrc_get_and_clear(p_instance->reg.p_uarte);
;;;713        )
;;;714        CODE_FOR_UART
000004  21ff              MOVS     r1,#0xff
000006  3125              ADDS     r1,r1,#0x25
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       nrf_uart_event_clear
00000e  6820              LDR      r0,[r4,#0]
000010  f7fffffe          BL       nrf_uart_errorsrc_get_and_clear
000014  4605              MOV      r5,r0
;;;715        (
;;;716            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
;;;717            errsrc = nrf_uart_errorsrc_get_and_clear(p_instance->reg.p_uart);
;;;718        )
;;;719        return errsrc;
000016  4628              MOV      r0,r5
;;;720    }
000018  bd70              POP      {r4-r6,pc}
;;;721    
                          ENDP


                          AREA ||i.nrf_drv_uart_init||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_init PROC
;;;262    
;;;263    ret_code_t nrf_drv_uart_init(const nrf_drv_uart_t * p_instance, nrf_drv_uart_config_t const * p_config,
000000  b5fe              PUSH     {r1-r7,lr}
;;;264                                 nrf_uart_event_handler_t event_handler)
;;;265    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;266        ASSERT(p_config);
;;;267        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000008  7928              LDRB     r0,[r5,#4]
00000a  211c              MOVS     r1,#0x1c
00000c  4348              MULS     r0,r1,r0
00000e  4920              LDR      r1,|L5.144|
000010  1844              ADDS     r4,r0,r1
;;;268        ret_code_t err_code = NRF_SUCCESS;
000012  2000              MOVS     r0,#0
000014  9002              STR      r0,[sp,#8]
;;;269    
;;;270        if (p_cb->state != NRF_DRV_STATE_UNINITIALIZED)
000016  7ee0              LDRB     r0,[r4,#0x1b]
000018  2800              CMP      r0,#0
00001a  d003              BEQ      |L5.36|
;;;271        {
;;;272            err_code = NRF_ERROR_INVALID_STATE;
00001c  2008              MOVS     r0,#8
00001e  9002              STR      r0,[sp,#8]
;;;273            NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;274            return err_code;
000020  9802              LDR      r0,[sp,#8]
                  |L5.34|
;;;275        }
;;;276    
;;;277    #if (defined(UARTE_IN_USE) && defined(UART_IN_USE))
;;;278        p_cb->use_easy_dma = p_config->use_easy_dma;
;;;279    #endif
;;;280        apply_config(p_instance, p_config);
;;;281    
;;;282        p_cb->handler = event_handler;
;;;283        p_cb->p_context = p_config->p_context;
;;;284    
;;;285        if (p_cb->handler)
;;;286        {
;;;287            interrupts_enable(p_instance, p_config->interrupt_priority);
;;;288        }
;;;289    
;;;290        uart_enable(p_instance);
;;;291        p_cb->rx_buffer_length = 0;
;;;292        p_cb->rx_secondary_buffer_length = 0;
;;;293        p_cb->tx_buffer_length = 0;
;;;294        p_cb->state = NRF_DRV_STATE_INITIALIZED;
;;;295        p_cb->rx_enabled = false;
;;;296        NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;297        return err_code;
;;;298    }
000022  bdfe              POP      {r1-r7,pc}
                  |L5.36|
000024  4631              MOV      r1,r6                 ;280
000026  4628              MOV      r0,r5                 ;280
000028  f7fffffe          BL       apply_config
00002c  6067              STR      r7,[r4,#4]            ;282
00002e  6930              LDR      r0,[r6,#0x10]         ;283
000030  6020              STR      r0,[r4,#0]            ;283
000032  6860              LDR      r0,[r4,#4]            ;285
000034  2800              CMP      r0,#0                 ;285
000036  d018              BEQ      |L5.106|
000038  7f30              LDRB     r0,[r6,#0x1c]         ;287
00003a  9001              STR      r0,[sp,#4]            ;287
00003c  21ff              MOVS     r1,#0xff              ;287
00003e  311d              ADDS     r1,r1,#0x1d           ;287
000040  6828              LDR      r0,[r5,#0]            ;287
000042  f7fffffe          BL       nrf_uart_event_clear
000046  21ff              MOVS     r1,#0xff              ;287
000048  3145              ADDS     r1,r1,#0x45           ;287
00004a  6828              LDR      r0,[r5,#0]            ;287
00004c  f7fffffe          BL       nrf_uart_event_clear
000050  4910              LDR      r1,|L5.148|
000052  6828              LDR      r0,[r5,#0]            ;287
000054  f7fffffe          BL       nrf_uart_int_enable
000058  6828              LDR      r0,[r5,#0]            ;287
00005a  f7fffffe          BL       nrf_drv_get_IRQn
00005e  9000              STR      r0,[sp,#0]            ;287
000060  9901              LDR      r1,[sp,#4]            ;287
000062  f7fffffe          BL       nrf_drv_common_irq_enable
000066  bf00              NOP                            ;287
000068  bf00              NOP                            ;287
                  |L5.106|
00006a  bf00              NOP                            ;290
00006c  6828              LDR      r0,[r5,#0]            ;290
00006e  2104              MOVS     r1,#4                 ;290
000070  2205              MOVS     r2,#5                 ;290
000072  0212              LSLS     r2,r2,#8              ;290
000074  1882              ADDS     r2,r0,r2              ;290
000076  6011              STR      r1,[r2,#0]            ;290
000078  bf00              NOP                            ;290
00007a  bf00              NOP                            ;290
00007c  2000              MOVS     r0,#0                 ;291
00007e  75e0              STRB     r0,[r4,#0x17]         ;291
000080  7620              STRB     r0,[r4,#0x18]         ;292
000082  75a0              STRB     r0,[r4,#0x16]         ;293
000084  2001              MOVS     r0,#1                 ;294
000086  76e0              STRB     r0,[r4,#0x1b]         ;294
000088  2000              MOVS     r0,#0                 ;295
00008a  76a0              STRB     r0,[r4,#0x1a]         ;295
00008c  9802              LDR      r0,[sp,#8]            ;297
00008e  e7c8              B        |L5.34|
;;;299    
                          ENDP

                  |L5.144|
                          DCD      m_cb
                  |L5.148|
                          DCD      0x00020080

                          AREA ||i.nrf_drv_uart_rx||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx PROC
;;;592    
;;;593    ret_code_t nrf_drv_uart_rx(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length)
000000  b5fe              PUSH     {r1-r7,lr}
;;;594    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;595        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000008  7928              LDRB     r0,[r5,#4]
00000a  211c              MOVS     r1,#0x1c
00000c  4348              MULS     r0,r1,r0
00000e  4918              LDR      r1,|L6.112|
000010  1844              ADDS     r4,r0,r1
;;;596    
;;;597        ASSERT(m_cb[p_instance->drv_inst_idx].state == NRF_DRV_STATE_INITIALIZED);
;;;598        ASSERT(length>0);
;;;599    
;;;600        ret_code_t err_code;
;;;601    
;;;602        CODE_FOR_UARTE
;;;603        (
;;;604            // EasyDMA requires that transfer buffers are placed in DataRAM,
;;;605            // signal error if the are not.
;;;606            if (!nrf_drv_is_in_RAM(p_data))
;;;607            {
;;;608                err_code = NRF_ERROR_INVALID_ADDR;
;;;609                NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;610                return err_code;
;;;611            }
;;;612        )
;;;613    
;;;614        bool second_buffer = false;
000012  2000              MOVS     r0,#0
000014  9000              STR      r0,[sp,#0]
;;;615    
;;;616        if (p_cb->handler)
000016  6860              LDR      r0,[r4,#4]
000018  2800              CMP      r0,#0
00001a  d004              BEQ      |L6.38|
;;;617        {
;;;618            CODE_FOR_UARTE
;;;619            (
;;;620                nrf_uarte_int_disable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
;;;621            )
;;;622            CODE_FOR_UART
00001c  2181              MOVS     r1,#0x81
00001e  0089              LSLS     r1,r1,#2
000020  6828              LDR      r0,[r5,#0]
000022  f7fffffe          BL       nrf_uart_int_disable
                  |L6.38|
;;;623            (
;;;624                nrf_uart_int_disable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;625            )
;;;626        }
;;;627        if (p_cb->rx_buffer_length != 0)
000026  7de0              LDRB     r0,[r4,#0x17]
000028  2800              CMP      r0,#0
00002a  d010              BEQ      |L6.78|
;;;628        {
;;;629            if (p_cb->rx_secondary_buffer_length != 0)
00002c  7e20              LDRB     r0,[r4,#0x18]
00002e  2800              CMP      r0,#0
000030  d00b              BEQ      |L6.74|
;;;630            {
;;;631                if (p_cb->handler)
000032  6860              LDR      r0,[r4,#4]
000034  2800              CMP      r0,#0
000036  d004              BEQ      |L6.66|
;;;632                {
;;;633                    CODE_FOR_UARTE
;;;634                    (
;;;635                        nrf_uarte_int_enable(p_instance->reg.p_uarte, NRF_UARTE_INT_ERROR_MASK | NRF_UARTE_INT_ENDRX_MASK);
;;;636                    )
;;;637                    CODE_FOR_UART
000038  2181              MOVS     r1,#0x81
00003a  0089              LSLS     r1,r1,#2
00003c  6828              LDR      r0,[r5,#0]
00003e  f7fffffe          BL       nrf_uart_int_enable
                  |L6.66|
;;;638                    (
;;;639                        nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;640                    )
;;;641                }
;;;642                err_code = NRF_ERROR_BUSY;
000042  2011              MOVS     r0,#0x11
000044  9001              STR      r0,[sp,#4]
;;;643                NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;644                return err_code;
000046  9801              LDR      r0,[sp,#4]
                  |L6.72|
;;;645            }
;;;646            second_buffer = true;
;;;647        }
;;;648    
;;;649        if (!second_buffer)
;;;650        {
;;;651            p_cb->rx_buffer_length = length;
;;;652            p_cb->p_rx_buffer      = p_data;
;;;653            p_cb->rx_counter       = 0;
;;;654            p_cb->rx_secondary_buffer_length = 0;
;;;655        }
;;;656        else
;;;657        {
;;;658            p_cb->p_rx_secondary_buffer = p_data;
;;;659            p_cb->rx_secondary_buffer_length = length;
;;;660        }
;;;661    
;;;662        NRF_LOG_INFO("Transfer rx_len: %d.\r\n", length);
;;;663    
;;;664    
;;;665        CODE_FOR_UARTE
;;;666        (
;;;667            return nrf_drv_uart_rx_for_uarte(p_instance, p_data, length, second_buffer);
;;;668        )
;;;669        CODE_FOR_UART
;;;670        (
;;;671            return nrf_drv_uart_rx_for_uart(p_instance, p_data, length, second_buffer);
;;;672        )
;;;673    }
000048  bdfe              POP      {r1-r7,pc}
                  |L6.74|
00004a  2001              MOVS     r0,#1                 ;646
00004c  9000              STR      r0,[sp,#0]            ;646
                  |L6.78|
00004e  9800              LDR      r0,[sp,#0]            ;649
000050  2800              CMP      r0,#0                 ;649
000052  d104              BNE      |L6.94|
000054  75e7              STRB     r7,[r4,#0x17]         ;651
000056  60e6              STR      r6,[r4,#0xc]          ;652
000058  7660              STRB     r0,[r4,#0x19]         ;653
00005a  7620              STRB     r0,[r4,#0x18]         ;654
00005c  e001              B        |L6.98|
                  |L6.94|
00005e  6126              STR      r6,[r4,#0x10]         ;658
000060  7627              STRB     r7,[r4,#0x18]         ;659
                  |L6.98|
000062  463a              MOV      r2,r7                 ;669
000064  4631              MOV      r1,r6                 ;669
000066  4628              MOV      r0,r5                 ;669
000068  9b00              LDR      r3,[sp,#0]            ;669
00006a  f7fffffe          BL       nrf_drv_uart_rx_for_uart
00006e  e7eb              B        |L6.72|
;;;674    
                          ENDP

                  |L6.112|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_abort||, CODE, READONLY, ALIGN=1

                  nrf_drv_uart_rx_abort PROC
;;;773    
;;;774    void nrf_drv_uart_rx_abort(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;775    {
000002  4604              MOV      r4,r0
;;;776        CODE_FOR_UARTE
;;;777        (
;;;778            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STOPRX);
;;;779        )
;;;780        CODE_FOR_UART
000004  2181              MOVS     r1,#0x81
000006  0089              LSLS     r1,r1,#2
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       nrf_uart_int_disable
00000e  2104              MOVS     r1,#4
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       nrf_uart_task_trigger
;;;781        (
;;;782            nrf_uart_int_disable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;783            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;784        )
;;;785        NRF_LOG_INFO("RX transaction aborted.\r\n");
;;;786    }
000016  bd10              POP      {r4,pc}
;;;787    
                          ENDP


                          AREA ||i.nrf_drv_uart_rx_disable||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_disable PROC
;;;691    
;;;692    void nrf_drv_uart_rx_disable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;693    {
000002  4604              MOV      r4,r0
;;;694        //Easy dma mode does not support enabling receiver without setting up buffer.
;;;695        CODE_FOR_UARTE
;;;696        (
;;;697            ASSERT(false);
;;;698        )
;;;699        CODE_FOR_UART
000004  2104              MOVS     r1,#4
000006  6820              LDR      r0,[r4,#0]
000008  f7fffffe          BL       nrf_uart_task_trigger
00000c  2100              MOVS     r1,#0
00000e  7920              LDRB     r0,[r4,#4]
000010  221c              MOVS     r2,#0x1c
000012  4350              MULS     r0,r2,r0
000014  4a01              LDR      r2,|L8.28|
000016  1880              ADDS     r0,r0,r2
000018  7681              STRB     r1,[r0,#0x1a]
;;;700        (
;;;701            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;702            m_cb[p_instance->drv_inst_idx].rx_enabled = false;
;;;703        )
;;;704    }
00001a  bd10              POP      {r4,pc}
;;;705    
                          ENDP

                  |L8.28|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_enable||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_enable PROC
;;;674    
;;;675    void nrf_drv_uart_rx_enable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;676    {
000002  4604              MOV      r4,r0
;;;677        //Easy dma mode does not support enabling receiver without setting up buffer.
;;;678        CODE_FOR_UARTE
;;;679        (
;;;680            ASSERT(false);
;;;681        )
;;;682        CODE_FOR_UART
000004  7920              LDRB     r0,[r4,#4]
000006  211c              MOVS     r1,#0x1c
000008  4348              MULS     r0,r1,r0
00000a  4908              LDR      r1,|L9.44|
00000c  1840              ADDS     r0,r0,r1
00000e  7e80              LDRB     r0,[r0,#0x1a]
000010  2800              CMP      r0,#0
000012  d109              BNE      |L9.40|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rx_enable
00001a  2101              MOVS     r1,#1
00001c  7920              LDRB     r0,[r4,#4]
00001e  221c              MOVS     r2,#0x1c
000020  4350              MULS     r0,r2,r0
000022  4a02              LDR      r2,|L9.44|
000024  1880              ADDS     r0,r0,r2
000026  7681              STRB     r1,[r0,#0x1a]
                  |L9.40|
;;;683        (
;;;684            if (!m_cb[p_instance->drv_inst_idx].rx_enabled)
;;;685            {
;;;686                rx_enable(p_instance);
;;;687                m_cb[p_instance->drv_inst_idx].rx_enabled = true;
;;;688            }
;;;689        )
;;;690    }
000028  bd10              POP      {r4,pc}
;;;691    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_rx_for_uart||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_rx_for_uart PROC
;;;475    
;;;476    __STATIC_INLINE ret_code_t nrf_drv_uart_rx_for_uart(const nrf_drv_uart_t * p_instance, uint8_t * p_data, uint8_t length, bool second_buffer)
000000  b5ff              PUSH     {r0-r7,lr}
;;;477    {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
;;;478        ret_code_t err_code;
;;;479        
;;;480        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000006  7920              LDRB     r0,[r4,#4]
000008  211c              MOVS     r1,#0x1c
00000a  4348              MULS     r0,r1,r0
00000c  4930              LDR      r1,|L10.208|
00000e  1845              ADDS     r5,r0,r1
;;;481    
;;;482        if ((!p_cb->rx_enabled) && (!second_buffer))
000010  7ea8              LDRB     r0,[r5,#0x1a]
000012  2800              CMP      r0,#0
000014  d105              BNE      |L10.34|
000016  9806              LDR      r0,[sp,#0x18]
000018  2800              CMP      r0,#0
00001a  d102              BNE      |L10.34|
;;;483        {
;;;484            rx_enable(p_instance);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rx_enable
                  |L10.34|
;;;485        }
;;;486    
;;;487        if (p_cb->handler == NULL)
000022  6868              LDR      r0,[r5,#4]
000024  2800              CMP      r0,#0
000026  d14a              BNE      |L10.190|
;;;488        {
;;;489            nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
000028  21ff              MOVS     r1,#0xff
00002a  3145              ADDS     r1,r1,#0x45
00002c  6820              LDR      r0,[r4,#0]
00002e  f7fffffe          BL       nrf_uart_event_clear
;;;490    
;;;491            bool rxrdy;
;;;492            bool rxto;
;;;493            bool error;
;;;494            do
000032  bf00              NOP      
                  |L10.52|
;;;495            {
;;;496                do
000034  bf00              NOP      
                  |L10.54|
;;;497                {
;;;498                    error = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
000036  21ff              MOVS     r1,#0xff
000038  3125              ADDS     r1,r1,#0x25
00003a  6820              LDR      r0,[r4,#0]
00003c  f7fffffe          BL       nrf_uart_event_check
000040  9001              STR      r0,[sp,#4]
;;;499                    rxrdy = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_RXDRDY);
000042  21ff              MOVS     r1,#0xff
000044  3109              ADDS     r1,r1,#9
000046  6820              LDR      r0,[r4,#0]
000048  f7fffffe          BL       nrf_uart_event_check
00004c  9002              STR      r0,[sp,#8]
;;;500                    rxto  = nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_RXTO);
00004e  21ff              MOVS     r1,#0xff
000050  3145              ADDS     r1,r1,#0x45
000052  6820              LDR      r0,[r4,#0]
000054  f7fffffe          BL       nrf_uart_event_check
000058  4606              MOV      r6,r0
;;;501                } while ((!rxrdy) && (!rxto) && (!error));
00005a  9802              LDR      r0,[sp,#8]
00005c  2800              CMP      r0,#0
00005e  d104              BNE      |L10.106|
000060  2e00              CMP      r6,#0
000062  d102              BNE      |L10.106|
000064  9801              LDR      r0,[sp,#4]
000066  2800              CMP      r0,#0
000068  d0e5              BEQ      |L10.54|
                  |L10.106|
;;;502    
;;;503                if (error || rxto)
00006a  9801              LDR      r0,[sp,#4]
00006c  2800              CMP      r0,#0
00006e  d101              BNE      |L10.116|
000070  2e00              CMP      r6,#0
000072  d000              BEQ      |L10.118|
                  |L10.116|
;;;504                {
;;;505                    break;
000074  e007              B        |L10.134|
                  |L10.118|
;;;506                }
;;;507                rx_byte(p_instance->reg.p_uart, p_cb);
000076  4629              MOV      r1,r5
000078  6820              LDR      r0,[r4,#0]
00007a  f7fffffe          BL       rx_byte
;;;508            } while (p_cb->rx_buffer_length > p_cb->rx_counter);
00007e  7de8              LDRB     r0,[r5,#0x17]
000080  7e69              LDRB     r1,[r5,#0x19]
000082  4288              CMP      r0,r1
000084  dcd6              BGT      |L10.52|
                  |L10.134|
000086  bf00              NOP                            ;505
;;;509    
;;;510            p_cb->rx_buffer_length = 0;
000088  2000              MOVS     r0,#0
00008a  75e8              STRB     r0,[r5,#0x17]
;;;511            if (error)
00008c  9801              LDR      r0,[sp,#4]
00008e  2800              CMP      r0,#0
000090  d003              BEQ      |L10.154|
;;;512            {
;;;513                err_code = NRF_ERROR_INTERNAL;
000092  2703              MOVS     r7,#3
;;;514                NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;515                return err_code;
000094  4638              MOV      r0,r7
                  |L10.150|
;;;516            }
;;;517    
;;;518            if (rxto)
;;;519            {
;;;520                err_code = NRF_ERROR_FORBIDDEN;
;;;521                NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;522                return err_code;
;;;523            }
;;;524    
;;;525            if (p_cb->rx_enabled)
;;;526            {
;;;527                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTRX);
;;;528            }
;;;529            else
;;;530            {
;;;531                // Skip stopping RX if driver is forced to be enabled.
;;;532                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPRX);
;;;533            }
;;;534        }
;;;535        else
;;;536        {
;;;537            nrf_uart_int_enable(p_instance->reg.p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
;;;538        }
;;;539        err_code = NRF_SUCCESS;
;;;540        NRF_LOG_INFO("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;541        return err_code;
;;;542    }
000096  b007              ADD      sp,sp,#0x1c
000098  bdf0              POP      {r4-r7,pc}
                  |L10.154|
00009a  2e00              CMP      r6,#0                 ;518
00009c  d002              BEQ      |L10.164|
00009e  270f              MOVS     r7,#0xf               ;520
0000a0  4638              MOV      r0,r7                 ;522
0000a2  e7f8              B        |L10.150|
                  |L10.164|
0000a4  7ea8              LDRB     r0,[r5,#0x1a]         ;525
0000a6  2800              CMP      r0,#0                 ;525
0000a8  d004              BEQ      |L10.180|
0000aa  2100              MOVS     r1,#0                 ;527
0000ac  6820              LDR      r0,[r4,#0]            ;527
0000ae  f7fffffe          BL       nrf_uart_task_trigger
0000b2  e003              B        |L10.188|
                  |L10.180|
0000b4  2104              MOVS     r1,#4                 ;532
0000b6  6820              LDR      r0,[r4,#0]            ;532
0000b8  f7fffffe          BL       nrf_uart_task_trigger
                  |L10.188|
0000bc  e004              B        |L10.200|
                  |L10.190|
0000be  2181              MOVS     r1,#0x81              ;537
0000c0  0089              LSLS     r1,r1,#2              ;537
0000c2  6820              LDR      r0,[r4,#0]            ;537
0000c4  f7fffffe          BL       nrf_uart_int_enable
                  |L10.200|
0000c8  2700              MOVS     r7,#0                 ;539
0000ca  4638              MOV      r0,r7                 ;541
0000cc  e7e3              B        |L10.150|
;;;543    #endif
                          ENDP

0000ce  0000              DCW      0x0000
                  |L10.208|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx PROC
;;;403    
;;;404    ret_code_t nrf_drv_uart_tx(const nrf_drv_uart_t * p_instance, uint8_t const * const p_data, uint8_t length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;405    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;406        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000008  7928              LDRB     r0,[r5,#4]
00000a  211c              MOVS     r1,#0x1c
00000c  4348              MULS     r0,r1,r0
00000e  4909              LDR      r1,|L11.52|
000010  1844              ADDS     r4,r0,r1
;;;407        ASSERT(p_cb->state == NRF_DRV_STATE_INITIALIZED);
;;;408        ASSERT(length>0);
;;;409        ASSERT(p_data);
;;;410    
;;;411        ret_code_t err_code;
;;;412        
;;;413        CODE_FOR_UARTE
;;;414        (
;;;415            // EasyDMA requires that transfer buffers are placed in DataRAM,
;;;416            // signal error if the are not.
;;;417            if (!nrf_drv_is_in_RAM(p_data))
;;;418            {
;;;419                err_code = NRF_ERROR_INVALID_ADDR;
;;;420                NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;421                return err_code;
;;;422            }
;;;423        )
;;;424    
;;;425        if (nrf_drv_uart_tx_in_progress(p_instance))
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       nrf_drv_uart_tx_in_progress
000018  2800              CMP      r0,#0
00001a  d003              BEQ      |L11.36|
;;;426        {
;;;427            err_code = NRF_ERROR_BUSY;
00001c  2011              MOVS     r0,#0x11
00001e  9000              STR      r0,[sp,#0]
;;;428            NRF_LOG_WARNING("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;429            return err_code;
000020  9800              LDR      r0,[sp,#0]
                  |L11.34|
;;;430        }
;;;431        p_cb->tx_buffer_length = length;
;;;432        p_cb->p_tx_buffer      = p_data;
;;;433        p_cb->tx_counter       = 0;
;;;434    
;;;435        NRF_LOG_INFO("Transfer tx_len: %d.\r\n", p_cb->tx_buffer_length);
;;;436        NRF_LOG_DEBUG("Tx data:\r\n");
;;;437        NRF_LOG_HEXDUMP_DEBUG((uint8_t *)p_cb->p_tx_buffer, p_cb->tx_buffer_length * sizeof(p_cb->p_tx_buffer));
;;;438    
;;;439        CODE_FOR_UARTE
;;;440        (
;;;441            return nrf_drv_uart_tx_for_uarte(p_instance);
;;;442        )
;;;443        CODE_FOR_UART
;;;444        (
;;;445            return nrf_drv_uart_tx_for_uart(p_instance);
;;;446        )
;;;447    }
000022  bdf8              POP      {r3-r7,pc}
                  |L11.36|
000024  75a7              STRB     r7,[r4,#0x16]         ;431
000026  60a6              STR      r6,[r4,#8]            ;432
000028  2000              MOVS     r0,#0                 ;433
00002a  82a0              STRH     r0,[r4,#0x14]         ;433
00002c  4628              MOV      r0,r5                 ;443
00002e  f7fffffe          BL       nrf_drv_uart_tx_for_uart
000032  e7f6              B        |L11.34|
;;;448    
                          ENDP

                  |L11.52|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_abort||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_abort PROC
;;;745    
;;;746    void nrf_drv_uart_tx_abort(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;747    {
000002  4605              MOV      r5,r0
;;;748        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7928              LDRB     r0,[r5,#4]
000006  211c              MOVS     r1,#0x1c
000008  4348              MULS     r0,r1,r0
00000a  4909              LDR      r1,|L12.48|
00000c  1844              ADDS     r4,r0,r1
;;;749    
;;;750        CODE_FOR_UARTE
;;;751        (
;;;752            nrf_uarte_event_clear(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED);
;;;753            nrf_uarte_task_trigger(p_instance->reg.p_uarte, NRF_UARTE_TASK_STOPTX);
;;;754            if (p_cb->handler == NULL)
;;;755            {
;;;756                while (!nrf_uarte_event_check(p_instance->reg.p_uarte, NRF_UARTE_EVENT_TXSTOPPED));
;;;757            }
;;;758        )
;;;759        CODE_FOR_UART
00000e  210c              MOVS     r1,#0xc
000010  6828              LDR      r0,[r5,#0]
000012  f7fffffe          BL       nrf_uart_task_trigger
000016  6860              LDR      r0,[r4,#4]
000018  2800              CMP      r0,#0
00001a  d005              BEQ      |L12.40|
00001c  8aa0              LDRH     r0,[r4,#0x14]
00001e  b2c1              UXTB     r1,r0
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       tx_done_event
000026  e002              B        |L12.46|
                  |L12.40|
000028  20ff              MOVS     r0,#0xff
00002a  3001              ADDS     r0,#1
00002c  82a0              STRH     r0,[r4,#0x14]
                  |L12.46|
;;;760        (
;;;761            nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPTX);
;;;762            if (p_cb->handler)
;;;763            {
;;;764                tx_done_event(p_cb, p_cb->tx_counter);
;;;765            }
;;;766            else
;;;767            {
;;;768                p_cb->tx_counter       = TX_COUNTER_ABORT_REQ_VALUE;
;;;769            }
;;;770        )
;;;771        NRF_LOG_INFO("TX transaction aborted.\r\n");
;;;772    }
00002e  bd70              POP      {r4-r6,pc}
;;;773    
                          ENDP

                  |L12.48|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_for_uart||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_for_uart PROC
;;;326    
;;;327    __STATIC_INLINE ret_code_t nrf_drv_uart_tx_for_uart(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;328    {
000002  4604              MOV      r4,r0
;;;329        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  211c              MOVS     r1,#0x1c
000008  4348              MULS     r0,r1,r0
00000a  4922              LDR      r1,|L13.148|
00000c  1845              ADDS     r5,r0,r1
;;;330        ret_code_t err_code = NRF_SUCCESS;
00000e  2600              MOVS     r6,#0
;;;331    
;;;332        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY);
000010  21ff              MOVS     r1,#0xff
000012  311d              ADDS     r1,r1,#0x1d
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       nrf_uart_event_clear
;;;333        nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTTX);
00001a  2108              MOVS     r1,#8
00001c  6820              LDR      r0,[r4,#0]
00001e  f7fffffe          BL       nrf_uart_task_trigger
;;;334    
;;;335        tx_byte(p_instance->reg.p_uart, p_cb);
000022  4629              MOV      r1,r5
000024  6820              LDR      r0,[r4,#0]
000026  f7fffffe          BL       tx_byte
;;;336    
;;;337        if (p_cb->handler == NULL)
00002a  6868              LDR      r0,[r5,#4]
00002c  2800              CMP      r0,#0
00002e  d12f              BNE      |L13.144|
;;;338        {
;;;339            while (p_cb->tx_counter < (uint16_t) p_cb->tx_buffer_length)
000030  e015              B        |L13.94|
                  |L13.50|
;;;340            {
;;;341                while (!nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY) &&
000032  bf00              NOP      
                  |L13.52|
000034  21ff              MOVS     r1,#0xff
000036  311d              ADDS     r1,r1,#0x1d
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       nrf_uart_event_check
00003e  2800              CMP      r0,#0
000040  d104              BNE      |L13.76|
;;;342                        p_cb->tx_counter != TX_COUNTER_ABORT_REQ_VALUE)
000042  8aa8              LDRH     r0,[r5,#0x14]
000044  21ff              MOVS     r1,#0xff
000046  3101              ADDS     r1,#1
000048  4288              CMP      r0,r1
00004a  d1f3              BNE      |L13.52|
                  |L13.76|
;;;343                {
;;;344                }
;;;345                if (p_cb->tx_counter != TX_COUNTER_ABORT_REQ_VALUE)
00004c  8aa8              LDRH     r0,[r5,#0x14]
00004e  21ff              MOVS     r1,#0xff
000050  3101              ADDS     r1,#1
000052  4288              CMP      r0,r1
000054  d003              BEQ      |L13.94|
;;;346                {
;;;347                    tx_byte(p_instance->reg.p_uart, p_cb);
000056  4629              MOV      r1,r5
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       tx_byte
                  |L13.94|
00005e  8aa8              LDRH     r0,[r5,#0x14]         ;339
000060  7da9              LDRB     r1,[r5,#0x16]         ;339
000062  4288              CMP      r0,r1                 ;339
000064  dbe5              BLT      |L13.50|
;;;348                }
;;;349            }
;;;350    
;;;351            if (p_cb->tx_counter == TX_COUNTER_ABORT_REQ_VALUE)
000066  8aa8              LDRH     r0,[r5,#0x14]
000068  21ff              MOVS     r1,#0xff
00006a  3101              ADDS     r1,#1
00006c  4288              CMP      r0,r1
00006e  d101              BNE      |L13.116|
;;;352            {
;;;353                err_code = NRF_ERROR_FORBIDDEN;
000070  260f              MOVS     r6,#0xf
000072  e00b              B        |L13.140|
                  |L13.116|
;;;354            }
;;;355            else
;;;356            {
;;;357                while (!nrf_uart_event_check(p_instance->reg.p_uart, NRF_UART_EVENT_TXDRDY))
000074  bf00              NOP      
                  |L13.118|
000076  21ff              MOVS     r1,#0xff
000078  311d              ADDS     r1,r1,#0x1d
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       nrf_uart_event_check
000080  2800              CMP      r0,#0
000082  d0f8              BEQ      |L13.118|
;;;358                {
;;;359                }
;;;360                nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STOPTX);
000084  210c              MOVS     r1,#0xc
000086  6820              LDR      r0,[r4,#0]
000088  f7fffffe          BL       nrf_uart_task_trigger
                  |L13.140|
;;;361            }
;;;362            p_cb->tx_buffer_length = 0;
00008c  2000              MOVS     r0,#0
00008e  75a8              STRB     r0,[r5,#0x16]
                  |L13.144|
;;;363        }
;;;364    
;;;365        NRF_LOG_INFO("Function: %s, error code: %s.\r\n", (uint32_t)__func__, (uint32_t)ERR_TO_STR(err_code));
;;;366        return err_code;
000090  4630              MOV      r0,r6
;;;367    }
000092  bd70              POP      {r4-r6,pc}
;;;368    #endif
                          ENDP

                  |L13.148|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_tx_in_progress||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_tx_in_progress PROC
;;;448    
;;;449    bool nrf_drv_uart_tx_in_progress(const nrf_drv_uart_t * p_instance)
000000  4601              MOV      r1,r0
;;;450    {
;;;451        return (m_cb[p_instance->drv_inst_idx].tx_buffer_length != 0);
000002  7908              LDRB     r0,[r1,#4]
000004  221c              MOVS     r2,#0x1c
000006  4350              MULS     r0,r2,r0
000008  4a04              LDR      r2,|L14.28|
00000a  1880              ADDS     r0,r0,r2
00000c  7d80              LDRB     r0,[r0,#0x16]
00000e  2800              CMP      r0,#0
000010  d001              BEQ      |L14.22|
000012  2001              MOVS     r0,#1
                  |L14.20|
;;;452    }
000014  4770              BX       lr
                  |L14.22|
000016  2000              MOVS     r0,#0                 ;451
000018  e7fc              B        |L14.20|
;;;453    
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      m_cb

                          AREA ||i.nrf_drv_uart_uninit||, CODE, READONLY, ALIGN=2

                  nrf_drv_uart_uninit PROC
;;;299    
;;;300    void nrf_drv_uart_uninit(const nrf_drv_uart_t * p_instance)
000000  b570              PUSH     {r4-r6,lr}
;;;301    {
000002  4604              MOV      r4,r0
;;;302        uart_control_block_t * p_cb = &m_cb[p_instance->drv_inst_idx];
000004  7920              LDRB     r0,[r4,#4]
000006  211c              MOVS     r1,#0x1c
000008  4348              MULS     r0,r1,r0
00000a  4914              LDR      r1,|L15.92|
00000c  1846              ADDS     r6,r0,r1
;;;303    
;;;304        uart_disable(p_instance);
00000e  bf00              NOP      
000010  6820              LDR      r0,[r4,#0]
000012  2100              MOVS     r1,#0
000014  2205              MOVS     r2,#5
000016  0212              LSLS     r2,r2,#8
000018  1882              ADDS     r2,r0,r2
00001a  6011              STR      r1,[r2,#0]
00001c  bf00              NOP      
00001e  bf00              NOP      
;;;305    
;;;306        if (p_cb->handler)
000020  6870              LDR      r0,[r6,#4]
000022  2800              CMP      r0,#0
000024  d013              BEQ      |L15.78|
;;;307        {
;;;308            interrupts_disable(p_instance);
000026  bf00              NOP      
000028  490d              LDR      r1,|L15.96|
00002a  6820              LDR      r0,[r4,#0]
00002c  f7fffffe          BL       nrf_uart_int_disable
000030  6820              LDR      r0,[r4,#0]
000032  f7fffffe          BL       nrf_drv_get_IRQn
000036  4605              MOV      r5,r0
000038  4628              MOV      r0,r5
00003a  06c2              LSLS     r2,r0,#27
00003c  0ed2              LSRS     r2,r2,#27
00003e  2101              MOVS     r1,#1
000040  4091              LSLS     r1,r1,r2
000042  4a08              LDR      r2,|L15.100|
000044  6011              STR      r1,[r2,#0]
000046  bf00              NOP      
000048  bf00              NOP      
00004a  bf00              NOP      
00004c  bf00              NOP      
                  |L15.78|
;;;309        }
;;;310    
;;;311        pins_to_default(p_instance);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       pins_to_default
;;;312    
;;;313        p_cb->state = NRF_DRV_STATE_UNINITIALIZED;
000054  2000              MOVS     r0,#0
000056  76f0              STRB     r0,[r6,#0x1b]
;;;314        p_cb->handler = NULL;
000058  6070              STR      r0,[r6,#4]
;;;315        NRF_LOG_INFO("Instance uninitialized: %d.\r\n", p_instance->drv_inst_idx);
;;;316    }
00005a  bd70              POP      {r4-r6,pc}
;;;317    
                          ENDP

                  |L15.92|
                          DCD      m_cb
                  |L15.96|
                          DCD      0x00020284
                  |L15.100|
                          DCD      0xe000e180

                          AREA ||i.nrf_gpio_cfg||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg PROC
;;;503    
;;;504    __STATIC_INLINE void nrf_gpio_cfg(
000000  b5f0              PUSH     {r4-r7,lr}
;;;505        uint32_t             pin_number,
;;;506        nrf_gpio_pin_dir_t   dir,
;;;507        nrf_gpio_pin_input_t input,
;;;508        nrf_gpio_pin_pull_t  pull,
;;;509        nrf_gpio_pin_drive_t drive,
;;;510        nrf_gpio_pin_sense_t sense)
;;;511    {
;;;512        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000002  bf00              NOP      
000004  2505              MOVS     r5,#5
000006  072d              LSLS     r5,r5,#28
000008  462c              MOV      r4,r5
;;;513    
;;;514        reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
00000a  0055              LSLS     r5,r2,#1
00000c  430d              ORRS     r5,r5,r1
00000e  009e              LSLS     r6,r3,#2
000010  4335              ORRS     r5,r5,r6
000012  9e05              LDR      r6,[sp,#0x14]
000014  0236              LSLS     r6,r6,#8
000016  4335              ORRS     r5,r5,r6
000018  9e06              LDR      r6,[sp,#0x18]
00001a  0436              LSLS     r6,r6,#16
00001c  4335              ORRS     r5,r5,r6
00001e  0086              LSLS     r6,r0,#2
000020  2707              MOVS     r7,#7
000022  023f              LSLS     r7,r7,#8
000024  19e7              ADDS     r7,r4,r7
000026  51bd              STR      r5,[r7,r6]
;;;515                                   | ((uint32_t)input << GPIO_PIN_CNF_INPUT_Pos)
;;;516                                   | ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)
;;;517                                   | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
;;;518                                   | ((uint32_t)sense << GPIO_PIN_CNF_SENSE_Pos);
;;;519    }
000028  bdf0              POP      {r4-r7,pc}
;;;520    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_default||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_default PROC
;;;545    
;;;546    __STATIC_INLINE void nrf_gpio_cfg_default(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;547    {
000002  4604              MOV      r4,r0
;;;548        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4601              MOV      r1,r0
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;549            pin_number,
;;;550            NRF_GPIO_PIN_DIR_INPUT,
;;;551            NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;552            NRF_GPIO_PIN_NOPULL,
;;;553            NRF_GPIO_PIN_S0S1,
;;;554            NRF_GPIO_PIN_NOSENSE);
;;;555    }
000016  bd1c              POP      {r2-r4,pc}
;;;556    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_input||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_input PROC
;;;533    
;;;534    __STATIC_INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
000000  b57c              PUSH     {r2-r6,lr}
;;;535    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;536        nrf_gpio_cfg(
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
00000a  4623              MOV      r3,r4
00000c  4602              MOV      r2,r0
00000e  4601              MOV      r1,r0
000010  9001              STR      r0,[sp,#4]
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       nrf_gpio_cfg
;;;537            pin_number,
;;;538            NRF_GPIO_PIN_DIR_INPUT,
;;;539            NRF_GPIO_PIN_INPUT_CONNECT,
;;;540            pull_config,
;;;541            NRF_GPIO_PIN_S0S1,
;;;542            NRF_GPIO_PIN_NOSENSE);
;;;543    }
000018  bd7c              POP      {r2-r6,pc}
;;;544    
                          ENDP


                          AREA ||i.nrf_gpio_cfg_output||, CODE, READONLY, ALIGN=1

                  nrf_gpio_cfg_output PROC
;;;521    
;;;522    __STATIC_INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
000000  b51c              PUSH     {r2-r4,lr}
;;;523    {
000002  4604              MOV      r4,r0
;;;524        nrf_gpio_cfg(
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  4603              MOV      r3,r0
00000a  2201              MOVS     r2,#1
00000c  4611              MOV      r1,r2
00000e  9001              STR      r0,[sp,#4]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       nrf_gpio_cfg
;;;525            pin_number,
;;;526            NRF_GPIO_PIN_DIR_OUTPUT,
;;;527            NRF_GPIO_PIN_INPUT_DISCONNECT,
;;;528            NRF_GPIO_PIN_NOPULL,
;;;529            NRF_GPIO_PIN_S0S1,
;;;530            NRF_GPIO_PIN_NOSENSE);
;;;531    }
000016  bd1c              POP      {r2-r4,pc}
;;;532    
                          ENDP


                          AREA ||i.nrf_gpio_pin_set||, CODE, READONLY, ALIGN=1

                  nrf_gpio_pin_set PROC
;;;621    
;;;622    __STATIC_INLINE void nrf_gpio_pin_set(uint32_t pin_number)
000000  bf00              NOP      
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
;;;623    {
;;;624        NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
000006  460a              MOV      r2,r1
;;;625    
;;;626        nrf_gpio_port_out_set(reg, 1UL << pin_number);
000008  2101              MOVS     r1,#1
00000a  4081              LSLS     r1,r1,r0
00000c  2305              MOVS     r3,#5
00000e  021b              LSLS     r3,r3,#8
000010  18d3              ADDS     r3,r2,r3
000012  6099              STR      r1,[r3,#8]
000014  bf00              NOP      
;;;627    }
000016  4770              BX       lr
;;;628    
                          ENDP


                          AREA ||i.nrf_uart_errorsrc_get_and_clear||, CODE, READONLY, ALIGN=1

                  nrf_uart_errorsrc_get_and_clear PROC
;;;418    
;;;419    __STATIC_INLINE uint32_t nrf_uart_errorsrc_get_and_clear(NRF_UART_Type * p_reg)
000000  4601              MOV      r1,r0
;;;420    {
;;;421        uint32_t errsrc_mask = p_reg->ERRORSRC;
000002  2209              MOVS     r2,#9
000004  01d2              LSLS     r2,r2,#7
000006  188a              ADDS     r2,r1,r2
000008  6810              LDR      r0,[r2,#0]
;;;422        p_reg->ERRORSRC = errsrc_mask;
00000a  2209              MOVS     r2,#9
00000c  01d2              LSLS     r2,r2,#7
00000e  188a              ADDS     r2,r1,r2
000010  6010              STR      r0,[r2,#0]
;;;423        return errsrc_mask;
;;;424    }
000012  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i.nrf_uart_event_check||, CODE, READONLY, ALIGN=1

                  nrf_uart_event_check PROC
;;;392    
;;;393    __STATIC_INLINE bool nrf_uart_event_check(NRF_UART_Type * p_reg, nrf_uart_event_t event)
000000  4602              MOV      r2,r0
;;;394    {
;;;395        return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
000002  5850              LDR      r0,[r2,r1]
000004  2800              CMP      r0,#0
000006  d001              BEQ      |L22.12|
000008  2001              MOVS     r0,#1
                  |L22.10|
;;;396    }
00000a  4770              BX       lr
                  |L22.12|
00000c  2000              MOVS     r0,#0                 ;395
00000e  e7fc              B        |L22.10|
;;;397    
                          ENDP


                          AREA ||i.nrf_uart_event_clear||, CODE, READONLY, ALIGN=1

                  nrf_uart_event_clear PROC
;;;382    #ifndef SUPPRESS_INLINE_IMPLEMENTATION
;;;383    __STATIC_INLINE void nrf_uart_event_clear(NRF_UART_Type * p_reg, nrf_uart_event_t event)
000000  2200              MOVS     r2,#0
;;;384    {
;;;385        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
000002  5042              STR      r2,[r0,r1]
;;;386    #if __CORTEX_M == 0x04
;;;387        volatile uint32_t dummy = *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event));
;;;388        (void)dummy;
;;;389    #endif
;;;390    
;;;391    }
000004  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.nrf_uart_hwfc_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uart_hwfc_pins_set PROC
;;;490    
;;;491    __STATIC_INLINE void nrf_uart_hwfc_pins_set(NRF_UART_Type * p_reg, uint32_t pselrts, uint32_t pselcts)
000000  2305              MOVS     r3,#5
;;;492    {
;;;493    #if defined(UART_PSEL_RTS_CONNECT_Pos)
;;;494        p_reg->PSEL.RTS = pselrts;
;;;495    #else
;;;496        p_reg->PSELRTS = pselrts;
000002  021b              LSLS     r3,r3,#8
000004  18c3              ADDS     r3,r0,r3
000006  6099              STR      r1,[r3,#8]
;;;497    #endif
;;;498    
;;;499    #if defined(UART_PSEL_RTS_CONNECT_Pos)
;;;500        p_reg->PSEL.CTS = pselcts;
;;;501    #else
;;;502        p_reg->PSELCTS = pselcts;
000008  2305              MOVS     r3,#5
00000a  021b              LSLS     r3,r3,#8
00000c  18c3              ADDS     r3,r0,r3
00000e  611a              STR      r2,[r3,#0x10]
;;;503    #endif
;;;504    }
000010  4770              BX       lr
;;;505    
                          ENDP


                          AREA ||i.nrf_uart_int_disable||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_disable PROC
;;;413    
;;;414    __STATIC_INLINE void nrf_uart_int_disable(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  2203              MOVS     r2,#3
;;;415    {
;;;416        p_reg->INTENCLR = int_mask;
000002  0212              LSLS     r2,r2,#8
000004  1882              ADDS     r2,r0,r2
000006  6091              STR      r1,[r2,#8]
;;;417    }
000008  4770              BX       lr
;;;418    
                          ENDP


                          AREA ||i.nrf_uart_int_enable||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_enable PROC
;;;403    
;;;404    __STATIC_INLINE void nrf_uart_int_enable(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  2203              MOVS     r2,#3
;;;405    {
;;;406        p_reg->INTENSET = int_mask;
000002  0212              LSLS     r2,r2,#8
000004  1882              ADDS     r2,r0,r2
000006  6051              STR      r1,[r2,#4]
;;;407    }
000008  4770              BX       lr
;;;408    
                          ENDP


                          AREA ||i.nrf_uart_int_enable_check||, CODE, READONLY, ALIGN=1

                  nrf_uart_int_enable_check PROC
;;;408    
;;;409    __STATIC_INLINE bool nrf_uart_int_enable_check(NRF_UART_Type * p_reg, uint32_t int_mask)
000000  4602              MOV      r2,r0
;;;410    {
;;;411        return (bool)(p_reg->INTENSET & int_mask);
000002  2003              MOVS     r0,#3
000004  0200              LSLS     r0,r0,#8
000006  1810              ADDS     r0,r2,r0
000008  6840              LDR      r0,[r0,#4]
00000a  4008              ANDS     r0,r0,r1
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L27.20|
000010  2001              MOVS     r0,#1
                  |L27.18|
;;;412    }
000012  4770              BX       lr
                  |L27.20|
000014  2000              MOVS     r0,#0                 ;411
000016  e7fc              B        |L27.18|
;;;413    
                          ENDP


                          AREA ||i.nrf_uart_task_trigger||, CODE, READONLY, ALIGN=1

                  nrf_uart_task_trigger PROC
;;;520    
;;;521    __STATIC_INLINE void nrf_uart_task_trigger(NRF_UART_Type * p_reg, nrf_uart_task_t task)
000000  2201              MOVS     r2,#1
;;;522    {
;;;523        *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
000002  5042              STR      r2,[r0,r1]
;;;524    }
000004  4770              BX       lr
;;;525    
                          ENDP


                          AREA ||i.nrf_uart_txrx_pins_set||, CODE, READONLY, ALIGN=1

                  nrf_uart_txrx_pins_set PROC
;;;435    
;;;436    __STATIC_INLINE void nrf_uart_txrx_pins_set(NRF_UART_Type * p_reg, uint32_t pseltxd, uint32_t pselrxd)
000000  2305              MOVS     r3,#5
;;;437    {
;;;438    #if defined(UART_PSEL_RXD_CONNECT_Pos)
;;;439        p_reg->PSEL.RXD = pselrxd;
;;;440    #else
;;;441        p_reg->PSELRXD = pselrxd;
000002  021b              LSLS     r3,r3,#8
000004  18c3              ADDS     r3,r0,r3
000006  615a              STR      r2,[r3,#0x14]
;;;442    #endif
;;;443    #if defined(UART_PSEL_TXD_CONNECT_Pos)
;;;444        p_reg->PSEL.TXD = pseltxd;
;;;445    #else
;;;446        p_reg->PSELTXD = pseltxd;
000008  2305              MOVS     r3,#5
00000a  021b              LSLS     r3,r3,#8
00000c  18c3              ADDS     r3,r0,r3
00000e  60d9              STR      r1,[r3,#0xc]
;;;447    #endif
;;;448    }
000010  4770              BX       lr
;;;449    
                          ENDP


                          AREA ||i.pins_to_default||, CODE, READONLY, ALIGN=1

                  pins_to_default PROC
;;;201    
;;;202    __STATIC_INLINE void pins_to_default(const nrf_drv_uart_t * p_instance)
000000  b5fe              PUSH     {r1-r7,lr}
;;;203    {
000002  4604              MOV      r4,r0
;;;204        /* Reset pins to default states */
;;;205        uint32_t txd;
;;;206        uint32_t rxd;
;;;207        uint32_t rts;
;;;208        uint32_t cts;
;;;209    
;;;210        CODE_FOR_UARTE
;;;211        (
;;;212            txd = nrf_uarte_tx_pin_get(p_instance->reg.p_uarte);
;;;213            rxd = nrf_uarte_rx_pin_get(p_instance->reg.p_uarte);
;;;214            rts = nrf_uarte_rts_pin_get(p_instance->reg.p_uarte);
;;;215            cts = nrf_uarte_cts_pin_get(p_instance->reg.p_uarte);
;;;216            nrf_uarte_txrx_pins_disconnect(p_instance->reg.p_uarte);
;;;217            nrf_uarte_hwfc_pins_disconnect(p_instance->reg.p_uarte);
;;;218        )
;;;219        CODE_FOR_UART
000004  6820              LDR      r0,[r4,#0]
000006  2105              MOVS     r1,#5
000008  0209              LSLS     r1,r1,#8
00000a  1841              ADDS     r1,r0,r1
00000c  68c9              LDR      r1,[r1,#0xc]
00000e  460d              MOV      r5,r1
000010  6820              LDR      r0,[r4,#0]
000012  2105              MOVS     r1,#5
000014  0209              LSLS     r1,r1,#8
000016  1841              ADDS     r1,r0,r1
000018  6949              LDR      r1,[r1,#0x14]
00001a  460e              MOV      r6,r1
00001c  6820              LDR      r0,[r4,#0]
00001e  2105              MOVS     r1,#5
000020  0209              LSLS     r1,r1,#8
000022  1841              ADDS     r1,r0,r1
000024  6889              LDR      r1,[r1,#8]
000026  9101              STR      r1,[sp,#4]
000028  6820              LDR      r0,[r4,#0]
00002a  2105              MOVS     r1,#5
00002c  0209              LSLS     r1,r1,#8
00002e  1841              ADDS     r1,r0,r1
000030  6909              LDR      r1,[r1,#0x10]
000032  9100              STR      r1,[sp,#0]
000034  6827              LDR      r7,[r4,#0]
000036  2200              MOVS     r2,#0
000038  43d2              MVNS     r2,r2
00003a  4611              MOV      r1,r2
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       nrf_uart_txrx_pins_set
000042  bf00              NOP      
000044  6827              LDR      r7,[r4,#0]
000046  2200              MOVS     r2,#0
000048  43d2              MVNS     r2,r2
00004a  4611              MOV      r1,r2
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       nrf_uart_hwfc_pins_set
000052  bf00              NOP      
;;;220        (
;;;221            txd = nrf_uart_tx_pin_get(p_instance->reg.p_uart);
;;;222            rxd = nrf_uart_rx_pin_get(p_instance->reg.p_uart);
;;;223            rts = nrf_uart_rts_pin_get(p_instance->reg.p_uart);
;;;224            cts = nrf_uart_cts_pin_get(p_instance->reg.p_uart);
;;;225            nrf_uart_txrx_pins_disconnect(p_instance->reg.p_uart);
;;;226            nrf_uart_hwfc_pins_disconnect(p_instance->reg.p_uart);
;;;227        )
;;;228    
;;;229        if (txd != NRF_UART_PSEL_DISCONNECTED)
000054  1c68              ADDS     r0,r5,#1
000056  2800              CMP      r0,#0
000058  d002              BEQ      |L30.96|
;;;230        {
;;;231            nrf_gpio_cfg_default(txd);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       nrf_gpio_cfg_default
                  |L30.96|
;;;232        }
;;;233    
;;;234        if (rxd != NRF_UART_PSEL_DISCONNECTED)
000060  1c70              ADDS     r0,r6,#1
000062  2800              CMP      r0,#0
000064  d002              BEQ      |L30.108|
;;;235        {
;;;236            nrf_gpio_cfg_default(rxd);
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       nrf_gpio_cfg_default
                  |L30.108|
;;;237        }
;;;238    
;;;239        if (cts != NRF_UART_PSEL_DISCONNECTED)
00006c  9800              LDR      r0,[sp,#0]
00006e  1c40              ADDS     r0,r0,#1
000070  2800              CMP      r0,#0
000072  d002              BEQ      |L30.122|
;;;240        {
;;;241            nrf_gpio_cfg_default(cts);
000074  9800              LDR      r0,[sp,#0]
000076  f7fffffe          BL       nrf_gpio_cfg_default
                  |L30.122|
;;;242        }
;;;243    
;;;244        if (rts != NRF_UART_PSEL_DISCONNECTED)
00007a  9801              LDR      r0,[sp,#4]
00007c  1c40              ADDS     r0,r0,#1
00007e  2800              CMP      r0,#0
000080  d002              BEQ      |L30.136|
;;;245        {
;;;246            nrf_gpio_cfg_default(rts);
000082  9801              LDR      r0,[sp,#4]
000084  f7fffffe          BL       nrf_gpio_cfg_default
                  |L30.136|
;;;247        }
;;;248    
;;;249    }
000088  bdfe              POP      {r1-r7,pc}
;;;250    
                          ENDP


                          AREA ||i.rx_byte||, CODE, READONLY, ALIGN=1

                  rx_byte PROC
;;;461    
;;;462    __STATIC_INLINE void rx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  b570              PUSH     {r4-r6,lr}
;;;463    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;464        if (!p_cb->rx_buffer_length)
000006  7de0              LDRB     r0,[r4,#0x17]
000008  2800              CMP      r0,#0
00000a  d10a              BNE      |L31.34|
;;;465        {
;;;466            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXDRDY);
00000c  21ff              MOVS     r1,#0xff
00000e  3109              ADDS     r1,r1,#9
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       nrf_uart_event_clear
;;;467            // Byte received when buffer is not set - data lost.
;;;468            (void) nrf_uart_rxd_get(p_uart);
000016  bf00              NOP      
000018  2005              MOVS     r0,#5
00001a  0200              LSLS     r0,r0,#8
00001c  1828              ADDS     r0,r5,r0
00001e  6980              LDR      r0,[r0,#0x18]
                  |L31.32|
;;;469            return;
;;;470        }
;;;471        nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXDRDY);
;;;472        p_cb->p_rx_buffer[p_cb->rx_counter] = nrf_uart_rxd_get(p_uart);
;;;473        p_cb->rx_counter++;
;;;474    }
000020  bd70              POP      {r4-r6,pc}
                  |L31.34|
000022  21ff              MOVS     r1,#0xff              ;471
000024  3109              ADDS     r1,r1,#9              ;471
000026  4628              MOV      r0,r5                 ;471
000028  f7fffffe          BL       nrf_uart_event_clear
00002c  bf00              NOP                            ;472
00002e  2005              MOVS     r0,#5                 ;472
000030  0200              LSLS     r0,r0,#8              ;472
000032  1828              ADDS     r0,r5,r0              ;472
000034  6980              LDR      r0,[r0,#0x18]         ;472
000036  b2c0              UXTB     r0,r0                 ;472
000038  7e62              LDRB     r2,[r4,#0x19]         ;472
00003a  68e1              LDR      r1,[r4,#0xc]          ;472
00003c  5488              STRB     r0,[r1,r2]            ;472
00003e  7e60              LDRB     r0,[r4,#0x19]         ;473
000040  1c40              ADDS     r0,r0,#1              ;473
000042  7660              STRB     r0,[r4,#0x19]         ;473
000044  bf00              NOP      
000046  e7eb              B        |L31.32|
;;;475    
                          ENDP


                          AREA ||i.rx_done_event||, CODE, READONLY, ALIGN=1

                  rx_done_event PROC
;;;721    
;;;722    __STATIC_INLINE void rx_done_event(uart_control_block_t * p_cb, uint8_t bytes, uint8_t * p_data)
000000  b57f              PUSH     {r0-r6,lr}
;;;723    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;724        nrf_drv_uart_event_t event;
;;;725    
;;;726        event.type             = NRF_DRV_UART_EVT_RX_DONE;
000008  2001              MOVS     r0,#1
00000a  4669              MOV      r1,sp
00000c  7008              STRB     r0,[r1,#0]
;;;727        event.data.rxtx.bytes  = bytes;
00000e  4668              MOV      r0,sp
000010  7205              STRB     r5,[r0,#8]
;;;728        event.data.rxtx.p_data = p_data;
000012  9601              STR      r6,[sp,#4]
;;;729    
;;;730        p_cb->handler(&event, p_cb->p_context);
000014  6862              LDR      r2,[r4,#4]
000016  6821              LDR      r1,[r4,#0]
000018  4790              BLX      r2
;;;731    }
00001a  bd7f              POP      {r0-r6,pc}
;;;732    
                          ENDP


                          AREA ||i.rx_enable||, CODE, READONLY, ALIGN=1

                  rx_enable PROC
;;;454    #if defined(UART_IN_USE)
;;;455    __STATIC_INLINE void rx_enable(const nrf_drv_uart_t * p_instance)
000000  b510              PUSH     {r4,lr}
;;;456    {
000002  4604              MOV      r4,r0
;;;457        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_ERROR);
000004  21ff              MOVS     r1,#0xff
000006  3125              ADDS     r1,r1,#0x25
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       nrf_uart_event_clear
;;;458        nrf_uart_event_clear(p_instance->reg.p_uart, NRF_UART_EVENT_RXDRDY);
00000e  21ff              MOVS     r1,#0xff
000010  3109              ADDS     r1,r1,#9
000012  6820              LDR      r0,[r4,#0]
000014  f7fffffe          BL       nrf_uart_event_clear
;;;459        nrf_uart_task_trigger(p_instance->reg.p_uart, NRF_UART_TASK_STARTRX);
000018  2100              MOVS     r1,#0
00001a  6820              LDR      r0,[r4,#0]
00001c  f7fffffe          BL       nrf_uart_task_trigger
;;;460    }
000020  bd10              POP      {r4,pc}
;;;461    
                          ENDP


                          AREA ||i.tx_byte||, CODE, READONLY, ALIGN=1

                  tx_byte PROC
;;;318    #if defined(UART_IN_USE)
;;;319    __STATIC_INLINE void tx_byte(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  b570              PUSH     {r4-r6,lr}
;;;320    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;321        nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);
000006  21ff              MOVS     r1,#0xff
000008  311d              ADDS     r1,r1,#0x1d
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       nrf_uart_event_clear
;;;322        uint8_t txd = p_cb->p_tx_buffer[p_cb->tx_counter];
000010  8aa1              LDRH     r1,[r4,#0x14]
000012  68a0              LDR      r0,[r4,#8]
000014  5c46              LDRB     r6,[r0,r1]
;;;323        p_cb->tx_counter++;
000016  8aa0              LDRH     r0,[r4,#0x14]
000018  1c40              ADDS     r0,r0,#1
00001a  82a0              STRH     r0,[r4,#0x14]
;;;324        nrf_uart_txd_set(p_uart, txd);
00001c  4630              MOV      r0,r6
00001e  2105              MOVS     r1,#5
000020  0209              LSLS     r1,r1,#8
000022  1869              ADDS     r1,r5,r1
000024  61c8              STR      r0,[r1,#0x1c]
000026  bf00              NOP      
;;;325    }
000028  bd70              POP      {r4-r6,pc}
;;;326    
                          ENDP


                          AREA ||i.tx_done_event||, CODE, READONLY, ALIGN=1

                  tx_done_event PROC
;;;732    
;;;733    __STATIC_INLINE void tx_done_event(uart_control_block_t * p_cb, uint8_t bytes)
000000  b57f              PUSH     {r0-r6,lr}
;;;734    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;735        nrf_drv_uart_event_t event;
;;;736    
;;;737        event.type             = NRF_DRV_UART_EVT_TX_DONE;
000006  2000              MOVS     r0,#0
000008  4669              MOV      r1,sp
00000a  7008              STRB     r0,[r1,#0]
;;;738        event.data.rxtx.bytes  = bytes;
00000c  4668              MOV      r0,sp
00000e  7205              STRB     r5,[r0,#8]
;;;739        event.data.rxtx.p_data = (uint8_t *)p_cb->p_tx_buffer;
000010  68a0              LDR      r0,[r4,#8]
000012  9001              STR      r0,[sp,#4]
;;;740    
;;;741        p_cb->tx_buffer_length = 0;
000014  2000              MOVS     r0,#0
000016  75a0              STRB     r0,[r4,#0x16]
;;;742    
;;;743        p_cb->handler(&event, p_cb->p_context);
000018  4668              MOV      r0,sp
00001a  6862              LDR      r2,[r4,#4]
00001c  6821              LDR      r1,[r4,#0]
00001e  4790              BLX      r2
;;;744    }
000020  bd7f              POP      {r0-r6,pc}
;;;745    
                          ENDP


                          AREA ||i.uart_irq_handler||, CODE, READONLY, ALIGN=1

                  uart_irq_handler PROC
;;;789    #if defined(UART_IN_USE)
;;;790    __STATIC_INLINE void uart_irq_handler(NRF_UART_Type * p_uart, uart_control_block_t * p_cb)
000000  b5f0              PUSH     {r4-r7,lr}
;;;791    {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;792        if (nrf_uart_int_enable_check(p_uart, NRF_UART_INT_MASK_ERROR) &&
000008  2101              MOVS     r1,#1
00000a  0249              LSLS     r1,r1,#9
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       nrf_uart_int_enable_check
000012  2800              CMP      r0,#0
000014  d02b              BEQ      |L36.110|
;;;793            nrf_uart_event_check(p_uart, NRF_UART_EVENT_ERROR))
000016  21ff              MOVS     r1,#0xff
000018  3125              ADDS     r1,r1,#0x25
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       nrf_uart_event_check
000020  2800              CMP      r0,#0
000022  d024              BEQ      |L36.110|
;;;794        {
;;;795            nrf_drv_uart_event_t event;
;;;796            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_ERROR);
000024  21ff              MOVS     r1,#0xff
000026  3125              ADDS     r1,r1,#0x25
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       nrf_uart_event_clear
;;;797            NRF_LOG_DEBUG("Event: %s.\r\n", (uint32_t)EVT_TO_STR(NRF_UART_EVENT_ERROR));
;;;798            nrf_uart_int_disable(p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
00002e  2181              MOVS     r1,#0x81
000030  0089              LSLS     r1,r1,#2
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       nrf_uart_int_disable
;;;799            if (!p_cb->rx_enabled)
000038  7ea0              LDRB     r0,[r4,#0x1a]
00003a  2800              CMP      r0,#0
00003c  d103              BNE      |L36.70|
;;;800            {
;;;801                nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STOPRX);
00003e  2104              MOVS     r1,#4
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       nrf_uart_task_trigger
                  |L36.70|
;;;802            }
;;;803            event.type                   = NRF_DRV_UART_EVT_ERROR;
000046  2002              MOVS     r0,#2
000048  4669              MOV      r1,sp
00004a  7008              STRB     r0,[r1,#0]
;;;804            event.data.error.error_mask  = nrf_uart_errorsrc_get_and_clear(p_uart);
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       nrf_uart_errorsrc_get_and_clear
000052  9003              STR      r0,[sp,#0xc]
;;;805            event.data.error.rxtx.bytes  = p_cb->rx_buffer_length;
000054  7de1              LDRB     r1,[r4,#0x17]
000056  4668              MOV      r0,sp
000058  7201              STRB     r1,[r0,#8]
;;;806            event.data.error.rxtx.p_data = p_cb->p_rx_buffer;
00005a  68e0              LDR      r0,[r4,#0xc]
00005c  9001              STR      r0,[sp,#4]
;;;807    
;;;808            //abort transfer
;;;809            p_cb->rx_buffer_length = 0;
00005e  2000              MOVS     r0,#0
000060  75e0              STRB     r0,[r4,#0x17]
;;;810            p_cb->rx_secondary_buffer_length = 0;
000062  7620              STRB     r0,[r4,#0x18]
;;;811    
;;;812            p_cb->handler(&event,p_cb->p_context);
000064  4668              MOV      r0,sp
000066  6862              LDR      r2,[r4,#4]
000068  6821              LDR      r1,[r4,#0]
00006a  4790              BLX      r2
;;;813        }
00006c  e039              B        |L36.226|
                  |L36.110|
;;;814        else if (nrf_uart_int_enable_check(p_uart, NRF_UART_INT_MASK_RXDRDY) &&
00006e  2104              MOVS     r1,#4
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       nrf_uart_int_enable_check
000076  2800              CMP      r0,#0
000078  d033              BEQ      |L36.226|
;;;815                 nrf_uart_event_check(p_uart, NRF_UART_EVENT_RXDRDY))
00007a  21ff              MOVS     r1,#0xff
00007c  3109              ADDS     r1,r1,#9
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       nrf_uart_event_check
000084  2800              CMP      r0,#0
000086  d02c              BEQ      |L36.226|
;;;816        {
;;;817            rx_byte(p_uart, p_cb);
000088  4621              MOV      r1,r4
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       rx_byte
;;;818            if (p_cb->rx_buffer_length == p_cb->rx_counter)
000090  7de0              LDRB     r0,[r4,#0x17]
000092  7e61              LDRB     r1,[r4,#0x19]
000094  4288              CMP      r0,r1
000096  d124              BNE      |L36.226|
;;;819            {
;;;820                if (p_cb->rx_secondary_buffer_length)
000098  7e20              LDRB     r0,[r4,#0x18]
00009a  2800              CMP      r0,#0
00009c  d00e              BEQ      |L36.188|
;;;821                {
;;;822                    uint8_t * p_data     = p_cb->p_rx_buffer;
00009e  68e6              LDR      r6,[r4,#0xc]
;;;823                    uint8_t   rx_counter = p_cb->rx_counter;
0000a0  7e67              LDRB     r7,[r4,#0x19]
;;;824    
;;;825                    //Switch to secondary buffer.
;;;826                    p_cb->rx_buffer_length = p_cb->rx_secondary_buffer_length;
0000a2  7e20              LDRB     r0,[r4,#0x18]
0000a4  75e0              STRB     r0,[r4,#0x17]
;;;827                    p_cb->p_rx_buffer = p_cb->p_rx_secondary_buffer;
0000a6  6920              LDR      r0,[r4,#0x10]
0000a8  60e0              STR      r0,[r4,#0xc]
;;;828                    p_cb->rx_secondary_buffer_length = 0;
0000aa  2000              MOVS     r0,#0
0000ac  7620              STRB     r0,[r4,#0x18]
;;;829                    p_cb->rx_counter = 0;
0000ae  7660              STRB     r0,[r4,#0x19]
;;;830                    rx_done_event(p_cb, rx_counter, p_data);
0000b0  4632              MOV      r2,r6
0000b2  4639              MOV      r1,r7
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       rx_done_event
;;;831                }
0000ba  e012              B        |L36.226|
                  |L36.188|
;;;832                else
;;;833                {
;;;834                    if (!p_cb->rx_enabled)
0000bc  7ea0              LDRB     r0,[r4,#0x1a]
0000be  2800              CMP      r0,#0
0000c0  d103              BNE      |L36.202|
;;;835                    {
;;;836                        nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STOPRX);
0000c2  2104              MOVS     r1,#4
0000c4  4628              MOV      r0,r5
0000c6  f7fffffe          BL       nrf_uart_task_trigger
                  |L36.202|
;;;837                    }
;;;838                    nrf_uart_int_disable(p_uart, NRF_UART_INT_MASK_RXDRDY | NRF_UART_INT_MASK_ERROR);
0000ca  2181              MOVS     r1,#0x81
0000cc  0089              LSLS     r1,r1,#2
0000ce  4628              MOV      r0,r5
0000d0  f7fffffe          BL       nrf_uart_int_disable
;;;839                    p_cb->rx_buffer_length = 0;
0000d4  2000              MOVS     r0,#0
0000d6  75e0              STRB     r0,[r4,#0x17]
;;;840                    rx_done_event(p_cb, p_cb->rx_counter, p_cb->p_rx_buffer);
0000d8  7e61              LDRB     r1,[r4,#0x19]
0000da  68e2              LDR      r2,[r4,#0xc]
0000dc  4620              MOV      r0,r4
0000de  f7fffffe          BL       rx_done_event
                  |L36.226|
;;;841                }
;;;842            }
;;;843        }
;;;844    
;;;845        if (nrf_uart_event_check(p_uart, NRF_UART_EVENT_TXDRDY))
0000e2  21ff              MOVS     r1,#0xff
0000e4  311d              ADDS     r1,r1,#0x1d
0000e6  4628              MOV      r0,r5
0000e8  f7fffffe          BL       nrf_uart_event_check
0000ec  2800              CMP      r0,#0
0000ee  d014              BEQ      |L36.282|
;;;846        {
;;;847            if (p_cb->tx_counter < (uint16_t) p_cb->tx_buffer_length)
0000f0  8aa0              LDRH     r0,[r4,#0x14]
0000f2  7da1              LDRB     r1,[r4,#0x16]
0000f4  4288              CMP      r0,r1
0000f6  da04              BGE      |L36.258|
;;;848            {
;;;849                tx_byte(p_uart, p_cb);
0000f8  4621              MOV      r1,r4
0000fa  4628              MOV      r0,r5
0000fc  f7fffffe          BL       tx_byte
000100  e00b              B        |L36.282|
                  |L36.258|
;;;850            }
;;;851            else
;;;852            {
;;;853                nrf_uart_event_clear(p_uart, NRF_UART_EVENT_TXDRDY);
000102  21ff              MOVS     r1,#0xff
000104  311d              ADDS     r1,r1,#0x1d
000106  4628              MOV      r0,r5
000108  f7fffffe          BL       nrf_uart_event_clear
;;;854                if (p_cb->tx_buffer_length)
00010c  7da0              LDRB     r0,[r4,#0x16]
00010e  2800              CMP      r0,#0
000110  d003              BEQ      |L36.282|
;;;855                {
;;;856                    tx_done_event(p_cb, p_cb->tx_buffer_length);
000112  7da1              LDRB     r1,[r4,#0x16]
000114  4620              MOV      r0,r4
000116  f7fffffe          BL       tx_done_event
                  |L36.282|
;;;857                }
;;;858            }
;;;859        }
;;;860    
;;;861        if (nrf_uart_event_check(p_uart, NRF_UART_EVENT_RXTO))
00011a  21ff              MOVS     r1,#0xff
00011c  3145              ADDS     r1,r1,#0x45
00011e  4628              MOV      r0,r5
000120  f7fffffe          BL       nrf_uart_event_check
000124  2800              CMP      r0,#0
000126  d015              BEQ      |L36.340|
;;;862        {
;;;863            nrf_uart_event_clear(p_uart, NRF_UART_EVENT_RXTO);
000128  21ff              MOVS     r1,#0xff
00012a  3145              ADDS     r1,r1,#0x45
00012c  4628              MOV      r0,r5
00012e  f7fffffe          BL       nrf_uart_event_clear
;;;864    
;;;865            // RXTO event may be triggered as a result of abort call. In th
;;;866            if (p_cb->rx_enabled)
000132  7ea0              LDRB     r0,[r4,#0x1a]
000134  2800              CMP      r0,#0
000136  d003              BEQ      |L36.320|
;;;867            {
;;;868                nrf_uart_task_trigger(p_uart, NRF_UART_TASK_STARTRX);
000138  2100              MOVS     r1,#0
00013a  4628              MOV      r0,r5
00013c  f7fffffe          BL       nrf_uart_task_trigger
                  |L36.320|
;;;869            }
;;;870            if (p_cb->rx_buffer_length)
000140  7de0              LDRB     r0,[r4,#0x17]
000142  2800              CMP      r0,#0
000144  d006              BEQ      |L36.340|
;;;871            {
;;;872                p_cb->rx_buffer_length = 0;
000146  2000              MOVS     r0,#0
000148  75e0              STRB     r0,[r4,#0x17]
;;;873                rx_done_event(p_cb, p_cb->rx_counter, p_cb->p_rx_buffer);
00014a  7e61              LDRB     r1,[r4,#0x19]
00014c  68e2              LDR      r2,[r4,#0xc]
00014e  4620              MOV      r0,r4
000150  f7fffffe          BL       rx_done_event
                  |L36.340|
;;;874            }
;;;875        }
;;;876    }
000154  b005              ADD      sp,sp,#0x14
000156  bdf0              POP      {r4-r7,pc}
;;;877    #endif
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb
                          %        28

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __func__
000000  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000004  6472765f          DCB      0x64,0x72,0x76,0x5f
000008  75617274          DCB      0x75,0x61,0x72,0x74
00000c  5f696e69          DCB      0x5f,0x69,0x6e,0x69
000010  7400              DCB      0x74,0x00
                  |symbol_number.90|
000012  6e72              DCB      0x6e,0x72
000014  665f6472          DCB      0x66,0x5f,0x64,0x72
000018  765f7561          DCB      0x76,0x5f,0x75,0x61
00001c  72745f74          DCB      0x72,0x74,0x5f,0x74
000020  785f666f          DCB      0x78,0x5f,0x66,0x6f
000024  725f7561          DCB      0x72,0x5f,0x75,0x61
000028  727400            DCB      0x72,0x74,0x00
                  |symbol_number.91|
00002b  6e                DCB      0x6e
00002c  72665f64          DCB      0x72,0x66,0x5f,0x64
000030  72765f75          DCB      0x72,0x76,0x5f,0x75
000034  6172745f          DCB      0x61,0x72,0x74,0x5f
000038  747800            DCB      0x74,0x78,0x00
                  |symbol_number.92|
00003b  6e                DCB      0x6e
00003c  72665f64          DCB      0x72,0x66,0x5f,0x64
000040  72765f75          DCB      0x72,0x76,0x5f,0x75
000044  6172745f          DCB      0x61,0x72,0x74,0x5f
000048  72785f66          DCB      0x72,0x78,0x5f,0x66
00004c  6f725f75          DCB      0x6f,0x72,0x5f,0x75
000050  61727400          DCB      0x61,0x72,0x74,0x00
                  |symbol_number.93|
000054  6e72665f          DCB      0x6e,0x72,0x66,0x5f
000058  6472765f          DCB      0x64,0x72,0x76,0x5f
00005c  75617274          DCB      0x75,0x61,0x72,0x74
000060  5f727800          DCB      0x5f,0x72,0x78,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\drivers_nrf\\uart\\nrf_drv_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_fa4207eb____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_nrf_drv_uart_c_fa4207eb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_nrf_drv_uart_c_fa4207eb____REVSH|
#line 144
|__asm___14_nrf_drv_uart_c_fa4207eb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
