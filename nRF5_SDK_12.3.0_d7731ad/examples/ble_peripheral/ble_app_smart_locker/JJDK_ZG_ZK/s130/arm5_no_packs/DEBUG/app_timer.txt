; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\app_timer.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\app_timer.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\app_timer.crf ..\..\..\..\..\..\components\libraries\timer\app_timer.c]
                          THUMB

                          AREA ||i.NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_ClearPendingIRQ PROC
;;;595     */
;;;596    __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;597    {
;;;598      NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L1.16|
00000a  6011              STR      r1,[r2,#0]
;;;599    }
00000c  4770              BX       lr
;;;600    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0xe000e280

                          AREA ||i.NVIC_EnableIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_EnableIRQ PROC
;;;543     */
;;;544    __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;545    {
;;;546      NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L2.16|
00000a  6011              STR      r1,[r2,#0]
;;;547    }
00000c  4770              BX       lr
;;;548    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0xe000e100

                          AREA ||i.NVIC_SetPendingIRQ||, CODE, READONLY, ALIGN=2

                  NVIC_SetPendingIRQ PROC
;;;583     */
;;;584    __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
000000  06c2              LSLS     r2,r0,#27
;;;585    {
;;;586      NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
000002  0ed2              LSRS     r2,r2,#27
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a01              LDR      r2,|L3.16|
00000a  6011              STR      r1,[r2,#0]
;;;587    }
00000c  4770              BX       lr
;;;588    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0xe000e200

                          AREA ||i.NVIC_SetPriority||, CODE, READONLY, ALIGN=2

                  NVIC_SetPriority PROC
;;;610     */
;;;611    __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  b510              PUSH     {r4,lr}
;;;612    {
;;;613      if(IRQn < 0) {
000002  2800              CMP      r0,#0
000004  da19              BGE      |L4.58|
;;;614        SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
000006  4a1a              LDR      r2,|L4.112|
000008  0703              LSLS     r3,r0,#28
00000a  0f1b              LSRS     r3,r3,#28
00000c  3b08              SUBS     r3,r3,#8
00000e  089b              LSRS     r3,r3,#2
000010  009b              LSLS     r3,r3,#2
000012  58d2              LDR      r2,[r2,r3]
000014  0783              LSLS     r3,r0,#30
000016  0edc              LSRS     r4,r3,#27
000018  23ff              MOVS     r3,#0xff
00001a  40a3              LSLS     r3,r3,r4
00001c  439a              BICS     r2,r2,r3
00001e  078b              LSLS     r3,r1,#30
000020  0e1b              LSRS     r3,r3,#24
000022  0784              LSLS     r4,r0,#30
000024  0ee4              LSRS     r4,r4,#27
000026  40a3              LSLS     r3,r3,r4
000028  431a              ORRS     r2,r2,r3
00002a  4b11              LDR      r3,|L4.112|
00002c  0704              LSLS     r4,r0,#28
00002e  0f24              LSRS     r4,r4,#28
000030  3c08              SUBS     r4,r4,#8
000032  08a4              LSRS     r4,r4,#2
000034  00a4              LSLS     r4,r4,#2
000036  511a              STR      r2,[r3,r4]
000038  e018              B        |L4.108|
                  |L4.58|
;;;615            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;616      else {
;;;617        NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
00003a  4a0e              LDR      r2,|L4.116|
00003c  2303              MOVS     r3,#3
00003e  021b              LSLS     r3,r3,#8
000040  18d2              ADDS     r2,r2,r3
000042  0883              LSRS     r3,r0,#2
000044  009b              LSLS     r3,r3,#2
000046  58d2              LDR      r2,[r2,r3]
000048  0783              LSLS     r3,r0,#30
00004a  0edc              LSRS     r4,r3,#27
00004c  23ff              MOVS     r3,#0xff
00004e  40a3              LSLS     r3,r3,r4
000050  439a              BICS     r2,r2,r3
000052  078b              LSLS     r3,r1,#30
000054  0e1b              LSRS     r3,r3,#24
000056  0784              LSLS     r4,r0,#30
000058  0ee4              LSRS     r4,r4,#27
00005a  40a3              LSLS     r3,r3,r4
00005c  431a              ORRS     r2,r2,r3
00005e  4b05              LDR      r3,|L4.116|
000060  2403              MOVS     r4,#3
000062  0224              LSLS     r4,r4,#8
000064  191b              ADDS     r3,r3,r4
000066  0884              LSRS     r4,r0,#2
000068  00a4              LSLS     r4,r4,#2
00006a  511a              STR      r2,[r3,r4]
                  |L4.108|
;;;618            (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
;;;619    }
00006c  bd10              POP      {r4,pc}
;;;620    
                          ENDP

00006e  0000              DCW      0x0000
                  |L4.112|
                          DCD      0xe000ed1c
                  |L4.116|
                          DCD      0xe000e100

                          AREA ||i.RTC1_IRQHandler||, CODE, READONLY, ALIGN=2

                  RTC1_IRQHandler PROC
;;;901     */
;;;902    void RTC1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;903    {
;;;904        // Clear all events (also unexpected ones)
;;;905        NRF_RTC1->EVENTS_COMPARE[0] = 0;
000002  2000              MOVS     r0,#0
000004  4907              LDR      r1,|L5.36|
000006  6008              STR      r0,[r1,#0]
;;;906        NRF_RTC1->EVENTS_COMPARE[1] = 0;
000008  2100              MOVS     r1,#0
00000a  4806              LDR      r0,|L5.36|
00000c  6041              STR      r1,[r0,#4]
;;;907        NRF_RTC1->EVENTS_COMPARE[2] = 0;
00000e  6081              STR      r1,[r0,#8]
;;;908        NRF_RTC1->EVENTS_COMPARE[3] = 0;
000010  60c1              STR      r1,[r0,#0xc]
;;;909        NRF_RTC1->EVENTS_TICK       = 0;
000012  2000              MOVS     r0,#0
000014  4903              LDR      r1,|L5.36|
000016  3940              SUBS     r1,r1,#0x40
000018  6008              STR      r0,[r1,#0]
;;;910        NRF_RTC1->EVENTS_OVRFLW     = 0;
00001a  6048              STR      r0,[r1,#4]
;;;911    
;;;912        // Check for expired timers
;;;913        timer_timeouts_check();
00001c  f7fffffe          BL       timer_timeouts_check
;;;914    }
000020  bd10              POP      {r4,pc}
;;;915    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x40011140

                          AREA ||i.SWI0_IRQHandler||, CODE, READONLY, ALIGN=1

                  SWI0_IRQHandler PROC
;;;920     */
;;;921    void SWI_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;922    {
;;;923        timer_list_handler();
000002  f7fffffe          BL       timer_list_handler
;;;924    }
000006  bd10              POP      {r4,pc}
;;;925    
                          ENDP


                          AREA ||i.app_timer_cnt_diff_compute||, CODE, READONLY, ALIGN=1

                  app_timer_cnt_diff_compute PROC
;;;1063   
;;;1064   uint32_t app_timer_cnt_diff_compute(uint32_t   ticks_to,
000000  b570              PUSH     {r4-r6,lr}
;;;1065                                       uint32_t   ticks_from,
;;;1066                                       uint32_t * p_ticks_diff)
;;;1067   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1068       *p_ticks_diff = ticks_diff_get(ticks_to, ticks_from);
000008  4631              MOV      r1,r6
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ticks_diff_get
000010  6020              STR      r0,[r4,#0]
;;;1069       return NRF_SUCCESS;
000012  2000              MOVS     r0,#0
;;;1070   }
000014  bd70              POP      {r4-r6,pc}
;;;1071   
                          ENDP


                          AREA ||i.app_timer_cnt_get||, CODE, READONLY, ALIGN=1

                  app_timer_cnt_get PROC
;;;1057   
;;;1058   uint32_t app_timer_cnt_get(void)
000000  b510              PUSH     {r4,lr}
;;;1059   {
;;;1060       return rtc1_counter_get();
000002  f7fffffe          BL       rtc1_counter_get
;;;1061   }
000006  bd10              POP      {r4,pc}
;;;1062   
                          ENDP


                          AREA ||i.app_timer_create||, CODE, READONLY, ALIGN=2

                  app_timer_create PROC
;;;973    
;;;974    uint32_t app_timer_create(app_timer_id_t const *      p_timer_id,
000000  b510              PUSH     {r4,lr}
;;;975                              app_timer_mode_t            mode,
;;;976                              app_timer_timeout_handler_t timeout_handler)
;;;977    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;978        // Check state and parameters
;;;979        VERIFY_MODULE_INITIALIZED();
000006  bf00              NOP      
000008  480d              LDR      r0,|L9.64|
00000a  6840              LDR      r0,[r0,#4]  ; m_op_queue
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L9.20|
000010  2008              MOVS     r0,#8
                  |L9.18|
;;;980    
;;;981        if (timeout_handler == NULL)
;;;982        {
;;;983            return NRF_ERROR_INVALID_PARAM;
;;;984        }
;;;985        if (p_timer_id == NULL)
;;;986        {
;;;987            return NRF_ERROR_INVALID_PARAM;
;;;988        }
;;;989        if (((timer_node_t*)*p_timer_id)->is_running)
;;;990        {
;;;991            return NRF_ERROR_INVALID_STATE;
;;;992        }
;;;993    
;;;994        timer_node_t * p_node     = (timer_node_t *)*p_timer_id;
;;;995        p_node->is_running        = false;
;;;996        p_node->mode              = mode;
;;;997        p_node->p_timeout_handler = timeout_handler;
;;;998        return NRF_SUCCESS;
;;;999    }
000012  bd10              POP      {r4,pc}
                  |L9.20|
000014  bf00              NOP                            ;979
000016  2a00              CMP      r2,#0                 ;981
000018  d101              BNE      |L9.30|
00001a  2007              MOVS     r0,#7                 ;983
00001c  e7f9              B        |L9.18|
                  |L9.30|
00001e  2b00              CMP      r3,#0                 ;985
000020  d101              BNE      |L9.38|
000022  2007              MOVS     r0,#7                 ;987
000024  e7f5              B        |L9.18|
                  |L9.38|
000026  6818              LDR      r0,[r3,#0]            ;989
000028  7c00              LDRB     r0,[r0,#0x10]         ;989
00002a  2800              CMP      r0,#0                 ;989
00002c  d001              BEQ      |L9.50|
00002e  2008              MOVS     r0,#8                 ;991
000030  e7ef              B        |L9.18|
                  |L9.50|
000032  6819              LDR      r1,[r3,#0]            ;994
000034  2000              MOVS     r0,#0                 ;995
000036  7408              STRB     r0,[r1,#0x10]         ;995
000038  744c              STRB     r4,[r1,#0x11]         ;996
00003a  614a              STR      r2,[r1,#0x14]         ;997
00003c  bf00              NOP                            ;998
00003e  e7e8              B        |L9.18|
;;;1000   
                          ENDP

                  |L9.64|
                          DCD      m_op_queue

                          AREA ||i.app_timer_init||, CODE, READONLY, ALIGN=2

                  app_timer_init PROC
;;;926    
;;;927    uint32_t app_timer_init(uint32_t                      prescaler,
000000  b5f8              PUSH     {r3-r7,lr}
;;;928                            uint8_t                       op_queue_size,
;;;929                            void *                        p_buffer,
;;;930                            app_timer_evt_schedule_func_t evt_schedule_func)
;;;931    {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
000008  461e              MOV      r6,r3
;;;932        // Check that buffer is correctly aligned
;;;933        if (!is_word_aligned(p_buffer))
00000a  4620              MOV      r0,r4
00000c  0781              LSLS     r1,r0,#30
00000e  0f89              LSRS     r1,r1,#30
000010  2900              CMP      r1,#0
000012  d101              BNE      |L10.24|
000014  2101              MOVS     r1,#1
000016  e000              B        |L10.26|
                  |L10.24|
000018  2100              MOVS     r1,#0
                  |L10.26|
00001a  2900              CMP      r1,#0
00001c  d101              BNE      |L10.34|
;;;934        {
;;;935            return NRF_ERROR_INVALID_PARAM;
00001e  2007              MOVS     r0,#7
                  |L10.32|
;;;936        }
;;;937        // Check for NULL buffer
;;;938        if (p_buffer == NULL)
;;;939        {
;;;940            return NRF_ERROR_INVALID_PARAM;
;;;941        }
;;;942    
;;;943        // Stop RTC to prevent any running timers from expiring (in case of reinitialization)
;;;944        rtc1_stop();
;;;945    
;;;946        m_evt_schedule_func = evt_schedule_func;
;;;947    
;;;948        // Initialize operation queue
;;;949        m_op_queue.first           = 0;
;;;950        m_op_queue.last            = 0;
;;;951        m_op_queue.size            = op_queue_size;
;;;952        m_op_queue.p_user_op_queue = p_buffer;
;;;953    
;;;954        mp_timer_id_head            = NULL;
;;;955        m_ticks_elapsed_q_read_ind  = 0;
;;;956        m_ticks_elapsed_q_write_ind = 0;
;;;957    
;;;958    #if APP_TIMER_WITH_PROFILER
;;;959        m_max_user_op_queue_utilization   = 0;
;;;960    #endif
;;;961    
;;;962        NVIC_ClearPendingIRQ(SWI_IRQn);
;;;963        NVIC_SetPriority(SWI_IRQn, SWI_IRQ_PRI);
;;;964        NVIC_EnableIRQ(SWI_IRQn);
;;;965    
;;;966        rtc1_init(prescaler);
;;;967    
;;;968        m_ticks_latest = rtc1_counter_get();
;;;969    
;;;970        return NRF_SUCCESS;
;;;971    }
000020  bdf8              POP      {r3-r7,pc}
                  |L10.34|
000022  2c00              CMP      r4,#0                 ;938
000024  d101              BNE      |L10.42|
000026  2007              MOVS     r0,#7                 ;940
000028  e7fa              B        |L10.32|
                  |L10.42|
00002a  f7fffffe          BL       rtc1_stop
00002e  4811              LDR      r0,|L10.116|
000030  6006              STR      r6,[r0,#0]            ;946  ; m_evt_schedule_func
000032  2000              MOVS     r0,#0                 ;949
000034  4910              LDR      r1,|L10.120|
000036  7008              STRB     r0,[r1,#0]            ;949
000038  7048              STRB     r0,[r1,#1]            ;950
00003a  4608              MOV      r0,r1                 ;951
00003c  7085              STRB     r5,[r0,#2]            ;951
00003e  6044              STR      r4,[r0,#4]            ;952  ; m_op_queue
000040  2000              MOVS     r0,#0                 ;954
000042  490e              LDR      r1,|L10.124|
000044  6008              STR      r0,[r1,#0]            ;954  ; mp_timer_id_head
000046  490e              LDR      r1,|L10.128|
000048  7008              STRB     r0,[r1,#0]            ;955
00004a  490e              LDR      r1,|L10.132|
00004c  7008              STRB     r0,[r1,#0]            ;956
00004e  2014              MOVS     r0,#0x14              ;962
000050  f7fffffe          BL       NVIC_ClearPendingIRQ
000054  2103              MOVS     r1,#3                 ;963
000056  2014              MOVS     r0,#0x14              ;963
000058  f7fffffe          BL       NVIC_SetPriority
00005c  2014              MOVS     r0,#0x14              ;964
00005e  f7fffffe          BL       NVIC_EnableIRQ
000062  4638              MOV      r0,r7                 ;966
000064  f7fffffe          BL       rtc1_init
000068  f7fffffe          BL       rtc1_counter_get
00006c  4906              LDR      r1,|L10.136|
00006e  6008              STR      r0,[r1,#0]            ;968  ; m_ticks_latest
000070  2000              MOVS     r0,#0                 ;970
000072  e7d5              B        |L10.32|
;;;972    
                          ENDP

                  |L10.116|
                          DCD      m_evt_schedule_func
                  |L10.120|
                          DCD      m_op_queue
                  |L10.124|
                          DCD      mp_timer_id_head
                  |L10.128|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L10.132|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L10.136|
                          DCD      m_ticks_latest

                          AREA ||i.app_timer_start||, CODE, READONLY, ALIGN=2

                  app_timer_start PROC
;;;1000   
;;;1001   uint32_t app_timer_start(app_timer_id_t timer_id, uint32_t timeout_ticks, void * p_context)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1002   {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;1003       uint32_t timeout_periodic;
;;;1004       timer_node_t * p_node = (timer_node_t*)timer_id;
000008  4625              MOV      r5,r4
;;;1005   
;;;1006       // Check state and parameters
;;;1007       VERIFY_MODULE_INITIALIZED();
00000a  bf00              NOP      
00000c  4810              LDR      r0,|L11.80|
00000e  6840              LDR      r0,[r0,#4]  ; m_op_queue
000010  2800              CMP      r0,#0
000012  d101              BNE      |L11.24|
000014  2008              MOVS     r0,#8
                  |L11.22|
;;;1008   
;;;1009       if (timer_id == 0)
;;;1010       {
;;;1011           return NRF_ERROR_INVALID_STATE;
;;;1012       }
;;;1013       if (timeout_ticks < APP_TIMER_MIN_TIMEOUT_TICKS)
;;;1014       {
;;;1015           return NRF_ERROR_INVALID_PARAM;
;;;1016       }
;;;1017       if (p_node->p_timeout_handler == NULL)
;;;1018       {
;;;1019           return NRF_ERROR_INVALID_STATE;
;;;1020       }
;;;1021   
;;;1022       // Schedule timer start operation
;;;1023       timeout_periodic = (p_node->mode == APP_TIMER_MODE_REPEATED) ? timeout_ticks : 0;
;;;1024   
;;;1025       return timer_start_op_schedule(p_node,
;;;1026                                      timeout_ticks,
;;;1027                                      timeout_periodic,
;;;1028                                      p_context);
;;;1029   }
000016  bdf8              POP      {r3-r7,pc}
                  |L11.24|
000018  bf00              NOP                            ;1007
00001a  2c00              CMP      r4,#0                 ;1009
00001c  d101              BNE      |L11.34|
00001e  2008              MOVS     r0,#8                 ;1011
000020  e7f9              B        |L11.22|
                  |L11.34|
000022  2e05              CMP      r6,#5                 ;1013
000024  d201              BCS      |L11.42|
000026  2007              MOVS     r0,#7                 ;1015
000028  e7f5              B        |L11.22|
                  |L11.42|
00002a  6968              LDR      r0,[r5,#0x14]         ;1017
00002c  2800              CMP      r0,#0                 ;1017
00002e  d101              BNE      |L11.52|
000030  2008              MOVS     r0,#8                 ;1019
000032  e7f0              B        |L11.22|
                  |L11.52|
000034  7c68              LDRB     r0,[r5,#0x11]         ;1023
000036  2801              CMP      r0,#1                 ;1023
000038  d101              BNE      |L11.62|
00003a  4630              MOV      r0,r6                 ;1023
00003c  e000              B        |L11.64|
                  |L11.62|
00003e  2000              MOVS     r0,#0                 ;1023
                  |L11.64|
000040  9000              STR      r0,[sp,#0]            ;1023
000042  463b              MOV      r3,r7                 ;1025
000044  4631              MOV      r1,r6                 ;1025
000046  4628              MOV      r0,r5                 ;1025
000048  9a00              LDR      r2,[sp,#0]            ;1025
00004a  f7fffffe          BL       timer_start_op_schedule
00004e  e7e2              B        |L11.22|
;;;1030   
                          ENDP

                  |L11.80|
                          DCD      m_op_queue

                          AREA ||i.app_timer_stop||, CODE, READONLY, ALIGN=2

                  app_timer_stop PROC
;;;1031   
;;;1032   uint32_t app_timer_stop(app_timer_id_t timer_id)
000000  b570              PUSH     {r4-r6,lr}
;;;1033   {
000002  4604              MOV      r4,r0
;;;1034       timer_node_t * p_node = (timer_node_t*)timer_id;
000004  4625              MOV      r5,r4
;;;1035       // Check state and parameters
;;;1036       VERIFY_MODULE_INITIALIZED();
000006  bf00              NOP      
000008  480a              LDR      r0,|L12.52|
00000a  6840              LDR      r0,[r0,#4]  ; m_op_queue
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L12.20|
000010  2008              MOVS     r0,#8
                  |L12.18|
;;;1037   
;;;1038       if ((timer_id == NULL) || (p_node->p_timeout_handler == NULL))
;;;1039       {
;;;1040           return NRF_ERROR_INVALID_STATE;
;;;1041       }
;;;1042   
;;;1043       p_node->is_running = false;
;;;1044       // Schedule timer stop operation
;;;1045       return timer_stop_op_schedule(p_node, TIMER_USER_OP_TYPE_STOP);
;;;1046   }
000012  bd70              POP      {r4-r6,pc}
                  |L12.20|
000014  bf00              NOP                            ;1036
000016  2c00              CMP      r4,#0                 ;1038
000018  d002              BEQ      |L12.32|
00001a  6968              LDR      r0,[r5,#0x14]         ;1038
00001c  2800              CMP      r0,#0                 ;1038
00001e  d101              BNE      |L12.36|
                  |L12.32|
000020  2008              MOVS     r0,#8                 ;1040
000022  e7f6              B        |L12.18|
                  |L12.36|
000024  2000              MOVS     r0,#0                 ;1043
000026  7428              STRB     r0,[r5,#0x10]         ;1043
000028  2102              MOVS     r1,#2                 ;1045
00002a  4628              MOV      r0,r5                 ;1045
00002c  f7fffffe          BL       timer_stop_op_schedule
000030  e7ef              B        |L12.18|
;;;1047   
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      m_op_queue

                          AREA ||i.app_timer_stop_all||, CODE, READONLY, ALIGN=2

                  app_timer_stop_all PROC
;;;1048   
;;;1049   uint32_t app_timer_stop_all(void)
000000  b510              PUSH     {r4,lr}
;;;1050   {
;;;1051       // Check state
;;;1052       VERIFY_MODULE_INITIALIZED();
000002  bf00              NOP      
000004  4805              LDR      r0,|L13.28|
000006  6840              LDR      r0,[r0,#4]  ; m_op_queue
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L13.16|
00000c  2008              MOVS     r0,#8
                  |L13.14|
;;;1053   
;;;1054       return timer_stop_op_schedule(NULL, TIMER_USER_OP_TYPE_STOP_ALL);
;;;1055   }
00000e  bd10              POP      {r4,pc}
                  |L13.16|
000010  bf00              NOP                            ;1052
000012  2103              MOVS     r1,#3                 ;1054
000014  2000              MOVS     r0,#0                 ;1054
000016  f7fffffe          BL       timer_stop_op_schedule
00001a  e7f8              B        |L13.14|
;;;1056   
                          ENDP

                  |L13.28|
                          DCD      m_op_queue

                          AREA ||i.compare_reg_update||, CODE, READONLY, ALIGN=2

                  compare_reg_update PROC
;;;666     */
;;;667    static void compare_reg_update(timer_node_t * p_timer_id_head_old)
000000  b5fe              PUSH     {r1-r7,lr}
;;;668    {
;;;669        // Setup the timeout for timers on the head of the list
;;;670        if (mp_timer_id_head != NULL)
000002  481f              LDR      r0,|L14.128|
000004  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000006  2800              CMP      r0,#0
000008  d036              BEQ      |L14.120|
;;;671        {
;;;672            uint32_t ticks_to_expire = mp_timer_id_head->ticks_to_expire;
00000a  481d              LDR      r0,|L14.128|
00000c  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
00000e  6805              LDR      r5,[r0,#0]
;;;673            uint32_t pre_counter_val = rtc1_counter_get();
000010  f7fffffe          BL       rtc1_counter_get
000014  9001              STR      r0,[sp,#4]
;;;674            uint32_t cc              = m_ticks_latest;
000016  481b              LDR      r0,|L14.132|
000018  6804              LDR      r4,[r0,#0]  ; m_ticks_latest
;;;675            uint32_t ticks_elapsed   = ticks_diff_get(pre_counter_val, cc) + RTC_COMPARE_OFFSET_MIN;
00001a  4621              MOV      r1,r4
00001c  9801              LDR      r0,[sp,#4]
00001e  f7fffffe          BL       ticks_diff_get
000022  1cc6              ADDS     r6,r0,#3
;;;676    
;;;677            if (!m_rtc1_running)
000024  4818              LDR      r0,|L14.136|
000026  7800              LDRB     r0,[r0,#0]  ; m_rtc1_running
000028  2800              CMP      r0,#0
00002a  d101              BNE      |L14.48|
;;;678            {
;;;679                // No timers were already running, start RTC
;;;680                rtc1_start();
00002c  f7fffffe          BL       rtc1_start
                  |L14.48|
;;;681            }
;;;682    
;;;683            cc += (ticks_elapsed < ticks_to_expire) ? ticks_to_expire : ticks_elapsed;
000030  42ae              CMP      r6,r5
000032  d201              BCS      |L14.56|
000034  4628              MOV      r0,r5
000036  e000              B        |L14.58|
                  |L14.56|
000038  4630              MOV      r0,r6
                  |L14.58|
00003a  1904              ADDS     r4,r0,r4
;;;684            cc &= MAX_RTC_COUNTER_VAL;
00003c  0224              LSLS     r4,r4,#8
00003e  0a24              LSRS     r4,r4,#8
;;;685    
;;;686            rtc1_compare0_set(cc);
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       rtc1_compare0_set
;;;687    
;;;688            uint32_t post_counter_val = rtc1_counter_get();
000046  f7fffffe          BL       rtc1_counter_get
00004a  9000              STR      r0,[sp,#0]
;;;689    
;;;690            if (
00004c  9901              LDR      r1,[sp,#4]
00004e  9800              LDR      r0,[sp,#0]
000050  f7fffffe          BL       ticks_diff_get
000054  1cc7              ADDS     r7,r0,#3
000056  4620              MOV      r0,r4
000058  9901              LDR      r1,[sp,#4]
00005a  f7fffffe          BL       ticks_diff_get
00005e  4287              CMP      r7,r0
000060  d909              BLS      |L14.118|
;;;691                (ticks_diff_get(post_counter_val, pre_counter_val) + RTC_COMPARE_OFFSET_MIN)
;;;692                >
;;;693                ticks_diff_get(cc, pre_counter_val)
;;;694               )
;;;695            {
;;;696                // When this happens the COMPARE event may not be triggered by the RTC.
;;;697                // The nRF51 Series User Specification states that if the COUNTER value is N
;;;698                // (i.e post_counter_val = N), writing N or N + 1 to a CC register may not trigger a
;;;699                // COMPARE event. Hence the RTC interrupt is forcefully pended by calling the following
;;;700                // function.
;;;701                rtc1_compare0_set(rtc1_counter_get());  // this should prevent CC to fire again in the background while the code is in RTC-ISR
000062  f7fffffe          BL       rtc1_counter_get
000066  4607              MOV      r7,r0
000068  f7fffffe          BL       rtc1_compare0_set
;;;702                nrf_delay_us(MAX_RTC_TASKS_DELAY);
00006c  202f              MOVS     r0,#0x2f
00006e  f7fffffe          BL       nrf_delay_us
;;;703                timer_timeouts_check_sched();
000072  f7fffffe          BL       timer_timeouts_check_sched
                  |L14.118|
;;;704            }
;;;705        }
000076  e001              B        |L14.124|
                  |L14.120|
;;;706        else
;;;707        {
;;;708    #if (APP_TIMER_KEEPS_RTC_ACTIVE == 0)
;;;709            // No timers are running, stop RTC
;;;710            rtc1_stop();
000078  f7fffffe          BL       rtc1_stop
                  |L14.124|
;;;711    #endif //(APP_TIMER_KEEPS_RTC_ACTIVE == 0)
;;;712        }
;;;713    }
00007c  bdfe              POP      {r1-r7,pc}
;;;714    
                          ENDP

00007e  0000              DCW      0x0000
                  |L14.128|
                          DCD      mp_timer_id_head
                  |L14.132|
                          DCD      m_ticks_latest
                  |L14.136|
                          DCD      m_rtc1_running

                          AREA ||i.elapsed_ticks_acquire||, CODE, READONLY, ALIGN=2

                  elapsed_ticks_acquire PROC
;;;445     */
;;;446    static bool elapsed_ticks_acquire(uint32_t * p_ticks_elapsed)
000000  4601              MOV      r1,r0
;;;447    {
;;;448        // Pick the elapsed value from queue.
;;;449        if (m_ticks_elapsed_q_read_ind != m_ticks_elapsed_q_write_ind)
000002  4814              LDR      r0,|L15.84|
000004  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000006  4a14              LDR      r2,|L15.88|
000008  7812              LDRB     r2,[r2,#0]  ; m_ticks_elapsed_q_write_ind
00000a  4290              CMP      r0,r2
00000c  d01d              BEQ      |L15.74|
;;;450        {
;;;451            // Dequeue elapsed value.
;;;452            m_ticks_elapsed_q_read_ind++;
00000e  4811              LDR      r0,|L15.84|
000010  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000012  1c40              ADDS     r0,r0,#1
000014  4a0f              LDR      r2,|L15.84|
000016  7010              STRB     r0,[r2,#0]
;;;453            if (m_ticks_elapsed_q_read_ind == CONTEXT_QUEUE_SIZE_MAX)
000018  4610              MOV      r0,r2
00001a  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
00001c  2802              CMP      r0,#2
00001e  d101              BNE      |L15.36|
;;;454            {
;;;455                m_ticks_elapsed_q_read_ind = 0;
000020  2000              MOVS     r0,#0
000022  7010              STRB     r0,[r2,#0]
                  |L15.36|
;;;456            }
;;;457    
;;;458            *p_ticks_elapsed = m_ticks_elapsed[m_ticks_elapsed_q_read_ind];
000024  480b              LDR      r0,|L15.84|
000026  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000028  0080              LSLS     r0,r0,#2
00002a  4a0c              LDR      r2,|L15.92|
00002c  5810              LDR      r0,[r2,r0]
00002e  6008              STR      r0,[r1,#0]
;;;459    
;;;460            m_ticks_latest += *p_ticks_elapsed;
000030  4a0b              LDR      r2,|L15.96|
000032  6808              LDR      r0,[r1,#0]
000034  6812              LDR      r2,[r2,#0]  ; m_ticks_latest
000036  1880              ADDS     r0,r0,r2
000038  4a09              LDR      r2,|L15.96|
00003a  6010              STR      r0,[r2,#0]  ; m_ticks_latest
;;;461            m_ticks_latest &= MAX_RTC_COUNTER_VAL;
00003c  4610              MOV      r0,r2
00003e  6800              LDR      r0,[r0,#0]  ; m_ticks_latest
000040  0200              LSLS     r0,r0,#8
000042  0a00              LSRS     r0,r0,#8
000044  6010              STR      r0,[r2,#0]  ; m_ticks_latest
;;;462    
;;;463            return true;
000046  2001              MOVS     r0,#1
                  |L15.72|
;;;464        }
;;;465        else
;;;466        {
;;;467            // No elapsed value in queue.
;;;468            *p_ticks_elapsed = 0;
;;;469            return false;
;;;470        }
;;;471    }
000048  4770              BX       lr
                  |L15.74|
00004a  2000              MOVS     r0,#0                 ;468
00004c  6008              STR      r0,[r1,#0]            ;468
00004e  bf00              NOP                            ;469
000050  e7fa              B        |L15.72|
;;;472    
                          ENDP

000052  0000              DCW      0x0000
                  |L15.84|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L15.88|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L15.92|
                          DCD      m_ticks_elapsed
                  |L15.96|
                          DCD      m_ticks_latest

                          AREA ||i.expired_timers_handler||, CODE, READONLY, ALIGN=2

                  expired_timers_handler PROC
;;;531     */
;;;532    static void expired_timers_handler(uint32_t         ticks_elapsed,
000000  b5f0              PUSH     {r4-r7,lr}
;;;533                                       uint32_t         ticks_previous,
;;;534                                       timer_node_t **  p_restart_list_head)
;;;535    {
000002  4603              MOV      r3,r0
;;;536        uint32_t ticks_expired = 0;
000004  2400              MOVS     r4,#0
;;;537    
;;;538        while (mp_timer_id_head != NULL)
000006  e020              B        |L16.74|
                  |L16.8|
;;;539        {
;;;540            timer_node_t * p_timer;
;;;541            timer_node_t * p_timer_expired;
;;;542    
;;;543            // Auto variable for current timer node.
;;;544            p_timer = mp_timer_id_head;
000008  4e13              LDR      r6,|L16.88|
00000a  6830              LDR      r0,[r6,#0]  ; mp_timer_id_head
;;;545    
;;;546            // Do nothing if timer did not expire
;;;547            if (ticks_elapsed < p_timer->ticks_to_expire)
00000c  6806              LDR      r6,[r0,#0]
00000e  429e              CMP      r6,r3
000010  d903              BLS      |L16.26|
;;;548            {
;;;549                p_timer->ticks_to_expire -= ticks_elapsed;
000012  6806              LDR      r6,[r0,#0]
000014  1af6              SUBS     r6,r6,r3
000016  6006              STR      r6,[r0,#0]
;;;550                break;
000018  e01b              B        |L16.82|
                  |L16.26|
;;;551            }
;;;552    
;;;553            // Decrement ticks_elapsed and collect expired ticks.
;;;554            ticks_elapsed -= p_timer->ticks_to_expire;
00001a  6806              LDR      r6,[r0,#0]
00001c  1b9b              SUBS     r3,r3,r6
;;;555            ticks_expired += p_timer->ticks_to_expire;
00001e  6806              LDR      r6,[r0,#0]
000020  1934              ADDS     r4,r6,r4
;;;556    
;;;557            // Timer expired, set ticks_to_expire zero.
;;;558            p_timer->ticks_to_expire = 0;
000022  2600              MOVS     r6,#0
000024  6006              STR      r6,[r0,#0]
;;;559    
;;;560            // Remove the expired timer from head.
;;;561            p_timer_expired  = mp_timer_id_head;
000026  4e0c              LDR      r6,|L16.88|
000028  6835              LDR      r5,[r6,#0]  ; mp_timer_id_head
;;;562            mp_timer_id_head = p_timer->next;
00002a  4f0b              LDR      r7,|L16.88|
00002c  69c6              LDR      r6,[r0,#0x1c]
00002e  603e              STR      r6,[r7,#0]  ; mp_timer_id_head
;;;563    
;;;564            // Timer will be restarted if periodic.
;;;565            if (p_timer->ticks_periodic_interval != 0)
000030  68c6              LDR      r6,[r0,#0xc]
000032  2e00              CMP      r6,#0
000034  d008              BEQ      |L16.72|
;;;566            {
;;;567                p_timer->ticks_at_start       = (ticks_previous + ticks_expired) & MAX_RTC_COUNTER_VAL;
000036  190e              ADDS     r6,r1,r4
000038  0236              LSLS     r6,r6,#8
00003a  0a36              LSRS     r6,r6,#8
00003c  6046              STR      r6,[r0,#4]
;;;568                p_timer->ticks_first_interval = p_timer->ticks_periodic_interval;
00003e  68c6              LDR      r6,[r0,#0xc]
000040  6086              STR      r6,[r0,#8]
;;;569                p_timer->next                 = *p_restart_list_head;
000042  6816              LDR      r6,[r2,#0]
000044  61c6              STR      r6,[r0,#0x1c]
;;;570                *p_restart_list_head          = p_timer_expired;
000046  6015              STR      r5,[r2,#0]
                  |L16.72|
;;;571            }
;;;572        }
000048  bf00              NOP      
                  |L16.74|
00004a  4803              LDR      r0,|L16.88|
00004c  6800              LDR      r0,[r0,#0]            ;538  ; mp_timer_id_head
00004e  2800              CMP      r0,#0                 ;538
000050  d1da              BNE      |L16.8|
                  |L16.82|
000052  bf00              NOP                            ;550
;;;573    }
000054  bdf0              POP      {r4-r7,pc}
;;;574    
                          ENDP

000056  0000              DCW      0x0000
                  |L16.88|
                          DCD      mp_timer_id_head

                          AREA ||i.list_deletions_handler||, CODE, READONLY, ALIGN=2

                  list_deletions_handler PROC
;;;477     */
;;;478    static bool list_deletions_handler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;479    {
;;;480        timer_node_t * p_timer_old_head;
;;;481        uint8_t        user_ops_first = m_op_queue.first;
000002  481c              LDR      r0,|L17.116|
000004  7804              LDRB     r4,[r0,#0]  ; m_op_queue
;;;482    
;;;483        // Remember the old head, so as to decide if new compare needs to be set.
;;;484        p_timer_old_head = mp_timer_id_head;
000006  481c              LDR      r0,|L17.120|
000008  6806              LDR      r6,[r0,#0]  ; mp_timer_id_head
;;;485    
;;;486        while (user_ops_first != m_op_queue.last)
00000a  e026              B        |L17.90|
                  |L17.12|
;;;487        {
;;;488            timer_user_op_t * p_user_op = &m_op_queue.p_user_op_queue[user_ops_first];
00000c  4819              LDR      r0,|L17.116|
00000e  6841              LDR      r1,[r0,#4]  ; m_op_queue
000010  2018              MOVS     r0,#0x18
000012  4360              MULS     r0,r4,r0
000014  180d              ADDS     r5,r1,r0
;;;489    
;;;490            // Traverse to next operation in queue.
;;;491            user_ops_first++;
000016  1c60              ADDS     r0,r4,#1
000018  b2c4              UXTB     r4,r0
;;;492            if (user_ops_first == m_op_queue.size)
00001a  4816              LDR      r0,|L17.116|
00001c  7880              LDRB     r0,[r0,#2]  ; m_op_queue
00001e  42a0              CMP      r0,r4
000020  d100              BNE      |L17.36|
;;;493            {
;;;494                user_ops_first = 0;
000022  2400              MOVS     r4,#0
                  |L17.36|
;;;495            }
;;;496    
;;;497            switch (p_user_op->op_type)
000024  7828              LDRB     r0,[r5,#0]
000026  2802              CMP      r0,#2
000028  d002              BEQ      |L17.48|
00002a  2803              CMP      r0,#3
00002c  d112              BNE      |L17.84|
00002e  e003              B        |L17.56|
                  |L17.48|
;;;498            {
;;;499                case TIMER_USER_OP_TYPE_STOP:
;;;500                    // Delete node if timer is running.
;;;501                    timer_list_remove(p_user_op->p_node);
000030  6868              LDR      r0,[r5,#4]
000032  f7fffffe          BL       timer_list_remove
;;;502                    break;
000036  e00e              B        |L17.86|
                  |L17.56|
;;;503    
;;;504                case TIMER_USER_OP_TYPE_STOP_ALL:
;;;505                    // Delete list of running timers, and mark all timers as not running.
;;;506                    while (mp_timer_id_head != NULL)
000038  e007              B        |L17.74|
                  |L17.58|
;;;507                    {
;;;508                        timer_node_t * p_head = mp_timer_id_head;
00003a  490f              LDR      r1,|L17.120|
00003c  6808              LDR      r0,[r1,#0]  ; mp_timer_id_head
;;;509    
;;;510                        p_head->is_running = false;
00003e  2100              MOVS     r1,#0
000040  7401              STRB     r1,[r0,#0x10]
;;;511                        mp_timer_id_head    = p_head->next;
000042  4a0d              LDR      r2,|L17.120|
000044  69c1              LDR      r1,[r0,#0x1c]
000046  6011              STR      r1,[r2,#0]  ; mp_timer_id_head
;;;512                    }
000048  bf00              NOP      
                  |L17.74|
00004a  480b              LDR      r0,|L17.120|
00004c  6800              LDR      r0,[r0,#0]            ;506  ; mp_timer_id_head
00004e  2800              CMP      r0,#0                 ;506
000050  d1f3              BNE      |L17.58|
;;;513                    break;
000052  e000              B        |L17.86|
                  |L17.84|
;;;514    
;;;515                default:
;;;516                    // No implementation needed.
;;;517                    break;
000054  bf00              NOP      
                  |L17.86|
000056  bf00              NOP                            ;502
;;;518            }
;;;519        }
000058  bf00              NOP      
                  |L17.90|
00005a  4806              LDR      r0,|L17.116|
00005c  7840              LDRB     r0,[r0,#1]            ;486  ; m_op_queue
00005e  42a0              CMP      r0,r4                 ;486
000060  d1d4              BNE      |L17.12|
;;;520    
;;;521        // Detect change in head of the list.
;;;522        return (mp_timer_id_head != p_timer_old_head);
000062  4805              LDR      r0,|L17.120|
000064  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000066  42b0              CMP      r0,r6
000068  d001              BEQ      |L17.110|
00006a  2001              MOVS     r0,#1
                  |L17.108|
;;;523    }
00006c  bd70              POP      {r4-r6,pc}
                  |L17.110|
00006e  2000              MOVS     r0,#0                 ;522
000070  e7fc              B        |L17.108|
;;;524    
                          ENDP

000072  0000              DCW      0x0000
                  |L17.116|
                          DCD      m_op_queue
                  |L17.120|
                          DCD      mp_timer_id_head

                          AREA ||i.list_insertions_handler||, CODE, READONLY, ALIGN=2

                  list_insertions_handler PROC
;;;581     */
;;;582    static bool list_insertions_handler(timer_node_t * p_restart_list_head)
000000  b5f8              PUSH     {r3-r7,lr}
;;;583    {
000002  4605              MOV      r5,r0
;;;584        timer_node_t * p_timer_id_old_head;
;;;585    
;;;586        // Remember the old head, so as to decide if new compare needs to be set.
;;;587        p_timer_id_old_head = mp_timer_id_head;
000004  4837              LDR      r0,|L18.228|
000006  6806              LDR      r6,[r0,#0]  ; mp_timer_id_head
;;;588    
;;;589        // Handle insertions of timers.
;;;590        while ((p_restart_list_head != NULL) || (m_op_queue.first != m_op_queue.last))
000008  e05b              B        |L18.194|
                  |L18.10|
;;;591        {
;;;592            timer_node_t * p_timer;
;;;593    
;;;594            if (p_restart_list_head != NULL)
00000a  2d00              CMP      r5,#0
00000c  d002              BEQ      |L18.20|
;;;595            {
;;;596                p_timer           = p_restart_list_head;
00000e  462c              MOV      r4,r5
;;;597                p_restart_list_head = p_timer->next;
000010  69e5              LDR      r5,[r4,#0x1c]
000012  e029              B        |L18.104|
                  |L18.20|
;;;598            }
;;;599            else
;;;600            {
;;;601                timer_user_op_t * p_user_op = &m_op_queue.p_user_op_queue[m_op_queue.first];
000014  4934              LDR      r1,|L18.232|
000016  684a              LDR      r2,[r1,#4]  ; m_op_queue
000018  7809              LDRB     r1,[r1,#0]  ; m_op_queue
00001a  2318              MOVS     r3,#0x18
00001c  4359              MULS     r1,r3,r1
00001e  1850              ADDS     r0,r2,r1
;;;602    
;;;603                m_op_queue.first++;
000020  4931              LDR      r1,|L18.232|
000022  7809              LDRB     r1,[r1,#0]  ; m_op_queue
000024  1c49              ADDS     r1,r1,#1
000026  4a30              LDR      r2,|L18.232|
000028  7011              STRB     r1,[r2,#0]
;;;604                if (m_op_queue.first == m_op_queue.size)
00002a  4611              MOV      r1,r2
00002c  7809              LDRB     r1,[r1,#0]  ; m_op_queue
00002e  7892              LDRB     r2,[r2,#2]  ; m_op_queue
000030  4291              CMP      r1,r2
000032  d102              BNE      |L18.58|
;;;605                {
;;;606                    m_op_queue.first = 0;
000034  2100              MOVS     r1,#0
000036  4a2c              LDR      r2,|L18.232|
000038  7011              STRB     r1,[r2,#0]
                  |L18.58|
;;;607                }
;;;608    
;;;609                p_timer = p_user_op->p_node;
00003a  6844              LDR      r4,[r0,#4]
;;;610    
;;;611                if ((p_user_op->op_type != TIMER_USER_OP_TYPE_START) || p_timer->is_running)
00003c  7801              LDRB     r1,[r0,#0]
00003e  2901              CMP      r1,#1
000040  d102              BNE      |L18.72|
000042  7c21              LDRB     r1,[r4,#0x10]
000044  2900              CMP      r1,#0
000046  d000              BEQ      |L18.74|
                  |L18.72|
;;;612                {
;;;613                    continue;
000048  e03b              B        |L18.194|
                  |L18.74|
;;;614                }
;;;615    
;;;616                p_timer->ticks_at_start          = p_user_op->params.start.ticks_at_start;
00004a  6881              LDR      r1,[r0,#8]
00004c  6061              STR      r1,[r4,#4]
;;;617                p_timer->ticks_first_interval    = p_user_op->params.start.ticks_first_interval;
00004e  68c1              LDR      r1,[r0,#0xc]
000050  60a1              STR      r1,[r4,#8]
;;;618                p_timer->ticks_periodic_interval = p_user_op->params.start.ticks_periodic_interval;
000052  6901              LDR      r1,[r0,#0x10]
000054  60e1              STR      r1,[r4,#0xc]
;;;619                p_timer->p_context               = p_user_op->params.start.p_context;
000056  6941              LDR      r1,[r0,#0x14]
000058  61a1              STR      r1,[r4,#0x18]
;;;620    
;;;621                if (m_rtc1_reset)
00005a  4924              LDR      r1,|L18.236|
00005c  7809              LDRB     r1,[r1,#0]  ; m_rtc1_reset
00005e  2900              CMP      r1,#0
000060  d001              BEQ      |L18.102|
;;;622                {
;;;623                    p_timer->ticks_at_start = 0;
000062  2100              MOVS     r1,#0
000064  6061              STR      r1,[r4,#4]
                  |L18.102|
;;;624                }
;;;625            }
000066  bf00              NOP      
                  |L18.104|
;;;626    
;;;627            // Prepare the node to be inserted.
;;;628            if (
000068  4921              LDR      r1,|L18.240|
00006a  6860              LDR      r0,[r4,#4]
00006c  6809              LDR      r1,[r1,#0]  ; m_ticks_latest
00006e  1a40              SUBS     r0,r0,r1
000070  0200              LSLS     r0,r0,#8
000072  0a00              LSRS     r0,r0,#8
000074  491f              LDR      r1,|L18.244|
000076  4288              CMP      r0,r1
000078  d208              BCS      |L18.140|
;;;629                 ((p_timer->ticks_at_start - m_ticks_latest) & MAX_RTC_COUNTER_VAL)
;;;630                 <
;;;631                 (MAX_RTC_COUNTER_VAL / 2)
;;;632                )
;;;633            {
;;;634                p_timer->ticks_to_expire = ticks_diff_get(p_timer->ticks_at_start, m_ticks_latest) +
00007a  491d              LDR      r1,|L18.240|
00007c  6860              LDR      r0,[r4,#4]
00007e  6809              LDR      r1,[r1,#0]  ; m_ticks_latest
000080  f7fffffe          BL       ticks_diff_get
000084  68a1              LDR      r1,[r4,#8]
000086  1840              ADDS     r0,r0,r1
000088  6020              STR      r0,[r4,#0]
00008a  e00f              B        |L18.172|
                  |L18.140|
;;;635                                           p_timer->ticks_first_interval;
;;;636            }
;;;637            else
;;;638            {
;;;639                uint32_t delta_current_start;
;;;640    
;;;641                delta_current_start = ticks_diff_get(m_ticks_latest, p_timer->ticks_at_start);
00008c  4818              LDR      r0,|L18.240|
00008e  6861              LDR      r1,[r4,#4]
000090  6800              LDR      r0,[r0,#0]  ; m_ticks_latest
000092  f7fffffe          BL       ticks_diff_get
000096  4607              MOV      r7,r0
;;;642                if (p_timer->ticks_first_interval > delta_current_start)
000098  68a0              LDR      r0,[r4,#8]
00009a  42b8              CMP      r0,r7
00009c  d903              BLS      |L18.166|
;;;643                {
;;;644                    p_timer->ticks_to_expire = p_timer->ticks_first_interval - delta_current_start;
00009e  68a0              LDR      r0,[r4,#8]
0000a0  1bc0              SUBS     r0,r0,r7
0000a2  6020              STR      r0,[r4,#0]
0000a4  e001              B        |L18.170|
                  |L18.166|
;;;645                }
;;;646                else
;;;647                {
;;;648                    p_timer->ticks_to_expire = 0;
0000a6  2000              MOVS     r0,#0
0000a8  6020              STR      r0,[r4,#0]
                  |L18.170|
;;;649                }
;;;650            }
0000aa  bf00              NOP      
                  |L18.172|
;;;651    
;;;652            p_timer->ticks_at_start       = 0;
0000ac  2000              MOVS     r0,#0
0000ae  6060              STR      r0,[r4,#4]
;;;653            p_timer->ticks_first_interval = 0;
0000b0  60a0              STR      r0,[r4,#8]
;;;654            p_timer->is_running           = true;
0000b2  2001              MOVS     r0,#1
0000b4  7420              STRB     r0,[r4,#0x10]
;;;655            p_timer->next                 = NULL;
0000b6  2000              MOVS     r0,#0
0000b8  61e0              STR      r0,[r4,#0x1c]
;;;656    
;;;657            // Insert into list
;;;658            timer_list_insert(p_timer);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       timer_list_insert
0000c0  bf00              NOP                            ;613
                  |L18.194|
0000c2  2d00              CMP      r5,#0                 ;590
0000c4  d1a1              BNE      |L18.10|
0000c6  4808              LDR      r0,|L18.232|
0000c8  7800              LDRB     r0,[r0,#0]            ;590  ; m_op_queue
0000ca  4907              LDR      r1,|L18.232|
0000cc  7849              LDRB     r1,[r1,#1]            ;590  ; m_op_queue
0000ce  4288              CMP      r0,r1                 ;590
0000d0  d19b              BNE      |L18.10|
;;;659        }
;;;660    
;;;661        return (mp_timer_id_head != p_timer_id_old_head);
0000d2  4804              LDR      r0,|L18.228|
0000d4  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
0000d6  42b0              CMP      r0,r6
0000d8  d001              BEQ      |L18.222|
0000da  2001              MOVS     r0,#1
                  |L18.220|
;;;662    }
0000dc  bdf8              POP      {r3-r7,pc}
                  |L18.222|
0000de  2000              MOVS     r0,#0                 ;661
0000e0  e7fc              B        |L18.220|
;;;663    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L18.228|
                          DCD      mp_timer_id_head
                  |L18.232|
                          DCD      m_op_queue
                  |L18.236|
                          DCD      m_rtc1_reset
                  |L18.240|
                          DCD      m_ticks_latest
                  |L18.244|
                          DCD      0x007fffff

                          AREA ||i.nrf_delay_us||, CODE, READONLY, ALIGN=2

                  nrf_delay_us PROC
;;;78     #if defined ( __CC_ARM   )
;;;79     __STATIC_INLINE void nrf_delay_us(uint32_t number_of_us)
000000  2800              CMP      r0,#0
;;;80     {
;;;81         if(!number_of_us)
000002  d100              BNE      |L19.6|
                  |L19.4|
;;;82             return;
;;;83     __asm
;;;84         {
;;;85     loop:
;;;86         NOP
;;;87         NOP
;;;88         NOP
;;;89         NOP
;;;90         NOP
;;;91         NOP
;;;92         NOP
;;;93         NOP
;;;94         CMP SystemCoreClock, CLOCK_FREQ_16MHz
;;;95         BEQ cond
;;;96         NOP
;;;97     #if defined(NRF52) || defined(NRF52840_XXAA) || defined(NRF52832)
;;;98         NOP
;;;99         NOP
;;;100        NOP
;;;101        NOP
;;;102        NOP
;;;103        NOP
;;;104        NOP
;;;105        NOP
;;;106        NOP
;;;107        NOP
;;;108        NOP
;;;109        NOP
;;;110        NOP
;;;111        NOP
;;;112        NOP
;;;113        NOP
;;;114        NOP
;;;115        NOP
;;;116        NOP
;;;117        NOP
;;;118        NOP
;;;119        NOP
;;;120        NOP
;;;121        NOP
;;;122        NOP
;;;123        NOP
;;;124        NOP
;;;125        NOP
;;;126        NOP
;;;127        NOP
;;;128        NOP
;;;129        NOP
;;;130        NOP
;;;131        NOP
;;;132        NOP
;;;133        NOP
;;;134        NOP
;;;135        NOP
;;;136        NOP
;;;137        NOP
;;;138        NOP
;;;139        NOP
;;;140        NOP
;;;141        NOP
;;;142        NOP
;;;143        NOP
;;;144        NOP
;;;145    #endif
;;;146    cond:
;;;147        SUBS number_of_us, #1
;;;148        BNE loop
;;;149        }
;;;150    }
000004  4770              BX       lr
                  |L19.6|
000006  bf00              NOP                            ;85
                  |L19.8|
000008  bf00              NOP                            ;86
00000a  bf00              NOP                            ;87
00000c  bf00              NOP                            ;88
00000e  bf00              NOP                            ;89
000010  bf00              NOP                            ;90
000012  bf00              NOP                            ;91
000014  bf00              NOP                            ;92
000016  bf00              NOP                            ;93
000018  4907              LDR      r1,|L19.56|
00001a  6809              LDR      r1,[r1,#0]            ;94  ; SystemCoreClock
00001c  4a07              LDR      r2,|L19.60|
00001e  4291              CMP      r1,r2                 ;94
000020  d100              BNE      |L19.36|
000022  e001              B        |L19.40|
                  |L19.36|
000024  bf00              NOP                            ;96
000026  bf00              NOP                            ;146
                  |L19.40|
000028  4601              MOV      r1,r0                 ;147
00002a  3901              SUBS     r1,#1                 ;147
00002c  4608              MOV      r0,r1                 ;147
00002e  d000              BEQ      |L19.50|
000030  e7ea              B        |L19.8|
                  |L19.50|
000032  bf00              NOP      
000034  e7e6              B        |L19.4|
;;;151    
                          ENDP

000036  0000              DCW      0x0000
                  |L19.56|
                          DCD      SystemCoreClock
                  |L19.60|
                          DCD      0x00f42400

                          AREA ||i.rtc1_compare0_set||, CODE, READONLY, ALIGN=2

                  rtc1_compare0_set PROC
;;;220     */
;;;221    static __INLINE void rtc1_compare0_set(uint32_t value)
000000  4901              LDR      r1,|L20.8|
;;;222    {
;;;223        NRF_RTC1->CC[0] = value;
000002  6008              STR      r0,[r1,#0]
;;;224    }
000004  4770              BX       lr
;;;225    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x40011540

                          AREA ||i.rtc1_counter_get||, CODE, READONLY, ALIGN=2

                  rtc1_counter_get PROC
;;;199     */
;;;200    static __INLINE uint32_t rtc1_counter_get(void)
000000  4801              LDR      r0,|L21.8|
;;;201    {
;;;202        return NRF_RTC1->COUNTER;
000002  6840              LDR      r0,[r0,#4]
;;;203    }
000004  4770              BX       lr
;;;204    
                          ENDP

000006  0000              DCW      0x0000
                  |L21.8|
                          DCD      0x40011500

                          AREA ||i.rtc1_init||, CODE, READONLY, ALIGN=2

                  rtc1_init PROC
;;;151     */
;;;152    static void rtc1_init(uint32_t prescaler)
000000  b510              PUSH     {r4,lr}
;;;153    {
000002  4604              MOV      r4,r0
;;;154        NRF_RTC1->PRESCALER = prescaler;
000004  4803              LDR      r0,|L22.20|
000006  6084              STR      r4,[r0,#8]
;;;155        NVIC_SetPriority(RTC1_IRQn, RTC1_IRQ_PRI);
000008  2103              MOVS     r1,#3
00000a  2011              MOVS     r0,#0x11
00000c  f7fffffe          BL       NVIC_SetPriority
;;;156    }
000010  bd10              POP      {r4,pc}
;;;157    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x40011500

                          AREA ||i.rtc1_start||, CODE, READONLY, ALIGN=2

                  rtc1_start PROC
;;;160     */
;;;161    static void rtc1_start(void)
000000  b510              PUSH     {r4,lr}
;;;162    {
;;;163        NRF_RTC1->EVTENSET = RTC_EVTEN_COMPARE0_Msk;
000002  2001              MOVS     r0,#1
000004  0400              LSLS     r0,r0,#16
000006  490a              LDR      r1,|L23.48|
000008  6048              STR      r0,[r1,#4]
;;;164        NRF_RTC1->INTENSET = RTC_INTENSET_COMPARE0_Msk;
00000a  4909              LDR      r1,|L23.48|
00000c  3940              SUBS     r1,r1,#0x40
00000e  6048              STR      r0,[r1,#4]
;;;165    
;;;166        NVIC_ClearPendingIRQ(RTC1_IRQn);
000010  2011              MOVS     r0,#0x11
000012  f7fffffe          BL       NVIC_ClearPendingIRQ
;;;167        NVIC_EnableIRQ(RTC1_IRQn);
000016  2011              MOVS     r0,#0x11
000018  f7fffffe          BL       NVIC_EnableIRQ
;;;168    
;;;169        NRF_RTC1->TASKS_START = 1;
00001c  2001              MOVS     r0,#1
00001e  4905              LDR      r1,|L23.52|
000020  6008              STR      r0,[r1,#0]
;;;170        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000022  202f              MOVS     r0,#0x2f
000024  f7fffffe          BL       nrf_delay_us
;;;171    
;;;172        m_rtc1_running = true;
000028  2001              MOVS     r0,#1
00002a  4903              LDR      r1,|L23.56|
00002c  7008              STRB     r0,[r1,#0]
;;;173    }
00002e  bd10              POP      {r4,pc}
;;;174    
                          ENDP

                  |L23.48|
                          DCD      0x40011340
                  |L23.52|
                          DCD      0x40011000
                  |L23.56|
                          DCD      m_rtc1_running

                          AREA ||i.rtc1_stop||, CODE, READONLY, ALIGN=2

                  rtc1_stop PROC
;;;177     */
;;;178    static void rtc1_stop(void)
000000  b510              PUSH     {r4,lr}
;;;179    {
;;;180        NVIC_DisableIRQ(RTC1_IRQn);
000002  2011              MOVS     r0,#0x11
000004  2101              MOVS     r1,#1
000006  4081              LSLS     r1,r1,r0
000008  4a0e              LDR      r2,|L24.68|
00000a  6011              STR      r1,[r2,#0]
00000c  bf00              NOP      
;;;181    
;;;182        NRF_RTC1->EVTENCLR = RTC_EVTEN_COMPARE0_Msk;
00000e  2001              MOVS     r0,#1
000010  0400              LSLS     r0,r0,#16
000012  490d              LDR      r1,|L24.72|
000014  6088              STR      r0,[r1,#8]
;;;183        NRF_RTC1->INTENCLR = RTC_INTENSET_COMPARE0_Msk;
000016  490c              LDR      r1,|L24.72|
000018  3940              SUBS     r1,r1,#0x40
00001a  6088              STR      r0,[r1,#8]
;;;184    
;;;185        NRF_RTC1->TASKS_STOP = 1;
00001c  2001              MOVS     r0,#1
00001e  490b              LDR      r1,|L24.76|
000020  6048              STR      r0,[r1,#4]
;;;186        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000022  202f              MOVS     r0,#0x2f
000024  f7fffffe          BL       nrf_delay_us
;;;187    
;;;188        NRF_RTC1->TASKS_CLEAR = 1;
000028  2001              MOVS     r0,#1
00002a  4908              LDR      r1,|L24.76|
00002c  6088              STR      r0,[r1,#8]
;;;189        m_ticks_latest        = 0;
00002e  2000              MOVS     r0,#0
000030  4907              LDR      r1,|L24.80|
000032  6008              STR      r0,[r1,#0]  ; m_ticks_latest
;;;190        nrf_delay_us(MAX_RTC_TASKS_DELAY);
000034  202f              MOVS     r0,#0x2f
000036  f7fffffe          BL       nrf_delay_us
;;;191    
;;;192        m_rtc1_running = false;
00003a  2000              MOVS     r0,#0
00003c  4905              LDR      r1,|L24.84|
00003e  7008              STRB     r0,[r1,#0]
;;;193    }
000040  bd10              POP      {r4,pc}
;;;194    
                          ENDP

000042  0000              DCW      0x0000
                  |L24.68|
                          DCD      0xe000e180
                  |L24.72|
                          DCD      0x40011340
                  |L24.76|
                          DCD      0x40011000
                  |L24.80|
                          DCD      m_ticks_latest
                  |L24.84|
                          DCD      m_rtc1_running

                          AREA ||i.ticks_diff_get||, CODE, READONLY, ALIGN=1

                  ticks_diff_get PROC
;;;209     */
;;;210    static __INLINE uint32_t ticks_diff_get(uint32_t ticks_now, uint32_t ticks_old)
000000  4602              MOV      r2,r0
;;;211    {
;;;212        return ((ticks_now - ticks_old) & MAX_RTC_COUNTER_VAL);
000002  1a50              SUBS     r0,r2,r1
000004  0200              LSLS     r0,r0,#8
000006  0a00              LSRS     r0,r0,#8
;;;213    }
000008  4770              BX       lr
;;;214    
                          ENDP


                          AREA ||i.timeout_handler_exec||, CODE, READONLY, ALIGN=2

                  timeout_handler_exec PROC
;;;355     */
;;;356    static void timeout_handler_exec(timer_node_t * p_timer)
000000  b570              PUSH     {r4-r6,lr}
;;;357    {
000002  4604              MOV      r4,r0
;;;358        if (m_evt_schedule_func != NULL)
000004  480c              LDR      r0,|L26.56|
000006  6800              LDR      r0,[r0,#0]  ; m_evt_schedule_func
000008  2800              CMP      r0,#0
00000a  d010              BEQ      |L26.46|
;;;359        {
;;;360            uint32_t err_code = m_evt_schedule_func(p_timer->p_timeout_handler, p_timer->p_context);
00000c  4a0a              LDR      r2,|L26.56|
00000e  69a1              LDR      r1,[r4,#0x18]
000010  6960              LDR      r0,[r4,#0x14]
000012  6812              LDR      r2,[r2,#0]  ; m_evt_schedule_func
000014  4790              BLX      r2
000016  4605              MOV      r5,r0
;;;361            APP_ERROR_CHECK(err_code);
000018  bf00              NOP      
00001a  462e              MOV      r6,r5
00001c  2e00              CMP      r6,#0
00001e  d004              BEQ      |L26.42|
000020  bf00              NOP      
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       app_error_handler_bare
000028  bf00              NOP      
                  |L26.42|
00002a  bf00              NOP      
;;;362        }
00002c  e002              B        |L26.52|
                  |L26.46|
;;;363        else
;;;364        {
;;;365            p_timer->p_timeout_handler(p_timer->p_context);
00002e  6961              LDR      r1,[r4,#0x14]
000030  69a0              LDR      r0,[r4,#0x18]
000032  4788              BLX      r1
                  |L26.52|
;;;366        }
;;;367    }
000034  bd70              POP      {r4-r6,pc}
;;;368    
                          ENDP

000036  0000              DCW      0x0000
                  |L26.56|
                          DCD      m_evt_schedule_func

                          AREA ||i.timer_list_handler||, CODE, READONLY, ALIGN=2

                  timer_list_handler PROC
;;;717     */
;;;718    static void timer_list_handler(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;719    {
;;;720        timer_node_t * p_restart_list_head = NULL;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
;;;721    
;;;722        uint32_t       ticks_elapsed;
;;;723        uint32_t       ticks_previous;
;;;724        bool           ticks_have_elapsed;
;;;725        bool           compare_update;
;;;726        timer_node_t * p_timer_id_head_old;
;;;727    
;;;728    #if APP_TIMER_WITH_PROFILER
;;;729        {
;;;730            uint8_t size = m_op_queue.size;
;;;731            uint8_t first = m_op_queue.first;
;;;732            uint8_t last = m_op_queue.last;
;;;733            uint8_t utilization = (first <= last) ? (last - first) : (size + 1 - first + last);
;;;734    
;;;735            if (utilization > m_max_user_op_queue_utilization)
;;;736            {
;;;737                m_max_user_op_queue_utilization = utilization;
;;;738            }
;;;739        }
;;;740    #endif
;;;741    
;;;742        // Back up the previous known tick and previous list head
;;;743        ticks_previous    = m_ticks_latest;
000006  4811              LDR      r0,|L27.76|
000008  6804              LDR      r4,[r0,#0]  ; m_ticks_latest
;;;744        p_timer_id_head_old = mp_timer_id_head;
00000a  4811              LDR      r0,|L27.80|
00000c  6807              LDR      r7,[r0,#0]  ; mp_timer_id_head
;;;745    
;;;746        // Get number of elapsed ticks
;;;747        ticks_have_elapsed = elapsed_ticks_acquire(&ticks_elapsed);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       elapsed_ticks_acquire
000014  4605              MOV      r5,r0
;;;748    
;;;749        // Handle list deletions
;;;750        compare_update = list_deletions_handler();
000016  f7fffffe          BL       list_deletions_handler
00001a  4606              MOV      r6,r0
;;;751    
;;;752        // Handle expired timers
;;;753        if (ticks_have_elapsed)
00001c  2d00              CMP      r5,#0
00001e  d005              BEQ      |L27.44|
;;;754        {
;;;755            expired_timers_handler(ticks_elapsed, ticks_previous, &p_restart_list_head);
000020  aa01              ADD      r2,sp,#4
000022  4621              MOV      r1,r4
000024  9800              LDR      r0,[sp,#0]
000026  f7fffffe          BL       expired_timers_handler
;;;756            compare_update = true;
00002a  2601              MOVS     r6,#1
                  |L27.44|
;;;757        }
;;;758    
;;;759        // Handle list insertions
;;;760        if (list_insertions_handler(p_restart_list_head))
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       list_insertions_handler
000032  2800              CMP      r0,#0
000034  d000              BEQ      |L27.56|
;;;761        {
;;;762            compare_update = true;
000036  2601              MOVS     r6,#1
                  |L27.56|
;;;763        }
;;;764    
;;;765        // Update compare register if necessary
;;;766        if (compare_update)
000038  2e00              CMP      r6,#0
00003a  d002              BEQ      |L27.66|
;;;767        {
;;;768            compare_reg_update(p_timer_id_head_old);
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       compare_reg_update
                  |L27.66|
;;;769        }
;;;770        m_rtc1_reset = false;
000042  2000              MOVS     r0,#0
000044  4903              LDR      r1,|L27.84|
000046  7008              STRB     r0,[r1,#0]
;;;771    }
000048  bdfe              POP      {r1-r7,pc}
;;;772    
                          ENDP

00004a  0000              DCW      0x0000
                  |L27.76|
                          DCD      m_ticks_latest
                  |L27.80|
                          DCD      mp_timer_id_head
                  |L27.84|
                          DCD      m_rtc1_reset

                          AREA ||i.timer_list_handler_sched||, CODE, READONLY, ALIGN=1

                  timer_list_handler_sched PROC
;;;344     */
;;;345    static void timer_list_handler_sched(void)
000000  b510              PUSH     {r4,lr}
;;;346    {
;;;347        NVIC_SetPendingIRQ(SWI_IRQn);
000002  2014              MOVS     r0,#0x14
000004  f7fffffe          BL       NVIC_SetPendingIRQ
;;;348    }
000008  bd10              POP      {r4,pc}
;;;349    
                          ENDP


                          AREA ||i.timer_list_insert||, CODE, READONLY, ALIGN=2

                  timer_list_insert PROC
;;;230     */
;;;231    static void timer_list_insert(timer_node_t * p_timer)
000000  b510              PUSH     {r4,lr}
;;;232    {
;;;233        if (mp_timer_id_head == NULL)
000002  4919              LDR      r1,|L29.104|
000004  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
000006  2900              CMP      r1,#0
000008  d102              BNE      |L29.16|
;;;234        {
;;;235            mp_timer_id_head = p_timer;
00000a  4917              LDR      r1,|L29.104|
00000c  6008              STR      r0,[r1,#0]  ; mp_timer_id_head
00000e  e02a              B        |L29.102|
                  |L29.16|
;;;236        }
;;;237        else
;;;238        {
;;;239            if (p_timer->ticks_to_expire <= mp_timer_id_head->ticks_to_expire)
000010  4a15              LDR      r2,|L29.104|
000012  6801              LDR      r1,[r0,#0]
000014  6812              LDR      r2,[r2,#0]  ; mp_timer_id_head
000016  6812              LDR      r2,[r2,#0]
000018  4291              CMP      r1,r2
00001a  d80d              BHI      |L29.56|
;;;240            {
;;;241                mp_timer_id_head->ticks_to_expire -= p_timer->ticks_to_expire;
00001c  4912              LDR      r1,|L29.104|
00001e  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
000020  6809              LDR      r1,[r1,#0]
000022  6802              LDR      r2,[r0,#0]
000024  1a89              SUBS     r1,r1,r2
000026  4a10              LDR      r2,|L29.104|
000028  6812              LDR      r2,[r2,#0]  ; mp_timer_id_head
00002a  6011              STR      r1,[r2,#0]
;;;242    
;;;243                p_timer->next   = mp_timer_id_head;
00002c  490e              LDR      r1,|L29.104|
00002e  6809              LDR      r1,[r1,#0]  ; mp_timer_id_head
000030  61c1              STR      r1,[r0,#0x1c]
;;;244                mp_timer_id_head = p_timer;
000032  490d              LDR      r1,|L29.104|
000034  6008              STR      r0,[r1,#0]  ; mp_timer_id_head
000036  e016              B        |L29.102|
                  |L29.56|
;;;245            }
;;;246            else
;;;247            {
;;;248                timer_node_t * p_previous;
;;;249                timer_node_t * p_current;
;;;250                uint32_t       ticks_to_expire;
;;;251    
;;;252                ticks_to_expire   = p_timer->ticks_to_expire;
000038  6802              LDR      r2,[r0,#0]
;;;253                p_previous        = mp_timer_id_head;
00003a  4c0b              LDR      r4,|L29.104|
00003c  6823              LDR      r3,[r4,#0]  ; mp_timer_id_head
;;;254                p_current         = mp_timer_id_head;
00003e  6821              LDR      r1,[r4,#0]  ; mp_timer_id_head
;;;255    
;;;256                while ((p_current != NULL) && (ticks_to_expire > p_current->ticks_to_expire))
000040  e003              B        |L29.74|
                  |L29.66|
;;;257                {
;;;258                    ticks_to_expire   -= p_current->ticks_to_expire;
000042  680c              LDR      r4,[r1,#0]
000044  1b12              SUBS     r2,r2,r4
;;;259                    p_previous         = p_current;
000046  460b              MOV      r3,r1
;;;260                    p_current          = p_current->next;
000048  69c9              LDR      r1,[r1,#0x1c]
                  |L29.74|
00004a  2900              CMP      r1,#0                 ;256
00004c  d002              BEQ      |L29.84|
00004e  680c              LDR      r4,[r1,#0]            ;256
000050  4294              CMP      r4,r2                 ;256
000052  d3f6              BCC      |L29.66|
                  |L29.84|
;;;261                }
;;;262    
;;;263                if (p_current != NULL)
000054  2900              CMP      r1,#0
000056  d002              BEQ      |L29.94|
;;;264                {
;;;265                    p_current->ticks_to_expire -= ticks_to_expire;
000058  680c              LDR      r4,[r1,#0]
00005a  1aa4              SUBS     r4,r4,r2
00005c  600c              STR      r4,[r1,#0]
                  |L29.94|
;;;266                }
;;;267    
;;;268                p_timer->ticks_to_expire = ticks_to_expire;
00005e  6002              STR      r2,[r0,#0]
;;;269                p_timer->next            = p_current;
000060  61c1              STR      r1,[r0,#0x1c]
;;;270                p_previous->next         = p_timer;
000062  61d8              STR      r0,[r3,#0x1c]
;;;271            }
000064  bf00              NOP      
                  |L29.102|
;;;272        }
;;;273    }
000066  bd10              POP      {r4,pc}
;;;274    
                          ENDP

                  |L29.104|
                          DCD      mp_timer_id_head

                          AREA ||i.timer_list_remove||, CODE, READONLY, ALIGN=2

                  timer_list_remove PROC
;;;279     */
;;;280    static void timer_list_remove(timer_node_t * p_timer)
000000  b530              PUSH     {r4,r5,lr}
;;;281    {
000002  4602              MOV      r2,r0
;;;282        timer_node_t * p_previous;
;;;283        timer_node_t * p_current;
;;;284        uint32_t       timeout;
;;;285    
;;;286        // Find the timer's position in timer list.
;;;287        p_previous = mp_timer_id_head;
000004  4c16              LDR      r4,|L30.96|
000006  6821              LDR      r1,[r4,#0]  ; mp_timer_id_head
;;;288        p_current  = p_previous;
000008  4608              MOV      r0,r1
;;;289    
;;;290        while (p_current != NULL)
00000a  e004              B        |L30.22|
                  |L30.12|
;;;291        {
;;;292            if (p_current == p_timer)
00000c  4290              CMP      r0,r2
00000e  d100              BNE      |L30.18|
;;;293            {
;;;294                break;
000010  e003              B        |L30.26|
                  |L30.18|
;;;295            }
;;;296            p_previous = p_current;
000012  4601              MOV      r1,r0
;;;297            p_current  = p_current->next;
000014  69c0              LDR      r0,[r0,#0x1c]
                  |L30.22|
000016  2800              CMP      r0,#0                 ;290
000018  d1f8              BNE      |L30.12|
                  |L30.26|
00001a  bf00              NOP                            ;294
;;;298        }
;;;299    
;;;300        // Timer not in active list.
;;;301        if (p_current == NULL)
00001c  2800              CMP      r0,#0
00001e  d100              BNE      |L30.34|
                  |L30.32|
;;;302        {
;;;303            return;
;;;304        }
;;;305    
;;;306        // Timer is the first in the list
;;;307        if (p_previous == p_current)
;;;308        {
;;;309            mp_timer_id_head = mp_timer_id_head->next;
;;;310    
;;;311            // No more timers in the list. Reset RTC1 in case Start timer operations are present in the queue.
;;;312            if (mp_timer_id_head == NULL)
;;;313            {
;;;314                NRF_RTC1->TASKS_CLEAR = 1;
;;;315                m_ticks_latest        = 0;
;;;316                m_rtc1_reset          = true;
;;;317            }
;;;318        }
;;;319    
;;;320        // Remaining timeout between next timeout.
;;;321        timeout = p_current->ticks_to_expire;
;;;322    
;;;323        // Link previous timer with next of this timer, i.e. removing the timer from list.
;;;324        p_previous->next = p_current->next;
;;;325    
;;;326        // If this is not the last timer, increment the next timer by this timer timeout.
;;;327        p_current = p_previous->next;
;;;328        if (p_current != NULL)
;;;329        {
;;;330            p_current->ticks_to_expire += timeout;
;;;331        }
;;;332    }
000020  bd30              POP      {r4,r5,pc}
                  |L30.34|
000022  4281              CMP      r1,r0                 ;307
000024  d111              BNE      |L30.74|
000026  4c0e              LDR      r4,|L30.96|
000028  6824              LDR      r4,[r4,#0]            ;309  ; mp_timer_id_head
00002a  69e4              LDR      r4,[r4,#0x1c]         ;309
00002c  4d0c              LDR      r5,|L30.96|
00002e  602c              STR      r4,[r5,#0]            ;309  ; mp_timer_id_head
000030  462c              MOV      r4,r5                 ;312
000032  6824              LDR      r4,[r4,#0]            ;312  ; mp_timer_id_head
000034  2c00              CMP      r4,#0                 ;312
000036  d108              BNE      |L30.74|
000038  2401              MOVS     r4,#1                 ;314
00003a  4d0a              LDR      r5,|L30.100|
00003c  60ac              STR      r4,[r5,#8]            ;314
00003e  2400              MOVS     r4,#0                 ;315
000040  4d09              LDR      r5,|L30.104|
000042  602c              STR      r4,[r5,#0]            ;315  ; m_ticks_latest
000044  2401              MOVS     r4,#1                 ;316
000046  4d09              LDR      r5,|L30.108|
000048  702c              STRB     r4,[r5,#0]            ;316
                  |L30.74|
00004a  6803              LDR      r3,[r0,#0]            ;321
00004c  69c4              LDR      r4,[r0,#0x1c]         ;324
00004e  61cc              STR      r4,[r1,#0x1c]         ;324
000050  69c8              LDR      r0,[r1,#0x1c]         ;327
000052  2800              CMP      r0,#0                 ;328
000054  d002              BEQ      |L30.92|
000056  6804              LDR      r4,[r0,#0]            ;330
000058  18e4              ADDS     r4,r4,r3              ;330
00005a  6004              STR      r4,[r0,#0]            ;330
                  |L30.92|
00005c  bf00              NOP      
00005e  e7df              B        |L30.32|
;;;333    
                          ENDP

                  |L30.96|
                          DCD      mp_timer_id_head
                  |L30.100|
                          DCD      0x40011000
                  |L30.104|
                          DCD      m_ticks_latest
                  |L30.108|
                          DCD      m_rtc1_reset

                          AREA ||i.timer_start_op_schedule||, CODE, READONLY, ALIGN=1

                  timer_start_op_schedule PROC
;;;823    
;;;824    static uint32_t timer_start_op_schedule(timer_node_t * p_node,
000000  b5ff              PUSH     {r0-r7,lr}
;;;825                                            uint32_t        timeout_initial,
;;;826                                            uint32_t        timeout_periodic,
;;;827                                            void *          p_context)
;;;828    {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;829        uint8_t last_index;
;;;830        uint32_t err_code = NRF_SUCCESS;
00000a  2000              MOVS     r0,#0
00000c  9001              STR      r0,[sp,#4]
;;;831    
;;;832        CRITICAL_REGION_ENTER();
00000e  9000              STR      r0,[sp,#0]
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       app_util_critical_region_enter
;;;833        timer_user_op_t * p_user_op = user_op_alloc(&last_index);
000016  a802              ADD      r0,sp,#8
000018  f7fffffe          BL       user_op_alloc
00001c  4604              MOV      r4,r0
;;;834        if (p_user_op == NULL)
00001e  2c00              CMP      r4,#0
000020  d102              BNE      |L31.40|
;;;835        {
;;;836            err_code = NRF_ERROR_NO_MEM;
000022  2004              MOVS     r0,#4
000024  9001              STR      r0,[sp,#4]
000026  e00d              B        |L31.68|
                  |L31.40|
;;;837        }
;;;838        else
;;;839        {
;;;840    
;;;841            p_user_op->op_type                              = TIMER_USER_OP_TYPE_START;
000028  2001              MOVS     r0,#1
00002a  7020              STRB     r0,[r4,#0]
;;;842            p_user_op->p_node                               = p_node;
00002c  6065              STR      r5,[r4,#4]
;;;843            p_user_op->params.start.ticks_at_start          = rtc1_counter_get();
00002e  f7fffffe          BL       rtc1_counter_get
000032  60a0              STR      r0,[r4,#8]
;;;844            p_user_op->params.start.ticks_first_interval    = timeout_initial;
000034  60e6              STR      r6,[r4,#0xc]
;;;845            p_user_op->params.start.ticks_periodic_interval = timeout_periodic;
000036  6127              STR      r7,[r4,#0x10]
;;;846            p_user_op->params.start.p_context               = p_context;
000038  9806              LDR      r0,[sp,#0x18]
00003a  6160              STR      r0,[r4,#0x14]
;;;847    
;;;848            user_op_enque(last_index);
00003c  4668              MOV      r0,sp
00003e  7a00              LDRB     r0,[r0,#8]
000040  f7fffffe          BL       user_op_enque
                  |L31.68|
;;;849        }
;;;850        CRITICAL_REGION_EXIT();
000044  4668              MOV      r0,sp
000046  7800              LDRB     r0,[r0,#0]
000048  f7fffffe          BL       app_util_critical_region_exit
;;;851    
;;;852        if (err_code == NRF_SUCCESS)
00004c  9801              LDR      r0,[sp,#4]
00004e  2800              CMP      r0,#0
000050  d101              BNE      |L31.86|
;;;853        {
;;;854            timer_list_handler_sched();
000052  f7fffffe          BL       timer_list_handler_sched
                  |L31.86|
;;;855        }
;;;856    
;;;857        return err_code;
000056  9801              LDR      r0,[sp,#4]
;;;858    }
000058  b007              ADD      sp,sp,#0x1c
00005a  bdf0              POP      {r4-r7,pc}
;;;859    
                          ENDP


                          AREA ||i.timer_stop_op_schedule||, CODE, READONLY, ALIGN=1

                  timer_stop_op_schedule PROC
;;;868     */
;;;869    static uint32_t timer_stop_op_schedule(timer_node_t * p_node,
000000  b5fe              PUSH     {r1-r7,lr}
;;;870                                           timer_user_op_type_t op_type)
;;;871    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;872        uint8_t last_index;
;;;873        uint32_t err_code = NRF_SUCCESS;
000006  2700              MOVS     r7,#0
;;;874    
;;;875        CRITICAL_REGION_ENTER();
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       app_util_critical_region_enter
;;;876        timer_user_op_t * p_user_op = user_op_alloc(&last_index);
000012  a801              ADD      r0,sp,#4
000014  f7fffffe          BL       user_op_alloc
000018  4604              MOV      r4,r0
;;;877        if (p_user_op == NULL)
00001a  2c00              CMP      r4,#0
00001c  d101              BNE      |L32.34|
;;;878        {
;;;879            err_code = NRF_ERROR_NO_MEM;
00001e  2704              MOVS     r7,#4
000020  e005              B        |L32.46|
                  |L32.34|
;;;880        }
;;;881        else
;;;882        {
;;;883            p_user_op->op_type  = op_type;
000022  7026              STRB     r6,[r4,#0]
;;;884            p_user_op->p_node = p_node;
000024  6065              STR      r5,[r4,#4]
;;;885    
;;;886            user_op_enque(last_index);
000026  4668              MOV      r0,sp
000028  7900              LDRB     r0,[r0,#4]
00002a  f7fffffe          BL       user_op_enque
                  |L32.46|
;;;887        }
;;;888        CRITICAL_REGION_EXIT();
00002e  4668              MOV      r0,sp
000030  7800              LDRB     r0,[r0,#0]
000032  f7fffffe          BL       app_util_critical_region_exit
;;;889    
;;;890        if (err_code == NRF_SUCCESS)
000036  2f00              CMP      r7,#0
000038  d101              BNE      |L32.62|
;;;891        {
;;;892            timer_list_handler_sched();
00003a  f7fffffe          BL       timer_list_handler_sched
                  |L32.62|
;;;893        }
;;;894    
;;;895        return err_code;
00003e  4638              MOV      r0,r7
;;;896    }
000040  bdfe              POP      {r1-r7,pc}
;;;897    
                          ENDP


                          AREA ||i.timer_timeouts_check||, CODE, READONLY, ALIGN=2

                  timer_timeouts_check PROC
;;;371     */
;;;372    static void timer_timeouts_check(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;373    {
;;;374        // Handle expired of timer
;;;375        if (mp_timer_id_head != NULL)
000002  481f              LDR      r0,|L33.128|
000004  6800              LDR      r0,[r0,#0]  ; mp_timer_id_head
000006  2800              CMP      r0,#0
000008  d039              BEQ      |L33.126|
;;;376        {
;;;377            timer_node_t *  p_timer;
;;;378            timer_node_t *  p_previous_timer;
;;;379            uint32_t        ticks_elapsed;
;;;380            uint32_t        ticks_expired;
;;;381    
;;;382            // Initialize actual elapsed ticks being consumed to 0.
;;;383            ticks_expired = 0;
00000a  2700              MOVS     r7,#0
;;;384    
;;;385            // ticks_elapsed is collected here, job will use it.
;;;386            ticks_elapsed = ticks_diff_get(rtc1_counter_get(), m_ticks_latest);
00000c  f7fffffe          BL       rtc1_counter_get
000010  9000              STR      r0,[sp,#0]
000012  481c              LDR      r0,|L33.132|
000014  6801              LDR      r1,[r0,#0]  ; m_ticks_latest
000016  9800              LDR      r0,[sp,#0]
000018  f7fffffe          BL       ticks_diff_get
00001c  4606              MOV      r6,r0
;;;387    
;;;388            // Auto variable containing the head of timers expiring.
;;;389            p_timer = mp_timer_id_head;
00001e  4818              LDR      r0,|L33.128|
000020  6805              LDR      r5,[r0,#0]  ; mp_timer_id_head
;;;390    
;;;391            // Expire all timers within ticks_elapsed and collect ticks_expired.
;;;392            while (p_timer != NULL)
000022  e011              B        |L33.72|
                  |L33.36|
;;;393            {
;;;394                // Do nothing if timer did not expire.
;;;395                if (ticks_elapsed < p_timer->ticks_to_expire)
000024  6828              LDR      r0,[r5,#0]
000026  42b0              CMP      r0,r6
000028  d900              BLS      |L33.44|
;;;396                {
;;;397                    break;
00002a  e00f              B        |L33.76|
                  |L33.44|
;;;398                }
;;;399    
;;;400                // Decrement ticks_elapsed and collect expired ticks.
;;;401                ticks_elapsed -= p_timer->ticks_to_expire;
00002c  6828              LDR      r0,[r5,#0]
00002e  1a36              SUBS     r6,r6,r0
;;;402                ticks_expired += p_timer->ticks_to_expire;
000030  6828              LDR      r0,[r5,#0]
000032  19c7              ADDS     r7,r0,r7
;;;403    
;;;404                // Move to next timer.
;;;405                p_previous_timer = p_timer;
000034  462c              MOV      r4,r5
;;;406                p_timer = p_timer->next;
000036  69ed              LDR      r5,[r5,#0x1c]
;;;407    
;;;408                // Execute Task.
;;;409                if (p_previous_timer->is_running)
000038  7c20              LDRB     r0,[r4,#0x10]
00003a  2800              CMP      r0,#0
00003c  d004              BEQ      |L33.72|
;;;410                {
;;;411                    p_previous_timer->is_running = false;
00003e  2000              MOVS     r0,#0
000040  7420              STRB     r0,[r4,#0x10]
;;;412                    timeout_handler_exec(p_previous_timer);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       timeout_handler_exec
                  |L33.72|
000048  2d00              CMP      r5,#0                 ;392
00004a  d1eb              BNE      |L33.36|
                  |L33.76|
00004c  bf00              NOP                            ;397
;;;413                }
;;;414            }
;;;415    
;;;416            // Prepare to queue the ticks expired in the m_ticks_elapsed queue.
;;;417            if (m_ticks_elapsed_q_read_ind == m_ticks_elapsed_q_write_ind)
00004e  480e              LDR      r0,|L33.136|
000050  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_read_ind
000052  490e              LDR      r1,|L33.140|
000054  7809              LDRB     r1,[r1,#0]  ; m_ticks_elapsed_q_write_ind
000056  4288              CMP      r0,r1
000058  d109              BNE      |L33.110|
;;;418            {
;;;419                // The read index of the queue is equal to the write index. This means the new
;;;420                // value of ticks_expired should be stored at a new location in the m_ticks_elapsed
;;;421                // queue (which is implemented as a double buffer).
;;;422    
;;;423                // Check if there will be a queue overflow.
;;;424                if (++m_ticks_elapsed_q_write_ind == CONTEXT_QUEUE_SIZE_MAX)
00005a  480c              LDR      r0,|L33.140|
00005c  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_write_ind
00005e  1c40              ADDS     r0,r0,#1
000060  b2c0              UXTB     r0,r0
000062  490a              LDR      r1,|L33.140|
000064  7008              STRB     r0,[r1,#0]
000066  2802              CMP      r0,#2
000068  d101              BNE      |L33.110|
;;;425                {
;;;426                    // There will be a queue overflow. Hence the write index should point to the start
;;;427                    // of the queue.
;;;428                    m_ticks_elapsed_q_write_ind = 0;
00006a  2000              MOVS     r0,#0
00006c  7008              STRB     r0,[r1,#0]
                  |L33.110|
;;;429                }
;;;430            }
;;;431    
;;;432            // Queue the ticks expired.
;;;433            m_ticks_elapsed[m_ticks_elapsed_q_write_ind] = ticks_expired;
00006e  4807              LDR      r0,|L33.140|
000070  7800              LDRB     r0,[r0,#0]  ; m_ticks_elapsed_q_write_ind
000072  0080              LSLS     r0,r0,#2
000074  4906              LDR      r1,|L33.144|
000076  500f              STR      r7,[r1,r0]
;;;434    
;;;435            timer_list_handler_sched();
000078  f7fffffe          BL       timer_list_handler_sched
;;;436        }
00007c  bf00              NOP      
                  |L33.126|
;;;437    }
00007e  bdf8              POP      {r3-r7,pc}
;;;438    
                          ENDP

                  |L33.128|
                          DCD      mp_timer_id_head
                  |L33.132|
                          DCD      m_ticks_latest
                  |L33.136|
                          DCD      m_ticks_elapsed_q_read_ind
                  |L33.140|
                          DCD      m_ticks_elapsed_q_write_ind
                  |L33.144|
                          DCD      m_ticks_elapsed

                          AREA ||i.timer_timeouts_check_sched||, CODE, READONLY, ALIGN=1

                  timer_timeouts_check_sched PROC
;;;336     */
;;;337    static void timer_timeouts_check_sched(void)
000000  b510              PUSH     {r4,lr}
;;;338    {
;;;339        NVIC_SetPendingIRQ(RTC1_IRQn);
000002  2011              MOVS     r0,#0x11
000004  f7fffffe          BL       NVIC_SetPendingIRQ
;;;340    }
000008  bd10              POP      {r4,pc}
;;;341    
                          ENDP


                          AREA ||i.user_op_alloc||, CODE, READONLY, ALIGN=2

                  user_op_alloc PROC
;;;789     */
;;;790    static timer_user_op_t * user_op_alloc( uint8_t * p_last_index)
000000  b530              PUSH     {r4,r5,lr}
;;;791    {
000002  4602              MOV      r2,r0
;;;792        uint8_t           last;
;;;793        timer_user_op_t * p_user_op;
;;;794    
;;;795        last = m_op_queue.last + 1;
000004  480b              LDR      r0,|L35.52|
000006  7840              LDRB     r0,[r0,#1]  ; m_op_queue
000008  1c40              ADDS     r0,r0,#1
00000a  b2c1              UXTB     r1,r0
;;;796        if (last == m_op_queue.size)
00000c  4809              LDR      r0,|L35.52|
00000e  7880              LDRB     r0,[r0,#2]  ; m_op_queue
000010  4288              CMP      r0,r1
000012  d100              BNE      |L35.22|
;;;797        {
;;;798            // Overflow case.
;;;799            last = 0;
000014  2100              MOVS     r1,#0
                  |L35.22|
;;;800        }
;;;801        if (last == m_op_queue.first)
000016  4807              LDR      r0,|L35.52|
000018  7800              LDRB     r0,[r0,#0]  ; m_op_queue
00001a  4288              CMP      r0,r1
00001c  d101              BNE      |L35.34|
;;;802        {
;;;803            // Queue is full.
;;;804            return NULL;
00001e  2000              MOVS     r0,#0
                  |L35.32|
;;;805        }
;;;806    
;;;807        *p_last_index = last;
;;;808        p_user_op     = &m_op_queue.p_user_op_queue[m_op_queue.last];
;;;809    
;;;810        return p_user_op;
;;;811    }
000020  bd30              POP      {r4,r5,pc}
                  |L35.34|
000022  7011              STRB     r1,[r2,#0]            ;807
000024  4803              LDR      r0,|L35.52|
000026  6844              LDR      r4,[r0,#4]            ;808  ; m_op_queue
000028  7840              LDRB     r0,[r0,#1]            ;808  ; m_op_queue
00002a  2518              MOVS     r5,#0x18              ;808
00002c  4368              MULS     r0,r5,r0              ;808
00002e  1823              ADDS     r3,r4,r0              ;808
000030  4618              MOV      r0,r3                 ;810
000032  e7f5              B        |L35.32|
;;;812    
                          ENDP

                  |L35.52|
                          DCD      m_op_queue

                          AREA ||i.user_op_enque||, CODE, READONLY, ALIGN=2

                  user_op_enque PROC
;;;777     */
;;;778    static void user_op_enque(uint8_t last_index)
000000  4901              LDR      r1,|L36.8|
;;;779    {
;;;780        m_op_queue.last = last_index;
000002  7048              STRB     r0,[r1,#1]
;;;781    }
000004  4770              BX       lr
;;;782    
                          ENDP

000006  0000              DCW      0x0000
                  |L36.8|
                          DCD      m_op_queue

                          AREA ||.data||, DATA, ALIGN=2

                  m_op_queue
                          %        8
                  mp_timer_id_head
                          DCD      0x00000000
                  m_ticks_latest
                          DCD      0x00000000
                  m_ticks_elapsed
                          %        8
                  m_ticks_elapsed_q_read_ind
000018  00                DCB      0x00
                  m_ticks_elapsed_q_write_ind
000019  000000            DCB      0x00,0x00,0x00
                  m_evt_schedule_func
                          DCD      0x00000000
                  m_rtc1_running
000020  00                DCB      0x00
                  m_rtc1_reset
000021  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\timer\\app_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_app_timer_c_cd27f9c3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_app_timer_c_cd27f9c3____REVSH|
#line 144
|__asm___11_app_timer_c_cd27f9c3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
