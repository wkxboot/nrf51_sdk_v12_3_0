L 1 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.c"
N/**
N * Copyright (c) 2015 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N#include "sdk_mapped_flags.h"
L 1 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.h" 1
N/**
N * Copyright (c) 2015 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N#ifndef SDK_MAPPED_FLAGS_H__
N#define SDK_MAPPED_FLAGS_H__
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5050041
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX INT64_MAX
N#else
N#define UINTPTR_MAX INT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 45 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.h" 2
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 177844 $
N * Checkin $Date: 2012-11-21 11:51:12 +0000 (Wed, 21 Nov 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5050041
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 46 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.h" 2
N#include "app_util.h"
L 1 "..\..\..\..\..\..\components\libraries\util\app_util.h" 1
N/**
N * Copyright (c) 2012 - 2017, Nordic Semiconductor ASA
N * 
N * All rights reserved.
N * 
N * Redistribution and use in source and binary forms, with or without modification,
N * are permitted provided that the following conditions are met:
N * 
N * 1. Redistributions of source code must retain the above copyright notice, this
N *    list of conditions and the following disclaimer.
N * 
N * 2. Redistributions in binary form, except as embedded into a Nordic
N *    Semiconductor ASA integrated circuit in a product or a software update for
N *    such product, must reproduce the above copyright notice, this list of
N *    conditions and the following disclaimer in the documentation and/or other
N *    materials provided with the distribution.
N * 
N * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
N *    contributors may be used to endorse or promote products derived from this
N *    software without specific prior written permission.
N * 
N * 4. This software, with or without modification, must only be used with a
N *    Nordic Semiconductor ASA integrated circuit.
N * 
N * 5. Any software provided in binary form under this license must not be reverse
N *    engineered, decompiled, modified and/or disassembled.
N * 
N * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
N * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
N * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
N * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
N * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
N * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
N * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N * 
N */
N
N/** @file
N *
N * @defgroup app_util Utility Functions and Definitions
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications.
N */
N
N#ifndef APP_UTIL_H__
N#define APP_UTIL_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "compiler_abstraction.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\compiler_abstraction.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef _COMPILER_ABSTRACTION_H
N#define _COMPILER_ABSTRACTION_H
N
N/*lint ++flb "Enter library region" */
N
N#if defined ( __CC_ARM )
X#if 1L
N
N    #ifndef __ASM
N        #define __ASM               __asm
N    #endif
N
N    #ifndef __INLINE
N        #define __INLINE            __inline
N    #endif
N
N    #ifndef __WEAK
N        #define __WEAK              __weak
N    #endif
N
N    #ifndef __ALIGN
N        #define __ALIGN(n)          __align(n)
N    #endif
N
N    #ifndef __PACKED
N        #define __PACKED            __packed
N    #endif
N
N    #define GET_SP()                __current_sp()
N
N#elif defined ( __ICCARM__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __weak
S    #endif
S
S    #ifndef __ALIGN
S        #define STRING_PRAGMA(x) _Pragma(#x)
S        #define __ALIGN(n) STRING_PRAGMA(data_alignment = n)
S    #endif
S
S    #ifndef __PACKED
S        #define __PACKED            __packed
S    #endif
S    
S    #define GET_SP()                __get_SP()
S
S#elif defined   ( __GNUC__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __attribute__((weak))
S    #endif
S
S    #ifndef __ALIGN
S        #define __ALIGN(n)          __attribute__((aligned(n)))
S    #endif
S
S    #ifndef __PACKED
S        #define __PACKED           __attribute__((packed)) 
S    #endif
S
S    #define GET_SP()                gcc_current_sp()
S
S    static inline unsigned int gcc_current_sp(void)
S    {
S        register unsigned sp __ASM("sp");
S        return sp;
S    }
S
S#elif defined   ( __TASKING__ )
S
S    #ifndef __ASM
S        #define __ASM               __asm
S    #endif
S
S    #ifndef __INLINE
S        #define __INLINE            inline
S    #endif
S
S    #ifndef __WEAK
S        #define __WEAK              __attribute__((weak))
S    #endif
S
S    #ifndef __ALIGN
S        #define __ALIGN(n)          __align(n)
S    #endif
S    
S    /* Not defined for TASKING. */
S    #ifndef __PACKED
S        #define __PACKED
S    #endif
S
S    #define GET_SP()                __get_MSP()
S
N#endif
N
N/*lint --flb "Leave library region" */
N
N#endif
L 56 "..\..\..\..\..\..\components\libraries\util\app_util.h" 2
N#include "nrf.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef NRF_H
N#define NRF_H
N
N/* MDK version */
N#define MDK_MAJOR_VERSION   8
N#define MDK_MINOR_VERSION   11
N#define MDK_MICRO_VERSION   1
N
N/* Redefine "old" too-generic name NRF52 to NRF52832_XXAA to keep backwards compatibility. */
N#if defined (NRF52)
X#if 0L
S    #ifndef NRF52832_XXAA
S        #define NRF52832_XXAA
S    #endif
N#endif
N
N/* Define NRF52_SERIES for common use in nRF52 series devices. */
N#if defined (NRF52832_XXAA) || defined (NRF52840_XXAA)
X#if 0L || 0L
S    #define NRF52_SERIES
N#endif
N
N
N#if defined(_WIN32)
X#if 0L
S    /* Do not include nrf specific files when building for PC host */
S#elif defined(__unix)
X#elif 0L
S    /* Do not include nrf specific files when building for PC host */
S#elif defined(__APPLE__)
X#elif 0L
S    /* Do not include nrf specific files when building for PC host */
N#else
N
N    /* Device selection for device includes. */
N    #if defined (NRF51)
X    #if 1L
N        #include "nrf51.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51.h" 1
N
N/****************************************************************************************************//**
N * @file     nrf51.h
N *
N * @brief    CMSIS Cortex-M0 Peripheral Access Layer Header File for
N *           nrf51 from Nordic Semiconductor.
N *
N * @version  V522
N * @date     18. November 2016
N *
N * @note     Generated with SVDConv V2.81d 
N *           from CMSIS SVD File 'nrf51.svd' Version 522,
N *
N * @par      Copyright (c) 2016, Nordic Semiconductor ASA
N *           All rights reserved.
N *           
N *           Redistribution and use in source and binary forms, with or without
N *           modification, are permitted provided that the following conditions are met:
N *           
N *           * Redistributions of source code must retain the above copyright notice, this
N *           list of conditions and the following disclaimer.
N *           
N *           * Redistributions in binary form must reproduce the above copyright notice,
N *           this list of conditions and the following disclaimer in the documentation
N *           and/or other materials provided with the distribution.
N *           
N *           * Neither the name of Nordic Semiconductor ASA nor the names of its
N *           contributors may be used to endorse or promote products derived from
N *           this software without specific prior written permission.
N *           
N *           THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N *           AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N *           IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N *           DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N *           FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N *           DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N *           SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N *           CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N *           OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N *           OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *           
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup Nordic Semiconductor
N  * @{
N  */
N
N/** @addtogroup nrf51
N  * @{
N  */
N
N#ifndef NRF51_H
N#define NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M0 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* ----------------------  nrf51 Specific Interrupt Numbers  ---------------------- */
N  POWER_CLOCK_IRQn              =   0,              /*!<   0  POWER_CLOCK                                                      */
N  RADIO_IRQn                    =   1,              /*!<   1  RADIO                                                            */
N  UART0_IRQn                    =   2,              /*!<   2  UART0                                                            */
N  SPI0_TWI0_IRQn                =   3,              /*!<   3  SPI0_TWI0                                                        */
N  SPI1_TWI1_IRQn                =   4,              /*!<   4  SPI1_TWI1                                                        */
N  GPIOTE_IRQn                   =   6,              /*!<   6  GPIOTE                                                           */
N  ADC_IRQn                      =   7,              /*!<   7  ADC                                                              */
N  TIMER0_IRQn                   =   8,              /*!<   8  TIMER0                                                           */
N  TIMER1_IRQn                   =   9,              /*!<   9  TIMER1                                                           */
N  TIMER2_IRQn                   =  10,              /*!<  10  TIMER2                                                           */
N  RTC0_IRQn                     =  11,              /*!<  11  RTC0                                                             */
N  TEMP_IRQn                     =  12,              /*!<  12  TEMP                                                             */
N  RNG_IRQn                      =  13,              /*!<  13  RNG                                                              */
N  ECB_IRQn                      =  14,              /*!<  14  ECB                                                              */
N  CCM_AAR_IRQn                  =  15,              /*!<  15  CCM_AAR                                                          */
N  WDT_IRQn                      =  16,              /*!<  16  WDT                                                              */
N  RTC1_IRQn                     =  17,              /*!<  17  RTC1                                                             */
N  QDEC_IRQn                     =  18,              /*!<  18  QDEC                                                             */
N  LPCOMP_IRQn                   =  19,              /*!<  19  LPCOMP                                                           */
N  SWI0_IRQn                     =  20,              /*!<  20  SWI0                                                             */
N  SWI1_IRQn                     =  21,              /*!<  21  SWI1                                                             */
N  SWI2_IRQn                     =  22,              /*!<  22  SWI2                                                             */
N  SWI3_IRQn                     =  23,              /*!<  23  SWI3                                                             */
N  SWI4_IRQn                     =  24,              /*!<  24  SWI4                                                             */
N  SWI5_IRQn                     =  25               /*!<  25  SWI5                                                             */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the Cortex-M0 Processor and Core Peripherals---------------- */
N#define __CM0_REV                 0x0301            /*!< Cortex-M0 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               2            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include "core_cm0.h"                               /*!< Cortex-M0 processor and core peripherals                              */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V4.00
N * @date     22. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.00
N * @date     28. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050041 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x00) >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit. The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit. The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RRX(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
S{
S   __ASM volatile ("strbt %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
S{
S   __ASM volatile ("strht %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
S{
S   __ASM volatile ("strt %1, %0" : "=Q" (*addr) : "r" (value) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 149 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.00
N * @date     28. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5050041 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x00) >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
X#if       ((0x00) == 0x04) || ((0x00) == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 150 "C:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include\core_cm0.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_CALIB_TENMS_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & 0xFF) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) & 0xFF) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 120 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51.h" 2
N#include "system_nrf51.h"                           /*!< nrf51 System                                                          */
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\system_nrf51.h" 1
N/* Copyright (c) 2012 ARM LIMITED
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of ARM nor the names of its contributors may be used to
N *     endorse or promote products derived from this software without specific
N *     prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef SYSTEM_NRF51_H
N#define SYSTEM_NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_NRF51_H */
L 121 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51.h" 2
N
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
Ntypedef struct {
N  __O  uint32_t  EN;                                /*!< Enable channel group.                                                 */
X  volatile  uint32_t  EN;                                 
N  __O  uint32_t  DIS;                               /*!< Disable channel group.                                                */
X  volatile  uint32_t  DIS;                                
N} PPI_TASKS_CHG_Type;
N
Ntypedef struct {
N  __IO uint32_t  EEP;                               /*!< Channel event end-point.                                              */
X  volatile uint32_t  EEP;                                
N  __IO uint32_t  TEP;                               /*!< Channel task end-point.                                               */
X  volatile uint32_t  TEP;                                
N} PPI_CH_Type;
N
N
N/* ================================================================================ */
N/* ================                      POWER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Power Control. (POWER)
N  */
N
Ntypedef struct {                                    /*!< POWER Structure                                                       */
N  __I  uint32_t  RESERVED0[30];
X  volatile const  uint32_t  RESERVED0[30];
N  __O  uint32_t  TASKS_CONSTLAT;                    /*!< Enable constant latency mode.                                         */
X  volatile  uint32_t  TASKS_CONSTLAT;                     
N  __O  uint32_t  TASKS_LOWPWR;                      /*!< Enable low power mode (variable latency).                             */
X  volatile  uint32_t  TASKS_LOWPWR;                       
N  __I  uint32_t  RESERVED1[34];
X  volatile const  uint32_t  RESERVED1[34];
N  __IO uint32_t  EVENTS_POFWARN;                    /*!< Power failure warning.                                                */
X  volatile uint32_t  EVENTS_POFWARN;                     
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __IO uint32_t  RESETREAS;                         /*!< Reset reason.                                                         */
X  volatile uint32_t  RESETREAS;                          
N  __I  uint32_t  RESERVED4[9];
X  volatile const  uint32_t  RESERVED4[9];
N  __I  uint32_t  RAMSTATUS;                         /*!< Ram status register.                                                  */
X  volatile const  uint32_t  RAMSTATUS;                          
N  __I  uint32_t  RESERVED5[53];
X  volatile const  uint32_t  RESERVED5[53];
N  __O  uint32_t  SYSTEMOFF;                         /*!< System off register.                                                  */
X  volatile  uint32_t  SYSTEMOFF;                          
N  __I  uint32_t  RESERVED6[3];
X  volatile const  uint32_t  RESERVED6[3];
N  __IO uint32_t  POFCON;                            /*!< Power failure configuration.                                          */
X  volatile uint32_t  POFCON;                             
N  __I  uint32_t  RESERVED7[2];
X  volatile const  uint32_t  RESERVED7[2];
N  __IO uint32_t  GPREGRET;                          /*!< General purpose retention register. This register is a retained
X  volatile uint32_t  GPREGRET;                          
N                                                         register.                                                             */
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  RAMON;                             /*!< Ram on/off.                                                           */
X  volatile uint32_t  RAMON;                              
N  __I  uint32_t  RESERVED9[7];
X  volatile const  uint32_t  RESERVED9[7];
N  __IO uint32_t  RESET;                             /*!< Pin reset functionality configuration register. This register
X  volatile uint32_t  RESET;                             
N                                                         is a retained register.                                               */
N  __I  uint32_t  RESERVED10[3];
X  volatile const  uint32_t  RESERVED10[3];
N  __IO uint32_t  RAMONB;                            /*!< Ram on/off.                                                           */
X  volatile uint32_t  RAMONB;                             
N  __I  uint32_t  RESERVED11[8];
X  volatile const  uint32_t  RESERVED11[8];
N  __IO uint32_t  DCDCEN;                            /*!< DCDC converter enable configuration register.                         */
X  volatile uint32_t  DCDCEN;                             
N  __I  uint32_t  RESERVED12[291];
X  volatile const  uint32_t  RESERVED12[291];
N  __IO uint32_t  DCDCFORCE;                         /*!< DCDC power-up force register.                                         */
X  volatile uint32_t  DCDCFORCE;                          
N} NRF_POWER_Type;
N
N
N/* ================================================================================ */
N/* ================                      CLOCK                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Clock control. (CLOCK)
N  */
N
Ntypedef struct {                                    /*!< CLOCK Structure                                                       */
N  __O  uint32_t  TASKS_HFCLKSTART;                  /*!< Start HFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_HFCLKSTART;                   
N  __O  uint32_t  TASKS_HFCLKSTOP;                   /*!< Stop HFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_HFCLKSTOP;                    
N  __O  uint32_t  TASKS_LFCLKSTART;                  /*!< Start LFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_LFCLKSTART;                   
N  __O  uint32_t  TASKS_LFCLKSTOP;                   /*!< Stop LFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_LFCLKSTOP;                    
N  __O  uint32_t  TASKS_CAL;                         /*!< Start calibration of LFCLK RC oscillator.                             */
X  volatile  uint32_t  TASKS_CAL;                          
N  __O  uint32_t  TASKS_CTSTART;                     /*!< Start calibration timer.                                              */
X  volatile  uint32_t  TASKS_CTSTART;                      
N  __O  uint32_t  TASKS_CTSTOP;                      /*!< Stop calibration timer.                                               */
X  volatile  uint32_t  TASKS_CTSTOP;                       
N  __I  uint32_t  RESERVED0[57];
X  volatile const  uint32_t  RESERVED0[57];
N  __IO uint32_t  EVENTS_HFCLKSTARTED;               /*!< HFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_HFCLKSTARTED;                
N  __IO uint32_t  EVENTS_LFCLKSTARTED;               /*!< LFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_LFCLKSTARTED;                
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __IO uint32_t  EVENTS_DONE;                       /*!< Calibration of LFCLK RC oscillator completed.                         */
X  volatile uint32_t  EVENTS_DONE;                        
N  __IO uint32_t  EVENTS_CTTO;                       /*!< Calibration timer timeout.                                            */
X  volatile uint32_t  EVENTS_CTTO;                        
N  __I  uint32_t  RESERVED2[124];
X  volatile const  uint32_t  RESERVED2[124];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __I  uint32_t  HFCLKRUN;                          /*!< Task HFCLKSTART trigger status.                                       */
X  volatile const  uint32_t  HFCLKRUN;                           
N  __I  uint32_t  HFCLKSTAT;                         /*!< High frequency clock status.                                          */
X  volatile const  uint32_t  HFCLKSTAT;                          
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __I  uint32_t  LFCLKRUN;                          /*!< Task LFCLKSTART triggered status.                                     */
X  volatile const  uint32_t  LFCLKRUN;                           
N  __I  uint32_t  LFCLKSTAT;                         /*!< Low frequency clock status.                                           */
X  volatile const  uint32_t  LFCLKSTAT;                          
N  __I  uint32_t  LFCLKSRCCOPY;                      /*!< Clock source for the LFCLK clock, set when task LKCLKSTART is
X  volatile const  uint32_t  LFCLKSRCCOPY;                      
N                                                         triggered.                                                            */
N  __I  uint32_t  RESERVED5[62];
X  volatile const  uint32_t  RESERVED5[62];
N  __IO uint32_t  LFCLKSRC;                          /*!< Clock source for the LFCLK clock.                                     */
X  volatile uint32_t  LFCLKSRC;                           
N  __I  uint32_t  RESERVED6[7];
X  volatile const  uint32_t  RESERVED6[7];
N  __IO uint32_t  CTIV;                              /*!< Calibration timer interval.                                           */
X  volatile uint32_t  CTIV;                               
N  __I  uint32_t  RESERVED7[5];
X  volatile const  uint32_t  RESERVED7[5];
N  __IO uint32_t  XTALFREQ;                          /*!< Crystal frequency.                                                    */
X  volatile uint32_t  XTALFREQ;                           
N} NRF_CLOCK_Type;
N
N
N/* ================================================================================ */
N/* ================                       MPU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Memory Protection Unit. (MPU)
N  */
N
Ntypedef struct {                                    /*!< MPU Structure                                                         */
N  __I  uint32_t  RESERVED0[330];
X  volatile const  uint32_t  RESERVED0[330];
N  __IO uint32_t  PERR0;                             /*!< Configuration of peripherals in mpu regions.                          */
X  volatile uint32_t  PERR0;                              
N  __IO uint32_t  RLENR0;                            /*!< Length of RAM region 0.                                               */
X  volatile uint32_t  RLENR0;                             
N  __I  uint32_t  RESERVED1[52];
X  volatile const  uint32_t  RESERVED1[52];
N  __IO uint32_t  PROTENSET0;                        /*!< Erase and write protection bit enable set register.                   */
X  volatile uint32_t  PROTENSET0;                         
N  __IO uint32_t  PROTENSET1;                        /*!< Erase and write protection bit enable set register.                   */
X  volatile uint32_t  PROTENSET1;                         
N  __IO uint32_t  DISABLEINDEBUG;                    /*!< Disable erase and write protection mechanism in debug mode.           */
X  volatile uint32_t  DISABLEINDEBUG;                     
N  __IO uint32_t  PROTBLOCKSIZE;                     /*!< Erase and write protection block size.                                */
X  volatile uint32_t  PROTBLOCKSIZE;                      
N} NRF_MPU_Type;
N
N
N/* ================================================================================ */
N/* ================                      RADIO                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief The radio. (RADIO)
N  */
N
Ntypedef struct {                                    /*!< RADIO Structure                                                       */
N  __O  uint32_t  TASKS_TXEN;                        /*!< Enable radio in TX mode.                                              */
X  volatile  uint32_t  TASKS_TXEN;                         
N  __O  uint32_t  TASKS_RXEN;                        /*!< Enable radio in RX mode.                                              */
X  volatile  uint32_t  TASKS_RXEN;                         
N  __O  uint32_t  TASKS_START;                       /*!< Start radio.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop radio.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable radio.                                                        */
X  volatile  uint32_t  TASKS_DISABLE;                      
N  __O  uint32_t  TASKS_RSSISTART;                   /*!< Start the RSSI and take one sample of the receive signal strength.    */
X  volatile  uint32_t  TASKS_RSSISTART;                    
N  __O  uint32_t  TASKS_RSSISTOP;                    /*!< Stop the RSSI measurement.                                            */
X  volatile  uint32_t  TASKS_RSSISTOP;                     
N  __O  uint32_t  TASKS_BCSTART;                     /*!< Start the bit counter.                                                */
X  volatile  uint32_t  TASKS_BCSTART;                      
N  __O  uint32_t  TASKS_BCSTOP;                      /*!< Stop the bit counter.                                                 */
X  volatile  uint32_t  TASKS_BCSTOP;                       
N  __I  uint32_t  RESERVED0[55];
X  volatile const  uint32_t  RESERVED0[55];
N  __IO uint32_t  EVENTS_READY;                      /*!< Ready event.                                                          */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_ADDRESS;                    /*!< Address event.                                                        */
X  volatile uint32_t  EVENTS_ADDRESS;                     
N  __IO uint32_t  EVENTS_PAYLOAD;                    /*!< Payload event.                                                        */
X  volatile uint32_t  EVENTS_PAYLOAD;                     
N  __IO uint32_t  EVENTS_END;                        /*!< End event.                                                            */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_DISABLED;                   /*!< Disable event.                                                        */
X  volatile uint32_t  EVENTS_DISABLED;                    
N  __IO uint32_t  EVENTS_DEVMATCH;                   /*!< A device address match occurred on the last received packet.          */
X  volatile uint32_t  EVENTS_DEVMATCH;                    
N  __IO uint32_t  EVENTS_DEVMISS;                    /*!< No device address match occurred on the last received packet.         */
X  volatile uint32_t  EVENTS_DEVMISS;                     
N  __IO uint32_t  EVENTS_RSSIEND;                    /*!< Sampling of the receive signal strength complete. A new RSSI
X  volatile uint32_t  EVENTS_RSSIEND;                    
N                                                         sample is ready for readout at the RSSISAMPLE register.               */
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __IO uint32_t  EVENTS_BCMATCH;                    /*!< Bit counter reached bit count value specified in BCC register.        */
X  volatile uint32_t  EVENTS_BCMATCH;                     
N  __I  uint32_t  RESERVED2[53];
X  volatile const  uint32_t  RESERVED2[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the radio.                                              */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[61];
X  volatile const  uint32_t  RESERVED4[61];
N  __I  uint32_t  CRCSTATUS;                         /*!< CRC status of received packet.                                        */
X  volatile const  uint32_t  CRCSTATUS;                          
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __I  uint32_t  RXMATCH;                           /*!< Received address.                                                     */
X  volatile const  uint32_t  RXMATCH;                            
N  __I  uint32_t  RXCRC;                             /*!< Received CRC.                                                         */
X  volatile const  uint32_t  RXCRC;                              
N  __I  uint32_t  DAI;                               /*!< Device address match index.                                           */
X  volatile const  uint32_t  DAI;                                
N  __I  uint32_t  RESERVED6[60];
X  volatile const  uint32_t  RESERVED6[60];
N  __IO uint32_t  PACKETPTR;                         /*!< Packet pointer. Decision point: START task.                           */
X  volatile uint32_t  PACKETPTR;                          
N  __IO uint32_t  FREQUENCY;                         /*!< Frequency.                                                            */
X  volatile uint32_t  FREQUENCY;                          
N  __IO uint32_t  TXPOWER;                           /*!< Output power.                                                         */
X  volatile uint32_t  TXPOWER;                            
N  __IO uint32_t  MODE;                              /*!< Data rate and modulation.                                             */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  PCNF0;                             /*!< Packet configuration 0.                                               */
X  volatile uint32_t  PCNF0;                              
N  __IO uint32_t  PCNF1;                             /*!< Packet configuration 1.                                               */
X  volatile uint32_t  PCNF1;                              
N  __IO uint32_t  BASE0;                             /*!< Radio base address 0. Decision point: START task.                     */
X  volatile uint32_t  BASE0;                              
N  __IO uint32_t  BASE1;                             /*!< Radio base address 1. Decision point: START task.                     */
X  volatile uint32_t  BASE1;                              
N  __IO uint32_t  PREFIX0;                           /*!< Prefixes bytes for logical addresses 0 to 3.                          */
X  volatile uint32_t  PREFIX0;                            
N  __IO uint32_t  PREFIX1;                           /*!< Prefixes bytes for logical addresses 4 to 7.                          */
X  volatile uint32_t  PREFIX1;                            
N  __IO uint32_t  TXADDRESS;                         /*!< Transmit address select.                                              */
X  volatile uint32_t  TXADDRESS;                          
N  __IO uint32_t  RXADDRESSES;                       /*!< Receive address select.                                               */
X  volatile uint32_t  RXADDRESSES;                        
N  __IO uint32_t  CRCCNF;                            /*!< CRC configuration.                                                    */
X  volatile uint32_t  CRCCNF;                             
N  __IO uint32_t  CRCPOLY;                           /*!< CRC polynomial.                                                       */
X  volatile uint32_t  CRCPOLY;                            
N  __IO uint32_t  CRCINIT;                           /*!< CRC initial value.                                                    */
X  volatile uint32_t  CRCINIT;                            
N  __IO uint32_t  TEST;                              /*!< Test features enable register.                                        */
X  volatile uint32_t  TEST;                               
N  __IO uint32_t  TIFS;                              /*!< Inter Frame Spacing in microseconds.                                  */
X  volatile uint32_t  TIFS;                               
N  __I  uint32_t  RSSISAMPLE;                        /*!< RSSI sample.                                                          */
X  volatile const  uint32_t  RSSISAMPLE;                         
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __I  uint32_t  STATE;                             /*!< Current radio state.                                                  */
X  volatile const  uint32_t  STATE;                              
N  __IO uint32_t  DATAWHITEIV;                       /*!< Data whitening initial value.                                         */
X  volatile uint32_t  DATAWHITEIV;                        
N  __I  uint32_t  RESERVED8[2];
X  volatile const  uint32_t  RESERVED8[2];
N  __IO uint32_t  BCC;                               /*!< Bit counter compare.                                                  */
X  volatile uint32_t  BCC;                                
N  __I  uint32_t  RESERVED9[39];
X  volatile const  uint32_t  RESERVED9[39];
N  __IO uint32_t  DAB[8];                            /*!< Device address base segment.                                          */
X  volatile uint32_t  DAB[8];                             
N  __IO uint32_t  DAP[8];                            /*!< Device address prefix.                                                */
X  volatile uint32_t  DAP[8];                             
N  __IO uint32_t  DACNF;                             /*!< Device address match configuration.                                   */
X  volatile uint32_t  DACNF;                              
N  __I  uint32_t  RESERVED10[56];
X  volatile const  uint32_t  RESERVED10[56];
N  __IO uint32_t  OVERRIDE0;                         /*!< Trim value override register 0.                                       */
X  volatile uint32_t  OVERRIDE0;                          
N  __IO uint32_t  OVERRIDE1;                         /*!< Trim value override register 1.                                       */
X  volatile uint32_t  OVERRIDE1;                          
N  __IO uint32_t  OVERRIDE2;                         /*!< Trim value override register 2.                                       */
X  volatile uint32_t  OVERRIDE2;                          
N  __IO uint32_t  OVERRIDE3;                         /*!< Trim value override register 3.                                       */
X  volatile uint32_t  OVERRIDE3;                          
N  __IO uint32_t  OVERRIDE4;                         /*!< Trim value override register 4.                                       */
X  volatile uint32_t  OVERRIDE4;                          
N  __I  uint32_t  RESERVED11[561];
X  volatile const  uint32_t  RESERVED11[561];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RADIO_Type;
N
N
N/* ================================================================================ */
N/* ================                      UART                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Universal Asynchronous Receiver/Transmitter. (UART)
N  */
N
Ntypedef struct {                                    /*!< UART Structure                                                        */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start UART receiver.                                                  */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __O  uint32_t  TASKS_STOPRX;                      /*!< Stop UART receiver.                                                   */
X  volatile  uint32_t  TASKS_STOPRX;                       
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start UART transmitter.                                               */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __O  uint32_t  TASKS_STOPTX;                      /*!< Stop UART transmitter.                                                */
X  volatile  uint32_t  TASKS_STOPTX;                       
N  __I  uint32_t  RESERVED0[3];
X  volatile const  uint32_t  RESERVED0[3];
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend UART.                                                         */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __I  uint32_t  RESERVED1[56];
X  volatile const  uint32_t  RESERVED1[56];
N  __IO uint32_t  EVENTS_CTS;                        /*!< CTS activated.                                                        */
X  volatile uint32_t  EVENTS_CTS;                         
N  __IO uint32_t  EVENTS_NCTS;                       /*!< CTS deactivated.                                                      */
X  volatile uint32_t  EVENTS_NCTS;                        
N  __IO uint32_t  EVENTS_RXDRDY;                     /*!< Data received in RXD.                                                 */
X  volatile uint32_t  EVENTS_RXDRDY;                      
N  __I  uint32_t  RESERVED2[4];
X  volatile const  uint32_t  RESERVED2[4];
N  __IO uint32_t  EVENTS_TXDRDY;                     /*!< Data sent from TXD.                                                   */
X  volatile uint32_t  EVENTS_TXDRDY;                      
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error detected.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_RXTO;                       /*!< Receiver timeout.                                                     */
X  volatile uint32_t  EVENTS_RXTO;                        
N  __I  uint32_t  RESERVED5[46];
X  volatile const  uint32_t  RESERVED5[46];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for UART.                                                   */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED6[64];
X  volatile const  uint32_t  RESERVED6[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED7[93];
X  volatile const  uint32_t  RESERVED7[93];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source. Write error field to 1 to clear error.                  */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED8[31];
X  volatile const  uint32_t  RESERVED8[31];
N  __IO uint32_t  ENABLE;                            /*!< Enable UART and acquire IOs.                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  PSELRTS;                           /*!< Pin select for RTS.                                                   */
X  volatile uint32_t  PSELRTS;                            
N  __IO uint32_t  PSELTXD;                           /*!< Pin select for TXD.                                                   */
X  volatile uint32_t  PSELTXD;                            
N  __IO uint32_t  PSELCTS;                           /*!< Pin select for CTS.                                                   */
X  volatile uint32_t  PSELCTS;                            
N  __IO uint32_t  PSELRXD;                           /*!< Pin select for RXD.                                                   */
X  volatile uint32_t  PSELRXD;                            
N  __I  uint32_t  RXD;                               /*!< RXD register. On read action the buffer pointer is displaced.
X  volatile const  uint32_t  RXD;                               
N                                                         Once read the character is consumed. If read when no character
N                                                          available, the UART will stop working.                               */
N  __O  uint32_t  TXD;                               /*!< TXD register.                                                         */
X  volatile  uint32_t  TXD;                                
N  __I  uint32_t  RESERVED10;
X  volatile const  uint32_t  RESERVED10;
N  __IO uint32_t  BAUDRATE;                          /*!< UART Baudrate.                                                        */
X  volatile uint32_t  BAUDRATE;                           
N  __I  uint32_t  RESERVED11[17];
X  volatile const  uint32_t  RESERVED11[17];
N  __IO uint32_t  CONFIG;                            /*!< Configuration of parity and hardware flow control register.           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED12[675];
X  volatile const  uint32_t  RESERVED12[675];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_UART_Type;
N
N
N/* ================================================================================ */
N/* ================                       SPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI master 0. (SPI)
N  */
N
Ntypedef struct {                                    /*!< SPI Structure                                                         */
N  __I  uint32_t  RESERVED0[66];
X  volatile const  uint32_t  RESERVED0[66];
N  __IO uint32_t  EVENTS_READY;                      /*!< TXD byte sent and RXD byte received.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __I  uint32_t  RESERVED1[126];
X  volatile const  uint32_t  RESERVED1[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[125];
X  volatile const  uint32_t  RESERVED2[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPI.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __I  uint32_t  RXD;                               /*!< RX data.                                                              */
X  volatile const  uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data.                                                              */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  FREQUENCY;                         /*!< SPI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED7[681];
X  volatile const  uint32_t  RESERVED7[681];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPI_Type;
N
N
N/* ================================================================================ */
N/* ================                       TWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Two-wire interface master 0. (TWI)
N  */
N
Ntypedef struct {                                    /*!< TWI Structure                                                         */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start 2-Wire master receive sequence.                                 */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start 2-Wire master transmit sequence.                                */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop 2-Wire transaction.                                              */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend 2-Wire transaction.                                           */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume 2-Wire transaction.                                            */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED3[56];
X  volatile const  uint32_t  RESERVED3[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< Two-wire stopped.                                                     */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __IO uint32_t  EVENTS_RXDREADY;                   /*!< Two-wire ready to deliver new RXD byte received.                      */
X  volatile uint32_t  EVENTS_RXDREADY;                    
N  __I  uint32_t  RESERVED4[4];
X  volatile const  uint32_t  RESERVED4[4];
N  __IO uint32_t  EVENTS_TXDSENT;                    /*!< Two-wire finished sending last TXD byte.                              */
X  volatile uint32_t  EVENTS_TXDSENT;                     
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Two-wire error detected.                                              */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED6[4];
X  volatile const  uint32_t  RESERVED6[4];
N  __IO uint32_t  EVENTS_BB;                         /*!< Two-wire byte boundary.                                               */
X  volatile uint32_t  EVENTS_BB;                          
N  __I  uint32_t  RESERVED7[3];
X  volatile const  uint32_t  RESERVED7[3];
N  __IO uint32_t  EVENTS_SUSPENDED;                  /*!< Two-wire suspended.                                                   */
X  volatile uint32_t  EVENTS_SUSPENDED;                   
N  __I  uint32_t  RESERVED8[45];
X  volatile const  uint32_t  RESERVED8[45];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for TWI.                                                    */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED9[64];
X  volatile const  uint32_t  RESERVED9[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED10[110];
X  volatile const  uint32_t  RESERVED10[110];
N  __IO uint32_t  ERRORSRC;                          /*!< Two-wire error source. Write error field to 1 to clear error.         */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED11[14];
X  volatile const  uint32_t  RESERVED11[14];
N  __IO uint32_t  ENABLE;                            /*!< Enable two-wire master.                                               */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  PSELSCL;                           /*!< Pin select for SCL.                                                   */
X  volatile uint32_t  PSELSCL;                            
N  __IO uint32_t  PSELSDA;                           /*!< Pin select for SDA.                                                   */
X  volatile uint32_t  PSELSDA;                            
N  __I  uint32_t  RESERVED13[2];
X  volatile const  uint32_t  RESERVED13[2];
N  __I  uint32_t  RXD;                               /*!< RX data register.                                                     */
X  volatile const  uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data register.                                                     */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED14;
X  volatile const  uint32_t  RESERVED14;
N  __IO uint32_t  FREQUENCY;                         /*!< Two-wire frequency.                                                   */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED15[24];
X  volatile const  uint32_t  RESERVED15[24];
N  __IO uint32_t  ADDRESS;                           /*!< Address used in the two-wire transfer.                                */
X  volatile uint32_t  ADDRESS;                            
N  __I  uint32_t  RESERVED16[668];
X  volatile const  uint32_t  RESERVED16[668];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      SPIS                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI slave 1. (SPIS)
N  */
N
Ntypedef struct {                                    /*!< SPIS Structure                                                        */
N  __I  uint32_t  RESERVED0[9];
X  volatile const  uint32_t  RESERVED0[9];
N  __O  uint32_t  TASKS_ACQUIRE;                     /*!< Acquire SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_ACQUIRE;                      
N  __O  uint32_t  TASKS_RELEASE;                     /*!< Release SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_RELEASE;                      
N  __I  uint32_t  RESERVED1[54];
X  volatile const  uint32_t  RESERVED1[54];
N  __IO uint32_t  EVENTS_END;                        /*!< Granted transaction completed.                                        */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED2[2];
X  volatile const  uint32_t  RESERVED2[2];
N  __IO uint32_t  EVENTS_ENDRX;                      /*!< End of RXD buffer reached                                             */
X  volatile uint32_t  EVENTS_ENDRX;                       
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __IO uint32_t  EVENTS_ACQUIRED;                   /*!< Semaphore acquired.                                                   */
X  volatile uint32_t  EVENTS_ACQUIRED;                    
N  __I  uint32_t  RESERVED4[53];
X  volatile const  uint32_t  RESERVED4[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for SPIS.                                                   */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED5[64];
X  volatile const  uint32_t  RESERVED5[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED6[61];
X  volatile const  uint32_t  RESERVED6[61];
N  __I  uint32_t  SEMSTAT;                           /*!< Semaphore status.                                                     */
X  volatile const  uint32_t  SEMSTAT;                            
N  __I  uint32_t  RESERVED7[15];
X  volatile const  uint32_t  RESERVED7[15];
N  __IO uint32_t  STATUS;                            /*!< Status from last transaction.                                         */
X  volatile uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED8[47];
X  volatile const  uint32_t  RESERVED8[47];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPIS.                                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELCSN;                           /*!< Pin select for CSN.                                                   */
X  volatile uint32_t  PSELCSN;                            
N  __I  uint32_t  RESERVED10[7];
X  volatile const  uint32_t  RESERVED10[7];
N  __IO uint32_t  RXDPTR;                            /*!< RX data pointer.                                                      */
X  volatile uint32_t  RXDPTR;                             
N  __IO uint32_t  MAXRX;                             /*!< Maximum number of bytes in the receive buffer.                        */
X  volatile uint32_t  MAXRX;                              
N  __I  uint32_t  AMOUNTRX;                          /*!< Number of bytes received in last granted transaction.                 */
X  volatile const  uint32_t  AMOUNTRX;                           
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  TXDPTR;                            /*!< TX data pointer.                                                      */
X  volatile uint32_t  TXDPTR;                             
N  __IO uint32_t  MAXTX;                             /*!< Maximum number of bytes in the transmit buffer.                       */
X  volatile uint32_t  MAXTX;                              
N  __I  uint32_t  AMOUNTTX;                          /*!< Number of bytes transmitted in last granted transaction.              */
X  volatile const  uint32_t  AMOUNTTX;                           
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED13;
X  volatile const  uint32_t  RESERVED13;
N  __IO uint32_t  DEF;                               /*!< Default character.                                                    */
X  volatile uint32_t  DEF;                                
N  __I  uint32_t  RESERVED14[24];
X  volatile const  uint32_t  RESERVED14[24];
N  __IO uint32_t  ORC;                               /*!< Over-read character.                                                  */
X  volatile uint32_t  ORC;                                
N  __I  uint32_t  RESERVED15[654];
X  volatile const  uint32_t  RESERVED15[654];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPIS_Type;
N
N
N/* ================================================================================ */
N/* ================                     GPIOTE                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief GPIO tasks and events. (GPIOTE)
N  */
N
Ntypedef struct {                                    /*!< GPIOTE Structure                                                      */
N  __O  uint32_t  TASKS_OUT[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile  uint32_t  TASKS_OUT[4];                       
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_IN[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile uint32_t  EVENTS_IN[4];                       
N  __I  uint32_t  RESERVED1[27];
X  volatile const  uint32_t  RESERVED1[27];
N  __IO uint32_t  EVENTS_PORT;                       /*!< Event generated from multiple pins.                                   */
X  volatile uint32_t  EVENTS_PORT;                        
N  __I  uint32_t  RESERVED2[97];
X  volatile const  uint32_t  RESERVED2[97];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[129];
X  volatile const  uint32_t  RESERVED3[129];
N  __IO uint32_t  CONFIG[4];                         /*!< Channel configuration registers.                                      */
X  volatile uint32_t  CONFIG[4];                          
N  __I  uint32_t  RESERVED4[695];
X  volatile const  uint32_t  RESERVED4[695];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_GPIOTE_Type;
N
N
N/* ================================================================================ */
N/* ================                       ADC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Analog to digital converter. (ADC)
N  */
N
Ntypedef struct {                                    /*!< ADC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start an ADC conversion.                                              */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop ADC.                                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_END;                        /*!< ADC conversion complete.                                              */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  BUSY;                              /*!< ADC busy register.                                                    */
X  volatile const  uint32_t  BUSY;                               
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  ENABLE;                            /*!< ADC enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  CONFIG;                            /*!< ADC configuration register.                                           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESULT;                            /*!< Result of ADC conversion.                                             */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ADC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TIMER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Timer 0. (TIMER)
N  */
N
Ntypedef struct {                                    /*!< TIMER Structure                                                       */
N  __O  uint32_t  TASKS_START;                       /*!< Start Timer.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop Timer.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_COUNT;                       /*!< Increment Timer (In counter mode).                                    */
X  volatile  uint32_t  TASKS_COUNT;                        
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear timer.                                                          */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_SHUTDOWN;                    /*!< Shutdown timer.                                                       */
X  volatile  uint32_t  TASKS_SHUTDOWN;                     
N  __I  uint32_t  RESERVED0[11];
X  volatile const  uint32_t  RESERVED0[11];
N  __O  uint32_t  TASKS_CAPTURE[4];                  /*!< Capture Timer value to CC[n] registers.                               */
X  volatile  uint32_t  TASKS_CAPTURE[4];                   
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[44];
X  volatile const  uint32_t  RESERVED2[44];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for Timer.                                                  */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[126];
X  volatile const  uint32_t  RESERVED4[126];
N  __IO uint32_t  MODE;                              /*!< Timer Mode selection.                                                 */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  BITMODE;                           /*!< Sets timer behaviour.                                                 */
X  volatile uint32_t  BITMODE;                            
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  PRESCALER;                         /*!< 4-bit prescaler to source clock frequency (max value 9). Source
X  volatile uint32_t  PRESCALER;                         
N                                                         clock frequency is divided by 2^SCALE.                                */
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED7[683];
X  volatile const  uint32_t  RESERVED7[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TIMER_Type;
N
N
N/* ================================================================================ */
N/* ================                       RTC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Real time counter 0. (RTC)
N  */
N
Ntypedef struct {                                    /*!< RTC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop RTC Counter.                                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_TRIGOVRFLW;                  /*!< Set COUNTER to 0xFFFFFFF0.                                            */
X  volatile  uint32_t  TASKS_TRIGOVRFLW;                   
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_TICK;                       /*!< Event on COUNTER increment.                                           */
X  volatile uint32_t  EVENTS_TICK;                        
N  __IO uint32_t  EVENTS_OVRFLW;                     /*!< Event on COUNTER overflow.                                            */
X  volatile uint32_t  EVENTS_OVRFLW;                      
N  __I  uint32_t  RESERVED1[14];
X  volatile const  uint32_t  RESERVED1[14];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[109];
X  volatile const  uint32_t  RESERVED2[109];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[13];
X  volatile const  uint32_t  RESERVED3[13];
N  __IO uint32_t  EVTEN;                             /*!< Configures event enable routing to PPI for each RTC event.            */
X  volatile uint32_t  EVTEN;                              
N  __IO uint32_t  EVTENSET;                          /*!< Enable events routing to PPI. The reading of this register gives
X  volatile uint32_t  EVTENSET;                          
N                                                         the value of EVTEN.                                                   */
N  __IO uint32_t  EVTENCLR;                          /*!< Disable events routing to PPI. The reading of this register
X  volatile uint32_t  EVTENCLR;                          
N                                                         gives the value of EVTEN.                                             */
N  __I  uint32_t  RESERVED4[110];
X  volatile const  uint32_t  RESERVED4[110];
N  __I  uint32_t  COUNTER;                           /*!< Current COUNTER value.                                                */
X  volatile const  uint32_t  COUNTER;                            
N  __IO uint32_t  PRESCALER;                         /*!< 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).
X  volatile uint32_t  PRESCALER;                         
N                                                         Must be written when RTC is STOPed.                                   */
N  __I  uint32_t  RESERVED5[13];
X  volatile const  uint32_t  RESERVED5[13];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED6[683];
X  volatile const  uint32_t  RESERVED6[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RTC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TEMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Temperature Sensor. (TEMP)
N  */
N
Ntypedef struct {                                    /*!< TEMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start temperature measurement.                                        */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop temperature measurement.                                         */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_DATARDY;                    /*!< Temperature measurement complete, data ready event.                   */
X  volatile uint32_t  EVENTS_DATARDY;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[127];
X  volatile const  uint32_t  RESERVED2[127];
N  __I  int32_t   TEMP;                              /*!< Die temperature in degC, 2's complement format, 0.25 degC pecision.   */
X  volatile const  int32_t   TEMP;                               
N  __I  uint32_t  RESERVED3[700];
X  volatile const  uint32_t  RESERVED3[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TEMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       RNG                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Random Number Generator. (RNG)
N  */
N
Ntypedef struct {                                    /*!< RNG Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the random number generator.                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the random number generator.                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_VALRDY;                     /*!< New random number generated and written to VALUE register.            */
X  volatile uint32_t  EVENTS_VALRDY;                      
N  __I  uint32_t  RESERVED1[63];
X  volatile const  uint32_t  RESERVED1[63];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the RNG.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register                                         */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register                                       */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[126];
X  volatile const  uint32_t  RESERVED3[126];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  VALUE;                             /*!< RNG random number.                                                    */
X  volatile const  uint32_t  VALUE;                              
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RNG_Type;
N
N
N/* ================================================================================ */
N/* ================                       ECB                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES ECB Mode Encryption. (ECB)
N  */
N
Ntypedef struct {                                    /*!< ECB Structure                                                         */
N  __O  uint32_t  TASKS_STARTECB;                    /*!< Start ECB block encrypt. If a crypto operation is running, this
X  volatile  uint32_t  TASKS_STARTECB;                    
N                                                         will not initiate a new encryption and the ERRORECB event will
N                                                          be triggered.                                                        */
N  __O  uint32_t  TASKS_STOPECB;                     /*!< Stop current ECB encryption. If a crypto operation is running,
X  volatile  uint32_t  TASKS_STOPECB;                     
N                                                         this will will trigger the ERRORECB event.                            */
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_ENDECB;                     /*!< ECB block encrypt complete.                                           */
X  volatile uint32_t  EVENTS_ENDECB;                      
N  __IO uint32_t  EVENTS_ERRORECB;                   /*!< ECB block encrypt aborted due to a STOPECB task or due to an
X  volatile uint32_t  EVENTS_ERRORECB;                   
N                                                         error.                                                                */
N  __I  uint32_t  RESERVED1[127];
X  volatile const  uint32_t  RESERVED1[127];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  ECBDATAPTR;                        /*!< ECB block encrypt memory pointer.                                     */
X  volatile uint32_t  ECBDATAPTR;                         
N  __I  uint32_t  RESERVED3[701];
X  volatile const  uint32_t  RESERVED3[701];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ECB_Type;
N
N
N/* ================================================================================ */
N/* ================                       AAR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Accelerated Address Resolver. (AAR)
N  */
N
Ntypedef struct {                                    /*!< AAR Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start resolving addresses based on IRKs specified in the IRK
X  volatile  uint32_t  TASKS_START;                       
N                                                         data structure.                                                       */
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop resolving addresses.                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  EVENTS_END;                        /*!< Address resolution procedure completed.                               */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_RESOLVED;                   /*!< Address resolved.                                                     */
X  volatile uint32_t  EVENTS_RESOLVED;                    
N  __IO uint32_t  EVENTS_NOTRESOLVED;                /*!< Address not resolved.                                                 */
X  volatile uint32_t  EVENTS_NOTRESOLVED;                 
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  STATUS;                            /*!< Resolution status.                                                    */
X  volatile const  uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable AAR.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  NIRK;                              /*!< Number of Identity root Keys in the IRK data structure.               */
X  volatile uint32_t  NIRK;                               
N  __IO uint32_t  IRKPTR;                            /*!< Pointer to the IRK data structure.                                    */
X  volatile uint32_t  IRKPTR;                             
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  ADDRPTR;                           /*!< Pointer to the resolvable address (6 bytes).                          */
X  volatile uint32_t  ADDRPTR;                            
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to a scratch data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 3 bytes must be reserved.                    */
N  __I  uint32_t  RESERVED6[697];
X  volatile const  uint32_t  RESERVED6[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_AAR_Type;
N
N
N/* ================================================================================ */
N/* ================                       CCM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES CCM Mode Encryption. (CCM)
N  */
N
Ntypedef struct {                                    /*!< CCM Structure                                                         */
N  __O  uint32_t  TASKS_KSGEN;                       /*!< Start generation of key-stream. This operation will stop by
X  volatile  uint32_t  TASKS_KSGEN;                       
N                                                         itself when completed.                                                */
N  __O  uint32_t  TASKS_CRYPT;                       /*!< Start encrypt/decrypt. This operation will stop by itself when
X  volatile  uint32_t  TASKS_CRYPT;                       
N                                                         completed.                                                            */
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop encrypt/decrypt.                                                 */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_ENDKSGEN;                   /*!< Keystream generation completed.                                       */
X  volatile uint32_t  EVENTS_ENDKSGEN;                    
N  __IO uint32_t  EVENTS_ENDCRYPT;                   /*!< Encrypt/decrypt completed.                                            */
X  volatile uint32_t  EVENTS_ENDCRYPT;                    
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error happened.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the CCM.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  MICSTATUS;                         /*!< CCM RX MIC check result.                                              */
X  volatile const  uint32_t  MICSTATUS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< CCM enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  MODE;                              /*!< Operation mode.                                                       */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  CNFPTR;                            /*!< Pointer to a data structure holding AES key and NONCE vector.         */
X  volatile uint32_t  CNFPTR;                             
N  __IO uint32_t  INPTR;                             /*!< Pointer to the input packet.                                          */
X  volatile uint32_t  INPTR;                              
N  __IO uint32_t  OUTPTR;                            /*!< Pointer to the output packet.                                         */
X  volatile uint32_t  OUTPTR;                             
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to a scratch data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 43 bytes must be reserved.                   */
N  __I  uint32_t  RESERVED5[697];
X  volatile const  uint32_t  RESERVED5[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_CCM_Type;
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Watchdog Timer. (WDT)
N  */
N
Ntypedef struct {                                    /*!< WDT Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the watchdog.                                                   */
X  volatile  uint32_t  TASKS_START;                        
N  __I  uint32_t  RESERVED0[63];
X  volatile const  uint32_t  RESERVED0[63];
N  __IO uint32_t  EVENTS_TIMEOUT;                    /*!< Watchdog timeout.                                                     */
X  volatile uint32_t  EVENTS_TIMEOUT;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  RUNSTATUS;                         /*!< Watchdog running status.                                              */
X  volatile const  uint32_t  RUNSTATUS;                          
N  __I  uint32_t  REQSTATUS;                         /*!< Request status.                                                       */
X  volatile const  uint32_t  REQSTATUS;                          
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  CRV;                               /*!< Counter reload value in number of 32kiHz clock cycles.                */
X  volatile uint32_t  CRV;                                
N  __IO uint32_t  RREN;                              /*!< Reload request enable.                                                */
X  volatile uint32_t  RREN;                               
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED4[60];
X  volatile const  uint32_t  RESERVED4[60];
N  __O  uint32_t  RR[8];                             /*!< Reload requests registers.                                            */
X  volatile  uint32_t  RR[8];                              
N  __I  uint32_t  RESERVED5[631];
X  volatile const  uint32_t  RESERVED5[631];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_WDT_Type;
N
N
N/* ================================================================================ */
N/* ================                      QDEC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Rotary decoder. (QDEC)
N  */
N
Ntypedef struct {                                    /*!< QDEC Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the quadrature decoder.                                         */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the quadrature decoder.                                          */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_READCLRACC;                  /*!< Transfers the content from ACC registers to ACCREAD registers,
X  volatile  uint32_t  TASKS_READCLRACC;                  
N                                                         and clears the ACC registers.                                         */
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_SAMPLERDY;                  /*!< A new sample is written to the sample register.                       */
X  volatile uint32_t  EVENTS_SAMPLERDY;                   
N  __IO uint32_t  EVENTS_REPORTRDY;                  /*!< REPORTPER number of samples accumulated in ACC register, and
X  volatile uint32_t  EVENTS_REPORTRDY;                  
N                                                         ACC register different than zero.                                     */
N  __IO uint32_t  EVENTS_ACCOF;                      /*!< ACC or ACCDBL register overflow.                                      */
X  volatile uint32_t  EVENTS_ACCOF;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the QDEC.                                               */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[125];
X  volatile const  uint32_t  RESERVED3[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable the QDEC.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  LEDPOL;                            /*!< LED output pin polarity.                                              */
X  volatile uint32_t  LEDPOL;                             
N  __IO uint32_t  SAMPLEPER;                         /*!< Sample period.                                                        */
X  volatile uint32_t  SAMPLEPER;                          
N  __I  int32_t   SAMPLE;                            /*!< Motion sample value.                                                  */
X  volatile const  int32_t   SAMPLE;                             
N  __IO uint32_t  REPORTPER;                         /*!< Number of samples to generate an EVENT_REPORTRDY.                     */
X  volatile uint32_t  REPORTPER;                          
N  __I  int32_t   ACC;                               /*!< Accumulated valid transitions register.                               */
X  volatile const  int32_t   ACC;                                
N  __I  int32_t   ACCREAD;                           /*!< Snapshot of ACC register. Value generated by the TASKS_READCLEACC
X  volatile const  int32_t   ACCREAD;                           
N                                                         task.                                                                 */
N  __IO uint32_t  PSELLED;                           /*!< Pin select for LED output.                                            */
X  volatile uint32_t  PSELLED;                            
N  __IO uint32_t  PSELA;                             /*!< Pin select for phase A input.                                         */
X  volatile uint32_t  PSELA;                              
N  __IO uint32_t  PSELB;                             /*!< Pin select for phase B input.                                         */
X  volatile uint32_t  PSELB;                              
N  __IO uint32_t  DBFEN;                             /*!< Enable debouncer input filters.                                       */
X  volatile uint32_t  DBFEN;                              
N  __I  uint32_t  RESERVED4[5];
X  volatile const  uint32_t  RESERVED4[5];
N  __IO uint32_t  LEDPRE;                            /*!< Time LED is switched ON before the sample.                            */
X  volatile uint32_t  LEDPRE;                             
N  __I  uint32_t  ACCDBL;                            /*!< Accumulated double (error) transitions register.                      */
X  volatile const  uint32_t  ACCDBL;                             
N  __I  uint32_t  ACCDBLREAD;                        /*!< Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC
X  volatile const  uint32_t  ACCDBLREAD;                        
N                                                         task.                                                                 */
N  __I  uint32_t  RESERVED5[684];
X  volatile const  uint32_t  RESERVED5[684];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_QDEC_Type;
N
N
N/* ================================================================================ */
N/* ================                     LPCOMP                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Low power comparator. (LPCOMP)
N  */
N
Ntypedef struct {                                    /*!< LPCOMP Structure                                                      */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< LPCOMP is ready and output is valid.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for the LPCOMP.                                             */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Result of last compare.                                               */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the LPCOMP.                                                    */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[4];
X  volatile const  uint32_t  RESERVED5[4];
N  __IO uint32_t  ANADETECT;                         /*!< Analog detect configuration.                                          */
X  volatile uint32_t  ANADETECT;                          
N  __I  uint32_t  RESERVED6[694];
X  volatile const  uint32_t  RESERVED6[694];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_LPCOMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       SWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SW Interrupts. (SWI)
N  */
N
Ntypedef struct {                                    /*!< SWI Structure                                                         */
N  __I  uint32_t  UNUSED;                            /*!< Unused.                                                               */
X  volatile const  uint32_t  UNUSED;                             
N} NRF_SWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      NVMC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Non Volatile Memory Controller. (NVMC)
N  */
N
Ntypedef struct {                                    /*!< NVMC Structure                                                        */
N  __I  uint32_t  RESERVED0[256];
X  volatile const  uint32_t  RESERVED0[256];
N  __I  uint32_t  READY;                             /*!< Ready flag.                                                           */
X  volatile const  uint32_t  READY;                              
N  __I  uint32_t  RESERVED1[64];
X  volatile const  uint32_t  RESERVED1[64];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  
N  union {
N    __IO uint32_t  ERASEPCR1;                       /*!< Register for erasing a non-protected non-volatile memory page.        */
X    volatile uint32_t  ERASEPCR1;                        
N    __IO uint32_t  ERASEPAGE;                       /*!< Register for erasing a non-protected non-volatile memory page.        */
X    volatile uint32_t  ERASEPAGE;                        
N  };
N  __IO uint32_t  ERASEALL;                          /*!< Register for erasing all non-volatile user memory.                    */
X  volatile uint32_t  ERASEALL;                           
N  __IO uint32_t  ERASEPCR0;                         /*!< Register for erasing a protected non-volatile memory page.            */
X  volatile uint32_t  ERASEPCR0;                          
N  __IO uint32_t  ERASEUICR;                         /*!< Register for start erasing User Information Congfiguration Registers. */
X  volatile uint32_t  ERASEUICR;                          
N} NRF_NVMC_Type;
N
N
N/* ================================================================================ */
N/* ================                       PPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief PPI controller. (PPI)
N  */
N
Ntypedef struct {                                    /*!< PPI Structure                                                         */
N  PPI_TASKS_CHG_Type TASKS_CHG[4];                  /*!< Channel group tasks.                                                  */
N  __I  uint32_t  RESERVED0[312];
X  volatile const  uint32_t  RESERVED0[312];
N  __IO uint32_t  CHEN;                              /*!< Channel enable.                                                       */
X  volatile uint32_t  CHEN;                               
N  __IO uint32_t  CHENSET;                           /*!< Channel enable set.                                                   */
X  volatile uint32_t  CHENSET;                            
N  __IO uint32_t  CHENCLR;                           /*!< Channel enable clear.                                                 */
X  volatile uint32_t  CHENCLR;                            
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  PPI_CH_Type CH[16];                               /*!< PPI Channel.                                                          */
N  __I  uint32_t  RESERVED2[156];
X  volatile const  uint32_t  RESERVED2[156];
N  __IO uint32_t  CHG[4];                            /*!< Channel group configuration.                                          */
X  volatile uint32_t  CHG[4];                             
N} NRF_PPI_Type;
N
N
N/* ================================================================================ */
N/* ================                      FICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Factory Information Configuration. (FICR)
N  */
N
Ntypedef struct {                                    /*!< FICR Structure                                                        */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __I  uint32_t  CODEPAGESIZE;                      /*!< Code memory page size in bytes.                                       */
X  volatile const  uint32_t  CODEPAGESIZE;                       
N  __I  uint32_t  CODESIZE;                          /*!< Code memory size in pages.                                            */
X  volatile const  uint32_t  CODESIZE;                           
N  __I  uint32_t  RESERVED1[4];
X  volatile const  uint32_t  RESERVED1[4];
N  __I  uint32_t  CLENR0;                            /*!< Length of code region 0 in bytes.                                     */
X  volatile const  uint32_t  CLENR0;                             
N  __I  uint32_t  PPFC;                              /*!< Pre-programmed factory code present.                                  */
X  volatile const  uint32_t  PPFC;                               
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __I  uint32_t  NUMRAMBLOCK;                       /*!< Number of individualy controllable RAM blocks.                        */
X  volatile const  uint32_t  NUMRAMBLOCK;                        
N  
N  union {
N    __I  uint32_t  SIZERAMBLOCK[4];                 /*!< Deprecated array of size of RAM block in bytes. This name is
X    volatile const  uint32_t  SIZERAMBLOCK[4];                 
N                                                         kept for backward compatinility purposes. Use SIZERAMBLOCKS
N                                                          instead.                                                             */
N    __I  uint32_t  SIZERAMBLOCKS;                   /*!< Size of RAM blocks in bytes.                                          */
X    volatile const  uint32_t  SIZERAMBLOCKS;                    
N  };
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __I  uint32_t  CONFIGID;                          /*!< Configuration identifier.                                             */
X  volatile const  uint32_t  CONFIGID;                           
N  __I  uint32_t  DEVICEID[2];                       /*!< Device identifier.                                                    */
X  volatile const  uint32_t  DEVICEID[2];                        
N  __I  uint32_t  RESERVED4[6];
X  volatile const  uint32_t  RESERVED4[6];
N  __I  uint32_t  ER[4];                             /*!< Encryption root.                                                      */
X  volatile const  uint32_t  ER[4];                              
N  __I  uint32_t  IR[4];                             /*!< Identity root.                                                        */
X  volatile const  uint32_t  IR[4];                              
N  __I  uint32_t  DEVICEADDRTYPE;                    /*!< Device address type.                                                  */
X  volatile const  uint32_t  DEVICEADDRTYPE;                     
N  __I  uint32_t  DEVICEADDR[2];                     /*!< Device address.                                                       */
X  volatile const  uint32_t  DEVICEADDR[2];                      
N  __I  uint32_t  OVERRIDEEN;                        /*!< Radio calibration override enable.                                    */
X  volatile const  uint32_t  OVERRIDEEN;                         
N  __I  uint32_t  NRF_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for NRF_1Mbit
X  volatile const  uint32_t  NRF_1MBIT[5];                      
N                                                         mode.                                                                 */
N  __I  uint32_t  RESERVED5[10];
X  volatile const  uint32_t  RESERVED5[10];
N  __I  uint32_t  BLE_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit
X  volatile const  uint32_t  BLE_1MBIT[5];                      
N                                                         mode.                                                                 */
N} NRF_FICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      UICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief User Information Configuration. (UICR)
N  */
N
Ntypedef struct {                                    /*!< UICR Structure                                                        */
N  __IO uint32_t  CLENR0;                            /*!< Length of code region 0.                                              */
X  volatile uint32_t  CLENR0;                             
N  __IO uint32_t  RBPCONF;                           /*!< Readback protection configuration.                                    */
X  volatile uint32_t  RBPCONF;                            
N  __IO uint32_t  XTALFREQ;                          /*!< Reset value for CLOCK XTALFREQ register.                              */
X  volatile uint32_t  XTALFREQ;                           
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __I  uint32_t  FWID;                              /*!< Firmware ID.                                                          */
X  volatile const  uint32_t  FWID;                               
N  
N  union {
N    __IO uint32_t  NRFFW[15];                       /*!< Reserved for Nordic firmware design.                                  */
X    volatile uint32_t  NRFFW[15];                        
N    __IO uint32_t  BOOTLOADERADDR;                  /*!< Bootloader start address.                                             */
X    volatile uint32_t  BOOTLOADERADDR;                   
N  };
N  __IO uint32_t  NRFHW[12];                         /*!< Reserved for Nordic hardware design.                                  */
X  volatile uint32_t  NRFHW[12];                          
N  __IO uint32_t  CUSTOMER[32];                      /*!< Reserved for customer.                                                */
X  volatile uint32_t  CUSTOMER[32];                       
N} NRF_UICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      GPIO                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief General purpose input and output. (GPIO)
N  */
N
Ntypedef struct {                                    /*!< GPIO Structure                                                        */
N  __I  uint32_t  RESERVED0[321];
X  volatile const  uint32_t  RESERVED0[321];
N  __IO uint32_t  OUT;                               /*!< Write GPIO port.                                                      */
X  volatile uint32_t  OUT;                                
N  __IO uint32_t  OUTSET;                            /*!< Set individual bits in GPIO port.                                     */
X  volatile uint32_t  OUTSET;                             
N  __IO uint32_t  OUTCLR;                            /*!< Clear individual bits in GPIO port.                                   */
X  volatile uint32_t  OUTCLR;                             
N  __I  uint32_t  IN;                                /*!< Read GPIO port.                                                       */
X  volatile const  uint32_t  IN;                                 
N  __IO uint32_t  DIR;                               /*!< Direction of GPIO pins.                                               */
X  volatile uint32_t  DIR;                                
N  __IO uint32_t  DIRSET;                            /*!< DIR set register.                                                     */
X  volatile uint32_t  DIRSET;                             
N  __IO uint32_t  DIRCLR;                            /*!< DIR clear register.                                                   */
X  volatile uint32_t  DIRCLR;                             
N  __I  uint32_t  RESERVED1[120];
X  volatile const  uint32_t  RESERVED1[120];
N  __IO uint32_t  PIN_CNF[32];                       /*!< Configuration of GPIO pins.                                           */
X  volatile uint32_t  PIN_CNF[32];                        
N} NRF_GPIO_Type;
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER_BASE                  0x40000000UL
N#define NRF_CLOCK_BASE                  0x40000000UL
N#define NRF_MPU_BASE                    0x40000000UL
N#define NRF_RADIO_BASE                  0x40001000UL
N#define NRF_UART0_BASE                  0x40002000UL
N#define NRF_SPI0_BASE                   0x40003000UL
N#define NRF_TWI0_BASE                   0x40003000UL
N#define NRF_SPI1_BASE                   0x40004000UL
N#define NRF_TWI1_BASE                   0x40004000UL
N#define NRF_SPIS1_BASE                  0x40004000UL
N#define NRF_GPIOTE_BASE                 0x40006000UL
N#define NRF_ADC_BASE                    0x40007000UL
N#define NRF_TIMER0_BASE                 0x40008000UL
N#define NRF_TIMER1_BASE                 0x40009000UL
N#define NRF_TIMER2_BASE                 0x4000A000UL
N#define NRF_RTC0_BASE                   0x4000B000UL
N#define NRF_TEMP_BASE                   0x4000C000UL
N#define NRF_RNG_BASE                    0x4000D000UL
N#define NRF_ECB_BASE                    0x4000E000UL
N#define NRF_AAR_BASE                    0x4000F000UL
N#define NRF_CCM_BASE                    0x4000F000UL
N#define NRF_WDT_BASE                    0x40010000UL
N#define NRF_RTC1_BASE                   0x40011000UL
N#define NRF_QDEC_BASE                   0x40012000UL
N#define NRF_LPCOMP_BASE                 0x40013000UL
N#define NRF_SWI_BASE                    0x40014000UL
N#define NRF_NVMC_BASE                   0x4001E000UL
N#define NRF_PPI_BASE                    0x4001F000UL
N#define NRF_FICR_BASE                   0x10000000UL
N#define NRF_UICR_BASE                   0x10001000UL
N#define NRF_GPIO_BASE                   0x50000000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER                       ((NRF_POWER_Type          *) NRF_POWER_BASE)
N#define NRF_CLOCK                       ((NRF_CLOCK_Type          *) NRF_CLOCK_BASE)
N#define NRF_MPU                         ((NRF_MPU_Type            *) NRF_MPU_BASE)
N#define NRF_RADIO                       ((NRF_RADIO_Type          *) NRF_RADIO_BASE)
N#define NRF_UART0                       ((NRF_UART_Type           *) NRF_UART0_BASE)
N#define NRF_SPI0                        ((NRF_SPI_Type            *) NRF_SPI0_BASE)
N#define NRF_TWI0                        ((NRF_TWI_Type            *) NRF_TWI0_BASE)
N#define NRF_SPI1                        ((NRF_SPI_Type            *) NRF_SPI1_BASE)
N#define NRF_TWI1                        ((NRF_TWI_Type            *) NRF_TWI1_BASE)
N#define NRF_SPIS1                       ((NRF_SPIS_Type           *) NRF_SPIS1_BASE)
N#define NRF_GPIOTE                      ((NRF_GPIOTE_Type         *) NRF_GPIOTE_BASE)
N#define NRF_ADC                         ((NRF_ADC_Type            *) NRF_ADC_BASE)
N#define NRF_TIMER0                      ((NRF_TIMER_Type          *) NRF_TIMER0_BASE)
N#define NRF_TIMER1                      ((NRF_TIMER_Type          *) NRF_TIMER1_BASE)
N#define NRF_TIMER2                      ((NRF_TIMER_Type          *) NRF_TIMER2_BASE)
N#define NRF_RTC0                        ((NRF_RTC_Type            *) NRF_RTC0_BASE)
N#define NRF_TEMP                        ((NRF_TEMP_Type           *) NRF_TEMP_BASE)
N#define NRF_RNG                         ((NRF_RNG_Type            *) NRF_RNG_BASE)
N#define NRF_ECB                         ((NRF_ECB_Type            *) NRF_ECB_BASE)
N#define NRF_AAR                         ((NRF_AAR_Type            *) NRF_AAR_BASE)
N#define NRF_CCM                         ((NRF_CCM_Type            *) NRF_CCM_BASE)
N#define NRF_WDT                         ((NRF_WDT_Type            *) NRF_WDT_BASE)
N#define NRF_RTC1                        ((NRF_RTC_Type            *) NRF_RTC1_BASE)
N#define NRF_QDEC                        ((NRF_QDEC_Type           *) NRF_QDEC_BASE)
N#define NRF_LPCOMP                      ((NRF_LPCOMP_Type         *) NRF_LPCOMP_BASE)
N#define NRF_SWI                         ((NRF_SWI_Type            *) NRF_SWI_BASE)
N#define NRF_NVMC                        ((NRF_NVMC_Type           *) NRF_NVMC_BASE)
N#define NRF_PPI                         ((NRF_PPI_Type            *) NRF_PPI_BASE)
N#define NRF_FICR                        ((NRF_FICR_Type           *) NRF_FICR_BASE)
N#define NRF_UICR                        ((NRF_UICR_Type           *) NRF_UICR_BASE)
N#define NRF_GPIO                        ((NRF_GPIO_Type           *) NRF_GPIO_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group nrf51 */
N/** @} */ /* End of group Nordic Semiconductor */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* nrf51_H */
N
L 63 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 2
N        #include "nrf51_bitfields.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51_bitfields.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef __NRF51_BITS_H
N#define __NRF51_BITS_H
N
N/*lint ++flb "Enter library region" */
N
N/* Peripheral: AAR */
N/* Description: Accelerated Address Resolver. */
N
N/* Register: AAR_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on NOTRESOLVED event. */
N#define AAR_INTENSET_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Msk (0x1UL << AAR_INTENSET_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_NOTRESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on RESOLVED event. */
N#define AAR_INTENSET_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Msk (0x1UL << AAR_INTENSET_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_RESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define AAR_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENSET_END_Msk (0x1UL << AAR_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: AAR_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on NOTRESOLVED event. */
N#define AAR_INTENCLR_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Msk (0x1UL << AAR_INTENCLR_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on RESOLVED event. */
N#define AAR_INTENCLR_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Msk (0x1UL << AAR_INTENCLR_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_RESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define AAR_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENCLR_END_Msk (0x1UL << AAR_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: AAR_STATUS */
N/* Description: Resolution status. */
N
N/* Bits 3..0 : The IRK used last time an address was resolved. */
N#define AAR_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define AAR_STATUS_STATUS_Msk (0xFUL << AAR_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
N
N/* Register: AAR_ENABLE */
N/* Description: Enable AAR. */
N
N/* Bits 1..0 : Enable AAR. */
N#define AAR_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Msk (0x3UL << AAR_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled AAR. */
N#define AAR_ENABLE_ENABLE_Enabled (0x03UL) /*!< Enable AAR. */
N
N/* Register: AAR_NIRK */
N/* Description: Number of Identity root Keys in the IRK data structure. */
N
N/* Bits 4..0 : Number of Identity root Keys in the IRK data structure. */
N#define AAR_NIRK_NIRK_Pos (0UL) /*!< Position of NIRK field. */
N#define AAR_NIRK_NIRK_Msk (0x1FUL << AAR_NIRK_NIRK_Pos) /*!< Bit mask of NIRK field. */
N
N/* Register: AAR_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define AAR_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define AAR_POWER_POWER_Msk (0x1UL << AAR_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define AAR_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define AAR_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: ADC */
N/* Description: Analog to digital converter. */
N
N/* Register: ADC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define ADC_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENSET_END_Msk (0x1UL << ADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ADC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on END event. */
N#define ADC_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENCLR_END_Msk (0x1UL << ADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ADC_BUSY */
N/* Description: ADC busy register. */
N
N/* Bit 0 : ADC busy register. */
N#define ADC_BUSY_BUSY_Pos (0UL) /*!< Position of BUSY field. */
N#define ADC_BUSY_BUSY_Msk (0x1UL << ADC_BUSY_BUSY_Pos) /*!< Bit mask of BUSY field. */
N#define ADC_BUSY_BUSY_Ready (0UL) /*!< No ongoing ADC conversion is taking place. ADC is ready. */
N#define ADC_BUSY_BUSY_Busy (1UL) /*!< An ADC conversion is taking place. ADC is busy. */
N
N/* Register: ADC_ENABLE */
N/* Description: ADC enable. */
N
N/* Bits 1..0 : ADC enable. */
N#define ADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Msk (0x3UL << ADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Disabled (0x00UL) /*!< ADC is disabled. */
N#define ADC_ENABLE_ENABLE_Enabled (0x01UL) /*!< ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input. */
N
N/* Register: ADC_CONFIG */
N/* Description: ADC configuration register. */
N
N/* Bits 17..16 : ADC external reference pin selection. */
N#define ADC_CONFIG_EXTREFSEL_Pos (16UL) /*!< Position of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_Msk (0x3UL << ADC_CONFIG_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_None (0UL) /*!< Analog external reference inputs disabled. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference0 (1UL) /*!< Use analog reference 0 as reference. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference1 (2UL) /*!< Use analog reference 1 as reference. */
N
N/* Bits 15..8 : ADC analog pin selection. */
N#define ADC_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define ADC_CONFIG_PSEL_Msk (0xFFUL << ADC_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define ADC_CONFIG_PSEL_Disabled (0UL) /*!< Analog input pins disabled. */
N#define ADC_CONFIG_PSEL_AnalogInput0 (1UL) /*!< Use analog input 0 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput1 (2UL) /*!< Use analog input 1 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput2 (4UL) /*!< Use analog input 2 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput3 (8UL) /*!< Use analog input 3 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput4 (16UL) /*!< Use analog input 4 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput5 (32UL) /*!< Use analog input 5 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput6 (64UL) /*!< Use analog input 6 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput7 (128UL) /*!< Use analog input 7 as analog input. */
N
N/* Bits 6..5 : ADC reference selection. */
N#define ADC_CONFIG_REFSEL_Pos (5UL) /*!< Position of REFSEL field. */
N#define ADC_CONFIG_REFSEL_Msk (0x3UL << ADC_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define ADC_CONFIG_REFSEL_VBG (0x00UL) /*!< Use internal 1.2V bandgap voltage as reference for conversion. */
N#define ADC_CONFIG_REFSEL_External (0x01UL) /*!< Use external source configured by EXTREFSEL as reference for conversion. */
N#define ADC_CONFIG_REFSEL_SupplyOneHalfPrescaling (0x02UL) /*!< Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V. */
N#define ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling (0x03UL) /*!< Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V. */
N
N/* Bits 4..2 : ADC input selection. */
N#define ADC_CONFIG_INPSEL_Pos (2UL) /*!< Position of INPSEL field. */
N#define ADC_CONFIG_INPSEL_Msk (0x7UL << ADC_CONFIG_INPSEL_Pos) /*!< Bit mask of INPSEL field. */
N#define ADC_CONFIG_INPSEL_AnalogInputNoPrescaling (0x00UL) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputTwoThirdsPrescaling (0x01UL) /*!< Analog input specified by PSEL with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling (0x02UL) /*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyTwoThirdsPrescaling (0x05UL) /*!< Supply voltage with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling (0x06UL) /*!< Supply voltage with 1/3 prescaling used as input for the conversion. */
N
N/* Bits 1..0 : ADC resolution. */
N#define ADC_CONFIG_RES_Pos (0UL) /*!< Position of RES field. */
N#define ADC_CONFIG_RES_Msk (0x3UL << ADC_CONFIG_RES_Pos) /*!< Bit mask of RES field. */
N#define ADC_CONFIG_RES_8bit (0x00UL) /*!< 8bit ADC resolution. */
N#define ADC_CONFIG_RES_9bit (0x01UL) /*!< 9bit ADC resolution. */
N#define ADC_CONFIG_RES_10bit (0x02UL) /*!< 10bit ADC resolution. */
N
N/* Register: ADC_RESULT */
N/* Description: Result of ADC conversion. */
N
N/* Bits 9..0 : Result of ADC conversion. */
N#define ADC_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define ADC_RESULT_RESULT_Msk (0x3FFUL << ADC_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N
N/* Register: ADC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ADC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ADC_POWER_POWER_Msk (0x1UL << ADC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ADC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ADC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: CCM */
N/* Description: AES CCM Mode Encryption. */
N
N/* Register: CCM_SHORTS */
N/* Description: Shortcuts for the CCM. */
N
N/* Bit 0 : Shortcut between ENDKSGEN event and CRYPT task. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Pos (0UL) /*!< Position of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Msk (0x1UL << CCM_SHORTS_ENDKSGEN_CRYPT_Pos) /*!< Bit mask of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Disabled (0UL) /*!< Shortcut disabled. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: CCM_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ERROR event. */
N#define CCM_INTENSET_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENSET_ERROR_Msk (0x1UL << CCM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ENDCRYPT event. */
N#define CCM_INTENSET_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Msk (0x1UL << CCM_INTENSET_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDCRYPT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDKSGEN event. */
N#define CCM_INTENSET_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Msk (0x1UL << CCM_INTENSET_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDKSGEN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CCM_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ERROR event. */
N#define CCM_INTENCLR_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENCLR_ERROR_Msk (0x1UL << CCM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ENDCRYPT event. */
N#define CCM_INTENCLR_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Msk (0x1UL << CCM_INTENCLR_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDCRYPT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define CCM_INTENCLR_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Msk (0x1UL << CCM_INTENCLR_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDKSGEN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CCM_MICSTATUS */
N/* Description: CCM RX MIC check result. */
N
N/* Bit 0 : Result of the MIC check performed during the previous CCM RX STARTCRYPT */
N#define CCM_MICSTATUS_MICSTATUS_Pos (0UL) /*!< Position of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_Msk (0x1UL << CCM_MICSTATUS_MICSTATUS_Pos) /*!< Bit mask of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_CheckFailed (0UL) /*!< MIC check failed. */
N#define CCM_MICSTATUS_MICSTATUS_CheckPassed (1UL) /*!< MIC check passed. */
N
N/* Register: CCM_ENABLE */
N/* Description: CCM enable. */
N
N/* Bits 1..0 : CCM enable. */
N#define CCM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Msk (0x3UL << CCM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Disabled (0x00UL) /*!< CCM is disabled. */
N#define CCM_ENABLE_ENABLE_Enabled (0x02UL) /*!< CCM is enabled. */
N
N/* Register: CCM_MODE */
N/* Description: Operation mode. */
N
N/* Bit 0 : CCM mode operation. */
N#define CCM_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define CCM_MODE_MODE_Msk (0x1UL << CCM_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define CCM_MODE_MODE_Encryption (0UL) /*!< CCM mode TX */
N#define CCM_MODE_MODE_Decryption (1UL) /*!< CCM mode TX */
N
N/* Register: CCM_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define CCM_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define CCM_POWER_POWER_Msk (0x1UL << CCM_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define CCM_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define CCM_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: CLOCK */
N/* Description: Clock control. */
N
N/* Register: CLOCK_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 4 : Enable interrupt on CTTO event. */
N#define CLOCK_INTENSET_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Msk (0x1UL << CLOCK_INTENSET_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_CTTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on DONE event. */
N#define CLOCK_INTENSET_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENSET_DONE_Msk (0x1UL << CLOCK_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENSET_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_DONE_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CLOCK_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 4 : Disable interrupt on CTTO event. */
N#define CLOCK_INTENCLR_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Msk (0x1UL << CLOCK_INTENCLR_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_CTTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on DONE event. */
N#define CLOCK_INTENCLR_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENCLR_DONE_Msk (0x1UL << CLOCK_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENCLR_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_DONE_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CLOCK_HFCLKRUN */
N/* Description: Task HFCLKSTART trigger status. */
N
N/* Bit 0 : Task HFCLKSTART trigger status. */
N#define CLOCK_HFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define CLOCK_HFCLKRUN_STATUS_Msk (0x1UL << CLOCK_HFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
N#define CLOCK_HFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task HFCLKSTART has not been triggered. */
N#define CLOCK_HFCLKRUN_STATUS_Triggered (1UL) /*!< Task HFCLKSTART has been triggered. */
N
N/* Register: CLOCK_HFCLKSTAT */
N/* Description: High frequency clock status. */
N
N/* Bit 16 : State for the HFCLK. */
N#define CLOCK_HFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_Msk (0x1UL << CLOCK_HFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_NotRunning (0UL) /*!< HFCLK clock not running. */
N#define CLOCK_HFCLKSTAT_STATE_Running (1UL) /*!< HFCLK clock running. */
N
N/* Bit 0 : Active clock source for the HF clock. */
N#define CLOCK_HFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_Msk (0x1UL << CLOCK_HFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_RC (0UL) /*!< Internal 16MHz RC oscillator running and generating the HFCLK clock. */
N#define CLOCK_HFCLKSTAT_SRC_Xtal (1UL) /*!< External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock. */
N
N/* Register: CLOCK_LFCLKRUN */
N/* Description: Task LFCLKSTART triggered status. */
N
N/* Bit 0 : Task LFCLKSTART triggered status. */
N#define CLOCK_LFCLKRUN_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define CLOCK_LFCLKRUN_STATUS_Msk (0x1UL << CLOCK_LFCLKRUN_STATUS_Pos) /*!< Bit mask of STATUS field. */
N#define CLOCK_LFCLKRUN_STATUS_NotTriggered (0UL) /*!< Task LFCLKSTART has not been triggered. */
N#define CLOCK_LFCLKRUN_STATUS_Triggered (1UL) /*!< Task LFCLKSTART has been triggered. */
N
N/* Register: CLOCK_LFCLKSTAT */
N/* Description: Low frequency clock status. */
N
N/* Bit 16 : State for the LF clock. */
N#define CLOCK_LFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_Msk (0x1UL << CLOCK_LFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_NotRunning (0UL) /*!< LFCLK clock not running. */
N#define CLOCK_LFCLKSTAT_STATE_Running (1UL) /*!< LFCLK clock running. */
N
N/* Bits 1..0 : Active clock source for the LF clock. */
N#define CLOCK_LFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_Msk (0x3UL << CLOCK_LFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Xtal (1UL) /*!< External 32KiHz crystal oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock. */
N
N/* Register: CLOCK_LFCLKSRCCOPY */
N/* Description: Clock source for the LFCLK clock, set when task LKCLKSTART is triggered. */
N
N/* Bits 1..0 : Clock source for the LFCLK clock, set when task LKCLKSTART is triggered. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Msk (0x3UL << CLOCK_LFCLKSRCCOPY_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRCCOPY_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Xtal (1UL) /*!< External 32KiHz crystal. */
N#define CLOCK_LFCLKSRCCOPY_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from HFCLK system clock. */
N
N/* Register: CLOCK_LFCLKSRC */
N/* Description: Clock source for the LFCLK clock. */
N
N/* Bits 1..0 : Clock source. */
N#define CLOCK_LFCLKSRC_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_Msk (0x3UL << CLOCK_LFCLKSRC_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator. */
N#define CLOCK_LFCLKSRC_SRC_Xtal (1UL) /*!< External 32KiHz crystal. */
N#define CLOCK_LFCLKSRC_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from HFCLK system clock. */
N
N/* Register: CLOCK_CTIV */
N/* Description: Calibration timer interval. */
N
N/* Bits 6..0 : Calibration timer interval in 0.25s resolution. */
N#define CLOCK_CTIV_CTIV_Pos (0UL) /*!< Position of CTIV field. */
N#define CLOCK_CTIV_CTIV_Msk (0x7FUL << CLOCK_CTIV_CTIV_Pos) /*!< Bit mask of CTIV field. */
N
N/* Register: CLOCK_XTALFREQ */
N/* Description: Crystal frequency. */
N
N/* Bits 7..0 : External Xtal frequency selection. */
N#define CLOCK_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_Msk (0xFFUL << CLOCK_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz xtal is used as source for the HFCLK oscillator. */
N#define CLOCK_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz xtal is used as source for the HFCLK oscillator. */
N
N
N/* Peripheral: ECB */
N/* Description: AES ECB Mode Encryption. */
N
N/* Register: ECB_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 1 : Enable interrupt on ERRORECB event. */
N#define ECB_INTENSET_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Msk (0x1UL << ECB_INTENSET_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ERRORECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDECB event. */
N#define ECB_INTENSET_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Msk (0x1UL << ECB_INTENSET_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ENDECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ECB_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 1 : Disable interrupt on ERRORECB event. */
N#define ECB_INTENCLR_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Msk (0x1UL << ECB_INTENCLR_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ERRORECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDECB event. */
N#define ECB_INTENCLR_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Msk (0x1UL << ECB_INTENCLR_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ENDECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ECB_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ECB_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ECB_POWER_POWER_Msk (0x1UL << ECB_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ECB_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ECB_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: FICR */
N/* Description: Factory Information Configuration. */
N
N/* Register: FICR_PPFC */
N/* Description: Pre-programmed factory code present. */
N
N/* Bits 7..0 : Pre-programmed factory code present. */
N#define FICR_PPFC_PPFC_Pos (0UL) /*!< Position of PPFC field. */
N#define FICR_PPFC_PPFC_Msk (0xFFUL << FICR_PPFC_PPFC_Pos) /*!< Bit mask of PPFC field. */
N#define FICR_PPFC_PPFC_Present (0x00UL) /*!< Present. */
N#define FICR_PPFC_PPFC_NotPresent (0xFFUL) /*!< Not present. */
N
N/* Register: FICR_CONFIGID */
N/* Description: Configuration identifier. */
N
N/* Bits 31..16 : Firmware Identification Number pre-loaded into the flash. */
N#define FICR_CONFIGID_FWID_Pos (16UL) /*!< Position of FWID field. */
N#define FICR_CONFIGID_FWID_Msk (0xFFFFUL << FICR_CONFIGID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N/* Bits 15..0 : Hardware Identification Number. */
N#define FICR_CONFIGID_HWID_Pos (0UL) /*!< Position of HWID field. */
N#define FICR_CONFIGID_HWID_Msk (0xFFFFUL << FICR_CONFIGID_HWID_Pos) /*!< Bit mask of HWID field. */
N
N/* Register: FICR_DEVICEADDRTYPE */
N/* Description: Device address type. */
N
N/* Bit 0 : Device address type. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address. */
N
N/* Register: FICR_OVERRIDEEN */
N/* Description: Radio calibration override enable. */
N
N/* Bit 3 : Override default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Pos (3UL) /*!< Position of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Msk (0x1UL << FICR_OVERRIDEEN_BLE_1MBIT_Pos) /*!< Bit mask of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Override (0UL) /*!< Override the default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_NotOverride (1UL) /*!< Do not override the default values for BLE_1Mbit mode. */
N
N/* Bit 0 : Override default values for NRF_1Mbit mode. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_Pos (0UL) /*!< Position of NRF_1MBIT field. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_Msk (0x1UL << FICR_OVERRIDEEN_NRF_1MBIT_Pos) /*!< Bit mask of NRF_1MBIT field. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_Override (0UL) /*!< Override the default values for NRF_1Mbit mode. */
N#define FICR_OVERRIDEEN_NRF_1MBIT_NotOverride (1UL) /*!< Do not override the default values for NRF_1Mbit mode. */
N
N
N/* Peripheral: GPIO */
N/* Description: General purpose input and output. */
N
N/* Register: GPIO_OUT */
N/* Description: Write GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUT_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUT_PIN31_Msk (0x1UL << GPIO_OUT_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUT_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN31_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUT_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUT_PIN30_Msk (0x1UL << GPIO_OUT_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUT_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN30_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUT_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUT_PIN29_Msk (0x1UL << GPIO_OUT_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUT_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN29_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUT_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUT_PIN28_Msk (0x1UL << GPIO_OUT_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUT_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN28_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUT_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUT_PIN27_Msk (0x1UL << GPIO_OUT_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUT_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN27_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUT_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUT_PIN26_Msk (0x1UL << GPIO_OUT_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUT_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN26_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUT_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUT_PIN25_Msk (0x1UL << GPIO_OUT_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUT_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN25_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUT_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUT_PIN24_Msk (0x1UL << GPIO_OUT_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUT_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN24_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUT_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUT_PIN23_Msk (0x1UL << GPIO_OUT_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUT_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN23_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUT_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUT_PIN22_Msk (0x1UL << GPIO_OUT_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUT_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN22_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUT_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUT_PIN21_Msk (0x1UL << GPIO_OUT_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUT_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN21_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUT_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUT_PIN20_Msk (0x1UL << GPIO_OUT_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUT_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN20_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUT_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUT_PIN19_Msk (0x1UL << GPIO_OUT_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUT_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN19_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUT_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUT_PIN18_Msk (0x1UL << GPIO_OUT_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUT_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN18_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUT_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUT_PIN17_Msk (0x1UL << GPIO_OUT_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUT_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN17_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUT_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUT_PIN16_Msk (0x1UL << GPIO_OUT_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUT_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN16_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUT_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUT_PIN15_Msk (0x1UL << GPIO_OUT_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUT_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN15_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUT_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUT_PIN14_Msk (0x1UL << GPIO_OUT_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUT_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN14_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUT_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUT_PIN13_Msk (0x1UL << GPIO_OUT_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUT_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN13_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUT_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUT_PIN12_Msk (0x1UL << GPIO_OUT_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUT_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN12_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUT_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUT_PIN11_Msk (0x1UL << GPIO_OUT_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUT_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN11_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUT_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUT_PIN10_Msk (0x1UL << GPIO_OUT_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUT_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN10_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUT_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUT_PIN9_Msk (0x1UL << GPIO_OUT_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUT_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN9_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUT_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUT_PIN8_Msk (0x1UL << GPIO_OUT_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUT_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN8_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUT_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUT_PIN7_Msk (0x1UL << GPIO_OUT_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUT_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN7_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUT_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUT_PIN6_Msk (0x1UL << GPIO_OUT_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUT_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN6_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUT_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUT_PIN5_Msk (0x1UL << GPIO_OUT_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUT_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN5_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUT_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUT_PIN4_Msk (0x1UL << GPIO_OUT_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUT_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN4_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUT_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUT_PIN3_Msk (0x1UL << GPIO_OUT_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUT_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN3_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUT_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUT_PIN2_Msk (0x1UL << GPIO_OUT_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUT_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN2_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUT_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUT_PIN1_Msk (0x1UL << GPIO_OUT_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUT_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN1_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUT_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUT_PIN0_Msk (0x1UL << GPIO_OUT_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUT_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN0_High (1UL) /*!< Pin driver is high. */
N
N/* Register: GPIO_OUTSET */
N/* Description: Set individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Msk (0x1UL << GPIO_OUTSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN31_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Msk (0x1UL << GPIO_OUTSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN30_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Msk (0x1UL << GPIO_OUTSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN29_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Msk (0x1UL << GPIO_OUTSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN28_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Msk (0x1UL << GPIO_OUTSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN27_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Msk (0x1UL << GPIO_OUTSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN26_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Msk (0x1UL << GPIO_OUTSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN25_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Msk (0x1UL << GPIO_OUTSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN24_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Msk (0x1UL << GPIO_OUTSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN23_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Msk (0x1UL << GPIO_OUTSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN22_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Msk (0x1UL << GPIO_OUTSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN21_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Msk (0x1UL << GPIO_OUTSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN20_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Msk (0x1UL << GPIO_OUTSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN19_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Msk (0x1UL << GPIO_OUTSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN18_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Msk (0x1UL << GPIO_OUTSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN17_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Msk (0x1UL << GPIO_OUTSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN16_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Msk (0x1UL << GPIO_OUTSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN15_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Msk (0x1UL << GPIO_OUTSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN14_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Msk (0x1UL << GPIO_OUTSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN13_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Msk (0x1UL << GPIO_OUTSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN12_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Msk (0x1UL << GPIO_OUTSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN11_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Msk (0x1UL << GPIO_OUTSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN10_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Msk (0x1UL << GPIO_OUTSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN9_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Msk (0x1UL << GPIO_OUTSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN8_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Msk (0x1UL << GPIO_OUTSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN7_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Msk (0x1UL << GPIO_OUTSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN6_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Msk (0x1UL << GPIO_OUTSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN5_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Msk (0x1UL << GPIO_OUTSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN4_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Msk (0x1UL << GPIO_OUTSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN3_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Msk (0x1UL << GPIO_OUTSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN2_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Msk (0x1UL << GPIO_OUTSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN1_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Msk (0x1UL << GPIO_OUTSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN0_Set (1UL) /*!< Set pin driver high. */
N
N/* Register: GPIO_OUTCLR */
N/* Description: Clear individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Msk (0x1UL << GPIO_OUTCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN31_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Msk (0x1UL << GPIO_OUTCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN30_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Msk (0x1UL << GPIO_OUTCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN29_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Msk (0x1UL << GPIO_OUTCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN28_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Msk (0x1UL << GPIO_OUTCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN27_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Msk (0x1UL << GPIO_OUTCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN26_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Msk (0x1UL << GPIO_OUTCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN25_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Msk (0x1UL << GPIO_OUTCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN24_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Msk (0x1UL << GPIO_OUTCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN23_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Msk (0x1UL << GPIO_OUTCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN22_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Msk (0x1UL << GPIO_OUTCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN21_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Msk (0x1UL << GPIO_OUTCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN20_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Msk (0x1UL << GPIO_OUTCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN19_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Msk (0x1UL << GPIO_OUTCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN18_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Msk (0x1UL << GPIO_OUTCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN17_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Msk (0x1UL << GPIO_OUTCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN16_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Msk (0x1UL << GPIO_OUTCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN15_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Msk (0x1UL << GPIO_OUTCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN14_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Msk (0x1UL << GPIO_OUTCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN13_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Msk (0x1UL << GPIO_OUTCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN12_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Msk (0x1UL << GPIO_OUTCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN11_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Msk (0x1UL << GPIO_OUTCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN10_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Msk (0x1UL << GPIO_OUTCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN9_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Msk (0x1UL << GPIO_OUTCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN8_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Msk (0x1UL << GPIO_OUTCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN7_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Msk (0x1UL << GPIO_OUTCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN6_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Msk (0x1UL << GPIO_OUTCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN5_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Msk (0x1UL << GPIO_OUTCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN4_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Msk (0x1UL << GPIO_OUTCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN3_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Msk (0x1UL << GPIO_OUTCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN2_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Msk (0x1UL << GPIO_OUTCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN1_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Msk (0x1UL << GPIO_OUTCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN0_Clear (1UL) /*!< Set pin driver low. */
N
N/* Register: GPIO_IN */
N/* Description: Read GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_IN_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_IN_PIN31_Msk (0x1UL << GPIO_IN_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_IN_PIN31_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN31_High (1UL) /*!< Pin input is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_IN_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_IN_PIN30_Msk (0x1UL << GPIO_IN_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_IN_PIN30_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN30_High (1UL) /*!< Pin input is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_IN_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_IN_PIN29_Msk (0x1UL << GPIO_IN_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_IN_PIN29_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN29_High (1UL) /*!< Pin input is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_IN_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_IN_PIN28_Msk (0x1UL << GPIO_IN_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_IN_PIN28_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN28_High (1UL) /*!< Pin input is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_IN_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_IN_PIN27_Msk (0x1UL << GPIO_IN_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_IN_PIN27_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN27_High (1UL) /*!< Pin input is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_IN_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_IN_PIN26_Msk (0x1UL << GPIO_IN_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_IN_PIN26_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN26_High (1UL) /*!< Pin input is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_IN_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_IN_PIN25_Msk (0x1UL << GPIO_IN_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_IN_PIN25_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN25_High (1UL) /*!< Pin input is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_IN_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_IN_PIN24_Msk (0x1UL << GPIO_IN_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_IN_PIN24_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN24_High (1UL) /*!< Pin input is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_IN_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_IN_PIN23_Msk (0x1UL << GPIO_IN_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_IN_PIN23_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN23_High (1UL) /*!< Pin input is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_IN_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_IN_PIN22_Msk (0x1UL << GPIO_IN_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_IN_PIN22_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN22_High (1UL) /*!< Pin input is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_IN_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_IN_PIN21_Msk (0x1UL << GPIO_IN_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_IN_PIN21_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN21_High (1UL) /*!< Pin input is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_IN_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_IN_PIN20_Msk (0x1UL << GPIO_IN_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_IN_PIN20_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN20_High (1UL) /*!< Pin input is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_IN_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_IN_PIN19_Msk (0x1UL << GPIO_IN_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_IN_PIN19_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN19_High (1UL) /*!< Pin input is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_IN_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_IN_PIN18_Msk (0x1UL << GPIO_IN_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_IN_PIN18_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN18_High (1UL) /*!< Pin input is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_IN_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_IN_PIN17_Msk (0x1UL << GPIO_IN_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_IN_PIN17_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN17_High (1UL) /*!< Pin input is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_IN_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_IN_PIN16_Msk (0x1UL << GPIO_IN_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_IN_PIN16_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN16_High (1UL) /*!< Pin input is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_IN_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_IN_PIN15_Msk (0x1UL << GPIO_IN_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_IN_PIN15_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN15_High (1UL) /*!< Pin input is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_IN_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_IN_PIN14_Msk (0x1UL << GPIO_IN_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_IN_PIN14_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN14_High (1UL) /*!< Pin input is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_IN_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_IN_PIN13_Msk (0x1UL << GPIO_IN_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_IN_PIN13_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN13_High (1UL) /*!< Pin input is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_IN_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_IN_PIN12_Msk (0x1UL << GPIO_IN_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_IN_PIN12_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN12_High (1UL) /*!< Pin input is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_IN_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_IN_PIN11_Msk (0x1UL << GPIO_IN_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_IN_PIN11_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN11_High (1UL) /*!< Pin input is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_IN_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_IN_PIN10_Msk (0x1UL << GPIO_IN_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_IN_PIN10_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN10_High (1UL) /*!< Pin input is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_IN_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_IN_PIN9_Msk (0x1UL << GPIO_IN_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_IN_PIN9_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN9_High (1UL) /*!< Pin input is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_IN_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_IN_PIN8_Msk (0x1UL << GPIO_IN_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_IN_PIN8_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN8_High (1UL) /*!< Pin input is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_IN_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_IN_PIN7_Msk (0x1UL << GPIO_IN_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_IN_PIN7_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN7_High (1UL) /*!< Pin input is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_IN_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_IN_PIN6_Msk (0x1UL << GPIO_IN_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_IN_PIN6_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN6_High (1UL) /*!< Pin input is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_IN_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_IN_PIN5_Msk (0x1UL << GPIO_IN_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_IN_PIN5_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN5_High (1UL) /*!< Pin input is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_IN_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_IN_PIN4_Msk (0x1UL << GPIO_IN_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_IN_PIN4_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN4_High (1UL) /*!< Pin input is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_IN_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_IN_PIN3_Msk (0x1UL << GPIO_IN_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_IN_PIN3_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN3_High (1UL) /*!< Pin input is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_IN_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_IN_PIN2_Msk (0x1UL << GPIO_IN_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_IN_PIN2_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN2_High (1UL) /*!< Pin input is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_IN_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_IN_PIN1_Msk (0x1UL << GPIO_IN_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_IN_PIN1_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN1_High (1UL) /*!< Pin input is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_IN_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_IN_PIN0_Msk (0x1UL << GPIO_IN_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_IN_PIN0_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN0_High (1UL) /*!< Pin input is high. */
N
N/* Register: GPIO_DIR */
N/* Description: Direction of GPIO pins. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_DIR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIR_PIN31_Msk (0x1UL << GPIO_DIR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN31_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_DIR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIR_PIN30_Msk (0x1UL << GPIO_DIR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN30_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_DIR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIR_PIN29_Msk (0x1UL << GPIO_DIR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN29_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_DIR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIR_PIN28_Msk (0x1UL << GPIO_DIR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN28_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_DIR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIR_PIN27_Msk (0x1UL << GPIO_DIR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN27_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_DIR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIR_PIN26_Msk (0x1UL << GPIO_DIR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN26_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_DIR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIR_PIN25_Msk (0x1UL << GPIO_DIR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN25_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_DIR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIR_PIN24_Msk (0x1UL << GPIO_DIR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN24_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_DIR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIR_PIN23_Msk (0x1UL << GPIO_DIR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN23_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_DIR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIR_PIN22_Msk (0x1UL << GPIO_DIR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN22_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_DIR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIR_PIN21_Msk (0x1UL << GPIO_DIR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN21_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_DIR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIR_PIN20_Msk (0x1UL << GPIO_DIR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN20_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_DIR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIR_PIN19_Msk (0x1UL << GPIO_DIR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN19_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_DIR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIR_PIN18_Msk (0x1UL << GPIO_DIR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN18_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_DIR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIR_PIN17_Msk (0x1UL << GPIO_DIR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN17_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_DIR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIR_PIN16_Msk (0x1UL << GPIO_DIR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN16_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_DIR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIR_PIN15_Msk (0x1UL << GPIO_DIR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN15_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_DIR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIR_PIN14_Msk (0x1UL << GPIO_DIR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN14_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_DIR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIR_PIN13_Msk (0x1UL << GPIO_DIR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN13_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_DIR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIR_PIN12_Msk (0x1UL << GPIO_DIR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN12_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_DIR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIR_PIN11_Msk (0x1UL << GPIO_DIR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN11_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_DIR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIR_PIN10_Msk (0x1UL << GPIO_DIR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN10_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_DIR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIR_PIN9_Msk (0x1UL << GPIO_DIR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN9_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_DIR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIR_PIN8_Msk (0x1UL << GPIO_DIR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN8_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_DIR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIR_PIN7_Msk (0x1UL << GPIO_DIR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN7_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_DIR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIR_PIN6_Msk (0x1UL << GPIO_DIR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN6_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_DIR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIR_PIN5_Msk (0x1UL << GPIO_DIR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN5_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_DIR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIR_PIN4_Msk (0x1UL << GPIO_DIR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN4_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_DIR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIR_PIN3_Msk (0x1UL << GPIO_DIR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN3_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_DIR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIR_PIN2_Msk (0x1UL << GPIO_DIR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN2_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_DIR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIR_PIN1_Msk (0x1UL << GPIO_DIR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN1_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_DIR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIR_PIN0_Msk (0x1UL << GPIO_DIR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN0_Output (1UL) /*!< Pin set as output. */
N
N/* Register: GPIO_DIRSET */
N/* Description: DIR set register. */
N
N/* Bit 31 : Set as output pin 31. */
N#define GPIO_DIRSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Msk (0x1UL << GPIO_DIRSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN31_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 30 : Set as output pin 30. */
N#define GPIO_DIRSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Msk (0x1UL << GPIO_DIRSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN30_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 29 : Set as output pin 29. */
N#define GPIO_DIRSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Msk (0x1UL << GPIO_DIRSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN29_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 28 : Set as output pin 28. */
N#define GPIO_DIRSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Msk (0x1UL << GPIO_DIRSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN28_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 27 : Set as output pin 27. */
N#define GPIO_DIRSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Msk (0x1UL << GPIO_DIRSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN27_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 26 : Set as output pin 26. */
N#define GPIO_DIRSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Msk (0x1UL << GPIO_DIRSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN26_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 25 : Set as output pin 25. */
N#define GPIO_DIRSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Msk (0x1UL << GPIO_DIRSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN25_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 24 : Set as output pin 24. */
N#define GPIO_DIRSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Msk (0x1UL << GPIO_DIRSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN24_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 23 : Set as output pin 23. */
N#define GPIO_DIRSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Msk (0x1UL << GPIO_DIRSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN23_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 22 : Set as output pin 22. */
N#define GPIO_DIRSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Msk (0x1UL << GPIO_DIRSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN22_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 21 : Set as output pin 21. */
N#define GPIO_DIRSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Msk (0x1UL << GPIO_DIRSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN21_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 20 : Set as output pin 20. */
N#define GPIO_DIRSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Msk (0x1UL << GPIO_DIRSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN20_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 19 : Set as output pin 19. */
N#define GPIO_DIRSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Msk (0x1UL << GPIO_DIRSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN19_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 18 : Set as output pin 18. */
N#define GPIO_DIRSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Msk (0x1UL << GPIO_DIRSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN18_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 17 : Set as output pin 17. */
N#define GPIO_DIRSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Msk (0x1UL << GPIO_DIRSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN17_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 16 : Set as output pin 16. */
N#define GPIO_DIRSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Msk (0x1UL << GPIO_DIRSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN16_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 15 : Set as output pin 15. */
N#define GPIO_DIRSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Msk (0x1UL << GPIO_DIRSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN15_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 14 : Set as output pin 14. */
N#define GPIO_DIRSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Msk (0x1UL << GPIO_DIRSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN14_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 13 : Set as output pin 13. */
N#define GPIO_DIRSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Msk (0x1UL << GPIO_DIRSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN13_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 12 : Set as output pin 12. */
N#define GPIO_DIRSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Msk (0x1UL << GPIO_DIRSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN12_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 11 : Set as output pin 11. */
N#define GPIO_DIRSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Msk (0x1UL << GPIO_DIRSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN11_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 10 : Set as output pin 10. */
N#define GPIO_DIRSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Msk (0x1UL << GPIO_DIRSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN10_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 9 : Set as output pin 9. */
N#define GPIO_DIRSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Msk (0x1UL << GPIO_DIRSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN9_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 8 : Set as output pin 8. */
N#define GPIO_DIRSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Msk (0x1UL << GPIO_DIRSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN8_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 7 : Set as output pin 7. */
N#define GPIO_DIRSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Msk (0x1UL << GPIO_DIRSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN7_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 6 : Set as output pin 6. */
N#define GPIO_DIRSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Msk (0x1UL << GPIO_DIRSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN6_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 5 : Set as output pin 5. */
N#define GPIO_DIRSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Msk (0x1UL << GPIO_DIRSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN5_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 4 : Set as output pin 4. */
N#define GPIO_DIRSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Msk (0x1UL << GPIO_DIRSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN4_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 3 : Set as output pin 3. */
N#define GPIO_DIRSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Msk (0x1UL << GPIO_DIRSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN3_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 2 : Set as output pin 2. */
N#define GPIO_DIRSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Msk (0x1UL << GPIO_DIRSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN2_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 1 : Set as output pin 1. */
N#define GPIO_DIRSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Msk (0x1UL << GPIO_DIRSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN1_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 0 : Set as output pin 0. */
N#define GPIO_DIRSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Msk (0x1UL << GPIO_DIRSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN0_Set (1UL) /*!< Set pin as output. */
N
N/* Register: GPIO_DIRCLR */
N/* Description: DIR clear register. */
N
N/* Bit 31 : Set as input pin 31. */
N#define GPIO_DIRCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Msk (0x1UL << GPIO_DIRCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN31_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 30 : Set as input pin 30. */
N#define GPIO_DIRCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Msk (0x1UL << GPIO_DIRCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN30_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 29 : Set as input pin 29. */
N#define GPIO_DIRCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Msk (0x1UL << GPIO_DIRCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN29_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 28 : Set as input pin 28. */
N#define GPIO_DIRCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Msk (0x1UL << GPIO_DIRCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN28_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 27 : Set as input pin 27. */
N#define GPIO_DIRCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Msk (0x1UL << GPIO_DIRCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN27_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 26 : Set as input pin 26. */
N#define GPIO_DIRCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Msk (0x1UL << GPIO_DIRCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN26_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 25 : Set as input pin 25. */
N#define GPIO_DIRCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Msk (0x1UL << GPIO_DIRCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN25_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 24 : Set as input pin 24. */
N#define GPIO_DIRCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Msk (0x1UL << GPIO_DIRCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN24_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 23 : Set as input pin 23. */
N#define GPIO_DIRCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Msk (0x1UL << GPIO_DIRCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN23_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 22 : Set as input pin 22. */
N#define GPIO_DIRCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Msk (0x1UL << GPIO_DIRCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN22_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 21 : Set as input pin 21. */
N#define GPIO_DIRCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Msk (0x1UL << GPIO_DIRCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN21_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 20 : Set as input pin 20. */
N#define GPIO_DIRCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Msk (0x1UL << GPIO_DIRCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN20_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 19 : Set as input pin 19. */
N#define GPIO_DIRCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Msk (0x1UL << GPIO_DIRCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN19_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 18 : Set as input pin 18. */
N#define GPIO_DIRCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Msk (0x1UL << GPIO_DIRCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN18_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 17 : Set as input pin 17. */
N#define GPIO_DIRCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Msk (0x1UL << GPIO_DIRCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN17_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 16 : Set as input pin 16. */
N#define GPIO_DIRCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Msk (0x1UL << GPIO_DIRCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN16_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 15 : Set as input pin 15. */
N#define GPIO_DIRCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Msk (0x1UL << GPIO_DIRCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN15_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 14 : Set as input pin 14. */
N#define GPIO_DIRCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Msk (0x1UL << GPIO_DIRCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN14_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 13 : Set as input pin 13. */
N#define GPIO_DIRCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Msk (0x1UL << GPIO_DIRCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN13_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 12 : Set as input pin 12. */
N#define GPIO_DIRCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Msk (0x1UL << GPIO_DIRCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN12_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 11 : Set as input pin 11. */
N#define GPIO_DIRCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Msk (0x1UL << GPIO_DIRCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN11_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 10 : Set as input pin 10. */
N#define GPIO_DIRCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Msk (0x1UL << GPIO_DIRCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN10_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 9 : Set as input pin 9. */
N#define GPIO_DIRCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Msk (0x1UL << GPIO_DIRCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN9_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 8 : Set as input pin 8. */
N#define GPIO_DIRCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Msk (0x1UL << GPIO_DIRCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN8_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 7 : Set as input pin 7. */
N#define GPIO_DIRCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Msk (0x1UL << GPIO_DIRCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN7_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 6 : Set as input pin 6. */
N#define GPIO_DIRCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Msk (0x1UL << GPIO_DIRCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN6_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 5 : Set as input pin 5. */
N#define GPIO_DIRCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Msk (0x1UL << GPIO_DIRCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN5_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 4 : Set as input pin 4. */
N#define GPIO_DIRCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Msk (0x1UL << GPIO_DIRCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN4_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 3 : Set as input pin 3. */
N#define GPIO_DIRCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Msk (0x1UL << GPIO_DIRCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN3_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 2 : Set as input pin 2. */
N#define GPIO_DIRCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Msk (0x1UL << GPIO_DIRCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN2_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 1 : Set as input pin 1. */
N#define GPIO_DIRCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Msk (0x1UL << GPIO_DIRCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN1_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 0 : Set as input pin 0. */
N#define GPIO_DIRCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Msk (0x1UL << GPIO_DIRCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN0_Clear (1UL) /*!< Set pin as input. */
N
N/* Register: GPIO_PIN_CNF */
N/* Description: Configuration of GPIO pins. */
N
N/* Bits 17..16 : Pin sensing mechanism. */
N#define GPIO_PIN_CNF_SENSE_Pos (16UL) /*!< Position of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Msk (0x3UL << GPIO_PIN_CNF_SENSE_Pos) /*!< Bit mask of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIO_PIN_CNF_SENSE_High (0x02UL) /*!< Wakeup on high level. */
N#define GPIO_PIN_CNF_SENSE_Low (0x03UL) /*!< Wakeup on low level. */
N
N/* Bits 10..8 : Drive configuration. */
N#define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_S0S1 (0x00UL) /*!< Standard '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0S1 (0x01UL) /*!< High '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0H1 (0x02UL) /*!< Standard '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0H1 (0x03UL) /*!< High '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0S1 (0x04UL) /*!< Disconnected '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0H1 (0x05UL) /*!< Disconnected '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0D1 (0x06UL) /*!< Standard '0', Disconnected '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0D1 (0x07UL) /*!< High '0', Disconnected '1'. */
N
N/* Bits 3..2 : Pull-up or -down configuration. */
N#define GPIO_PIN_CNF_PULL_Pos (2UL) /*!< Position of PULL field. */
N#define GPIO_PIN_CNF_PULL_Msk (0x3UL << GPIO_PIN_CNF_PULL_Pos) /*!< Bit mask of PULL field. */
N#define GPIO_PIN_CNF_PULL_Disabled (0x00UL) /*!< No pull. */
N#define GPIO_PIN_CNF_PULL_Pulldown (0x01UL) /*!< Pulldown on pin. */
N#define GPIO_PIN_CNF_PULL_Pullup (0x03UL) /*!< Pullup on pin. */
N
N/* Bit 1 : Connect or disconnect input path. */
N#define GPIO_PIN_CNF_INPUT_Pos (1UL) /*!< Position of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Msk (0x1UL << GPIO_PIN_CNF_INPUT_Pos) /*!< Bit mask of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Connect (0UL) /*!< Connect input pin. */
N#define GPIO_PIN_CNF_INPUT_Disconnect (1UL) /*!< Disconnect input pin. */
N
N/* Bit 0 : Pin direction. */
N#define GPIO_PIN_CNF_DIR_Pos (0UL) /*!< Position of DIR field. */
N#define GPIO_PIN_CNF_DIR_Msk (0x1UL << GPIO_PIN_CNF_DIR_Pos) /*!< Bit mask of DIR field. */
N#define GPIO_PIN_CNF_DIR_Input (0UL) /*!< Configure pin as an input pin. */
N#define GPIO_PIN_CNF_DIR_Output (1UL) /*!< Configure pin as an output pin. */
N
N
N/* Peripheral: GPIOTE */
N/* Description: GPIO tasks and events. */
N
N/* Register: GPIOTE_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 31 : Enable interrupt on PORT event. */
N#define GPIOTE_INTENSET_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENSET_PORT_Msk (0x1UL << GPIOTE_INTENSET_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENSET_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_PORT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on IN[3] event. */
N#define GPIOTE_INTENSET_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Msk (0x1UL << GPIOTE_INTENSET_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on IN[2] event. */
N#define GPIOTE_INTENSET_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Msk (0x1UL << GPIOTE_INTENSET_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on IN[1] event. */
N#define GPIOTE_INTENSET_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Msk (0x1UL << GPIOTE_INTENSET_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on IN[0] event. */
N#define GPIOTE_INTENSET_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Msk (0x1UL << GPIOTE_INTENSET_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: GPIOTE_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 31 : Disable interrupt on PORT event. */
N#define GPIOTE_INTENCLR_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Msk (0x1UL << GPIOTE_INTENCLR_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_PORT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on IN[3] event. */
N#define GPIOTE_INTENCLR_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Msk (0x1UL << GPIOTE_INTENCLR_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on IN[2] event. */
N#define GPIOTE_INTENCLR_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Msk (0x1UL << GPIOTE_INTENCLR_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on IN[1] event. */
N#define GPIOTE_INTENCLR_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Msk (0x1UL << GPIOTE_INTENCLR_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on IN[0] event. */
N#define GPIOTE_INTENCLR_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Msk (0x1UL << GPIOTE_INTENCLR_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: GPIOTE_CONFIG */
N/* Description: Channel configuration registers. */
N
N/* Bit 20 : Initial value of the output when the GPIOTE channel is configured as a Task. */
N#define GPIOTE_CONFIG_OUTINIT_Pos (20UL) /*!< Position of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Msk (0x1UL << GPIOTE_CONFIG_OUTINIT_Pos) /*!< Bit mask of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Low (0UL) /*!< Initial low output when in task mode. */
N#define GPIOTE_CONFIG_OUTINIT_High (1UL) /*!< Initial high output when in task mode. */
N
N/* Bits 17..16 : Effects on output when in Task mode, or events on input that generates an event. */
N#define GPIOTE_CONFIG_POLARITY_Pos (16UL) /*!< Position of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_Msk (0x3UL << GPIOTE_CONFIG_POLARITY_Pos) /*!< Bit mask of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_None (0x00UL) /*!< No task or event. */
N#define GPIOTE_CONFIG_POLARITY_LoToHi (0x01UL) /*!< Low to high. */
N#define GPIOTE_CONFIG_POLARITY_HiToLo (0x02UL) /*!< High to low. */
N#define GPIOTE_CONFIG_POLARITY_Toggle (0x03UL) /*!< Toggle. */
N
N/* Bits 12..8 : Pin select. */
N#define GPIOTE_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define GPIOTE_CONFIG_PSEL_Msk (0x1FUL << GPIOTE_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N
N/* Bits 1..0 : Mode */
N#define GPIOTE_CONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define GPIOTE_CONFIG_MODE_Msk (0x3UL << GPIOTE_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
N#define GPIOTE_CONFIG_MODE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIOTE_CONFIG_MODE_Event (0x01UL) /*!< Channel configure in event mode. */
N#define GPIOTE_CONFIG_MODE_Task (0x03UL) /*!< Channel configure in task mode. */
N
N/* Register: GPIOTE_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define GPIOTE_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define GPIOTE_POWER_POWER_Msk (0x1UL << GPIOTE_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define GPIOTE_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define GPIOTE_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: LPCOMP */
N/* Description: Low power comparator. */
N
N/* Register: LPCOMP_SHORTS */
N/* Description: Shortcuts for the LPCOMP. */
N
N/* Bit 4 : Shortcut between CROSS event and STOP task. */
N#define LPCOMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Msk (0x1UL << LPCOMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between UP event and STOP task. */
N#define LPCOMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Msk (0x1UL << LPCOMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between DOWN event and STOP task. */
N#define LPCOMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Msk (0x1UL << LPCOMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between RADY event and STOP task. */
N#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between READY event and SAMPLE task. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: LPCOMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 3 : Enable interrupt on CROSS event. */
N#define LPCOMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Msk (0x1UL << LPCOMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_CROSS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on UP event. */
N#define LPCOMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENSET_UP_Msk (0x1UL << LPCOMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENSET_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_UP_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on DOWN event. */
N#define LPCOMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Msk (0x1UL << LPCOMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_DOWN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: LPCOMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 3 : Disable interrupt on CROSS event. */
N#define LPCOMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Msk (0x1UL << LPCOMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on UP event. */
N#define LPCOMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENCLR_UP_Msk (0x1UL << LPCOMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENCLR_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_UP_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on DOWN event. */
N#define LPCOMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Msk (0x1UL << LPCOMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: LPCOMP_RESULT */
N/* Description: Result of last compare. */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define LPCOMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Msk (0x1UL << LPCOMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Below (0UL) /*!< Input voltage is bellow the reference threshold. */
N#define LPCOMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold. */
N
N/* Register: LPCOMP_ENABLE */
N/* Description: Enable the LPCOMP. */
N
N/* Bits 1..0 : Enable or disable LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Msk (0x3UL << LPCOMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable LPCOMP. */
N
N/* Register: LPCOMP_PSEL */
N/* Description: Input pin select. */
N
N/* Bits 2..0 : Analog input pin select. */
N#define LPCOMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define LPCOMP_PSEL_PSEL_Msk (0x7UL << LPCOMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define LPCOMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< Use analog input 0 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< Use analog input 1 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< Use analog input 2 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< Use analog input 3 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< Use analog input 4 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< Use analog input 5 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< Use analog input 6 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< Use analog input 7 as analog input. */
N
N/* Register: LPCOMP_REFSEL */
N/* Description: Reference select. */
N
N/* Bits 2..0 : Reference select. */
N#define LPCOMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_Msk (0x7UL << LPCOMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling (0UL) /*!< Use supply with a 1/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling (1UL) /*!< Use supply with a 2/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling (2UL) /*!< Use supply with a 3/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling (3UL) /*!< Use supply with a 4/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling (4UL) /*!< Use supply with a 5/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling (5UL) /*!< Use supply with a 6/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling (6UL) /*!< Use supply with a 7/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_ARef (7UL) /*!< Use external analog reference as reference. */
N
N/* Register: LPCOMP_EXTREFSEL */
N/* Description: External reference select. */
N
N/* Bit 0 : External analog reference pin selection. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use analog reference 0 as reference. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use analog reference 1 as reference. */
N
N/* Register: LPCOMP_ANADETECT */
N/* Description: Analog detect configuration. */
N
N/* Bits 1..0 : Analog detect configuration. */
N#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETEC on crossing, both upwards and downwards crossing. */
N#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETEC on upwards crossing only. */
N#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETEC on downwards crossing only. */
N
N/* Register: LPCOMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define LPCOMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define LPCOMP_POWER_POWER_Msk (0x1UL << LPCOMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define LPCOMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define LPCOMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: MPU */
N/* Description: Memory Protection Unit. */
N
N/* Register: MPU_PERR0 */
N/* Description: Configuration of peripherals in mpu regions. */
N
N/* Bit 31 : PPI region configuration. */
N#define MPU_PERR0_PPI_Pos (31UL) /*!< Position of PPI field. */
N#define MPU_PERR0_PPI_Msk (0x1UL << MPU_PERR0_PPI_Pos) /*!< Bit mask of PPI field. */
N#define MPU_PERR0_PPI_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_PPI_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 30 : NVMC region configuration. */
N#define MPU_PERR0_NVMC_Pos (30UL) /*!< Position of NVMC field. */
N#define MPU_PERR0_NVMC_Msk (0x1UL << MPU_PERR0_NVMC_Pos) /*!< Bit mask of NVMC field. */
N#define MPU_PERR0_NVMC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_NVMC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 19 : LPCOMP region configuration. */
N#define MPU_PERR0_LPCOMP_Pos (19UL) /*!< Position of LPCOMP field. */
N#define MPU_PERR0_LPCOMP_Msk (0x1UL << MPU_PERR0_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
N#define MPU_PERR0_LPCOMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_LPCOMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 18 : QDEC region configuration. */
N#define MPU_PERR0_QDEC_Pos (18UL) /*!< Position of QDEC field. */
N#define MPU_PERR0_QDEC_Msk (0x1UL << MPU_PERR0_QDEC_Pos) /*!< Bit mask of QDEC field. */
N#define MPU_PERR0_QDEC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_QDEC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 17 : RTC1 region configuration. */
N#define MPU_PERR0_RTC1_Pos (17UL) /*!< Position of RTC1 field. */
N#define MPU_PERR0_RTC1_Msk (0x1UL << MPU_PERR0_RTC1_Pos) /*!< Bit mask of RTC1 field. */
N#define MPU_PERR0_RTC1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 16 : WDT region configuration. */
N#define MPU_PERR0_WDT_Pos (16UL) /*!< Position of WDT field. */
N#define MPU_PERR0_WDT_Msk (0x1UL << MPU_PERR0_WDT_Pos) /*!< Bit mask of WDT field. */
N#define MPU_PERR0_WDT_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_WDT_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 15 : CCM and AAR region configuration. */
N#define MPU_PERR0_CCM_AAR_Pos (15UL) /*!< Position of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_Msk (0x1UL << MPU_PERR0_CCM_AAR_Pos) /*!< Bit mask of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_CCM_AAR_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 14 : ECB region configuration. */
N#define MPU_PERR0_ECB_Pos (14UL) /*!< Position of ECB field. */
N#define MPU_PERR0_ECB_Msk (0x1UL << MPU_PERR0_ECB_Pos) /*!< Bit mask of ECB field. */
N#define MPU_PERR0_ECB_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ECB_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 13 : RNG region configuration. */
N#define MPU_PERR0_RNG_Pos (13UL) /*!< Position of RNG field. */
N#define MPU_PERR0_RNG_Msk (0x1UL << MPU_PERR0_RNG_Pos) /*!< Bit mask of RNG field. */
N#define MPU_PERR0_RNG_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RNG_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 12 : TEMP region configuration. */
N#define MPU_PERR0_TEMP_Pos (12UL) /*!< Position of TEMP field. */
N#define MPU_PERR0_TEMP_Msk (0x1UL << MPU_PERR0_TEMP_Pos) /*!< Bit mask of TEMP field. */
N#define MPU_PERR0_TEMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TEMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 11 : RTC0 region configuration. */
N#define MPU_PERR0_RTC0_Pos (11UL) /*!< Position of RTC0 field. */
N#define MPU_PERR0_RTC0_Msk (0x1UL << MPU_PERR0_RTC0_Pos) /*!< Bit mask of RTC0 field. */
N#define MPU_PERR0_RTC0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 10 : TIMER2 region configuration. */
N#define MPU_PERR0_TIMER2_Pos (10UL) /*!< Position of TIMER2 field. */
N#define MPU_PERR0_TIMER2_Msk (0x1UL << MPU_PERR0_TIMER2_Pos) /*!< Bit mask of TIMER2 field. */
N#define MPU_PERR0_TIMER2_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER2_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 9 : TIMER1 region configuration. */
N#define MPU_PERR0_TIMER1_Pos (9UL) /*!< Position of TIMER1 field. */
N#define MPU_PERR0_TIMER1_Msk (0x1UL << MPU_PERR0_TIMER1_Pos) /*!< Bit mask of TIMER1 field. */
N#define MPU_PERR0_TIMER1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 8 : TIMER0 region configuration. */
N#define MPU_PERR0_TIMER0_Pos (8UL) /*!< Position of TIMER0 field. */
N#define MPU_PERR0_TIMER0_Msk (0x1UL << MPU_PERR0_TIMER0_Pos) /*!< Bit mask of TIMER0 field. */
N#define MPU_PERR0_TIMER0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 7 : ADC region configuration. */
N#define MPU_PERR0_ADC_Pos (7UL) /*!< Position of ADC field. */
N#define MPU_PERR0_ADC_Msk (0x1UL << MPU_PERR0_ADC_Pos) /*!< Bit mask of ADC field. */
N#define MPU_PERR0_ADC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ADC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 6 : GPIOTE region configuration. */
N#define MPU_PERR0_GPIOTE_Pos (6UL) /*!< Position of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_Msk (0x1UL << MPU_PERR0_GPIOTE_Pos) /*!< Bit mask of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_GPIOTE_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 4 : SPI1 and TWI1 region configuration. */
N#define MPU_PERR0_SPI1_TWI1_Pos (4UL) /*!< Position of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_Msk (0x1UL << MPU_PERR0_SPI1_TWI1_Pos) /*!< Bit mask of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI1_TWI1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 3 : SPI0 and TWI0 region configuration. */
N#define MPU_PERR0_SPI0_TWI0_Pos (3UL) /*!< Position of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_Msk (0x1UL << MPU_PERR0_SPI0_TWI0_Pos) /*!< Bit mask of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI0_TWI0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 2 : UART0 region configuration. */
N#define MPU_PERR0_UART0_Pos (2UL) /*!< Position of UART0 field. */
N#define MPU_PERR0_UART0_Msk (0x1UL << MPU_PERR0_UART0_Pos) /*!< Bit mask of UART0 field. */
N#define MPU_PERR0_UART0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_UART0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 1 : RADIO region configuration. */
N#define MPU_PERR0_RADIO_Pos (1UL) /*!< Position of RADIO field. */
N#define MPU_PERR0_RADIO_Msk (0x1UL << MPU_PERR0_RADIO_Pos) /*!< Bit mask of RADIO field. */
N#define MPU_PERR0_RADIO_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RADIO_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 0 : POWER_CLOCK region configuration. */
N#define MPU_PERR0_POWER_CLOCK_Pos (0UL) /*!< Position of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_Msk (0x1UL << MPU_PERR0_POWER_CLOCK_Pos) /*!< Bit mask of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_POWER_CLOCK_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Register: MPU_PROTENSET0 */
N/* Description: Erase and write protection bit enable set register. */
N
N/* Bit 31 : Protection enable for region 31. */
N#define MPU_PROTENSET0_PROTREG31_Pos (31UL) /*!< Position of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Msk (0x1UL << MPU_PROTENSET0_PROTREG31_Pos) /*!< Bit mask of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG31_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG31_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 30. */
N#define MPU_PROTENSET0_PROTREG30_Pos (30UL) /*!< Position of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Msk (0x1UL << MPU_PROTENSET0_PROTREG30_Pos) /*!< Bit mask of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG30_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG30_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 29. */
N#define MPU_PROTENSET0_PROTREG29_Pos (29UL) /*!< Position of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Msk (0x1UL << MPU_PROTENSET0_PROTREG29_Pos) /*!< Bit mask of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG29_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG29_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 28. */
N#define MPU_PROTENSET0_PROTREG28_Pos (28UL) /*!< Position of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Msk (0x1UL << MPU_PROTENSET0_PROTREG28_Pos) /*!< Bit mask of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG28_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG28_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 27. */
N#define MPU_PROTENSET0_PROTREG27_Pos (27UL) /*!< Position of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Msk (0x1UL << MPU_PROTENSET0_PROTREG27_Pos) /*!< Bit mask of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG27_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG27_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 26. */
N#define MPU_PROTENSET0_PROTREG26_Pos (26UL) /*!< Position of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Msk (0x1UL << MPU_PROTENSET0_PROTREG26_Pos) /*!< Bit mask of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG26_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG26_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 25. */
N#define MPU_PROTENSET0_PROTREG25_Pos (25UL) /*!< Position of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Msk (0x1UL << MPU_PROTENSET0_PROTREG25_Pos) /*!< Bit mask of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG25_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG25_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 24. */
N#define MPU_PROTENSET0_PROTREG24_Pos (24UL) /*!< Position of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Msk (0x1UL << MPU_PROTENSET0_PROTREG24_Pos) /*!< Bit mask of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG24_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG24_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 23. */
N#define MPU_PROTENSET0_PROTREG23_Pos (23UL) /*!< Position of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Msk (0x1UL << MPU_PROTENSET0_PROTREG23_Pos) /*!< Bit mask of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG23_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG23_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 22. */
N#define MPU_PROTENSET0_PROTREG22_Pos (22UL) /*!< Position of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Msk (0x1UL << MPU_PROTENSET0_PROTREG22_Pos) /*!< Bit mask of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG22_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG22_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 21. */
N#define MPU_PROTENSET0_PROTREG21_Pos (21UL) /*!< Position of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Msk (0x1UL << MPU_PROTENSET0_PROTREG21_Pos) /*!< Bit mask of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG21_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG21_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 20. */
N#define MPU_PROTENSET0_PROTREG20_Pos (20UL) /*!< Position of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Msk (0x1UL << MPU_PROTENSET0_PROTREG20_Pos) /*!< Bit mask of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG20_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG20_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 19. */
N#define MPU_PROTENSET0_PROTREG19_Pos (19UL) /*!< Position of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Msk (0x1UL << MPU_PROTENSET0_PROTREG19_Pos) /*!< Bit mask of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG19_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG19_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 18. */
N#define MPU_PROTENSET0_PROTREG18_Pos (18UL) /*!< Position of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Msk (0x1UL << MPU_PROTENSET0_PROTREG18_Pos) /*!< Bit mask of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG18_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG18_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 17. */
N#define MPU_PROTENSET0_PROTREG17_Pos (17UL) /*!< Position of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Msk (0x1UL << MPU_PROTENSET0_PROTREG17_Pos) /*!< Bit mask of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG17_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG17_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 16. */
N#define MPU_PROTENSET0_PROTREG16_Pos (16UL) /*!< Position of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Msk (0x1UL << MPU_PROTENSET0_PROTREG16_Pos) /*!< Bit mask of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG16_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG16_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 15. */
N#define MPU_PROTENSET0_PROTREG15_Pos (15UL) /*!< Position of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Msk (0x1UL << MPU_PROTENSET0_PROTREG15_Pos) /*!< Bit mask of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG15_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG15_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 14. */
N#define MPU_PROTENSET0_PROTREG14_Pos (14UL) /*!< Position of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Msk (0x1UL << MPU_PROTENSET0_PROTREG14_Pos) /*!< Bit mask of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG14_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG14_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 13. */
N#define MPU_PROTENSET0_PROTREG13_Pos (13UL) /*!< Position of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Msk (0x1UL << MPU_PROTENSET0_PROTREG13_Pos) /*!< Bit mask of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG13_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG13_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 12. */
N#define MPU_PROTENSET0_PROTREG12_Pos (12UL) /*!< Position of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Msk (0x1UL << MPU_PROTENSET0_PROTREG12_Pos) /*!< Bit mask of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG12_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG12_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 11. */
N#define MPU_PROTENSET0_PROTREG11_Pos (11UL) /*!< Position of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Msk (0x1UL << MPU_PROTENSET0_PROTREG11_Pos) /*!< Bit mask of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG11_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG11_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 10. */
N#define MPU_PROTENSET0_PROTREG10_Pos (10UL) /*!< Position of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Msk (0x1UL << MPU_PROTENSET0_PROTREG10_Pos) /*!< Bit mask of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG10_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG10_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 9. */
N#define MPU_PROTENSET0_PROTREG9_Pos (9UL) /*!< Position of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Msk (0x1UL << MPU_PROTENSET0_PROTREG9_Pos) /*!< Bit mask of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG9_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG9_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 8. */
N#define MPU_PROTENSET0_PROTREG8_Pos (8UL) /*!< Position of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Msk (0x1UL << MPU_PROTENSET0_PROTREG8_Pos) /*!< Bit mask of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG8_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG8_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 7. */
N#define MPU_PROTENSET0_PROTREG7_Pos (7UL) /*!< Position of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Msk (0x1UL << MPU_PROTENSET0_PROTREG7_Pos) /*!< Bit mask of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG7_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG7_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 6. */
N#define MPU_PROTENSET0_PROTREG6_Pos (6UL) /*!< Position of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Msk (0x1UL << MPU_PROTENSET0_PROTREG6_Pos) /*!< Bit mask of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG6_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG6_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 5. */
N#define MPU_PROTENSET0_PROTREG5_Pos (5UL) /*!< Position of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Msk (0x1UL << MPU_PROTENSET0_PROTREG5_Pos) /*!< Bit mask of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG5_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG5_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 4. */
N#define MPU_PROTENSET0_PROTREG4_Pos (4UL) /*!< Position of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Msk (0x1UL << MPU_PROTENSET0_PROTREG4_Pos) /*!< Bit mask of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG4_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG4_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 3. */
N#define MPU_PROTENSET0_PROTREG3_Pos (3UL) /*!< Position of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Msk (0x1UL << MPU_PROTENSET0_PROTREG3_Pos) /*!< Bit mask of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG3_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG3_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 2. */
N#define MPU_PROTENSET0_PROTREG2_Pos (2UL) /*!< Position of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Msk (0x1UL << MPU_PROTENSET0_PROTREG2_Pos) /*!< Bit mask of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG2_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG2_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 1. */
N#define MPU_PROTENSET0_PROTREG1_Pos (1UL) /*!< Position of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Msk (0x1UL << MPU_PROTENSET0_PROTREG1_Pos) /*!< Bit mask of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG1_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG1_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 0. */
N#define MPU_PROTENSET0_PROTREG0_Pos (0UL) /*!< Position of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Msk (0x1UL << MPU_PROTENSET0_PROTREG0_Pos) /*!< Bit mask of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG0_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG0_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_PROTENSET1 */
N/* Description: Erase and write protection bit enable set register. */
N
N/* Bit 31 : Protection enable for region 63. */
N#define MPU_PROTENSET1_PROTREG63_Pos (31UL) /*!< Position of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Msk (0x1UL << MPU_PROTENSET1_PROTREG63_Pos) /*!< Bit mask of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG63_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG63_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 62. */
N#define MPU_PROTENSET1_PROTREG62_Pos (30UL) /*!< Position of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Msk (0x1UL << MPU_PROTENSET1_PROTREG62_Pos) /*!< Bit mask of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG62_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG62_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 61. */
N#define MPU_PROTENSET1_PROTREG61_Pos (29UL) /*!< Position of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Msk (0x1UL << MPU_PROTENSET1_PROTREG61_Pos) /*!< Bit mask of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG61_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG61_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 60. */
N#define MPU_PROTENSET1_PROTREG60_Pos (28UL) /*!< Position of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Msk (0x1UL << MPU_PROTENSET1_PROTREG60_Pos) /*!< Bit mask of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG60_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG60_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 59. */
N#define MPU_PROTENSET1_PROTREG59_Pos (27UL) /*!< Position of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Msk (0x1UL << MPU_PROTENSET1_PROTREG59_Pos) /*!< Bit mask of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG59_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG59_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 58. */
N#define MPU_PROTENSET1_PROTREG58_Pos (26UL) /*!< Position of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Msk (0x1UL << MPU_PROTENSET1_PROTREG58_Pos) /*!< Bit mask of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG58_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG58_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 57. */
N#define MPU_PROTENSET1_PROTREG57_Pos (25UL) /*!< Position of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Msk (0x1UL << MPU_PROTENSET1_PROTREG57_Pos) /*!< Bit mask of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG57_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG57_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 56. */
N#define MPU_PROTENSET1_PROTREG56_Pos (24UL) /*!< Position of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Msk (0x1UL << MPU_PROTENSET1_PROTREG56_Pos) /*!< Bit mask of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG56_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG56_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 55. */
N#define MPU_PROTENSET1_PROTREG55_Pos (23UL) /*!< Position of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Msk (0x1UL << MPU_PROTENSET1_PROTREG55_Pos) /*!< Bit mask of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG55_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG55_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 54. */
N#define MPU_PROTENSET1_PROTREG54_Pos (22UL) /*!< Position of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Msk (0x1UL << MPU_PROTENSET1_PROTREG54_Pos) /*!< Bit mask of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG54_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG54_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 53. */
N#define MPU_PROTENSET1_PROTREG53_Pos (21UL) /*!< Position of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Msk (0x1UL << MPU_PROTENSET1_PROTREG53_Pos) /*!< Bit mask of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG53_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG53_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 52. */
N#define MPU_PROTENSET1_PROTREG52_Pos (20UL) /*!< Position of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Msk (0x1UL << MPU_PROTENSET1_PROTREG52_Pos) /*!< Bit mask of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG52_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG52_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 51. */
N#define MPU_PROTENSET1_PROTREG51_Pos (19UL) /*!< Position of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Msk (0x1UL << MPU_PROTENSET1_PROTREG51_Pos) /*!< Bit mask of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG51_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG51_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 50. */
N#define MPU_PROTENSET1_PROTREG50_Pos (18UL) /*!< Position of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Msk (0x1UL << MPU_PROTENSET1_PROTREG50_Pos) /*!< Bit mask of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG50_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG50_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 49. */
N#define MPU_PROTENSET1_PROTREG49_Pos (17UL) /*!< Position of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Msk (0x1UL << MPU_PROTENSET1_PROTREG49_Pos) /*!< Bit mask of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG49_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG49_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 48. */
N#define MPU_PROTENSET1_PROTREG48_Pos (16UL) /*!< Position of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Msk (0x1UL << MPU_PROTENSET1_PROTREG48_Pos) /*!< Bit mask of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG48_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG48_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 47. */
N#define MPU_PROTENSET1_PROTREG47_Pos (15UL) /*!< Position of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Msk (0x1UL << MPU_PROTENSET1_PROTREG47_Pos) /*!< Bit mask of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG47_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG47_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 46. */
N#define MPU_PROTENSET1_PROTREG46_Pos (14UL) /*!< Position of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Msk (0x1UL << MPU_PROTENSET1_PROTREG46_Pos) /*!< Bit mask of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG46_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG46_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 45. */
N#define MPU_PROTENSET1_PROTREG45_Pos (13UL) /*!< Position of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Msk (0x1UL << MPU_PROTENSET1_PROTREG45_Pos) /*!< Bit mask of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG45_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG45_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 44. */
N#define MPU_PROTENSET1_PROTREG44_Pos (12UL) /*!< Position of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Msk (0x1UL << MPU_PROTENSET1_PROTREG44_Pos) /*!< Bit mask of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG44_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG44_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 43. */
N#define MPU_PROTENSET1_PROTREG43_Pos (11UL) /*!< Position of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Msk (0x1UL << MPU_PROTENSET1_PROTREG43_Pos) /*!< Bit mask of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG43_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG43_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 42. */
N#define MPU_PROTENSET1_PROTREG42_Pos (10UL) /*!< Position of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Msk (0x1UL << MPU_PROTENSET1_PROTREG42_Pos) /*!< Bit mask of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG42_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG42_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 41. */
N#define MPU_PROTENSET1_PROTREG41_Pos (9UL) /*!< Position of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Msk (0x1UL << MPU_PROTENSET1_PROTREG41_Pos) /*!< Bit mask of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG41_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG41_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 40. */
N#define MPU_PROTENSET1_PROTREG40_Pos (8UL) /*!< Position of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Msk (0x1UL << MPU_PROTENSET1_PROTREG40_Pos) /*!< Bit mask of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG40_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG40_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 39. */
N#define MPU_PROTENSET1_PROTREG39_Pos (7UL) /*!< Position of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Msk (0x1UL << MPU_PROTENSET1_PROTREG39_Pos) /*!< Bit mask of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG39_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG39_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 38. */
N#define MPU_PROTENSET1_PROTREG38_Pos (6UL) /*!< Position of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Msk (0x1UL << MPU_PROTENSET1_PROTREG38_Pos) /*!< Bit mask of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG38_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG38_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 37. */
N#define MPU_PROTENSET1_PROTREG37_Pos (5UL) /*!< Position of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Msk (0x1UL << MPU_PROTENSET1_PROTREG37_Pos) /*!< Bit mask of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG37_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG37_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 36. */
N#define MPU_PROTENSET1_PROTREG36_Pos (4UL) /*!< Position of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Msk (0x1UL << MPU_PROTENSET1_PROTREG36_Pos) /*!< Bit mask of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG36_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG36_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 35. */
N#define MPU_PROTENSET1_PROTREG35_Pos (3UL) /*!< Position of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Msk (0x1UL << MPU_PROTENSET1_PROTREG35_Pos) /*!< Bit mask of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG35_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG35_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 34. */
N#define MPU_PROTENSET1_PROTREG34_Pos (2UL) /*!< Position of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Msk (0x1UL << MPU_PROTENSET1_PROTREG34_Pos) /*!< Bit mask of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG34_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG34_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 33. */
N#define MPU_PROTENSET1_PROTREG33_Pos (1UL) /*!< Position of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Msk (0x1UL << MPU_PROTENSET1_PROTREG33_Pos) /*!< Bit mask of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG33_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG33_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 32. */
N#define MPU_PROTENSET1_PROTREG32_Pos (0UL) /*!< Position of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Msk (0x1UL << MPU_PROTENSET1_PROTREG32_Pos) /*!< Bit mask of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG32_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG32_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_DISABLEINDEBUG */
N/* Description: Disable erase and write protection mechanism in debug mode. */
N
N/* Bit 0 : Disable protection mechanism in debug mode. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos (0UL) /*!< Position of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Msk (0x1UL << MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos) /*!< Bit mask of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Enabled (0UL) /*!< Protection enabled. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled (1UL) /*!< Protection disabled. */
N
N/* Register: MPU_PROTBLOCKSIZE */
N/* Description: Erase and write protection block size. */
N
N/* Bits 1..0 : Erase and write protection block size. */
N#define MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_Pos (0UL) /*!< Position of PROTBLOCKSIZE field. */
N#define MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_Msk (0x3UL << MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_Pos) /*!< Bit mask of PROTBLOCKSIZE field. */
N#define MPU_PROTBLOCKSIZE_PROTBLOCKSIZE_4k (0UL) /*!< Erase and write protection block size is 4k. */
N
N
N/* Peripheral: NVMC */
N/* Description: Non Volatile Memory Controller. */
N
N/* Register: NVMC_READY */
N/* Description: Ready flag. */
N
N/* Bit 0 : NVMC ready. */
N#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
N#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
N#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation). */
N#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready. */
N
N/* Register: NVMC_CONFIG */
N/* Description: Configuration register. */
N
N/* Bits 1..0 : Program write enable. */
N#define NVMC_CONFIG_WEN_Pos (0UL) /*!< Position of WEN field. */
N#define NVMC_CONFIG_WEN_Msk (0x3UL << NVMC_CONFIG_WEN_Pos) /*!< Bit mask of WEN field. */
N#define NVMC_CONFIG_WEN_Ren (0x00UL) /*!< Read only access. */
N#define NVMC_CONFIG_WEN_Wen (0x01UL) /*!< Write enabled. */
N#define NVMC_CONFIG_WEN_Een (0x02UL) /*!< Erase enabled. */
N
N/* Register: NVMC_ERASEALL */
N/* Description: Register for erasing all non-volatile user memory. */
N
N/* Bit 0 : Starts the erasing of all user NVM (code region 0/1 and UICR registers). */
N#define NVMC_ERASEALL_ERASEALL_Pos (0UL) /*!< Position of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_Msk (0x1UL << NVMC_ERASEALL_ERASEALL_Pos) /*!< Bit mask of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEALL_ERASEALL_Erase (1UL) /*!< Start chip erase. */
N
N/* Register: NVMC_ERASEUICR */
N/* Description: Register for start erasing User Information Congfiguration Registers. */
N
N/* Bit 0 : It can only be used when all contents of code region 1 are erased. */
N#define NVMC_ERASEUICR_ERASEUICR_Pos (0UL) /*!< Position of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_Msk (0x1UL << NVMC_ERASEUICR_ERASEUICR_Pos) /*!< Bit mask of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEUICR_ERASEUICR_Erase (1UL) /*!< Start UICR erase. */
N
N
N/* Peripheral: POWER */
N/* Description: Power Control. */
N
N/* Register: POWER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on POFWARN event. */
N#define POWER_INTENSET_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Msk (0x1UL << POWER_INTENSET_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENSET_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENSET_POFWARN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: POWER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on POFWARN event. */
N#define POWER_INTENCLR_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Msk (0x1UL << POWER_INTENCLR_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENCLR_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENCLR_POFWARN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: POWER_RESETREAS */
N/* Description: Reset reason. */
N
N/* Bit 18 : Reset from wake-up from OFF mode detected by entering into debug interface mode. */
N#define POWER_RESETREAS_DIF_Pos (18UL) /*!< Position of DIF field. */
N#define POWER_RESETREAS_DIF_Msk (0x1UL << POWER_RESETREAS_DIF_Pos) /*!< Bit mask of DIF field. */
N#define POWER_RESETREAS_DIF_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_DIF_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 17 : Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP. */
N#define POWER_RESETREAS_LPCOMP_Pos (17UL) /*!< Position of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_Msk (0x1UL << POWER_RESETREAS_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_LPCOMP_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 16 : Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO. */
N#define POWER_RESETREAS_OFF_Pos (16UL) /*!< Position of OFF field. */
N#define POWER_RESETREAS_OFF_Msk (0x1UL << POWER_RESETREAS_OFF_Pos) /*!< Bit mask of OFF field. */
N#define POWER_RESETREAS_OFF_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_OFF_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 3 : Reset from CPU lock-up detected. */
N#define POWER_RESETREAS_LOCKUP_Pos (3UL) /*!< Position of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_Msk (0x1UL << POWER_RESETREAS_LOCKUP_Pos) /*!< Bit mask of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_LOCKUP_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 2 : Reset from AIRCR.SYSRESETREQ detected. */
N#define POWER_RESETREAS_SREQ_Pos (2UL) /*!< Position of SREQ field. */
N#define POWER_RESETREAS_SREQ_Msk (0x1UL << POWER_RESETREAS_SREQ_Pos) /*!< Bit mask of SREQ field. */
N#define POWER_RESETREAS_SREQ_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_SREQ_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 1 : Reset from watchdog detected. */
N#define POWER_RESETREAS_DOG_Pos (1UL) /*!< Position of DOG field. */
N#define POWER_RESETREAS_DOG_Msk (0x1UL << POWER_RESETREAS_DOG_Pos) /*!< Bit mask of DOG field. */
N#define POWER_RESETREAS_DOG_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_DOG_Detected (1UL) /*!< Reset detected. */
N
N/* Bit 0 : Reset from pin-reset detected. */
N#define POWER_RESETREAS_RESETPIN_Pos (0UL) /*!< Position of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_Msk (0x1UL << POWER_RESETREAS_RESETPIN_Pos) /*!< Bit mask of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_NotDetected (0UL) /*!< Reset not detected. */
N#define POWER_RESETREAS_RESETPIN_Detected (1UL) /*!< Reset detected. */
N
N/* Register: POWER_RAMSTATUS */
N/* Description: Ram status register. */
N
N/* Bit 3 : RAM block 3 status. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Pos (3UL) /*!< Position of RAMBLOCK3 field. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK3_Pos) /*!< Bit mask of RAMBLOCK3 field. */
N#define POWER_RAMSTATUS_RAMBLOCK3_Off (0UL) /*!< RAM block 3 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK3_On (1UL) /*!< RAM block 3 is on. */
N
N/* Bit 2 : RAM block 2 status. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Pos (2UL) /*!< Position of RAMBLOCK2 field. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK2_Pos) /*!< Bit mask of RAMBLOCK2 field. */
N#define POWER_RAMSTATUS_RAMBLOCK2_Off (0UL) /*!< RAM block 2 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK2_On (1UL) /*!< RAM block 2 is on. */
N
N/* Bit 1 : RAM block 1 status. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Pos (1UL) /*!< Position of RAMBLOCK1 field. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK1_Pos) /*!< Bit mask of RAMBLOCK1 field. */
N#define POWER_RAMSTATUS_RAMBLOCK1_Off (0UL) /*!< RAM block 1 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK1_On (1UL) /*!< RAM block 1 is on. */
N
N/* Bit 0 : RAM block 0 status. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Pos (0UL) /*!< Position of RAMBLOCK0 field. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Msk (0x1UL << POWER_RAMSTATUS_RAMBLOCK0_Pos) /*!< Bit mask of RAMBLOCK0 field. */
N#define POWER_RAMSTATUS_RAMBLOCK0_Off (0UL) /*!< RAM block 0 is off or powering up. */
N#define POWER_RAMSTATUS_RAMBLOCK0_On (1UL) /*!< RAM block 0 is on. */
N
N/* Register: POWER_SYSTEMOFF */
N/* Description: System off register. */
N
N/* Bit 0 : Enter system off mode. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Pos (0UL) /*!< Position of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Msk (0x1UL << POWER_SYSTEMOFF_SYSTEMOFF_Pos) /*!< Bit mask of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Enter (1UL) /*!< Enter system off mode. */
N
N/* Register: POWER_POFCON */
N/* Description: Power failure configuration. */
N
N/* Bits 2..1 : Set threshold level. */
N#define POWER_POFCON_THRESHOLD_Pos (1UL) /*!< Position of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_Msk (0x3UL << POWER_POFCON_THRESHOLD_Pos) /*!< Bit mask of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_V21 (0x00UL) /*!< Set threshold to 2.1Volts. */
N#define POWER_POFCON_THRESHOLD_V23 (0x01UL) /*!< Set threshold to 2.3Volts. */
N#define POWER_POFCON_THRESHOLD_V25 (0x02UL) /*!< Set threshold to 2.5Volts. */
N#define POWER_POFCON_THRESHOLD_V27 (0x03UL) /*!< Set threshold to 2.7Volts. */
N
N/* Bit 0 : Power failure comparator enable. */
N#define POWER_POFCON_POF_Pos (0UL) /*!< Position of POF field. */
N#define POWER_POFCON_POF_Msk (0x1UL << POWER_POFCON_POF_Pos) /*!< Bit mask of POF field. */
N#define POWER_POFCON_POF_Disabled (0UL) /*!< Disabled. */
N#define POWER_POFCON_POF_Enabled (1UL) /*!< Enabled. */
N
N/* Register: POWER_GPREGRET */
N/* Description: General purpose retention register. This register is a retained register. */
N
N/* Bits 7..0 : General purpose retention register. */
N#define POWER_GPREGRET_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
N#define POWER_GPREGRET_GPREGRET_Msk (0xFFUL << POWER_GPREGRET_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
N
N/* Register: POWER_RAMON */
N/* Description: Ram on/off. */
N
N/* Bit 17 : RAM block 1 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM1_Pos (17UL) /*!< Position of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_Msk (0x1UL << POWER_RAMON_OFFRAM1_Pos) /*!< Bit mask of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM1_RAM1On (1UL) /*!< RAM block 1 ON in OFF mode. */
N
N/* Bit 16 : RAM block 0 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM0_Pos (16UL) /*!< Position of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_Msk (0x1UL << POWER_RAMON_OFFRAM0_Pos) /*!< Bit mask of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM0_RAM0On (1UL) /*!< RAM block 0 ON in OFF mode. */
N
N/* Bit 1 : RAM block 1 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM1_Pos (1UL) /*!< Position of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_Msk (0x1UL << POWER_RAMON_ONRAM1_Pos) /*!< Bit mask of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in ON mode. */
N#define POWER_RAMON_ONRAM1_RAM1On (1UL) /*!< RAM block 1 ON in ON mode. */
N
N/* Bit 0 : RAM block 0 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM0_Pos (0UL) /*!< Position of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_Msk (0x1UL << POWER_RAMON_ONRAM0_Pos) /*!< Bit mask of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in ON mode. */
N#define POWER_RAMON_ONRAM0_RAM0On (1UL) /*!< RAM block 0 ON in ON mode. */
N
N/* Register: POWER_RESET */
N/* Description: Pin reset functionality configuration register. This register is a retained register. */
N
N/* Bit 0 : Enable or disable pin reset in debug interface mode. */
N#define POWER_RESET_RESET_Pos (0UL) /*!< Position of RESET field. */
N#define POWER_RESET_RESET_Msk (0x1UL << POWER_RESET_RESET_Pos) /*!< Bit mask of RESET field. */
N#define POWER_RESET_RESET_Disabled (0UL) /*!< Pin reset in debug interface mode disabled. */
N#define POWER_RESET_RESET_Enabled (1UL) /*!< Pin reset in debug interface mode enabled. */
N
N/* Register: POWER_RAMONB */
N/* Description: Ram on/off. */
N
N/* Bit 17 : RAM block 3 behaviour in OFF mode. */
N#define POWER_RAMONB_OFFRAM3_Pos (17UL) /*!< Position of OFFRAM3 field. */
N#define POWER_RAMONB_OFFRAM3_Msk (0x1UL << POWER_RAMONB_OFFRAM3_Pos) /*!< Bit mask of OFFRAM3 field. */
N#define POWER_RAMONB_OFFRAM3_RAM3Off (0UL) /*!< RAM block 3 OFF in OFF mode. */
N#define POWER_RAMONB_OFFRAM3_RAM3On (1UL) /*!< RAM block 3 ON in OFF mode. */
N
N/* Bit 16 : RAM block 2 behaviour in OFF mode. */
N#define POWER_RAMONB_OFFRAM2_Pos (16UL) /*!< Position of OFFRAM2 field. */
N#define POWER_RAMONB_OFFRAM2_Msk (0x1UL << POWER_RAMONB_OFFRAM2_Pos) /*!< Bit mask of OFFRAM2 field. */
N#define POWER_RAMONB_OFFRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in OFF mode. */
N#define POWER_RAMONB_OFFRAM2_RAM2On (1UL) /*!< RAM block 2 ON in OFF mode. */
N
N/* Bit 1 : RAM block 3 behaviour in ON mode. */
N#define POWER_RAMONB_ONRAM3_Pos (1UL) /*!< Position of ONRAM3 field. */
N#define POWER_RAMONB_ONRAM3_Msk (0x1UL << POWER_RAMONB_ONRAM3_Pos) /*!< Bit mask of ONRAM3 field. */
N#define POWER_RAMONB_ONRAM3_RAM3Off (0UL) /*!< RAM block 33 OFF in ON mode. */
N#define POWER_RAMONB_ONRAM3_RAM3On (1UL) /*!< RAM block 3 ON in ON mode. */
N
N/* Bit 0 : RAM block 2 behaviour in ON mode. */
N#define POWER_RAMONB_ONRAM2_Pos (0UL) /*!< Position of ONRAM2 field. */
N#define POWER_RAMONB_ONRAM2_Msk (0x1UL << POWER_RAMONB_ONRAM2_Pos) /*!< Bit mask of ONRAM2 field. */
N#define POWER_RAMONB_ONRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in ON mode. */
N#define POWER_RAMONB_ONRAM2_RAM2On (1UL) /*!< RAM block 2 ON in ON mode. */
N
N/* Register: POWER_DCDCEN */
N/* Description: DCDC converter enable configuration register. */
N
N/* Bit 0 : Enable DCDC converter. */
N#define POWER_DCDCEN_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Msk (0x1UL << POWER_DCDCEN_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Disabled (0UL) /*!< DCDC converter disabled. */
N#define POWER_DCDCEN_DCDCEN_Enabled (1UL) /*!< DCDC converter enabled. */
N
N/* Register: POWER_DCDCFORCE */
N/* Description: DCDC power-up force register. */
N
N/* Bit 1 : DCDC power-up force on. */
N#define POWER_DCDCFORCE_FORCEON_Pos (1UL) /*!< Position of FORCEON field. */
N#define POWER_DCDCFORCE_FORCEON_Msk (0x1UL << POWER_DCDCFORCE_FORCEON_Pos) /*!< Bit mask of FORCEON field. */
N#define POWER_DCDCFORCE_FORCEON_NoForce (0UL) /*!< No force. */
N#define POWER_DCDCFORCE_FORCEON_Force (1UL) /*!< Force. */
N
N/* Bit 0 : DCDC power-up force off. */
N#define POWER_DCDCFORCE_FORCEOFF_Pos (0UL) /*!< Position of FORCEOFF field. */
N#define POWER_DCDCFORCE_FORCEOFF_Msk (0x1UL << POWER_DCDCFORCE_FORCEOFF_Pos) /*!< Bit mask of FORCEOFF field. */
N#define POWER_DCDCFORCE_FORCEOFF_NoForce (0UL) /*!< No force. */
N#define POWER_DCDCFORCE_FORCEOFF_Force (1UL) /*!< Force. */
N
N
N/* Peripheral: PPI */
N/* Description: PPI controller. */
N
N/* Register: PPI_CHEN */
N/* Description: Channel enable. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHEN_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHEN_CH31_Msk (0x1UL << PPI_CHEN_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHEN_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH31_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHEN_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHEN_CH30_Msk (0x1UL << PPI_CHEN_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHEN_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH30_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHEN_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHEN_CH29_Msk (0x1UL << PPI_CHEN_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHEN_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH29_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHEN_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHEN_CH28_Msk (0x1UL << PPI_CHEN_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHEN_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH28_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHEN_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHEN_CH27_Msk (0x1UL << PPI_CHEN_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHEN_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH27_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHEN_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHEN_CH26_Msk (0x1UL << PPI_CHEN_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHEN_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH26_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHEN_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHEN_CH25_Msk (0x1UL << PPI_CHEN_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHEN_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH25_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHEN_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHEN_CH24_Msk (0x1UL << PPI_CHEN_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHEN_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH24_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHEN_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHEN_CH23_Msk (0x1UL << PPI_CHEN_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHEN_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH23_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHEN_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHEN_CH22_Msk (0x1UL << PPI_CHEN_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHEN_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH22_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHEN_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHEN_CH21_Msk (0x1UL << PPI_CHEN_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHEN_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH21_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHEN_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHEN_CH20_Msk (0x1UL << PPI_CHEN_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHEN_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH20_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHEN_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHEN_CH15_Msk (0x1UL << PPI_CHEN_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHEN_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH15_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHEN_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHEN_CH14_Msk (0x1UL << PPI_CHEN_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHEN_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH14_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHEN_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHEN_CH13_Msk (0x1UL << PPI_CHEN_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHEN_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH13_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHEN_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHEN_CH12_Msk (0x1UL << PPI_CHEN_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHEN_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH12_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHEN_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHEN_CH11_Msk (0x1UL << PPI_CHEN_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHEN_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH11_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHEN_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHEN_CH10_Msk (0x1UL << PPI_CHEN_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHEN_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH10_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHEN_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHEN_CH9_Msk (0x1UL << PPI_CHEN_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHEN_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH9_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHEN_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHEN_CH8_Msk (0x1UL << PPI_CHEN_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHEN_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH8_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHEN_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHEN_CH7_Msk (0x1UL << PPI_CHEN_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHEN_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH7_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHEN_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHEN_CH6_Msk (0x1UL << PPI_CHEN_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHEN_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH6_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHEN_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHEN_CH5_Msk (0x1UL << PPI_CHEN_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHEN_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH5_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHEN_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHEN_CH4_Msk (0x1UL << PPI_CHEN_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHEN_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH4_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHEN_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHEN_CH3_Msk (0x1UL << PPI_CHEN_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHEN_CH3_Disabled (0UL) /*!< Channel disabled */
N#define PPI_CHEN_CH3_Enabled (1UL) /*!< Channel enabled */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHEN_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHEN_CH2_Msk (0x1UL << PPI_CHEN_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHEN_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH2_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHEN_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHEN_CH1_Msk (0x1UL << PPI_CHEN_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHEN_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH1_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHEN_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHEN_CH0_Msk (0x1UL << PPI_CHEN_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHEN_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH0_Enabled (1UL) /*!< Channel enabled. */
N
N/* Register: PPI_CHENSET */
N/* Description: Channel enable set. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHENSET_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENSET_CH31_Msk (0x1UL << PPI_CHENSET_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENSET_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH31_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHENSET_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENSET_CH30_Msk (0x1UL << PPI_CHENSET_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENSET_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH30_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHENSET_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENSET_CH29_Msk (0x1UL << PPI_CHENSET_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENSET_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH29_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHENSET_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENSET_CH28_Msk (0x1UL << PPI_CHENSET_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENSET_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH28_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHENSET_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENSET_CH27_Msk (0x1UL << PPI_CHENSET_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENSET_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH27_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHENSET_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENSET_CH26_Msk (0x1UL << PPI_CHENSET_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENSET_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH26_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHENSET_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENSET_CH25_Msk (0x1UL << PPI_CHENSET_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENSET_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH25_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHENSET_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENSET_CH24_Msk (0x1UL << PPI_CHENSET_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENSET_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH24_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHENSET_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENSET_CH23_Msk (0x1UL << PPI_CHENSET_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENSET_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH23_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHENSET_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENSET_CH22_Msk (0x1UL << PPI_CHENSET_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENSET_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH22_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHENSET_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENSET_CH21_Msk (0x1UL << PPI_CHENSET_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENSET_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH21_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHENSET_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENSET_CH20_Msk (0x1UL << PPI_CHENSET_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENSET_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH20_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHENSET_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENSET_CH15_Msk (0x1UL << PPI_CHENSET_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENSET_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH15_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHENSET_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENSET_CH14_Msk (0x1UL << PPI_CHENSET_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENSET_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH14_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHENSET_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENSET_CH13_Msk (0x1UL << PPI_CHENSET_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENSET_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH13_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHENSET_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENSET_CH12_Msk (0x1UL << PPI_CHENSET_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENSET_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH12_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHENSET_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENSET_CH11_Msk (0x1UL << PPI_CHENSET_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENSET_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH11_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHENSET_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENSET_CH10_Msk (0x1UL << PPI_CHENSET_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENSET_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH10_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHENSET_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENSET_CH9_Msk (0x1UL << PPI_CHENSET_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENSET_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH9_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHENSET_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENSET_CH8_Msk (0x1UL << PPI_CHENSET_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENSET_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH8_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHENSET_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENSET_CH7_Msk (0x1UL << PPI_CHENSET_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENSET_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH7_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHENSET_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENSET_CH6_Msk (0x1UL << PPI_CHENSET_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENSET_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH6_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHENSET_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENSET_CH5_Msk (0x1UL << PPI_CHENSET_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENSET_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH5_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHENSET_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENSET_CH4_Msk (0x1UL << PPI_CHENSET_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENSET_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH4_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHENSET_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENSET_CH3_Msk (0x1UL << PPI_CHENSET_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENSET_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH3_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHENSET_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENSET_CH2_Msk (0x1UL << PPI_CHENSET_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENSET_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH2_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHENSET_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENSET_CH1_Msk (0x1UL << PPI_CHENSET_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENSET_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH1_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHENSET_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENSET_CH0_Msk (0x1UL << PPI_CHENSET_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENSET_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH0_Set (1UL) /*!< Enable channel on write. */
N
N/* Register: PPI_CHENCLR */
N/* Description: Channel enable clear. */
N
N/* Bit 31 : Disable PPI channel 31. */
N#define PPI_CHENCLR_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENCLR_CH31_Msk (0x1UL << PPI_CHENCLR_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENCLR_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH31_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 30 : Disable PPI channel 30. */
N#define PPI_CHENCLR_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENCLR_CH30_Msk (0x1UL << PPI_CHENCLR_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENCLR_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH30_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 29 : Disable PPI channel 29. */
N#define PPI_CHENCLR_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENCLR_CH29_Msk (0x1UL << PPI_CHENCLR_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENCLR_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH29_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 28 : Disable PPI channel 28. */
N#define PPI_CHENCLR_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENCLR_CH28_Msk (0x1UL << PPI_CHENCLR_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENCLR_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH28_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 27 : Disable PPI channel 27. */
N#define PPI_CHENCLR_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENCLR_CH27_Msk (0x1UL << PPI_CHENCLR_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENCLR_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH27_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 26 : Disable PPI channel 26. */
N#define PPI_CHENCLR_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENCLR_CH26_Msk (0x1UL << PPI_CHENCLR_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENCLR_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH26_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 25 : Disable PPI channel 25. */
N#define PPI_CHENCLR_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENCLR_CH25_Msk (0x1UL << PPI_CHENCLR_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENCLR_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH25_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 24 : Disable PPI channel 24. */
N#define PPI_CHENCLR_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENCLR_CH24_Msk (0x1UL << PPI_CHENCLR_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENCLR_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH24_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 23 : Disable PPI channel 23. */
N#define PPI_CHENCLR_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENCLR_CH23_Msk (0x1UL << PPI_CHENCLR_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENCLR_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH23_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 22 : Disable PPI channel 22. */
N#define PPI_CHENCLR_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENCLR_CH22_Msk (0x1UL << PPI_CHENCLR_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENCLR_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH22_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 21 : Disable PPI channel 21. */
N#define PPI_CHENCLR_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENCLR_CH21_Msk (0x1UL << PPI_CHENCLR_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENCLR_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH21_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 20 : Disable PPI channel 20. */
N#define PPI_CHENCLR_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENCLR_CH20_Msk (0x1UL << PPI_CHENCLR_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENCLR_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH20_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 15 : Disable PPI channel 15. */
N#define PPI_CHENCLR_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENCLR_CH15_Msk (0x1UL << PPI_CHENCLR_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENCLR_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH15_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 14 : Disable PPI channel 14. */
N#define PPI_CHENCLR_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENCLR_CH14_Msk (0x1UL << PPI_CHENCLR_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENCLR_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH14_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 13 : Disable PPI channel 13. */
N#define PPI_CHENCLR_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENCLR_CH13_Msk (0x1UL << PPI_CHENCLR_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENCLR_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH13_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 12 : Disable PPI channel 12. */
N#define PPI_CHENCLR_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENCLR_CH12_Msk (0x1UL << PPI_CHENCLR_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENCLR_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH12_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 11 : Disable PPI channel 11. */
N#define PPI_CHENCLR_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENCLR_CH11_Msk (0x1UL << PPI_CHENCLR_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENCLR_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH11_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 10 : Disable PPI channel 10. */
N#define PPI_CHENCLR_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENCLR_CH10_Msk (0x1UL << PPI_CHENCLR_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENCLR_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH10_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 9 : Disable PPI channel 9. */
N#define PPI_CHENCLR_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENCLR_CH9_Msk (0x1UL << PPI_CHENCLR_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENCLR_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH9_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 8 : Disable PPI channel 8. */
N#define PPI_CHENCLR_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENCLR_CH8_Msk (0x1UL << PPI_CHENCLR_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENCLR_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH8_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 7 : Disable PPI channel 7. */
N#define PPI_CHENCLR_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENCLR_CH7_Msk (0x1UL << PPI_CHENCLR_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENCLR_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH7_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 6 : Disable PPI channel 6. */
N#define PPI_CHENCLR_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENCLR_CH6_Msk (0x1UL << PPI_CHENCLR_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENCLR_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH6_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 5 : Disable PPI channel 5. */
N#define PPI_CHENCLR_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENCLR_CH5_Msk (0x1UL << PPI_CHENCLR_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENCLR_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH5_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 4 : Disable PPI channel 4. */
N#define PPI_CHENCLR_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENCLR_CH4_Msk (0x1UL << PPI_CHENCLR_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENCLR_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH4_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 3 : Disable PPI channel 3. */
N#define PPI_CHENCLR_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENCLR_CH3_Msk (0x1UL << PPI_CHENCLR_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENCLR_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH3_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 2 : Disable PPI channel 2. */
N#define PPI_CHENCLR_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENCLR_CH2_Msk (0x1UL << PPI_CHENCLR_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENCLR_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH2_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 1 : Disable PPI channel 1. */
N#define PPI_CHENCLR_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENCLR_CH1_Msk (0x1UL << PPI_CHENCLR_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENCLR_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH1_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 0 : Disable PPI channel 0. */
N#define PPI_CHENCLR_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENCLR_CH0_Msk (0x1UL << PPI_CHENCLR_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENCLR_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH0_Clear (1UL) /*!< Disable channel on write. */
N
N/* Register: PPI_CHG */
N/* Description: Channel group configuration. */
N
N/* Bit 31 : Include CH31 in channel group. */
N#define PPI_CHG_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHG_CH31_Msk (0x1UL << PPI_CHG_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHG_CH31_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH31_Included (1UL) /*!< Channel included. */
N
N/* Bit 30 : Include CH30 in channel group. */
N#define PPI_CHG_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHG_CH30_Msk (0x1UL << PPI_CHG_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHG_CH30_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH30_Included (1UL) /*!< Channel included. */
N
N/* Bit 29 : Include CH29 in channel group. */
N#define PPI_CHG_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHG_CH29_Msk (0x1UL << PPI_CHG_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHG_CH29_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH29_Included (1UL) /*!< Channel included. */
N
N/* Bit 28 : Include CH28 in channel group. */
N#define PPI_CHG_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHG_CH28_Msk (0x1UL << PPI_CHG_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHG_CH28_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH28_Included (1UL) /*!< Channel included. */
N
N/* Bit 27 : Include CH27 in channel group. */
N#define PPI_CHG_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHG_CH27_Msk (0x1UL << PPI_CHG_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHG_CH27_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH27_Included (1UL) /*!< Channel included. */
N
N/* Bit 26 : Include CH26 in channel group. */
N#define PPI_CHG_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHG_CH26_Msk (0x1UL << PPI_CHG_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHG_CH26_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH26_Included (1UL) /*!< Channel included. */
N
N/* Bit 25 : Include CH25 in channel group. */
N#define PPI_CHG_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHG_CH25_Msk (0x1UL << PPI_CHG_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHG_CH25_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH25_Included (1UL) /*!< Channel included. */
N
N/* Bit 24 : Include CH24 in channel group. */
N#define PPI_CHG_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHG_CH24_Msk (0x1UL << PPI_CHG_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHG_CH24_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH24_Included (1UL) /*!< Channel included. */
N
N/* Bit 23 : Include CH23 in channel group. */
N#define PPI_CHG_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHG_CH23_Msk (0x1UL << PPI_CHG_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHG_CH23_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH23_Included (1UL) /*!< Channel included. */
N
N/* Bit 22 : Include CH22 in channel group. */
N#define PPI_CHG_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHG_CH22_Msk (0x1UL << PPI_CHG_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHG_CH22_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH22_Included (1UL) /*!< Channel included. */
N
N/* Bit 21 : Include CH21 in channel group. */
N#define PPI_CHG_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHG_CH21_Msk (0x1UL << PPI_CHG_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHG_CH21_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH21_Included (1UL) /*!< Channel included. */
N
N/* Bit 20 : Include CH20 in channel group. */
N#define PPI_CHG_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHG_CH20_Msk (0x1UL << PPI_CHG_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHG_CH20_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH20_Included (1UL) /*!< Channel included. */
N
N/* Bit 15 : Include CH15 in channel group. */
N#define PPI_CHG_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHG_CH15_Msk (0x1UL << PPI_CHG_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHG_CH15_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH15_Included (1UL) /*!< Channel included. */
N
N/* Bit 14 : Include CH14 in channel group. */
N#define PPI_CHG_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHG_CH14_Msk (0x1UL << PPI_CHG_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHG_CH14_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH14_Included (1UL) /*!< Channel included. */
N
N/* Bit 13 : Include CH13 in channel group. */
N#define PPI_CHG_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHG_CH13_Msk (0x1UL << PPI_CHG_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHG_CH13_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH13_Included (1UL) /*!< Channel included. */
N
N/* Bit 12 : Include CH12 in channel group. */
N#define PPI_CHG_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHG_CH12_Msk (0x1UL << PPI_CHG_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHG_CH12_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH12_Included (1UL) /*!< Channel included. */
N
N/* Bit 11 : Include CH11 in channel group. */
N#define PPI_CHG_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHG_CH11_Msk (0x1UL << PPI_CHG_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHG_CH11_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH11_Included (1UL) /*!< Channel included. */
N
N/* Bit 10 : Include CH10 in channel group. */
N#define PPI_CHG_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHG_CH10_Msk (0x1UL << PPI_CHG_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHG_CH10_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH10_Included (1UL) /*!< Channel included. */
N
N/* Bit 9 : Include CH9 in channel group. */
N#define PPI_CHG_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHG_CH9_Msk (0x1UL << PPI_CHG_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHG_CH9_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH9_Included (1UL) /*!< Channel included. */
N
N/* Bit 8 : Include CH8 in channel group. */
N#define PPI_CHG_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHG_CH8_Msk (0x1UL << PPI_CHG_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHG_CH8_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH8_Included (1UL) /*!< Channel included. */
N
N/* Bit 7 : Include CH7 in channel group. */
N#define PPI_CHG_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHG_CH7_Msk (0x1UL << PPI_CHG_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHG_CH7_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH7_Included (1UL) /*!< Channel included. */
N
N/* Bit 6 : Include CH6 in channel group. */
N#define PPI_CHG_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHG_CH6_Msk (0x1UL << PPI_CHG_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHG_CH6_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH6_Included (1UL) /*!< Channel included. */
N
N/* Bit 5 : Include CH5 in channel group. */
N#define PPI_CHG_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHG_CH5_Msk (0x1UL << PPI_CHG_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHG_CH5_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH5_Included (1UL) /*!< Channel included. */
N
N/* Bit 4 : Include CH4 in channel group. */
N#define PPI_CHG_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHG_CH4_Msk (0x1UL << PPI_CHG_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHG_CH4_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH4_Included (1UL) /*!< Channel included. */
N
N/* Bit 3 : Include CH3 in channel group. */
N#define PPI_CHG_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHG_CH3_Msk (0x1UL << PPI_CHG_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHG_CH3_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH3_Included (1UL) /*!< Channel included. */
N
N/* Bit 2 : Include CH2 in channel group. */
N#define PPI_CHG_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHG_CH2_Msk (0x1UL << PPI_CHG_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHG_CH2_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH2_Included (1UL) /*!< Channel included. */
N
N/* Bit 1 : Include CH1 in channel group. */
N#define PPI_CHG_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHG_CH1_Msk (0x1UL << PPI_CHG_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHG_CH1_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH1_Included (1UL) /*!< Channel included. */
N
N/* Bit 0 : Include CH0 in channel group. */
N#define PPI_CHG_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHG_CH0_Msk (0x1UL << PPI_CHG_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHG_CH0_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH0_Included (1UL) /*!< Channel included. */
N
N
N/* Peripheral: QDEC */
N/* Description: Rotary decoder. */
N
N/* Register: QDEC_SHORTS */
N/* Description: Shortcuts for the QDEC. */
N
N/* Bit 1 : Shortcut between SAMPLERDY event and STOP task. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Pos (1UL) /*!< Position of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_STOP_Pos) /*!< Bit mask of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between REPORTRDY event and READCLRACC task. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: QDEC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ACCOF event. */
N#define QDEC_INTENSET_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Msk (0x1UL << QDEC_INTENSET_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_ACCOF_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on REPORTRDY event. */
N#define QDEC_INTENSET_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Msk (0x1UL << QDEC_INTENSET_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_REPORTRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on SAMPLERDY event. */
N#define QDEC_INTENSET_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Msk (0x1UL << QDEC_INTENSET_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_SAMPLERDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: QDEC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ACCOF event. */
N#define QDEC_INTENCLR_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Msk (0x1UL << QDEC_INTENCLR_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_ACCOF_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on REPORTRDY event. */
N#define QDEC_INTENCLR_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Msk (0x1UL << QDEC_INTENCLR_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_REPORTRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on SAMPLERDY event. */
N#define QDEC_INTENCLR_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Msk (0x1UL << QDEC_INTENCLR_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: QDEC_ENABLE */
N/* Description: Enable the QDEC. */
N
N/* Bit 0 : Enable or disable QDEC. */
N#define QDEC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Msk (0x1UL << QDEC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Disabled (0UL) /*!< Disabled QDEC. */
N#define QDEC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable QDEC. */
N
N/* Register: QDEC_LEDPOL */
N/* Description: LED output pin polarity. */
N
N/* Bit 0 : LED output pin polarity. */
N#define QDEC_LEDPOL_LEDPOL_Pos (0UL) /*!< Position of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_Msk (0x1UL << QDEC_LEDPOL_LEDPOL_Pos) /*!< Bit mask of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_ActiveLow (0UL) /*!< LED output is active low. */
N#define QDEC_LEDPOL_LEDPOL_ActiveHigh (1UL) /*!< LED output is active high. */
N
N/* Register: QDEC_SAMPLEPER */
N/* Description: Sample period. */
N
N/* Bits 2..0 : Sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Pos (0UL) /*!< Position of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Msk (0x7UL << QDEC_SAMPLEPER_SAMPLEPER_Pos) /*!< Bit mask of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_128us (0x00UL) /*!< 128us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_256us (0x01UL) /*!< 256us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_512us (0x02UL) /*!< 512us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_1024us (0x03UL) /*!< 1024us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_2048us (0x04UL) /*!< 2048us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_4096us (0x05UL) /*!< 4096us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_8192us (0x06UL) /*!< 8192us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_16384us (0x07UL) /*!< 16384us sample period. */
N
N/* Register: QDEC_SAMPLE */
N/* Description: Motion sample value. */
N
N/* Bits 31..0 : Last sample taken in compliment to 2. */
N#define QDEC_SAMPLE_SAMPLE_Pos (0UL) /*!< Position of SAMPLE field. */
N#define QDEC_SAMPLE_SAMPLE_Msk (0xFFFFFFFFUL << QDEC_SAMPLE_SAMPLE_Pos) /*!< Bit mask of SAMPLE field. */
N
N/* Register: QDEC_REPORTPER */
N/* Description: Number of samples to generate an EVENT_REPORTRDY. */
N
N/* Bits 2..0 : Number of samples to generate an EVENT_REPORTRDY. */
N#define QDEC_REPORTPER_REPORTPER_Pos (0UL) /*!< Position of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_Msk (0x7UL << QDEC_REPORTPER_REPORTPER_Pos) /*!< Bit mask of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_10Smpl (0x00UL) /*!< 10 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_40Smpl (0x01UL) /*!< 40 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_80Smpl (0x02UL) /*!< 80 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_120Smpl (0x03UL) /*!< 120 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_160Smpl (0x04UL) /*!< 160 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_200Smpl (0x05UL) /*!< 200 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_240Smpl (0x06UL) /*!< 240 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_280Smpl (0x07UL) /*!< 280 samples per report. */
N
N/* Register: QDEC_DBFEN */
N/* Description: Enable debouncer input filters. */
N
N/* Bit 0 : Enable debounce input filters. */
N#define QDEC_DBFEN_DBFEN_Pos (0UL) /*!< Position of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Msk (0x1UL << QDEC_DBFEN_DBFEN_Pos) /*!< Bit mask of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Disabled (0UL) /*!< Debounce input filters disabled. */
N#define QDEC_DBFEN_DBFEN_Enabled (1UL) /*!< Debounce input filters enabled. */
N
N/* Register: QDEC_LEDPRE */
N/* Description: Time LED is switched ON before the sample. */
N
N/* Bits 8..0 : Period in us the LED in switched on prior to sampling. */
N#define QDEC_LEDPRE_LEDPRE_Pos (0UL) /*!< Position of LEDPRE field. */
N#define QDEC_LEDPRE_LEDPRE_Msk (0x1FFUL << QDEC_LEDPRE_LEDPRE_Pos) /*!< Bit mask of LEDPRE field. */
N
N/* Register: QDEC_ACCDBL */
N/* Description: Accumulated double (error) transitions register. */
N
N/* Bits 3..0 : Accumulated double (error) transitions. */
N#define QDEC_ACCDBL_ACCDBL_Pos (0UL) /*!< Position of ACCDBL field. */
N#define QDEC_ACCDBL_ACCDBL_Msk (0xFUL << QDEC_ACCDBL_ACCDBL_Pos) /*!< Bit mask of ACCDBL field. */
N
N/* Register: QDEC_ACCDBLREAD */
N/* Description: Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task. */
N
N/* Bits 3..0 : Snapshot of accumulated double (error) transitions. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
N
N/* Register: QDEC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define QDEC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define QDEC_POWER_POWER_Msk (0x1UL << QDEC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define QDEC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define QDEC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RADIO */
N/* Description: The radio. */
N
N/* Register: RADIO_SHORTS */
N/* Description: Shortcuts for the radio. */
N
N/* Bit 8 : Shortcut between DISABLED event and RSSISTOP task. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 6 : Shortcut between ADDRESS event and BCSTART task. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 5 : Shortcut between END event and START task. */
N#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
N#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
N#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 4 : Shortcut between ADDRESS event and RSSISTART task. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between DISABLED event and RXEN task. */
N#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between DISABLED event and TXEN task.  */
N#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between END event and DISABLE task. */
N#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between READY event and START task. */
N#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
N#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
N#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RADIO_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on BCMATCH event. */
N#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on RSSIEND event. */
N#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 6 : Enable interrupt on DEVMISS event. */
N#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 5 : Enable interrupt on DEVMATCH event. */
N#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 4 : Enable interrupt on DISABLED event. */
N#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on END event. */
N#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on PAYLOAD event. */
N#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ADDRESS event. */
N#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RADIO_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on BCMATCH event. */
N#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on RSSIEND event. */
N#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 6 : Disable interrupt on DEVMISS event. */
N#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 5 : Disable interrupt on DEVMATCH event. */
N#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 4 : Disable interrupt on DISABLED event. */
N#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on END event. */
N#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on PAYLOAD event. */
N#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ADDRESS event. */
N#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RADIO_CRCSTATUS */
N/* Description: CRC status of received packet. */
N
N/* Bit 0 : CRC status of received packet. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok. */
N
N/* Register: RADIO_RXMATCH */
N/* Description: Received address. */
N
N/* Bits 2..0 : Logical address in which previous packet was received. */
N#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
N#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
N
N/* Register: RADIO_RXCRC */
N/* Description: Received CRC. */
N
N/* Bits 23..0 : CRC field of previously received packet. */
N#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
N#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
N
N/* Register: RADIO_DAI */
N/* Description: Device address match index. */
N
N/* Bits 2..0 : Index (n) of device address (see DAB[n] and DAP[n]) that obtained an address match. */
N#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
N#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
N
N/* Register: RADIO_FREQUENCY */
N/* Description: Frequency. */
N
N/* Bits 6..0 : Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task.  */
N#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N
N/* Register: RADIO_TXPOWER */
N/* Description: Output power. */
N
N/* Bits 7..0 : Radio output power. Decision point: TXEN task. */
N#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_0dBm (0x00UL) /*!< 0dBm. */
N#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x04UL) /*!< +4dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xD8UL) /*!< -30dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4dBm. */
N
N/* Register: RADIO_MODE */
N/* Description: Data rate and modulation. */
N
N/* Bits 1..0 : Radio data rate and modulation setting. Decision point: TXEN or RXEN task. */
N#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define RADIO_MODE_MODE_Msk (0x3UL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define RADIO_MODE_MODE_Nrf_1Mbit (0x00UL) /*!< 1Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_2Mbit (0x01UL) /*!< 2Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_250Kbit (0x02UL) /*!< 250kbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Ble_1Mbit (0x03UL) /*!< 1Mbit/s Bluetooth Low Energy */
N
N/* Register: RADIO_PCNF0 */
N/* Description: Packet configuration 0. */
N
N/* Bits 19..16 : Length of S1 field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
N#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
N
N/* Bit 8 : Length of S0 field in number of bytes. Decision point: START task. */
N#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
N#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
N
N/* Bits 3..0 : Length of length field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
N#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
N
N/* Register: RADIO_PCNF1 */
N/* Description: Packet configuration 1. */
N
N/* Bit 25 : Packet whitening enable. */
N#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Whitening disabled. */
N#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Whitening enabled. */
N
N/* Bit 24 : On air endianness of packet length field. Decision point: START task. */
N#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least significant bit on air first */
N#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
N
N/* Bits 18..16 : Base address length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
N#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
N
N/* Bits 15..8 : Static length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
N#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
N
N/* Bits 7..0 : Maximum length of packet payload in number of bytes. */
N#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
N#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
N
N/* Register: RADIO_PREFIX0 */
N/* Description: Prefixes bytes for logical addresses 0 to 3. */
N
N/* Bits 31..24 : Address prefix 3. Decision point: START task. */
N#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
N#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
N
N/* Bits 23..16 : Address prefix 2. Decision point: START task. */
N#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
N#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
N
N/* Bits 15..8 : Address prefix 1. Decision point: START task. */
N#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
N#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
N
N/* Bits 7..0 : Address prefix 0. Decision point: START task. */
N#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
N#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
N
N/* Register: RADIO_PREFIX1 */
N/* Description: Prefixes bytes for logical addresses 4 to 7. */
N
N/* Bits 31..24 : Address prefix 7. Decision point: START task. */
N#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
N#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
N
N/* Bits 23..16 : Address prefix 6. Decision point: START task. */
N#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
N#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
N
N/* Bits 15..8 : Address prefix 5. Decision point: START task. */
N#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
N#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
N
N/* Bits 7..0 : Address prefix 4. Decision point: START task. */
N#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
N#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
N
N/* Register: RADIO_TXADDRESS */
N/* Description: Transmit address select. */
N
N/* Bits 2..0 : Logical address to be used when transmitting a packet. Decision point: START task. */
N#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
N#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
N
N/* Register: RADIO_RXADDRESSES */
N/* Description: Receive address select. */
N
N/* Bit 7 : Enable reception on logical address 7. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 6 : Enable reception on logical address 6. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 5 : Enable reception on logical address 5. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 4 : Enable reception on logical address 4. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 3 : Enable reception on logical address 3. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 2 : Enable reception on logical address 2. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 1 : Enable reception on logical address 1. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 0 : Enable reception on logical address 0. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Reception enabled. */
N
N/* Register: RADIO_CRCCNF */
N/* Description: CRC configuration. */
N
N/* Bit 8 : Leave packet address field out of the CRC calculation. Decision point: START task. */
N#define RADIO_CRCCNF_SKIPADDR_Pos (8UL) /*!< Position of SKIPADDR field. */
N#define RADIO_CRCCNF_SKIPADDR_Msk (0x1UL << RADIO_CRCCNF_SKIPADDR_Pos) /*!< Bit mask of SKIPADDR field. */
N#define RADIO_CRCCNF_SKIPADDR_Include (0UL) /*!< Include packet address in CRC calculation. */
N#define RADIO_CRCCNF_SKIPADDR_Skip (1UL) /*!< Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address. */
N
N/* Bits 1..0 : CRC length. Decision point: START task. */
N#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
N#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
N#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC calculation disabled. */
N#define RADIO_CRCCNF_LEN_One (1UL) /*!< One byte long CRC. */
N#define RADIO_CRCCNF_LEN_Two (2UL) /*!< Two bytes long CRC. */
N#define RADIO_CRCCNF_LEN_Three (3UL) /*!< Three bytes long CRC. */
N
N/* Register: RADIO_CRCPOLY */
N/* Description: CRC polynomial. */
N
N/* Bits 23..0 : CRC polynomial. Decision point: START task. */
N#define RADIO_CRCPOLY_CRCPOLY_Pos (0UL) /*!< Position of CRCPOLY field. */
N#define RADIO_CRCPOLY_CRCPOLY_Msk (0xFFFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
N
N/* Register: RADIO_CRCINIT */
N/* Description: CRC initial value. */
N
N/* Bits 23..0 : Initial value for CRC calculation. Decision point: START task. */
N#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
N#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
N
N/* Register: RADIO_TEST */
N/* Description: Test features enable register. */
N
N/* Bit 1 : PLL lock. Decision point: TXEN or RXEN task. */
N#define RADIO_TEST_PLLLOCK_Pos (1UL) /*!< Position of PLLLOCK field. */
N#define RADIO_TEST_PLLLOCK_Msk (0x1UL << RADIO_TEST_PLLLOCK_Pos) /*!< Bit mask of PLLLOCK field. */
N#define RADIO_TEST_PLLLOCK_Disabled (0UL) /*!< PLL lock disabled. */
N#define RADIO_TEST_PLLLOCK_Enabled (1UL) /*!< PLL lock enabled. */
N
N/* Bit 0 : Constant carrier. Decision point: TXEN task. */
N#define RADIO_TEST_CONSTCARRIER_Pos (0UL) /*!< Position of CONSTCARRIER field. */
N#define RADIO_TEST_CONSTCARRIER_Msk (0x1UL << RADIO_TEST_CONSTCARRIER_Pos) /*!< Bit mask of CONSTCARRIER field. */
N#define RADIO_TEST_CONSTCARRIER_Disabled (0UL) /*!< Constant carrier disabled. */
N#define RADIO_TEST_CONSTCARRIER_Enabled (1UL) /*!< Constant carrier enabled. */
N
N/* Register: RADIO_TIFS */
N/* Description: Inter Frame Spacing in microseconds. */
N
N/* Bits 7..0 : Inter frame spacing in microseconds. Decision point: START rask */
N#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
N#define RADIO_TIFS_TIFS_Msk (0xFFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
N
N/* Register: RADIO_RSSISAMPLE */
N/* Description: RSSI sample. */
N
N/* Bits 6..0 : RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
N
N/* Register: RADIO_STATE */
N/* Description: Current radio state. */
N
N/* Bits 3..0 : Current radio state. */
N#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
N#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
N#define RADIO_STATE_STATE_Disabled (0x00UL) /*!< Radio is in the Disabled state. */
N#define RADIO_STATE_STATE_RxRu (0x01UL) /*!< Radio is in the Rx Ramp Up state. */
N#define RADIO_STATE_STATE_RxIdle (0x02UL) /*!< Radio is in the Rx Idle state. */
N#define RADIO_STATE_STATE_Rx (0x03UL) /*!< Radio is in the Rx state. */
N#define RADIO_STATE_STATE_RxDisable (0x04UL) /*!< Radio is in the Rx Disable state. */
N#define RADIO_STATE_STATE_TxRu (0x09UL) /*!< Radio is in the Tx Ramp Up state. */
N#define RADIO_STATE_STATE_TxIdle (0x0AUL) /*!< Radio is in the Tx Idle state. */
N#define RADIO_STATE_STATE_Tx (0x0BUL) /*!< Radio is in the Tx state. */
N#define RADIO_STATE_STATE_TxDisable (0x0CUL) /*!< Radio is in the Tx Disable state. */
N
N/* Register: RADIO_DATAWHITEIV */
N/* Description: Data whitening initial value. */
N
N/* Bits 6..0 : Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x7FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
N
N/* Register: RADIO_DAP */
N/* Description: Device address prefix. */
N
N/* Bits 15..0 : Device address prefix. */
N#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
N#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
N
N/* Register: RADIO_DACNF */
N/* Description: Device address match configuration. */
N
N/* Bit 15 : TxAdd for device address 7. */
N#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
N#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
N
N/* Bit 14 : TxAdd for device address 6. */
N#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
N#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
N
N/* Bit 13 : TxAdd for device address 5. */
N#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
N#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
N
N/* Bit 12 : TxAdd for device address 4. */
N#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
N#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
N
N/* Bit 11 : TxAdd for device address 3. */
N#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
N#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
N
N/* Bit 10 : TxAdd for device address 2. */
N#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
N#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
N
N/* Bit 9 : TxAdd for device address 1. */
N#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
N#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
N
N/* Bit 8 : TxAdd for device address 0. */
N#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
N#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
N
N/* Bit 7 : Enable or disable device address matching using device address 7. */
N#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
N#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
N#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 6 : Enable or disable device address matching using device address 6. */
N#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
N#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
N#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 5 : Enable or disable device address matching using device address 5. */
N#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
N#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
N#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 4 : Enable or disable device address matching using device address 4. */
N#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
N#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
N#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 3 : Enable or disable device address matching using device address 3. */
N#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
N#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
N#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 2 : Enable or disable device address matching using device address 2. */
N#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
N#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
N#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 1 : Enable or disable device address matching using device address 1. */
N#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
N#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
N#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 0 : Enable or disable device address matching using device address 0. */
N#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
N#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
N#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled. */
N
N/* Register: RADIO_OVERRIDE0 */
N/* Description: Trim value override register 0. */
N
N/* Bits 31..0 : Trim value override 0. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Pos (0UL) /*!< Position of OVERRIDE0 field. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE0_OVERRIDE0_Pos) /*!< Bit mask of OVERRIDE0 field. */
N
N/* Register: RADIO_OVERRIDE1 */
N/* Description: Trim value override register 1. */
N
N/* Bits 31..0 : Trim value override 1. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Pos (0UL) /*!< Position of OVERRIDE1 field. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE1_OVERRIDE1_Pos) /*!< Bit mask of OVERRIDE1 field. */
N
N/* Register: RADIO_OVERRIDE2 */
N/* Description: Trim value override register 2. */
N
N/* Bits 31..0 : Trim value override 2. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Pos (0UL) /*!< Position of OVERRIDE2 field. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE2_OVERRIDE2_Pos) /*!< Bit mask of OVERRIDE2 field. */
N
N/* Register: RADIO_OVERRIDE3 */
N/* Description: Trim value override register 3. */
N
N/* Bits 31..0 : Trim value override 3. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Pos (0UL) /*!< Position of OVERRIDE3 field. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE3_OVERRIDE3_Pos) /*!< Bit mask of OVERRIDE3 field. */
N
N/* Register: RADIO_OVERRIDE4 */
N/* Description: Trim value override register 4. */
N
N/* Bit 31 : Enable or disable override of default trim values. */
N#define RADIO_OVERRIDE4_ENABLE_Pos (31UL) /*!< Position of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Msk (0x1UL << RADIO_OVERRIDE4_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Disabled (0UL) /*!< Override trim values disabled. */
N#define RADIO_OVERRIDE4_ENABLE_Enabled (1UL) /*!< Override trim values enabled. */
N
N/* Bits 27..0 : Trim value override 4. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Pos (0UL) /*!< Position of OVERRIDE4 field. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Msk (0xFFFFFFFUL << RADIO_OVERRIDE4_OVERRIDE4_Pos) /*!< Bit mask of OVERRIDE4 field. */
N
N/* Register: RADIO_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RADIO_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RADIO_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RNG */
N/* Description: Random Number Generator. */
N
N/* Register: RNG_SHORTS */
N/* Description: Shortcuts for the RNG. */
N
N/* Bit 0 : Shortcut between VALRDY event and STOP task. */
N#define RNG_SHORTS_VALRDY_STOP_Pos (0UL) /*!< Position of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Msk (0x1UL << RNG_SHORTS_VALRDY_STOP_Pos) /*!< Bit mask of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RNG_SHORTS_VALRDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RNG_INTENSET */
N/* Description: Interrupt enable set register */
N
N/* Bit 0 : Enable interrupt on VALRDY event. */
N#define RNG_INTENSET_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Msk (0x1UL << RNG_INTENSET_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENSET_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENSET_VALRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RNG_INTENCLR */
N/* Description: Interrupt enable clear register */
N
N/* Bit 0 : Disable interrupt on VALRDY event. */
N#define RNG_INTENCLR_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Msk (0x1UL << RNG_INTENCLR_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENCLR_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENCLR_VALRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RNG_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 0 : Digital error correction enable. */
N#define RNG_CONFIG_DERCEN_Pos (0UL) /*!< Position of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Msk (0x1UL << RNG_CONFIG_DERCEN_Pos) /*!< Bit mask of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Disabled (0UL) /*!< Digital error correction disabled. */
N#define RNG_CONFIG_DERCEN_Enabled (1UL) /*!< Digital error correction enabled. */
N
N/* Register: RNG_VALUE */
N/* Description: RNG random number. */
N
N/* Bits 7..0 : Generated random number. */
N#define RNG_VALUE_VALUE_Pos (0UL) /*!< Position of VALUE field. */
N#define RNG_VALUE_VALUE_Msk (0xFFUL << RNG_VALUE_VALUE_Pos) /*!< Bit mask of VALUE field. */
N
N/* Register: RNG_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RNG_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RNG_POWER_POWER_Msk (0x1UL << RNG_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RNG_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RNG_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RTC */
N/* Description: Real time counter 0. */
N
N/* Register: RTC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] event. */
N#define RTC_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Msk (0x1UL << RTC_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] event. */
N#define RTC_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Msk (0x1UL << RTC_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] event. */
N#define RTC_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Msk (0x1UL << RTC_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] event. */
N#define RTC_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Msk (0x1UL << RTC_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on OVRFLW event. */
N#define RTC_INTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Msk (0x1UL << RTC_INTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_OVRFLW_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on TICK event. */
N#define RTC_INTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENSET_TICK_Msk (0x1UL << RTC_INTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENSET_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_TICK_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RTC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] event. */
N#define RTC_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Msk (0x1UL << RTC_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] event. */
N#define RTC_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Msk (0x1UL << RTC_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] event. */
N#define RTC_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Msk (0x1UL << RTC_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] event. */
N#define RTC_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Msk (0x1UL << RTC_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on OVRFLW event. */
N#define RTC_INTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Msk (0x1UL << RTC_INTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_OVRFLW_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on TICK event. */
N#define RTC_INTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENCLR_TICK_Msk (0x1UL << RTC_INTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENCLR_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_TICK_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RTC_EVTEN */
N/* Description: Configures event enable routing to PPI for each RTC event. */
N
N/* Bit 19 : COMPARE[3] event enable. */
N#define RTC_EVTEN_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Msk (0x1UL << RTC_EVTEN_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 18 : COMPARE[2] event enable. */
N#define RTC_EVTEN_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Msk (0x1UL << RTC_EVTEN_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 17 : COMPARE[1] event enable. */
N#define RTC_EVTEN_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Msk (0x1UL << RTC_EVTEN_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 16 : COMPARE[0] event enable. */
N#define RTC_EVTEN_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Msk (0x1UL << RTC_EVTEN_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 1 : OVRFLW event enable. */
N#define RTC_EVTEN_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Msk (0x1UL << RTC_EVTEN_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 0 : TICK event enable. */
N#define RTC_EVTEN_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTEN_TICK_Msk (0x1UL << RTC_EVTEN_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTEN_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_TICK_Enabled (1UL) /*!< Event enabled. */
N
N/* Register: RTC_EVTENSET */
N/* Description: Enable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Enable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Msk (0x1UL << RTC_EVTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE3_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 18 : Enable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Msk (0x1UL << RTC_EVTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE2_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 17 : Enable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Msk (0x1UL << RTC_EVTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE1_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 16 : Enable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Msk (0x1UL << RTC_EVTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE0_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 1 : Enable routing to PPI of OVRFLW event. */
N#define RTC_EVTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Msk (0x1UL << RTC_EVTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_OVRFLW_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 0 : Enable routing to PPI of TICK event. */
N#define RTC_EVTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENSET_TICK_Msk (0x1UL << RTC_EVTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENSET_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_TICK_Set (1UL) /*!< Enable event on write. */
N
N/* Register: RTC_EVTENCLR */
N/* Description: Disable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Disable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Msk (0x1UL << RTC_EVTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE3_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 18 : Disable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Msk (0x1UL << RTC_EVTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE2_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 17 : Disable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Msk (0x1UL << RTC_EVTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE1_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 16 : Disable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Msk (0x1UL << RTC_EVTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE0_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 1 : Disable routing to PPI of OVRFLW event. */
N#define RTC_EVTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Msk (0x1UL << RTC_EVTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_OVRFLW_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 0 : Disable routing to PPI of TICK event. */
N#define RTC_EVTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENCLR_TICK_Msk (0x1UL << RTC_EVTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENCLR_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_TICK_Clear (1UL) /*!< Disable event on write. */
N
N/* Register: RTC_COUNTER */
N/* Description: Current COUNTER value. */
N
N/* Bits 23..0 : Counter value. */
N#define RTC_COUNTER_COUNTER_Pos (0UL) /*!< Position of COUNTER field. */
N#define RTC_COUNTER_COUNTER_Msk (0xFFFFFFUL << RTC_COUNTER_COUNTER_Pos) /*!< Bit mask of COUNTER field. */
N
N/* Register: RTC_PRESCALER */
N/* Description: 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed. */
N
N/* Bits 11..0 : RTC PRESCALER value. */
N#define RTC_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define RTC_PRESCALER_PRESCALER_Msk (0xFFFUL << RTC_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: RTC_CC */
N/* Description: Capture/compare registers. */
N
N/* Bits 23..0 : Compare value. */
N#define RTC_CC_COMPARE_Pos (0UL) /*!< Position of COMPARE field. */
N#define RTC_CC_COMPARE_Msk (0xFFFFFFUL << RTC_CC_COMPARE_Pos) /*!< Bit mask of COMPARE field. */
N
N/* Register: RTC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RTC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RTC_POWER_POWER_Msk (0x1UL << RTC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RTC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RTC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPI */
N/* Description: SPI master 0. */
N
N/* Register: SPI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on READY event. */
N#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPI_ENABLE */
N/* Description: Enable SPI. */
N
N/* Bits 2..0 : Enable or disable SPI. */
N#define SPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Msk (0x7UL << SPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPI. */
N#define SPI_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable SPI. */
N
N/* Register: SPI_RXD */
N/* Description: RX data. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define SPI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define SPI_RXD_RXD_Msk (0xFFUL << SPI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: SPI_TXD */
N/* Description: TX data. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define SPI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define SPI_TXD_TXD_Msk (0xFFUL << SPI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: SPI_FREQUENCY */
N/* Description: SPI frequency */
N
N/* Bits 31..0 : SPI data rate. */
N#define SPI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500kbps. */
N#define SPI_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8Mbps. */
N
N/* Register: SPI_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPI_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPI_CONFIG_CPOL_Msk (0x1UL << SPI_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPI_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPI_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPI_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPI_CONFIG_CPHA_Msk (0x1UL << SPI_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPI_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPI_CONFIG_ORDER_Msk (0x1UL << SPI_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPI_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPI_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPI_POWER_POWER_Msk (0x1UL << SPI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPIS */
N/* Description: SPI slave 1. */
N
N/* Register: SPIS_SHORTS */
N/* Description: Shortcuts for SPIS. */
N
N/* Bit 2 : Shortcut between END event and the ACQUIRE task. */
N#define SPIS_SHORTS_END_ACQUIRE_Pos (2UL) /*!< Position of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Msk (0x1UL << SPIS_SHORTS_END_ACQUIRE_Pos) /*!< Bit mask of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Disabled (0UL) /*!< Shortcut disabled. */
N#define SPIS_SHORTS_END_ACQUIRE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: SPIS_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on ACQUIRED event. */
N#define SPIS_INTENSET_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Msk (0x1UL << SPIS_INTENSET_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_ACQUIRED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 4 : enable interrupt on ENDRX event. */
N#define SPIS_INTENSET_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIS_INTENSET_ENDRX_Msk (0x1UL << SPIS_INTENSET_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIS_INTENSET_ENDRX_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_ENDRX_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_ENDRX_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on END event. */
N#define SPIS_INTENSET_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENSET_END_Msk (0x1UL << SPIS_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPIS_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on ACQUIRED event. */
N#define SPIS_INTENCLR_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Msk (0x1UL << SPIS_INTENCLR_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_ACQUIRED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 4 : Disable interrupt on ENDRX event. */
N#define SPIS_INTENCLR_ENDRX_Pos (4UL) /*!< Position of ENDRX field. */
N#define SPIS_INTENCLR_ENDRX_Msk (0x1UL << SPIS_INTENCLR_ENDRX_Pos) /*!< Bit mask of ENDRX field. */
N#define SPIS_INTENCLR_ENDRX_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_ENDRX_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_ENDRX_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on END event. */
N#define SPIS_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENCLR_END_Msk (0x1UL << SPIS_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPIS_SEMSTAT */
N/* Description: Semaphore status. */
N
N/* Bits 1..0 : Semaphore status. */
N#define SPIS_SEMSTAT_SEMSTAT_Pos (0UL) /*!< Position of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Msk (0x3UL << SPIS_SEMSTAT_SEMSTAT_Pos) /*!< Bit mask of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Free (0x00UL) /*!< Semaphore is free. */
N#define SPIS_SEMSTAT_SEMSTAT_CPU (0x01UL) /*!< Semaphore is assigned to the CPU. */
N#define SPIS_SEMSTAT_SEMSTAT_SPIS (0x02UL) /*!< Semaphore is assigned to the SPIS. */
N#define SPIS_SEMSTAT_SEMSTAT_CPUPending (0x03UL) /*!< Semaphore is assigned to the SPIS, but a handover to the CPU is pending. */
N
N/* Register: SPIS_STATUS */
N/* Description: Status from last transaction. */
N
N/* Bit 1 : RX buffer overflow detected, and prevented. */
N#define SPIS_STATUS_OVERFLOW_Pos (1UL) /*!< Position of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_Msk (0x1UL << SPIS_STATUS_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERFLOW_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERFLOW_Clear (1UL) /*!< Clear on write. */
N
N/* Bit 0 : TX buffer overread detected, and prevented. */
N#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Clear on write. */
N
N/* Register: SPIS_ENABLE */
N/* Description: Enable SPIS. */
N
N/* Bits 2..0 : Enable or disable SPIS. */
N#define SPIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Msk (0x7UL << SPIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPIS. */
N#define SPIS_ENABLE_ENABLE_Enabled (0x02UL) /*!< Enable SPIS. */
N
N/* Register: SPIS_MAXRX */
N/* Description: Maximum number of bytes in the receive buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the receive buffer. */
N#define SPIS_MAXRX_MAXRX_Pos (0UL) /*!< Position of MAXRX field. */
N#define SPIS_MAXRX_MAXRX_Msk (0xFFUL << SPIS_MAXRX_MAXRX_Pos) /*!< Bit mask of MAXRX field. */
N
N/* Register: SPIS_AMOUNTRX */
N/* Description: Number of bytes received in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes received in last granted transaction. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Pos (0UL) /*!< Position of AMOUNTRX field. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Msk (0xFFUL << SPIS_AMOUNTRX_AMOUNTRX_Pos) /*!< Bit mask of AMOUNTRX field. */
N
N/* Register: SPIS_MAXTX */
N/* Description: Maximum number of bytes in the transmit buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the transmit buffer. */
N#define SPIS_MAXTX_MAXTX_Pos (0UL) /*!< Position of MAXTX field. */
N#define SPIS_MAXTX_MAXTX_Msk (0xFFUL << SPIS_MAXTX_MAXTX_Pos) /*!< Bit mask of MAXTX field. */
N
N/* Register: SPIS_AMOUNTTX */
N/* Description: Number of bytes transmitted in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes transmitted in last granted transaction. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Pos (0UL) /*!< Position of AMOUNTTX field. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Msk (0xFFUL << SPIS_AMOUNTTX_AMOUNTTX_Pos) /*!< Bit mask of AMOUNTTX field. */
N
N/* Register: SPIS_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPIS_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPIS_CONFIG_CPOL_Msk (0x1UL << SPIS_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPIS_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPIS_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPIS_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPIS_CONFIG_CPHA_Msk (0x1UL << SPIS_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPIS_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPIS_CONFIG_ORDER_Msk (0x1UL << SPIS_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPIS_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPIS_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPIS_DEF */
N/* Description: Default character. */
N
N/* Bits 7..0 : Default character. */
N#define SPIS_DEF_DEF_Pos (0UL) /*!< Position of DEF field. */
N#define SPIS_DEF_DEF_Msk (0xFFUL << SPIS_DEF_DEF_Pos) /*!< Bit mask of DEF field. */
N
N/* Register: SPIS_ORC */
N/* Description: Over-read character. */
N
N/* Bits 7..0 : Over-read character. */
N#define SPIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
N#define SPIS_ORC_ORC_Msk (0xFFUL << SPIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
N
N/* Register: SPIS_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPIS_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPIS_POWER_POWER_Msk (0x1UL << SPIS_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPIS_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPIS_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TEMP */
N/* Description: Temperature Sensor. */
N
N/* Register: TEMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on DATARDY event. */
N#define TEMP_INTENSET_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Msk (0x1UL << TEMP_INTENSET_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENSET_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENSET_DATARDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TEMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on DATARDY event. */
N#define TEMP_INTENCLR_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Msk (0x1UL << TEMP_INTENCLR_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENCLR_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENCLR_DATARDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TEMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TEMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TEMP_POWER_POWER_Msk (0x1UL << TEMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TEMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TEMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TIMER */
N/* Description: Timer 0. */
N
N/* Register: TIMER_SHORTS */
N/* Description: Shortcuts for Timer. */
N
N/* Bit 11 : Shortcut between CC[3] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE3_STOP_Pos (11UL) /*!< Position of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE3_STOP_Pos) /*!< Bit mask of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 10 : Shortcut between CC[2] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE2_STOP_Pos (10UL) /*!< Position of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE2_STOP_Pos) /*!< Bit mask of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 9 : Shortcut between CC[1] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE1_STOP_Pos (9UL) /*!< Position of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE1_STOP_Pos) /*!< Bit mask of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 8 : Shortcut between CC[0] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE0_STOP_Pos (8UL) /*!< Position of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE0_STOP_Pos) /*!< Bit mask of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between CC[3] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Pos (3UL) /*!< Position of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE3_CLEAR_Pos) /*!< Bit mask of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between CC[2] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Pos (2UL) /*!< Position of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE2_CLEAR_Pos) /*!< Bit mask of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between CC[1] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Pos (1UL) /*!< Position of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE1_CLEAR_Pos) /*!< Bit mask of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between CC[0] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Pos (0UL) /*!< Position of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE0_CLEAR_Pos) /*!< Bit mask of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TIMER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] */
N#define TIMER_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Msk (0x1UL << TIMER_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] */
N#define TIMER_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Msk (0x1UL << TIMER_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] */
N#define TIMER_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Msk (0x1UL << TIMER_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] */
N#define TIMER_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Msk (0x1UL << TIMER_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TIMER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] */
N#define TIMER_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Msk (0x1UL << TIMER_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] */
N#define TIMER_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Msk (0x1UL << TIMER_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] */
N#define TIMER_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Msk (0x1UL << TIMER_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] */
N#define TIMER_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Msk (0x1UL << TIMER_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TIMER_MODE */
N/* Description: Timer Mode selection. */
N
N/* Bit 0 : Select Normal or Counter mode. */
N#define TIMER_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define TIMER_MODE_MODE_Msk (0x1UL << TIMER_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define TIMER_MODE_MODE_Timer (0UL) /*!< Timer in Normal mode. */
N#define TIMER_MODE_MODE_Counter (1UL) /*!< Timer in Counter mode. */
N
N/* Register: TIMER_BITMODE */
N/* Description: Sets timer behaviour. */
N
N/* Bits 1..0 : Sets timer behaviour ro be like the implementation of a timer with width as indicated. */
N#define TIMER_BITMODE_BITMODE_Pos (0UL) /*!< Position of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_Msk (0x3UL << TIMER_BITMODE_BITMODE_Pos) /*!< Bit mask of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_16Bit (0x00UL) /*!< 16-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_08Bit (0x01UL) /*!< 8-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_24Bit (0x02UL) /*!< 24-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_32Bit (0x03UL) /*!< 32-bit timer behaviour. */
N
N/* Register: TIMER_PRESCALER */
N/* Description: 4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE. */
N
N/* Bits 3..0 : Timer PRESCALER value. Max value is 9. */
N#define TIMER_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define TIMER_PRESCALER_PRESCALER_Msk (0xFUL << TIMER_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: TIMER_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TIMER_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TIMER_POWER_POWER_Msk (0x1UL << TIMER_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TIMER_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TIMER_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TWI */
N/* Description: Two-wire interface master 0. */
N
N/* Register: TWI_SHORTS */
N/* Description: Shortcuts for TWI. */
N
N/* Bit 1 : Shortcut between BB event and the STOP task. */
N#define TWI_SHORTS_BB_STOP_Pos (1UL) /*!< Position of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Msk (0x1UL << TWI_SHORTS_BB_STOP_Pos) /*!< Bit mask of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between BB event and the SUSPEND task. */
N#define TWI_SHORTS_BB_SUSPEND_Pos (0UL) /*!< Position of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Msk (0x1UL << TWI_SHORTS_BB_SUSPEND_Pos) /*!< Bit mask of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_SUSPEND_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TWI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 18 : Enable interrupt on SUSPENDED event. */
N#define TWI_INTENSET_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWI_INTENSET_SUSPENDED_Msk (0x1UL << TWI_INTENSET_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWI_INTENSET_SUSPENDED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_SUSPENDED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_SUSPENDED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 14 : Enable interrupt on BB event. */
N#define TWI_INTENSET_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENSET_BB_Msk (0x1UL << TWI_INTENSET_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENSET_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_BB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define TWI_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENSET_ERROR_Msk (0x1UL << TWI_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXDSENT event. */
N#define TWI_INTENSET_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Msk (0x1UL << TWI_INTENSET_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_TXDSENT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on STOPPED event. */
N#define TWI_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Msk (0x1UL << TWI_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_STOPPED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TWI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 18 : Disable interrupt on SUSPENDED event. */
N#define TWI_INTENCLR_SUSPENDED_Pos (18UL) /*!< Position of SUSPENDED field. */
N#define TWI_INTENCLR_SUSPENDED_Msk (0x1UL << TWI_INTENCLR_SUSPENDED_Pos) /*!< Bit mask of SUSPENDED field. */
N#define TWI_INTENCLR_SUSPENDED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_SUSPENDED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_SUSPENDED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 14 : Disable interrupt on BB event. */
N#define TWI_INTENCLR_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENCLR_BB_Msk (0x1UL << TWI_INTENCLR_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENCLR_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_BB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define TWI_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENCLR_ERROR_Msk (0x1UL << TWI_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXDSENT event. */
N#define TWI_INTENCLR_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Msk (0x1UL << TWI_INTENCLR_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_TXDSENT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXDREADY event. */
N#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on STOPPED event. */
N#define TWI_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Msk (0x1UL << TWI_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_STOPPED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TWI_ERRORSRC */
N/* Description: Two-wire error source. Write error field to 1 to clear error. */
N
N/* Bit 2 : NACK received after sending a data byte. */
N#define TWI_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
N#define TWI_ERRORSRC_DNACK_Msk (0x1UL << TWI_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
N#define TWI_ERRORSRC_DNACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_DNACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_DNACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : NACK received after sending the address. */
N#define TWI_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
N#define TWI_ERRORSRC_ANACK_Msk (0x1UL << TWI_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
N#define TWI_ERRORSRC_ANACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_ANACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_ANACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 0 : Byte received in RXD register before read of the last received byte (data loss). */
N#define TWI_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define TWI_ERRORSRC_OVERRUN_Msk (0x1UL << TWI_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define TWI_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_OVERRUN_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_OVERRUN_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: TWI_ENABLE */
N/* Description: Enable two-wire master. */
N
N/* Bits 2..0 : Enable or disable W2M */
N#define TWI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Msk (0x7UL << TWI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled. */
N#define TWI_ENABLE_ENABLE_Enabled (0x05UL) /*!< Enabled. */
N
N/* Register: TWI_RXD */
N/* Description: RX data register. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define TWI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define TWI_RXD_RXD_Msk (0xFFUL << TWI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: TWI_TXD */
N/* Description: TX data register. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define TWI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define TWI_TXD_TXD_Msk (0xFFUL << TWI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: TWI_FREQUENCY */
N/* Description: Two-wire frequency. */
N
N/* Bits 31..0 : Two-wire master clock frequency. */
N#define TWI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K400 (0x06680000UL) /*!< 400 kbps (actual rate 410.256 kbps). */
N
N/* Register: TWI_ADDRESS */
N/* Description: Address used in the two-wire transfer. */
N
N/* Bits 6..0 : Two-wire address. */
N#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
N#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N
N/* Register: TWI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TWI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TWI_POWER_POWER_Msk (0x1UL << TWI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TWI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TWI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UART */
N/* Description: Universal Asynchronous Receiver/Transmitter. */
N
N/* Register: UART_SHORTS */
N/* Description: Shortcuts for UART. */
N
N/* Bit 4 : Shortcut between NCTS event and STOPRX task. */
N#define UART_SHORTS_NCTS_STOPRX_Pos (4UL) /*!< Position of NCTS_STOPRX field. */
N#define UART_SHORTS_NCTS_STOPRX_Msk (0x1UL << UART_SHORTS_NCTS_STOPRX_Pos) /*!< Bit mask of NCTS_STOPRX field. */
N#define UART_SHORTS_NCTS_STOPRX_Disabled (0UL) /*!< Shortcut disabled. */
N#define UART_SHORTS_NCTS_STOPRX_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between CTS event and STARTRX task. */
N#define UART_SHORTS_CTS_STARTRX_Pos (3UL) /*!< Position of CTS_STARTRX field. */
N#define UART_SHORTS_CTS_STARTRX_Msk (0x1UL << UART_SHORTS_CTS_STARTRX_Pos) /*!< Bit mask of CTS_STARTRX field. */
N#define UART_SHORTS_CTS_STARTRX_Disabled (0UL) /*!< Shortcut disabled. */
N#define UART_SHORTS_CTS_STARTRX_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: UART_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 17 : Enable interrupt on RXTO event. */
N#define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENSET_RXTO_Msk (0x1UL << UART_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENSET_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENSET_ERROR_Msk (0x1UL << UART_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXRDY event. */
N#define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Msk (0x1UL << UART_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_TXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on RXRDY event. */
N#define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Msk (0x1UL << UART_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on NCTS event. */
N#define UART_INTENSET_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UART_INTENSET_NCTS_Msk (0x1UL << UART_INTENSET_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UART_INTENSET_NCTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_NCTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_NCTS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on CTS event. */
N#define UART_INTENSET_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UART_INTENSET_CTS_Msk (0x1UL << UART_INTENSET_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UART_INTENSET_CTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_CTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_CTS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: UART_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 17 : Disable interrupt on RXTO event. */
N#define UART_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENCLR_RXTO_Msk (0x1UL << UART_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENCLR_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define UART_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENCLR_ERROR_Msk (0x1UL << UART_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXRDY event. */
N#define UART_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Msk (0x1UL << UART_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXRDY event. */
N#define UART_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Msk (0x1UL << UART_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on NCTS event. */
N#define UART_INTENCLR_NCTS_Pos (1UL) /*!< Position of NCTS field. */
N#define UART_INTENCLR_NCTS_Msk (0x1UL << UART_INTENCLR_NCTS_Pos) /*!< Bit mask of NCTS field. */
N#define UART_INTENCLR_NCTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_NCTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_NCTS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on CTS event. */
N#define UART_INTENCLR_CTS_Pos (0UL) /*!< Position of CTS field. */
N#define UART_INTENCLR_CTS_Msk (0x1UL << UART_INTENCLR_CTS_Pos) /*!< Bit mask of CTS field. */
N#define UART_INTENCLR_CTS_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_CTS_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_CTS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: UART_ERRORSRC */
N/* Description: Error source. Write error field to 1 to clear error. */
N
N/* Bit 3 : The serial data input is '0' for longer than the length of a data frame. */
N#define UART_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
N#define UART_ERRORSRC_BREAK_Msk (0x1UL << UART_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
N#define UART_ERRORSRC_BREAK_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_BREAK_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_BREAK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 2 : A valid stop bit is not detected on the serial data input after all bits in a character have been received. */
N#define UART_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_Msk (0x1UL << UART_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_FRAMING_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_FRAMING_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : A character with bad parity is received. Only checked if HW parity control is enabled. */
N#define UART_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_ERRORSRC_PARITY_Msk (0x1UL << UART_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_ERRORSRC_PARITY_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_PARITY_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_PARITY_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 0 : A start bit is received while the previous data still lies in RXD. (Data loss). */
N#define UART_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_Msk (0x1UL << UART_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_OVERRUN_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_OVERRUN_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: UART_ENABLE */
N/* Description: Enable UART and acquire IOs. */
N
N/* Bits 2..0 : Enable or disable UART and acquire IOs. */
N#define UART_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define UART_ENABLE_ENABLE_Msk (0x7UL << UART_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define UART_ENABLE_ENABLE_Disabled (0x00UL) /*!< UART disabled. */
N#define UART_ENABLE_ENABLE_Enabled (0x04UL) /*!< UART enabled. */
N
N/* Register: UART_RXD */
N/* Description: RXD register. On read action the buffer pointer is displaced. Once read the character is consumed. If read when no character available, the UART will stop working. */
N
N/* Bits 7..0 : RX data from previous transfer. Double buffered. */
N#define UART_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define UART_RXD_RXD_Msk (0xFFUL << UART_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: UART_TXD */
N/* Description: TXD register. */
N
N/* Bits 7..0 : TX data for transfer. */
N#define UART_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define UART_TXD_TXD_Msk (0xFFUL << UART_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: UART_BAUDRATE */
N/* Description: UART Baudrate. */
N
N/* Bits 31..0 : UART baudrate. */
N#define UART_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UART_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud14400 (0x003B0000UL) /*!< 14400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud28800 (0x0075F000UL) /*!< 28800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud31250 (0x00800000UL) /*!< 31250 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud38400 (0x009D5000UL) /*!< 38400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud56000 (0x00E50000UL) /*!< 56000 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud57600 (0x00EBF000UL) /*!< 57600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud115200 (0x01D7E000UL) /*!< 115200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud230400 (0x03AFB000UL) /*!< 230400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud460800 (0x075F7000UL) /*!< 460800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud921600 (0x0EBED000UL) /*!< 921600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1M baud. */
N
N/* Register: UART_CONFIG */
N/* Description: Configuration of parity and hardware flow control register. */
N
N/* Bits 3..1 : Include parity bit. */
N#define UART_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_CONFIG_PARITY_Msk (0x7UL << UART_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_CONFIG_PARITY_Excluded (0UL) /*!< Parity bit excluded. */
N#define UART_CONFIG_PARITY_Included (7UL) /*!< Parity bit included. */
N
N/* Bit 0 : Hardware flow control. */
N#define UART_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
N#define UART_CONFIG_HWFC_Msk (0x1UL << UART_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
N#define UART_CONFIG_HWFC_Disabled (0UL) /*!< Hardware flow control disabled. */
N#define UART_CONFIG_HWFC_Enabled (1UL) /*!< Hardware flow control enabled. */
N
N/* Register: UART_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define UART_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define UART_POWER_POWER_Msk (0x1UL << UART_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define UART_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define UART_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UICR */
N/* Description: User Information Configuration. */
N
N/* Register: UICR_RBPCONF */
N/* Description: Readback protection configuration. */
N
N/* Bits 15..8 : Readback protect all code in the device. */
N#define UICR_RBPCONF_PALL_Pos (8UL) /*!< Position of PALL field. */
N#define UICR_RBPCONF_PALL_Msk (0xFFUL << UICR_RBPCONF_PALL_Pos) /*!< Bit mask of PALL field. */
N#define UICR_RBPCONF_PALL_Enabled (0x00UL) /*!< Enabled. */
N#define UICR_RBPCONF_PALL_Disabled (0xFFUL) /*!< Disabled. */
N
N/* Bits 7..0 : Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip. */
N#define UICR_RBPCONF_PR0_Pos (0UL) /*!< Position of PR0 field. */
N#define UICR_RBPCONF_PR0_Msk (0xFFUL << UICR_RBPCONF_PR0_Pos) /*!< Bit mask of PR0 field. */
N#define UICR_RBPCONF_PR0_Enabled (0x00UL) /*!< Enabled. */
N#define UICR_RBPCONF_PR0_Disabled (0xFFUL) /*!< Disabled. */
N
N/* Register: UICR_XTALFREQ */
N/* Description: Reset value for CLOCK XTALFREQ register. */
N
N/* Bits 7..0 : Reset value for CLOCK XTALFREQ register. */
N#define UICR_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_Msk (0xFFUL << UICR_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz Xtal is used. */
N#define UICR_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz Xtal is used. */
N
N/* Register: UICR_FWID */
N/* Description: Firmware ID. */
N
N/* Bits 15..0 : Identification number for the firmware loaded into the chip. */
N#define UICR_FWID_FWID_Pos (0UL) /*!< Position of FWID field. */
N#define UICR_FWID_FWID_Msk (0xFFFFUL << UICR_FWID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N
N/* Peripheral: WDT */
N/* Description: Watchdog Timer. */
N
N/* Register: WDT_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on TIMEOUT event. */
N#define WDT_INTENSET_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Msk (0x1UL << WDT_INTENSET_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENSET_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENSET_TIMEOUT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: WDT_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on TIMEOUT event. */
N#define WDT_INTENCLR_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Msk (0x1UL << WDT_INTENCLR_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENCLR_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENCLR_TIMEOUT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: WDT_RUNSTATUS */
N/* Description: Watchdog running status. */
N
N/* Bit 0 : Watchdog running status. */
N#define WDT_RUNSTATUS_RUNSTATUS_Pos (0UL) /*!< Position of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_Msk (0x1UL << WDT_RUNSTATUS_RUNSTATUS_Pos) /*!< Bit mask of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_NotRunning (0UL) /*!< Watchdog timer is not running. */
N#define WDT_RUNSTATUS_RUNSTATUS_Running (1UL) /*!< Watchdog timer is running. */
N
N/* Register: WDT_REQSTATUS */
N/* Description: Request status. */
N
N/* Bit 7 : Request status for RR[7]. */
N#define WDT_REQSTATUS_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_REQSTATUS_RR7_Msk (0x1UL << WDT_REQSTATUS_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR7_EnabledAndUnrequested (1UL) /*!< RR[7] register is enabled and has not jet requested. */
N
N/* Bit 6 : Request status for RR[6]. */
N#define WDT_REQSTATUS_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_REQSTATUS_RR6_Msk (0x1UL << WDT_REQSTATUS_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR6_EnabledAndUnrequested (1UL) /*!< RR[6] register is enabled and has not jet requested. */
N
N/* Bit 5 : Request status for RR[5]. */
N#define WDT_REQSTATUS_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_REQSTATUS_RR5_Msk (0x1UL << WDT_REQSTATUS_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR5_EnabledAndUnrequested (1UL) /*!< RR[5] register is enabled and has not jet requested. */
N
N/* Bit 4 : Request status for RR[4]. */
N#define WDT_REQSTATUS_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_REQSTATUS_RR4_Msk (0x1UL << WDT_REQSTATUS_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR4_EnabledAndUnrequested (1UL) /*!< RR[4] register is enabled and has not jet requested. */
N
N/* Bit 3 : Request status for RR[3]. */
N#define WDT_REQSTATUS_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_REQSTATUS_RR3_Msk (0x1UL << WDT_REQSTATUS_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR3_EnabledAndUnrequested (1UL) /*!< RR[3] register is enabled and has not jet requested. */
N
N/* Bit 2 : Request status for RR[2]. */
N#define WDT_REQSTATUS_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_REQSTATUS_RR2_Msk (0x1UL << WDT_REQSTATUS_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR2_EnabledAndUnrequested (1UL) /*!< RR[2] register is enabled and has not jet requested. */
N
N/* Bit 1 : Request status for RR[1]. */
N#define WDT_REQSTATUS_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_REQSTATUS_RR1_Msk (0x1UL << WDT_REQSTATUS_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR1_EnabledAndUnrequested (1UL) /*!< RR[1] register is enabled and has not jet requested. */
N
N/* Bit 0 : Request status for RR[0]. */
N#define WDT_REQSTATUS_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_REQSTATUS_RR0_Msk (0x1UL << WDT_REQSTATUS_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR0_EnabledAndUnrequested (1UL) /*!< RR[0] register is enabled and has not jet requested. */
N
N/* Register: WDT_RREN */
N/* Description: Reload request enable. */
N
N/* Bit 7 : Enable or disable RR[7] register. */
N#define WDT_RREN_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_RREN_RR7_Msk (0x1UL << WDT_RREN_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_RREN_RR7_Disabled (0UL) /*!< RR[7] register is disabled. */
N#define WDT_RREN_RR7_Enabled (1UL) /*!< RR[7] register is enabled. */
N
N/* Bit 6 : Enable or disable RR[6] register. */
N#define WDT_RREN_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_RREN_RR6_Msk (0x1UL << WDT_RREN_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_RREN_RR6_Disabled (0UL) /*!< RR[6] register is disabled. */
N#define WDT_RREN_RR6_Enabled (1UL) /*!< RR[6] register is enabled. */
N
N/* Bit 5 : Enable or disable RR[5] register. */
N#define WDT_RREN_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_RREN_RR5_Msk (0x1UL << WDT_RREN_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_RREN_RR5_Disabled (0UL) /*!< RR[5] register is disabled. */
N#define WDT_RREN_RR5_Enabled (1UL) /*!< RR[5] register is enabled. */
N
N/* Bit 4 : Enable or disable RR[4] register. */
N#define WDT_RREN_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_RREN_RR4_Msk (0x1UL << WDT_RREN_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_RREN_RR4_Disabled (0UL) /*!< RR[4] register is disabled. */
N#define WDT_RREN_RR4_Enabled (1UL) /*!< RR[4] register is enabled. */
N
N/* Bit 3 : Enable or disable RR[3] register. */
N#define WDT_RREN_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_RREN_RR3_Msk (0x1UL << WDT_RREN_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_RREN_RR3_Disabled (0UL) /*!< RR[3] register is disabled. */
N#define WDT_RREN_RR3_Enabled (1UL) /*!< RR[3] register is enabled. */
N
N/* Bit 2 : Enable or disable RR[2] register. */
N#define WDT_RREN_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_RREN_RR2_Msk (0x1UL << WDT_RREN_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_RREN_RR2_Disabled (0UL) /*!< RR[2] register is disabled. */
N#define WDT_RREN_RR2_Enabled (1UL) /*!< RR[2] register is enabled. */
N
N/* Bit 1 : Enable or disable RR[1] register. */
N#define WDT_RREN_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_RREN_RR1_Msk (0x1UL << WDT_RREN_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_RREN_RR1_Disabled (0UL) /*!< RR[1] register is disabled. */
N#define WDT_RREN_RR1_Enabled (1UL) /*!< RR[1] register is enabled. */
N
N/* Bit 0 : Enable or disable RR[0] register. */
N#define WDT_RREN_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_RREN_RR0_Msk (0x1UL << WDT_RREN_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_RREN_RR0_Disabled (0UL) /*!< RR[0] register is disabled. */
N#define WDT_RREN_RR0_Enabled (1UL) /*!< RR[0] register is enabled. */
N
N/* Register: WDT_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 3 : Configure the watchdog to pause or not while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Pos (3UL) /*!< Position of HALT field. */
N#define WDT_CONFIG_HALT_Msk (0x1UL << WDT_CONFIG_HALT_Pos) /*!< Bit mask of HALT field. */
N#define WDT_CONFIG_HALT_Pause (0UL) /*!< Pause watchdog while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Run (1UL) /*!< Do not pause watchdog while the CPU is halted by the debugger. */
N
N/* Bit 0 : Configure the watchdog to pause or not while the CPU is sleeping. */
N#define WDT_CONFIG_SLEEP_Pos (0UL) /*!< Position of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Msk (0x1UL << WDT_CONFIG_SLEEP_Pos) /*!< Bit mask of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Pause (0UL) /*!< Pause watchdog while the CPU is asleep. */
N#define WDT_CONFIG_SLEEP_Run (1UL) /*!< Do not pause watchdog while the CPU is asleep. */
N
N/* Register: WDT_RR */
N/* Description: Reload requests registers. */
N
N/* Bits 31..0 : Reload register. */
N#define WDT_RR_RR_Pos (0UL) /*!< Position of RR field. */
N#define WDT_RR_RR_Msk (0xFFFFFFFFUL << WDT_RR_RR_Pos) /*!< Bit mask of RR field. */
N#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer. */
N
N/* Register: WDT_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define WDT_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define WDT_POWER_POWER_Msk (0x1UL << WDT_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define WDT_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define WDT_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/*lint --flb "Leave library region" */
N#endif
L 64 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 2
N        #include "nrf51_deprecated.h"
L 1 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf51_deprecated.h" 1
N/* Copyright (c) 2016, Nordic Semiconductor ASA
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N *   * Redistributions of source code must retain the above copyright notice, this
N *     list of conditions and the following disclaimer.
N *
N *   * Redistributions in binary form must reproduce the above copyright notice,
N *     this list of conditions and the following disclaimer in the documentation
N *     and/or other materials provided with the distribution.
N *
N *   * Neither the name of Nordic Semiconductor ASA nor the names of its
N *     contributors may be used to endorse or promote products derived from
N *     this software without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *
N */
N 
N#ifndef NRF51_DEPRECATED_H
N#define NRF51_DEPRECATED_H
N
N/*lint ++flb "Enter library region */
N
N/* This file is given to prevent your SW from not compiling with the updates made to nrf51.h and 
N * nrf51_bitfields.h. The macros defined in this file were available previously. Do not use these
N * macros on purpose. Use the ones defined in nrf51.h and nrf51_bitfields.h instead.
N */
N
N/* NVMC */
N/* The register ERASEPROTECTEDPAGE is called ERASEPCR0 in the documentation. */
N#define ERASEPROTECTEDPAGE   ERASEPCR0
N
N 
N/* LPCOMP */
N/* The interrupt ISR was renamed. Adding old name to the macros. */
N#define LPCOMP_COMP_IRQHandler          LPCOMP_IRQHandler
N#define LPCOMP_COMP_IRQn                LPCOMP_IRQn
N/* Corrected typo in RESULT register. */
N#define LPCOMP_RESULT_RESULT_Bellow     LPCOMP_RESULT_RESULT_Below
N 
N 
N/* MPU */
N/* The field MPU.PERR0.LPCOMP_COMP was renamed. Added into deprecated in case somebody was using the macros defined for it. */
N#define MPU_PERR0_LPCOMP_COMP_Pos           MPU_PERR0_LPCOMP_Pos
N#define MPU_PERR0_LPCOMP_COMP_Msk           MPU_PERR0_LPCOMP_Msk
N#define MPU_PERR0_LPCOMP_COMP_InRegion1     MPU_PERR0_LPCOMP_InRegion1
N#define MPU_PERR0_LPCOMP_COMP_InRegion0     MPU_PERR0_LPCOMP_InRegion0
N 
N 
N/* POWER */
N/* The field POWER.RAMON.OFFRAM3 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_OFFRAM3_Pos         (19UL)                                  
N#define POWER_RAMON_OFFRAM3_Msk         (0x1UL << POWER_RAMON_OFFRAM3_Pos)      
N#define POWER_RAMON_OFFRAM3_RAM3Off     (0UL)                                   
N#define POWER_RAMON_OFFRAM3_RAM3On      (1UL)                                   
N/* The field POWER.RAMON.OFFRAM2 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_OFFRAM2_Pos         (18UL)                                  
N#define POWER_RAMON_OFFRAM2_Msk         (0x1UL << POWER_RAMON_OFFRAM2_Pos)      
N#define POWER_RAMON_OFFRAM2_RAM2Off     (0UL)                                   
N#define POWER_RAMON_OFFRAM2_RAM2On      (1UL)                                  
N/* The field POWER.RAMON.ONRAM3 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_ONRAM3_Pos          (3UL)                                  
N#define POWER_RAMON_ONRAM3_Msk          (0x1UL << POWER_RAMON_ONRAM3_Pos)      
N#define POWER_RAMON_ONRAM3_RAM3Off      (0UL)                                  
N#define POWER_RAMON_ONRAM3_RAM3On       (1UL)                                  
N/* The field POWER.RAMON.ONRAM2 was eliminated. Added into deprecated in case somebody was using the macros defined for it. */
N#define POWER_RAMON_ONRAM2_Pos          (2UL)                                  
N#define POWER_RAMON_ONRAM2_Msk          (0x1UL << POWER_RAMON_ONRAM2_Pos)       
N#define POWER_RAMON_ONRAM2_RAM2Off      (0UL)                                  
N#define POWER_RAMON_ONRAM2_RAM2On       (1UL)                                 
N
N 
N/* RADIO */
N/* The enumerated value RADIO.TXPOWER.TXPOWER.Neg40dBm was renamed. Added into deprecated with the new macro name. */
N#define RADIO_TXPOWER_TXPOWER_Neg40dBm  RADIO_TXPOWER_TXPOWER_Neg30dBm      
N/* The name of the field SKIPADDR was corrected. Old macros added for compatibility. */
N#define RADIO_CRCCNF_SKIP_ADDR_Pos      RADIO_CRCCNF_SKIPADDR_Pos 
N#define RADIO_CRCCNF_SKIP_ADDR_Msk      RADIO_CRCCNF_SKIPADDR_Msk 
N#define RADIO_CRCCNF_SKIP_ADDR_Include  RADIO_CRCCNF_SKIPADDR_Include 
N#define RADIO_CRCCNF_SKIP_ADDR_Skip     RADIO_CRCCNF_SKIPADDR_Skip 
N/* The name of the field PLLLOCK was corrected. Old macros added for compatibility. */
N#define RADIO_TEST_PLL_LOCK_Pos         RADIO_TEST_PLLLOCK_Pos 
N#define RADIO_TEST_PLL_LOCK_Msk         RADIO_TEST_PLLLOCK_Msk 
N#define RADIO_TEST_PLL_LOCK_Disabled    RADIO_TEST_PLLLOCK_Disabled 
N#define RADIO_TEST_PLL_LOCK_Enabled     RADIO_TEST_PLLLOCK_Enabled 
N/* The name of the field CONSTCARRIER was corrected. Old macros added for compatibility. */
N#define RADIO_TEST_CONST_CARRIER_Pos        RADIO_TEST_CONSTCARRIER_Pos 
N#define RADIO_TEST_CONST_CARRIER_Msk        RADIO_TEST_CONSTCARRIER_Msk 
N#define RADIO_TEST_CONST_CARRIER_Disabled   RADIO_TEST_CONSTCARRIER_Disabled 
N#define RADIO_TEST_CONST_CARRIER_Enabled    RADIO_TEST_CONSTCARRIER_Enabled 
N
N
N/* FICR */
N/* The registers FICR.SIZERAMBLOCK0, FICR.SIZERAMBLOCK1, FICR.SIZERAMBLOCK2 and FICR.SIZERAMBLOCK3 were renamed into an array. */
N#define SIZERAMBLOCK0   SIZERAMBLOCKS                   
N#define SIZERAMBLOCK1   SIZERAMBLOCKS                   
N#define SIZERAMBLOCK2   SIZERAMBLOCK[2]                 /*!< Note that this macro will disapear when SIZERAMBLOCK array is eliminated. SIZERAMBLOCK is a deprecated array. */
N#define SIZERAMBLOCK3   SIZERAMBLOCK[3]                 /*!< Note that this macro will disapear when SIZERAMBLOCK array is eliminated. SIZERAMBLOCK is a deprecated array. */
N/* The registers FICR.DEVICEID0 and FICR.DEVICEID1 were renamed into an array. */
N#define DEVICEID0       DEVICEID[0]                     
N#define DEVICEID1       DEVICEID[1]                     
N/* The registers FICR.ER0, FICR.ER1, FICR.ER2 and FICR.ER3 were renamed into an array. */
N#define ER0             ER[0]                           
N#define ER1             ER[1]                          
N#define ER2             ER[2]                       
N#define ER3             ER[3]                      
N/* The registers FICR.IR0, FICR.IR1, FICR.IR2 and FICR.IR3 were renamed into an array. */
N#define IR0             IR[0]                         
N#define IR1             IR[1]                         
N#define IR2             IR[2]                         
N#define IR3             IR[3]                          
N/* The registers FICR.DEVICEADDR0 and FICR.DEVICEADDR1 were renamed into an array. */
N#define DEVICEADDR0     DEVICEADDR[0]                  
N#define DEVICEADDR1     DEVICEADDR[1]                  
N
N
N/* PPI */
N/* The tasks PPI.TASKS_CHGxEN and PPI.TASKS_CHGxDIS were renamed into an array of structs. */
N#define TASKS_CHG0EN     TASKS_CHG[0].EN                    
N#define TASKS_CHG0DIS    TASKS_CHG[0].DIS                  
N#define TASKS_CHG1EN     TASKS_CHG[1].EN                    
N#define TASKS_CHG1DIS    TASKS_CHG[1].DIS                  
N#define TASKS_CHG2EN     TASKS_CHG[2].EN                   
N#define TASKS_CHG2DIS    TASKS_CHG[2].DIS                  
N#define TASKS_CHG3EN     TASKS_CHG[3].EN                    
N#define TASKS_CHG3DIS    TASKS_CHG[3].DIS                  
N/* The registers PPI.CHx_EEP and PPI.CHx_TEP were renamed into an array of structs. */
N#define CH0_EEP          CH[0].EEP                          
N#define CH0_TEP          CH[0].TEP                          
N#define CH1_EEP          CH[1].EEP                         
N#define CH1_TEP          CH[1].TEP                         
N#define CH2_EEP          CH[2].EEP                          
N#define CH2_TEP          CH[2].TEP                         
N#define CH3_EEP          CH[3].EEP                          
N#define CH3_TEP          CH[3].TEP                         
N#define CH4_EEP          CH[4].EEP                         
N#define CH4_TEP          CH[4].TEP                         
N#define CH5_EEP          CH[5].EEP                          
N#define CH5_TEP          CH[5].TEP                          
N#define CH6_EEP          CH[6].EEP                          
N#define CH6_TEP          CH[6].TEP                         
N#define CH7_EEP          CH[7].EEP                          
N#define CH7_TEP          CH[7].TEP                          
N#define CH8_EEP          CH[8].EEP                         
N#define CH8_TEP          CH[8].TEP                          
N#define CH9_EEP          CH[9].EEP                          
N#define CH9_TEP          CH[9].TEP                          
N#define CH10_EEP         CH[10].EEP                         
N#define CH10_TEP         CH[10].TEP                         
N#define CH11_EEP         CH[11].EEP                         
N#define CH11_TEP         CH[11].TEP                         
N#define CH12_EEP         CH[12].EEP                         
N#define CH12_TEP         CH[12].TEP                         
N#define CH13_EEP         CH[13].EEP                         
N#define CH13_TEP         CH[13].TEP                         
N#define CH14_EEP         CH[14].EEP                         
N#define CH14_TEP         CH[14].TEP                         
N#define CH15_EEP         CH[15].EEP                         
N#define CH15_TEP         CH[15].TEP                        
N/* The registers PPI.CHG0, PPI.CHG1, PPI.CHG2 and PPI.CHG3 were renamed into an array. */
N#define CHG0             CHG[0]                            
N#define CHG1             CHG[1]                            
N#define CHG2             CHG[2]                             
N#define CHG3             CHG[3]                           
N/* All bitfield macros for the CHGx registers therefore changed name. */
N#define PPI_CHG0_CH15_Pos       PPI_CHG_CH15_Pos            
N#define PPI_CHG0_CH15_Msk       PPI_CHG_CH15_Msk            
N#define PPI_CHG0_CH15_Excluded  PPI_CHG_CH15_Excluded       
N#define PPI_CHG0_CH15_Included  PPI_CHG_CH15_Included       
N#define PPI_CHG0_CH14_Pos       PPI_CHG_CH14_Pos            
N#define PPI_CHG0_CH14_Msk       PPI_CHG_CH14_Msk           
N#define PPI_CHG0_CH14_Excluded  PPI_CHG_CH14_Excluded       
N#define PPI_CHG0_CH14_Included  PPI_CHG_CH14_Included       
N#define PPI_CHG0_CH13_Pos       PPI_CHG_CH13_Pos            
N#define PPI_CHG0_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG0_CH13_Excluded  PPI_CHG_CH13_Excluded      
N#define PPI_CHG0_CH13_Included  PPI_CHG_CH13_Included       
N#define PPI_CHG0_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG0_CH12_Msk       PPI_CHG_CH12_Msk            
N#define PPI_CHG0_CH12_Excluded  PPI_CHG_CH12_Excluded       
N#define PPI_CHG0_CH12_Included  PPI_CHG_CH12_Included       
N#define PPI_CHG0_CH11_Pos       PPI_CHG_CH11_Pos            
N#define PPI_CHG0_CH11_Msk       PPI_CHG_CH11_Msk            
N#define PPI_CHG0_CH11_Excluded  PPI_CHG_CH11_Excluded       
N#define PPI_CHG0_CH11_Included  PPI_CHG_CH11_Included       
N#define PPI_CHG0_CH10_Pos       PPI_CHG_CH10_Pos            
N#define PPI_CHG0_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG0_CH10_Excluded  PPI_CHG_CH10_Excluded       
N#define PPI_CHG0_CH10_Included  PPI_CHG_CH10_Included       
N#define PPI_CHG0_CH9_Pos        PPI_CHG_CH9_Pos             
N#define PPI_CHG0_CH9_Msk        PPI_CHG_CH9_Msk             
N#define PPI_CHG0_CH9_Excluded   PPI_CHG_CH9_Excluded        
N#define PPI_CHG0_CH9_Included   PPI_CHG_CH9_Included        
N#define PPI_CHG0_CH8_Pos        PPI_CHG_CH8_Pos             
N#define PPI_CHG0_CH8_Msk        PPI_CHG_CH8_Msk             
N#define PPI_CHG0_CH8_Excluded   PPI_CHG_CH8_Excluded        
N#define PPI_CHG0_CH8_Included   PPI_CHG_CH8_Included        
N#define PPI_CHG0_CH7_Pos        PPI_CHG_CH7_Pos             
N#define PPI_CHG0_CH7_Msk        PPI_CHG_CH7_Msk             
N#define PPI_CHG0_CH7_Excluded   PPI_CHG_CH7_Excluded        
N#define PPI_CHG0_CH7_Included   PPI_CHG_CH7_Included        
N#define PPI_CHG0_CH6_Pos        PPI_CHG_CH6_Pos             
N#define PPI_CHG0_CH6_Msk        PPI_CHG_CH6_Msk             
N#define PPI_CHG0_CH6_Excluded   PPI_CHG_CH6_Excluded        
N#define PPI_CHG0_CH6_Included   PPI_CHG_CH6_Included        
N#define PPI_CHG0_CH5_Pos        PPI_CHG_CH5_Pos             
N#define PPI_CHG0_CH5_Msk        PPI_CHG_CH5_Msk             
N#define PPI_CHG0_CH5_Excluded   PPI_CHG_CH5_Excluded       
N#define PPI_CHG0_CH5_Included   PPI_CHG_CH5_Included        
N#define PPI_CHG0_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG0_CH4_Msk        PPI_CHG_CH4_Msk             
N#define PPI_CHG0_CH4_Excluded   PPI_CHG_CH4_Excluded       
N#define PPI_CHG0_CH4_Included   PPI_CHG_CH4_Included       
N#define PPI_CHG0_CH3_Pos        PPI_CHG_CH3_Pos             
N#define PPI_CHG0_CH3_Msk        PPI_CHG_CH3_Msk            
N#define PPI_CHG0_CH3_Excluded   PPI_CHG_CH3_Excluded        
N#define PPI_CHG0_CH3_Included   PPI_CHG_CH3_Included       
N#define PPI_CHG0_CH2_Pos        PPI_CHG_CH2_Pos            
N#define PPI_CHG0_CH2_Msk        PPI_CHG_CH2_Msk             
N#define PPI_CHG0_CH2_Excluded   PPI_CHG_CH2_Excluded       
N#define PPI_CHG0_CH2_Included   PPI_CHG_CH2_Included       
N#define PPI_CHG0_CH1_Pos        PPI_CHG_CH1_Pos            
N#define PPI_CHG0_CH1_Msk        PPI_CHG_CH1_Msk            
N#define PPI_CHG0_CH1_Excluded   PPI_CHG_CH1_Excluded        
N#define PPI_CHG0_CH1_Included   PPI_CHG_CH1_Included       
N#define PPI_CHG0_CH0_Pos        PPI_CHG_CH0_Pos            
N#define PPI_CHG0_CH0_Msk        PPI_CHG_CH0_Msk            
N#define PPI_CHG0_CH0_Excluded   PPI_CHG_CH0_Excluded        
N#define PPI_CHG0_CH0_Included   PPI_CHG_CH0_Included       
N#define PPI_CHG1_CH15_Pos       PPI_CHG_CH15_Pos           
N#define PPI_CHG1_CH15_Msk       PPI_CHG_CH15_Msk           
N#define PPI_CHG1_CH15_Excluded  PPI_CHG_CH15_Excluded       
N#define PPI_CHG1_CH15_Included  PPI_CHG_CH15_Included      
N#define PPI_CHG1_CH14_Pos       PPI_CHG_CH14_Pos           
N#define PPI_CHG1_CH14_Msk       PPI_CHG_CH14_Msk            
N#define PPI_CHG1_CH14_Excluded  PPI_CHG_CH14_Excluded      
N#define PPI_CHG1_CH14_Included  PPI_CHG_CH14_Included       
N#define PPI_CHG1_CH13_Pos       PPI_CHG_CH13_Pos           
N#define PPI_CHG1_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG1_CH13_Excluded  PPI_CHG_CH13_Excluded      
N#define PPI_CHG1_CH13_Included  PPI_CHG_CH13_Included      
N#define PPI_CHG1_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG1_CH12_Msk       PPI_CHG_CH12_Msk           
N#define PPI_CHG1_CH12_Excluded  PPI_CHG_CH12_Excluded      
N#define PPI_CHG1_CH12_Included  PPI_CHG_CH12_Included      
N#define PPI_CHG1_CH11_Pos       PPI_CHG_CH11_Pos            
N#define PPI_CHG1_CH11_Msk       PPI_CHG_CH11_Msk           
N#define PPI_CHG1_CH11_Excluded  PPI_CHG_CH11_Excluded      
N#define PPI_CHG1_CH11_Included  PPI_CHG_CH11_Included      
N#define PPI_CHG1_CH10_Pos       PPI_CHG_CH10_Pos           
N#define PPI_CHG1_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG1_CH10_Excluded  PPI_CHG_CH10_Excluded      
N#define PPI_CHG1_CH10_Included  PPI_CHG_CH10_Included      
N#define PPI_CHG1_CH9_Pos        PPI_CHG_CH9_Pos            
N#define PPI_CHG1_CH9_Msk        PPI_CHG_CH9_Msk            
N#define PPI_CHG1_CH9_Excluded   PPI_CHG_CH9_Excluded       
N#define PPI_CHG1_CH9_Included   PPI_CHG_CH9_Included       
N#define PPI_CHG1_CH8_Pos        PPI_CHG_CH8_Pos            
N#define PPI_CHG1_CH8_Msk        PPI_CHG_CH8_Msk            
N#define PPI_CHG1_CH8_Excluded   PPI_CHG_CH8_Excluded       
N#define PPI_CHG1_CH8_Included   PPI_CHG_CH8_Included       
N#define PPI_CHG1_CH7_Pos        PPI_CHG_CH7_Pos             
N#define PPI_CHG1_CH7_Msk        PPI_CHG_CH7_Msk            
N#define PPI_CHG1_CH7_Excluded   PPI_CHG_CH7_Excluded        
N#define PPI_CHG1_CH7_Included   PPI_CHG_CH7_Included       
N#define PPI_CHG1_CH6_Pos        PPI_CHG_CH6_Pos             
N#define PPI_CHG1_CH6_Msk        PPI_CHG_CH6_Msk            
N#define PPI_CHG1_CH6_Excluded   PPI_CHG_CH6_Excluded       
N#define PPI_CHG1_CH6_Included   PPI_CHG_CH6_Included       
N#define PPI_CHG1_CH5_Pos        PPI_CHG_CH5_Pos             
N#define PPI_CHG1_CH5_Msk        PPI_CHG_CH5_Msk             
N#define PPI_CHG1_CH5_Excluded   PPI_CHG_CH5_Excluded       
N#define PPI_CHG1_CH5_Included   PPI_CHG_CH5_Included        
N#define PPI_CHG1_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG1_CH4_Msk        PPI_CHG_CH4_Msk             
N#define PPI_CHG1_CH4_Excluded   PPI_CHG_CH4_Excluded        
N#define PPI_CHG1_CH4_Included   PPI_CHG_CH4_Included        
N#define PPI_CHG1_CH3_Pos        PPI_CHG_CH3_Pos            
N#define PPI_CHG1_CH3_Msk        PPI_CHG_CH3_Msk             
N#define PPI_CHG1_CH3_Excluded   PPI_CHG_CH3_Excluded        
N#define PPI_CHG1_CH3_Included   PPI_CHG_CH3_Included       
N#define PPI_CHG1_CH2_Pos        PPI_CHG_CH2_Pos            
N#define PPI_CHG1_CH2_Msk        PPI_CHG_CH2_Msk             
N#define PPI_CHG1_CH2_Excluded   PPI_CHG_CH2_Excluded        
N#define PPI_CHG1_CH2_Included   PPI_CHG_CH2_Included        
N#define PPI_CHG1_CH1_Pos        PPI_CHG_CH1_Pos             
N#define PPI_CHG1_CH1_Msk        PPI_CHG_CH1_Msk            
N#define PPI_CHG1_CH1_Excluded   PPI_CHG_CH1_Excluded        
N#define PPI_CHG1_CH1_Included   PPI_CHG_CH1_Included       
N#define PPI_CHG1_CH0_Pos        PPI_CHG_CH0_Pos             
N#define PPI_CHG1_CH0_Msk        PPI_CHG_CH0_Msk            
N#define PPI_CHG1_CH0_Excluded   PPI_CHG_CH0_Excluded       
N#define PPI_CHG1_CH0_Included   PPI_CHG_CH0_Included       
N#define PPI_CHG2_CH15_Pos       PPI_CHG_CH15_Pos           
N#define PPI_CHG2_CH15_Msk       PPI_CHG_CH15_Msk            
N#define PPI_CHG2_CH15_Excluded  PPI_CHG_CH15_Excluded      
N#define PPI_CHG2_CH15_Included  PPI_CHG_CH15_Included      
N#define PPI_CHG2_CH14_Pos       PPI_CHG_CH14_Pos           
N#define PPI_CHG2_CH14_Msk       PPI_CHG_CH14_Msk           
N#define PPI_CHG2_CH14_Excluded  PPI_CHG_CH14_Excluded       
N#define PPI_CHG2_CH14_Included  PPI_CHG_CH14_Included      
N#define PPI_CHG2_CH13_Pos       PPI_CHG_CH13_Pos           
N#define PPI_CHG2_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG2_CH13_Excluded  PPI_CHG_CH13_Excluded       
N#define PPI_CHG2_CH13_Included  PPI_CHG_CH13_Included      
N#define PPI_CHG2_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG2_CH12_Msk       PPI_CHG_CH12_Msk            
N#define PPI_CHG2_CH12_Excluded  PPI_CHG_CH12_Excluded      
N#define PPI_CHG2_CH12_Included  PPI_CHG_CH12_Included       
N#define PPI_CHG2_CH11_Pos       PPI_CHG_CH11_Pos           
N#define PPI_CHG2_CH11_Msk       PPI_CHG_CH11_Msk           
N#define PPI_CHG2_CH11_Excluded  PPI_CHG_CH11_Excluded       
N#define PPI_CHG2_CH11_Included  PPI_CHG_CH11_Included       
N#define PPI_CHG2_CH10_Pos       PPI_CHG_CH10_Pos            
N#define PPI_CHG2_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG2_CH10_Excluded  PPI_CHG_CH10_Excluded      
N#define PPI_CHG2_CH10_Included  PPI_CHG_CH10_Included      
N#define PPI_CHG2_CH9_Pos        PPI_CHG_CH9_Pos            
N#define PPI_CHG2_CH9_Msk        PPI_CHG_CH9_Msk            
N#define PPI_CHG2_CH9_Excluded   PPI_CHG_CH9_Excluded        
N#define PPI_CHG2_CH9_Included   PPI_CHG_CH9_Included       
N#define PPI_CHG2_CH8_Pos        PPI_CHG_CH8_Pos            
N#define PPI_CHG2_CH8_Msk        PPI_CHG_CH8_Msk            
N#define PPI_CHG2_CH8_Excluded   PPI_CHG_CH8_Excluded       
N#define PPI_CHG2_CH8_Included   PPI_CHG_CH8_Included        
N#define PPI_CHG2_CH7_Pos        PPI_CHG_CH7_Pos            
N#define PPI_CHG2_CH7_Msk        PPI_CHG_CH7_Msk            
N#define PPI_CHG2_CH7_Excluded   PPI_CHG_CH7_Excluded       
N#define PPI_CHG2_CH7_Included   PPI_CHG_CH7_Included       
N#define PPI_CHG2_CH6_Pos        PPI_CHG_CH6_Pos            
N#define PPI_CHG2_CH6_Msk        PPI_CHG_CH6_Msk            
N#define PPI_CHG2_CH6_Excluded   PPI_CHG_CH6_Excluded       
N#define PPI_CHG2_CH6_Included   PPI_CHG_CH6_Included       
N#define PPI_CHG2_CH5_Pos        PPI_CHG_CH5_Pos            
N#define PPI_CHG2_CH5_Msk        PPI_CHG_CH5_Msk            
N#define PPI_CHG2_CH5_Excluded   PPI_CHG_CH5_Excluded       
N#define PPI_CHG2_CH5_Included   PPI_CHG_CH5_Included        
N#define PPI_CHG2_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG2_CH4_Msk        PPI_CHG_CH4_Msk             
N#define PPI_CHG2_CH4_Excluded   PPI_CHG_CH4_Excluded        
N#define PPI_CHG2_CH4_Included   PPI_CHG_CH4_Included       
N#define PPI_CHG2_CH3_Pos        PPI_CHG_CH3_Pos            
N#define PPI_CHG2_CH3_Msk        PPI_CHG_CH3_Msk            
N#define PPI_CHG2_CH3_Excluded   PPI_CHG_CH3_Excluded       
N#define PPI_CHG2_CH3_Included   PPI_CHG_CH3_Included       
N#define PPI_CHG2_CH2_Pos        PPI_CHG_CH2_Pos            
N#define PPI_CHG2_CH2_Msk        PPI_CHG_CH2_Msk           
N#define PPI_CHG2_CH2_Excluded   PPI_CHG_CH2_Excluded       
N#define PPI_CHG2_CH2_Included   PPI_CHG_CH2_Included       
N#define PPI_CHG2_CH1_Pos        PPI_CHG_CH1_Pos             
N#define PPI_CHG2_CH1_Msk        PPI_CHG_CH1_Msk             
N#define PPI_CHG2_CH1_Excluded   PPI_CHG_CH1_Excluded       
N#define PPI_CHG2_CH1_Included   PPI_CHG_CH1_Included       
N#define PPI_CHG2_CH0_Pos        PPI_CHG_CH0_Pos            
N#define PPI_CHG2_CH0_Msk        PPI_CHG_CH0_Msk            
N#define PPI_CHG2_CH0_Excluded   PPI_CHG_CH0_Excluded       
N#define PPI_CHG2_CH0_Included   PPI_CHG_CH0_Included        
N#define PPI_CHG3_CH15_Pos       PPI_CHG_CH15_Pos           
N#define PPI_CHG3_CH15_Msk       PPI_CHG_CH15_Msk           
N#define PPI_CHG3_CH15_Excluded  PPI_CHG_CH15_Excluded     
N#define PPI_CHG3_CH15_Included  PPI_CHG_CH15_Included      
N#define PPI_CHG3_CH14_Pos       PPI_CHG_CH14_Pos          
N#define PPI_CHG3_CH14_Msk       PPI_CHG_CH14_Msk           
N#define PPI_CHG3_CH14_Excluded  PPI_CHG_CH14_Excluded      
N#define PPI_CHG3_CH14_Included  PPI_CHG_CH14_Included       
N#define PPI_CHG3_CH13_Pos       PPI_CHG_CH13_Pos           
N#define PPI_CHG3_CH13_Msk       PPI_CHG_CH13_Msk            
N#define PPI_CHG3_CH13_Excluded  PPI_CHG_CH13_Excluded      
N#define PPI_CHG3_CH13_Included  PPI_CHG_CH13_Included      
N#define PPI_CHG3_CH12_Pos       PPI_CHG_CH12_Pos            
N#define PPI_CHG3_CH12_Msk       PPI_CHG_CH12_Msk            
N#define PPI_CHG3_CH12_Excluded  PPI_CHG_CH12_Excluded       
N#define PPI_CHG3_CH12_Included  PPI_CHG_CH12_Included       
N#define PPI_CHG3_CH11_Pos       PPI_CHG_CH11_Pos            
N#define PPI_CHG3_CH11_Msk       PPI_CHG_CH11_Msk            
N#define PPI_CHG3_CH11_Excluded  PPI_CHG_CH11_Excluded      
N#define PPI_CHG3_CH11_Included  PPI_CHG_CH11_Included       
N#define PPI_CHG3_CH10_Pos       PPI_CHG_CH10_Pos            
N#define PPI_CHG3_CH10_Msk       PPI_CHG_CH10_Msk            
N#define PPI_CHG3_CH10_Excluded  PPI_CHG_CH10_Excluded      
N#define PPI_CHG3_CH10_Included  PPI_CHG_CH10_Included      
N#define PPI_CHG3_CH9_Pos        PPI_CHG_CH9_Pos            
N#define PPI_CHG3_CH9_Msk        PPI_CHG_CH9_Msk            
N#define PPI_CHG3_CH9_Excluded   PPI_CHG_CH9_Excluded       
N#define PPI_CHG3_CH9_Included   PPI_CHG_CH9_Included       
N#define PPI_CHG3_CH8_Pos        PPI_CHG_CH8_Pos            
N#define PPI_CHG3_CH8_Msk        PPI_CHG_CH8_Msk             
N#define PPI_CHG3_CH8_Excluded   PPI_CHG_CH8_Excluded       
N#define PPI_CHG3_CH8_Included   PPI_CHG_CH8_Included       
N#define PPI_CHG3_CH7_Pos        PPI_CHG_CH7_Pos             
N#define PPI_CHG3_CH7_Msk        PPI_CHG_CH7_Msk            
N#define PPI_CHG3_CH7_Excluded   PPI_CHG_CH7_Excluded        
N#define PPI_CHG3_CH7_Included   PPI_CHG_CH7_Included       
N#define PPI_CHG3_CH6_Pos        PPI_CHG_CH6_Pos             
N#define PPI_CHG3_CH6_Msk        PPI_CHG_CH6_Msk             
N#define PPI_CHG3_CH6_Excluded   PPI_CHG_CH6_Excluded       
N#define PPI_CHG3_CH6_Included   PPI_CHG_CH6_Included        
N#define PPI_CHG3_CH5_Pos        PPI_CHG_CH5_Pos             
N#define PPI_CHG3_CH5_Msk        PPI_CHG_CH5_Msk             
N#define PPI_CHG3_CH5_Excluded   PPI_CHG_CH5_Excluded        
N#define PPI_CHG3_CH5_Included   PPI_CHG_CH5_Included       
N#define PPI_CHG3_CH4_Pos        PPI_CHG_CH4_Pos             
N#define PPI_CHG3_CH4_Msk        PPI_CHG_CH4_Msk            
N#define PPI_CHG3_CH4_Excluded   PPI_CHG_CH4_Excluded        
N#define PPI_CHG3_CH4_Included   PPI_CHG_CH4_Included        
N#define PPI_CHG3_CH3_Pos        PPI_CHG_CH3_Pos             
N#define PPI_CHG3_CH3_Msk        PPI_CHG_CH3_Msk            
N#define PPI_CHG3_CH3_Excluded   PPI_CHG_CH3_Excluded        
N#define PPI_CHG3_CH3_Included   PPI_CHG_CH3_Included        
N#define PPI_CHG3_CH2_Pos        PPI_CHG_CH2_Pos             
N#define PPI_CHG3_CH2_Msk        PPI_CHG_CH2_Msk             
N#define PPI_CHG3_CH2_Excluded   PPI_CHG_CH2_Excluded        
N#define PPI_CHG3_CH2_Included   PPI_CHG_CH2_Included       
N#define PPI_CHG3_CH1_Pos        PPI_CHG_CH1_Pos             
N#define PPI_CHG3_CH1_Msk        PPI_CHG_CH1_Msk             
N#define PPI_CHG3_CH1_Excluded   PPI_CHG_CH1_Excluded        
N#define PPI_CHG3_CH1_Included   PPI_CHG_CH1_Included        
N#define PPI_CHG3_CH0_Pos        PPI_CHG_CH0_Pos             
N#define PPI_CHG3_CH0_Msk        PPI_CHG_CH0_Msk             
N#define PPI_CHG3_CH0_Excluded   PPI_CHG_CH0_Excluded        
N#define PPI_CHG3_CH0_Included   PPI_CHG_CH0_Included        
N
N
N
N/*lint --flb "Leave library region" */
N
N#endif /* NRF51_DEPRECATED_H */
N
L 65 "C:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include\nrf.h" 2
N    #elif defined (NRF52840_XXAA)
S        #include "nrf52840.h"
S        #include "nrf52840_bitfields.h"
S        #include "nrf51_to_nrf52840.h"
S        #include "nrf52_to_nrf52840.h"
S    #elif defined (NRF52832_XXAA)
S        #include "nrf52.h"
S        #include "nrf52_bitfields.h"
S        #include "nrf51_to_nrf52.h"
S        #include "nrf52_name_change.h"
S    #else
S        #error "Device must be defined. See nrf.h."
N    #endif /* NRF51, NRF52832_XXAA, NRF52840_XXAA */
N
N    #include "compiler_abstraction.h"
N
N#endif /* _WIN32 || __unix || __APPLE__ */
N
N#endif /* NRF_H */
N
L 57 "..\..\..\..\..\..\components\libraries\util\app_util.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N//lint -save -e27 -e10 -e19
N#if defined ( __CC_ARM )
X#if 1L
Nextern char STACK$$Base;
Nextern char STACK$$Length;
N#define STACK_BASE    &STACK$$Base
N#define STACK_TOP    ((void*)((uint32_t)STACK_BASE + (uint32_t)&STACK$$Length))
N#elif defined ( __ICCARM__ )
Sextern char CSTACK$$Base;
Sextern char CSTACK$$Length;
S#define STACK_BASE    &CSTACK$$Base
S#define STACK_TOP    ((void*)((uint32_t)STACK_BASE + (uint32_t)&CSTACK$$Length))
S#elif defined   ( __GNUC__ )
Sextern uint32_t __StackTop;
Sextern uint32_t __StackLimit;
S#define STACK_BASE    &__StackLimit
S#define STACK_TOP     &__StackTop
N#endif
N//lint -restore
N
Nenum
N{
N    UNIT_0_625_MS = 625,                                /**< Number of microseconds in 0.625 milliseconds. */
N    UNIT_1_25_MS  = 1250,                               /**< Number of microseconds in 1.25 milliseconds. */
N    UNIT_10_MS    = 10000                               /**< Number of microseconds in 10 milliseconds. */
N};
N
N
N/**@brief Implementation specific macro for delayed macro expansion used in string concatenation
N*
N* @param[in]   lhs   Left hand side in concatenation
N* @param[in]   rhs   Right hand side in concatenation
N*/
N#define STRING_CONCATENATE_IMPL(lhs, rhs) lhs ## rhs
N
N
N/**@brief Macro used to concatenate string using delayed macro expansion
N*
N* @note This macro will delay concatenation until the expressions have been resolved
N*
N* @param[in]   lhs   Left hand side in concatenation
N* @param[in]   rhs   Right hand side in concatenation
N*/
N#define STRING_CONCATENATE(lhs, rhs) STRING_CONCATENATE_IMPL(lhs, rhs)
N
N
N// Disable lint-warnings/errors for STATIC_ASSERT_MSG
N//lint --emacro(10, STATIC_ASSERT_MSG)
N//lint --emacro(18, STATIC_ASSERT_MSG)
N//lint --emacro(19, STATIC_ASSERT_MSG)
N//lint --emacro(30, STATIC_ASSERT_MSG)
N//lint --emacro(37, STATIC_ASSERT_MSG)
N//lint --emacro(42, STATIC_ASSERT_MSG)
N//lint --emacro(26, STATIC_ASSERT_MSG)
N//lint --emacro(102,STATIC_ASSERT_MSG)
N//lint --emacro(533,STATIC_ASSERT_MSG)
N//lint --emacro(534,STATIC_ASSERT_MSG)
N//lint --emacro(132,STATIC_ASSERT_MSG)
N//lint --emacro(414,STATIC_ASSERT_MSG)
N//lint --emacro(578,STATIC_ASSERT_MSG)
N//lint --emacro(628,STATIC_ASSERT_MSG)
N//lint --emacro(648,STATIC_ASSERT_MSG)
N//lint --emacro(830,STATIC_ASSERT_MSG)
N
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N*
N* @note If the EXPR isn't resolvable, then the error message won't be shown.
N*
N* @note The output of STATIC_ASSERT_MSG will be different across different compilers.
N*
N* @param[in] EXPR Constant expression to be verified.
N* @param[in] MSG  Name of the static assert.
N*/
N#if defined(__COUNTER__)
X#if 0L
S
S    #define STATIC_ASSERT_MSG(EXPR, MSG) \
S        ;enum { STRING_CONCATENATE(MSG, __COUNTER__) = 1 / (!!(EXPR)) }
X    #define STATIC_ASSERT_MSG(EXPR, MSG)         ;enum { STRING_CONCATENATE(MSG, __COUNTER__) = 1 / (!!(EXPR)) }
S
N#else
N
N    #define STATIC_ASSERT_MSG(EXPR, MSG) \
N        ;enum { STRING_CONCATENATE(MSG, __LINE__) = 1 / (!!(EXPR)) }
X    #define STATIC_ASSERT_MSG(EXPR, MSG)         ;enum { STRING_CONCATENATE(MSG, __LINE__) = 1 / (!!(EXPR)) }
N
N#endif
N
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N*
N* @note If the EXPR isn't resolvable, then the error message won't be shown.
N*
N* @note The output of STATIC_ASSERT will be different across different compilers.
N*
N* @param[in] EXPR Constant expression to be verified.
N*/
N#define STATIC_ASSERT(EXPR) STATIC_ASSERT_MSG((EXPR), static_assert_)
N
N
N/**@brief Implementation details for NUM_VAR_ARGS */
N#define NUM_VA_ARGS_IMPL(                              \
N    _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,       \
N    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,  \
N    _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,  \
N    _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,  \
N    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,  \
N    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,  \
N    _61, _62, N, ...) N
X#define NUM_VA_ARGS_IMPL(                                  _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,           _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,      _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,      _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,      _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,      _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,      _61, _62, N, ...) N
N
N
N/**@brief Macro to get the number of arguments in a call variadic macro call
N *
N * param[in]    ...     List of arguments
N *
N * @retval  Number of variadic arguments in the argument list
N */
N#define NUM_VA_ARGS(...) NUM_VA_ARGS_IMPL(__VA_ARGS__, 63, 62, 61,  \
N    60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                         \
N    50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                         \
N    40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                         \
N    30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                         \
N    20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                         \
N    10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
X#define NUM_VA_ARGS(...) NUM_VA_ARGS_IMPL(__VA_ARGS__, 63, 62, 61,      60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                             50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                             40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                             30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                             20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                             10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
N
N/**@brief Implementation details for NUM_VAR_ARGS */
N#define NUM_VA_ARGS_LESS_1_IMPL(                       \
N    _ignored,                                          \
N    _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,       \
N    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,  \
N    _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,  \
N    _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,  \
N    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,  \
N    _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,  \
N    _61, _62, N, ...) N
X#define NUM_VA_ARGS_LESS_1_IMPL(                           _ignored,                                              _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10,           _11, _12, _13, _14, _15, _16, _17, _18, _19, _20,      _21, _22, _23, _24, _25, _26, _27, _28, _29, _30,      _31, _32, _33, _34, _35, _36, _37, _38, _39, _40,      _41, _42, _43, _44, _45, _46, _47, _48, _49, _50,      _51, _52, _53, _54, _55, _56, _57, _58, _59, _60,      _61, _62, N, ...) N
N
N/**@brief Macro to get the number of arguments in a call variadic macro call.
N * First argument is not counted.
N *
N * param[in]    ...     List of arguments
N *
N * @retval  Number of variadic arguments in the argument list
N */
N#define NUM_VA_ARGS_LESS_1(...) NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__, 63, 62, 61,  \
N    60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                         \
N    50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                         \
N    40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                         \
N    30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                         \
N    20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                         \
N    10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ~)
X#define NUM_VA_ARGS_LESS_1(...) NUM_VA_ARGS_LESS_1_IMPL(__VA_ARGS__, 63, 62, 61,      60, 59, 58, 57, 56, 55, 54, 53, 52, 51,                             50, 49, 48, 47, 46, 45, 44, 43, 42, 41,                             40, 39, 38, 37, 36, 35, 34, 33, 32, 31,                             30, 29, 28, 27, 26, 25, 24, 23, 22, 21,                             20, 19, 18, 17, 16, 15, 14, 13, 12, 11,                             10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, ~)
N
N
N/**@brief type for holding an encoded (i.e. little endian) 16 bit unsigned integer. */
Ntypedef uint8_t uint16_le_t[2];
N
N/**@brief Type for holding an encoded (i.e. little endian) 32 bit unsigned integer. */
Ntypedef uint8_t uint32_le_t[4];
N
N/**@brief Byte array type. */
Ntypedef struct
N{
N    uint16_t  size;                 /**< Number of array entries. */
N    uint8_t * p_data;               /**< Pointer to array entries. */
N} uint8_array_t;
N
N
N/**@brief Macro for performing rounded integer division (as opposed to truncating the result).
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Rounded (integer) result of dividing A by B.
N */
N#define ROUNDED_DIV(A, B) (((A) + ((B) / 2)) / (B))
N
N
N/**@brief Macro for checking if an integer is a power of two.
N *
N * @param[in]   A   Number to be tested.
N *
N * @return      true if value is power of two.
N * @return      false if value not power of two.
N */
N#define IS_POWER_OF_TWO(A) ( ((A) != 0) && ((((A) - 1) & (A)) == 0) )
N
N
N/**@brief Macro for converting milliseconds to ticks.
N *
N * @param[in] TIME          Number of milliseconds to convert.
N * @param[in] RESOLUTION    Unit to be converted to in [us/ticks].
N */
N#define MSEC_TO_UNITS(TIME, RESOLUTION) (((TIME) * 1000) / (RESOLUTION))
N
N
N/**@brief Macro for performing integer division, making sure the result is rounded up.
N *
N * @details One typical use for this is to compute the number of objects with size B is needed to
N *          hold A number of bytes.
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Integer result of dividing A by B, rounded up.
N */
N#define CEIL_DIV(A, B)      \
N    (((A) + (B) - 1) / (B))
X#define CEIL_DIV(A, B)          (((A) + (B) - 1) / (B))
N
N
N/**@brief Macro for creating a buffer aligned to 4 bytes.
N *
N * @param[in]   NAME        Name of the buffor.
N * @param[in]   MIN_SIZE    Size of this buffor (it will be rounded up to multiples of 4 bytes).
N */
N#define WORD_ALIGNED_MEM_BUFF(NAME, MIN_SIZE) static uint32_t NAME[CEIL_DIV(MIN_SIZE, sizeof(uint32_t))]
N
N
N/**@brief Macro for calculating the number of words that are needed to hold a number of bytes.
N *
N * @details Adds 3 and divides by 4.
N *
N * @param[in]  n_bytes  The number of bytes.
N *
N * @return The number of words that @p n_bytes take up (rounded up).
N */
N#define BYTES_TO_WORDS(n_bytes) (((n_bytes) + 3) >> 2)
N
N
N/**@brief The number of bytes in a word.
N */
N#define BYTES_PER_WORD (4)
N
N
N/**@brief Macro for increasing a number to the nearest (larger) multiple of another number.
N *
N * @param[in]  alignment  The number to align to.
N * @param[in]  number     The number to align (increase).
N *
N * @return The aligned (increased) @p number.
N */
N#define ALIGN_NUM(alignment, number) ((number - 1) + alignment - ((number - 1) % alignment))
N
N/**@brief Macro for getting first of 2 parameters.
N *
N * @param[in] a1    First parameter.
N * @param[in] a2    Second parameter.
N */
N#define GET_ARG_1(a1, a2) a1
N
N/**@brief Macro for getting second of 2 parameters.
N *
N * @param[in] a1    First parameter.
N * @param[in] a2    Second parameter.
N */
N#define GET_ARG_2(a1, a2) a2
N
N
N/**@brief Container of macro (borrowed from Linux kernel).
N *
N * This macro returns parent structure address basing on child member address.
N *
N * @param ptr       Address of child type.
N * @param type      Type of parent structure.
N * @param member    Name of child field in parent structure.
N *
N * @return Parent structure address.
N * */
N#define CONTAINER_OF(ptr, type, member)                 \
N        (type *)((char *)ptr - offsetof(type, member))
X#define CONTAINER_OF(ptr, type, member)                         (type *)((char *)ptr - offsetof(type, member))
N
N
N/**
N * @brief Define Bit-field mask
N *
N * Macro that defined the mask with selected number of bits set, starting from
N * provided bit number.
N *
N * @param[in] bcnt Number of bits in the bit-field
N * @param[in] boff Lowest bit number
N */
N#define BF_MASK(bcnt, boff) ( ((1U << (bcnt)) - 1U) << (boff) )
N
N/**
N * @brief Get bit-field
N *
N * Macro that extracts selected bit-field from provided value
N *
N * @param[in] val  Value from witch selected bit-field would be extracted
N * @param[in] bcnt Number of bits in the bit-field
N * @param[in] boff Lowest bit number
N *
N * @return Value of the selected bits
N */
N#define BF_GET(val, bcnt, boff) ( ( (val) & BF_MASK((bcnt), (boff)) ) >> (boff) )
N
N/**
N * @brief Create bit-field value
N *
N * Value is masked and shifted to match given bit-field
N *
N * @param[in] val  Value to set on bit-field
N * @param[in] bcnt Number of bits for bit-field
N * @param[in] boff Offset of bit-field
N *
N * @return Value positioned of given bit-field.
N */
N#define BF_VAL(val, bcnt, boff) ( (((uint32_t)(val)) << (boff)) & BF_MASK(bcnt, boff) )
N
N/**
N * @name Configuration of complex bit-field
N *
N * @sa BF_CX
N * @{
N */
N/** @brief Position of bit count in complex bit-field value */
N#define BF_CX_BCNT_POS  0U
N/** @brief Mask of bit count in complex bit-field value */
N#define BF_CX_BCNT_MASK (0xffU << BF_CX_BCNT_POS)
N/** @brief Position of bit position in complex bit-field value */
N#define BF_CX_BOFF_POS  8U
N/** @brief Mask of bit position in complex bit-field value */
N#define BF_CX_BOFF_MASK (0xffU << BF_CX_BOFF_POS)
N/** @} */
N
N/**
N * @brief Define complex bit-field
N *
N * Complex bit-field would contain its position and size in one number.
N * @sa BF_CX_MASK
N * @sa BF_CX_POS
N * @sa BF_CX_GET
N *
N * @param[in] bcnt Number of bits in the bit-field
N * @param[in] boff Lowest bit number
N *
N * @return The single number that describes the bit-field completely.
N */
N#define BF_CX(bcnt, boff) ( ((((uint32_t)(bcnt)) << BF_CX_BCNT_POS) & BF_CX_BCNT_MASK) | ((((uint32_t)(boff)) << BF_CX_BOFF_POS) & BF_CX_BOFF_MASK) )
N
N/**
N * @brief Get number of bits in bit-field
N *
N * @sa BF_CX
N *
N * @param bf_cx Complex bit-field
N *
N * @return Number of bits in given bit-field
N */
N#define BF_CX_BCNT(bf_cx) ( ((bf_cx) & BF_CX_BCNT_MASK) >> BF_CX_BCNT_POS )
N
N/**
N * @brief Get lowest bit number in the field
N *
N * @sa BF_CX
N *
N * @param[in] bf_cx Complex bit-field
N *
N * @return Lowest bit number in given bit-field
N */
N#define BF_CX_BOFF(bf_cx) ( ((bf_cx) & BF_CX_BOFF_MASK) >> BF_CX_BOFF_POS )
N
N/**
N * @brief Get bit mask of the selected field
N *
N * @sa BF_CX
N *
N * @param[in] bf_cx Complex bit-field
N *
N * @return Mask of given bit-field
N */
N#define BF_CX_MASK(bf_cx) BF_MASK(BF_CX_BCNT(bf_cx), BF_CX_BOFF(bf_cx))
N
N/**
N * @brief Get bit-field
N *
N * Macro that extracts selected bit-field from provided value.
N * Bit-field is given as a complex value.
N *
N * @sa BF_CX
N * @sa BF_GET
N *
N * @param[in] val   Value from witch selected bit-field would be extracted
N * @param[in] bf_cx Complex bit-field
N *
N * @return Value of the selected bits.
N */
N#define BF_CX_GET(val, bf_cx) BF_GET(val, BF_CX_BCNT(bf_cx), BF_CX_BOFF(bf_cx))
N
N/**
N * @brief Create bit-field value
N *
N * Value is masked and shifted to match given bit-field.
N *
N * @param[in] val  Value to set on bit-field
N * @param[in] bf_cx Complex bit-field
N *
N * @return Value positioned of given bit-field.
N */
N#define BF_CX_VAL(val, bf_cx) BF_VAL(val, BF_CX_BCNT(bf_cx), BF_CX_BOFF(bf_cx))
N
N/**
N * @brief Extracting data from the brackets
N *
N * This macro get rid of brackets around the argument.
N * It can be used to pass multiple arguments in logical one argument to a macro.
N * Call it with arguments inside brackets:
N * @code
N * #define ARGUMENTS (a, b, c)
N * BRACKET_EXTRACT(ARGUMENTS)
N * @endcode
N * It would produce:
N * @code
N * a, b, c
N * @endcode
N *
N * @param a Argument with anything inside brackets
N * @return Anything that appears inside the brackets of the argument
N *
N * @note
N * The argument of the macro have to be inside brackets.
N * In other case the compilation would fail.
N */
N#define BRACKET_EXTRACT(a)  BRACKET_EXTRACT_(a)
N#define BRACKET_EXTRACT_(a) BRACKET_EXTRACT__ a
N#define BRACKET_EXTRACT__(...) __VA_ARGS__
N
N
N/**
N * @brief Check if number of parameters is more than 1
N *
N * @param ... Arguments to count
N *
N * @return 0 If argument count is <= 1
N * @return 1 If argument count is > 1
N *
N * @sa NUM_VA_ARGS
N * @sa NUM_IS_MORE_THAN_1
N */
N#define NUM_VA_ARGS_IS_MORE_THAN_1(...) NUM_IS_MORE_THAN_1(NUM_VA_ARGS(__VA_ARGS__))
N
N/**
N * @brief Check if given numeric value is bigger than 1
N *
N * This macro accepts numeric value, that may be the result of argument expansion.
N * This numeric value is then converted to 0 if it is lover than 1 or to 1 if
N * its value is higher than 1.
N * The generated result can be used to glue it into other macro mnemonic name.
N *
N * @param N Numeric value to check
N *
N * @return 0 If argument is <= 1
N * @return 1 If argument is > 1
N *
N * @note Any existing definition of a form NUM_IS_MORE_THAN_1_PROBE_[N] can
N *       broke the result of this macro
N */
N#define NUM_IS_MORE_THAN_1(N) NUM_IS_MORE_THAN_1_(N)
N#define NUM_IS_MORE_THAN_1_(N)  NUM_IS_MORE_THAN_1_PROBE_(NUM_IS_MORE_THAN_1_PROBE_ ## N, 1)
N#define NUM_IS_MORE_THAN_1_PROBE_(...) GET_VA_ARG_1(GET_ARGS_AFTER_1(__VA_ARGS__))
N#define NUM_IS_MORE_THAN_1_PROBE_0 ~, 0
N#define NUM_IS_MORE_THAN_1_PROBE_1 ~, 0
N
N/**
N * @brief Get the first argument
N *
N * @param ... Arguments to select
N *
N * @return First argument or empty if no arguments are provided
N */
N#define GET_VA_ARG_1(...) GET_VA_ARG_1_(__VA_ARGS__, ) // Make sure that also for 1 argument it works
N#define GET_VA_ARG_1_(a1, ...) a1
N
N/**
N * @brief Get all the arguments but the first one
N *
N * @param ... Arguments to select
N *
N * @return All arguments after the first one or empty if less than 2 arguments are provided
N */
N#define GET_ARGS_AFTER_1(...) GET_ARGS_AFTER_1_(__VA_ARGS__, ) // Make sure that also for 1 argument it works
N#define GET_ARGS_AFTER_1_(a1, ...) __VA_ARGS__
N
N/**
N * @brief Size of a field in declared structure
N *
N * Macro that returns the size of the structure field.
N * @param struct_type Variable type to get the field size from
N * @param field Field name to analyze. It can be even field inside field (field.somethingelse.and_another).
N *
N * @return Size of the field
N */
N#define FIELD_SIZE(struct_type, field) sizeof(((struct struct_type*)NULL)->field)
N
N/**
N * @brief Number of elements in field array in declared structure
N *
N * Macro that returns number of elementy in structure field.
N * @param struct_type Variable type to get the field size from
N * @param field Field name to analyze.
N *
N * @return Number of elements in field array
N *
N * @sa FIELD_SIZE
N */
N#define FIELD_ARRAY_SIZE(struct_type, field) (FIELD_SIZE(struct_type, field) / FIELD_SIZE(struct_type, field[0]))
N
N/**
N * @brief Mapping macro
N *
N * Macro that process all arguments using given macro
N *
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument)
N *
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP(...) MACRO_MAP_(__VA_ARGS__)
N#define MACRO_MAP_(...) MACRO_MAP_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), __VA_ARGS__) // To make sure it works also for 2 arguments in total
N
N/**
N * @brief Mapping macro, recursive version
N *
N *  Can be used in @ref MACRO_MAP macro
N */
N#define MACRO_MAP_REC(...) MACRO_MAP_REC_(__VA_ARGS__)
N#define MACRO_MAP_REC_(...) MACRO_MAP_REC_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), __VA_ARGS__) // To make sure it works also for 2 arguments in total
N/**
N * @brief Mapping N arguments macro
N *
N * Macro similar to @ref MACRO_MAP but maps exact number of arguments.
N * If there is more arguments given, the rest would be ignored.
N *
N * @param N   Number of arguments to map
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument)
N *
N * @return Selected number of arguments processed by given macro
N */
N#define MACRO_MAP_N(N, ...) MACRO_MAP_N_(N, __VA_ARGS__)
N#define MACRO_MAP_N_(N, ...) CONCAT_2(MACRO_MAP_, N)(__VA_ARGS__, )
N
N/**
N * @brief Mapping N arguments macro, recursive version
N *
N *  Can be used in @ref MACRO_MAP_N macro
N */
N#define MACRO_MAP_REC_N(N, ...) MACRO_MAP_REC_N_(N, __VA_ARGS__)
N#define MACRO_MAP_REC_N_(N, ...) CONCAT_2(MACRO_MAP_REC_, N)(__VA_ARGS__, )
N
N#define MACRO_MAP_0(           ...)
N#define MACRO_MAP_1( macro, a, ...) macro(a)
N#define MACRO_MAP_2( macro, a, ...) macro(a) MACRO_MAP_1 (macro, __VA_ARGS__, )
N#define MACRO_MAP_3( macro, a, ...) macro(a) MACRO_MAP_2 (macro, __VA_ARGS__, )
N#define MACRO_MAP_4( macro, a, ...) macro(a) MACRO_MAP_3 (macro, __VA_ARGS__, )
N#define MACRO_MAP_5( macro, a, ...) macro(a) MACRO_MAP_4 (macro, __VA_ARGS__, )
N#define MACRO_MAP_6( macro, a, ...) macro(a) MACRO_MAP_5 (macro, __VA_ARGS__, )
N#define MACRO_MAP_7( macro, a, ...) macro(a) MACRO_MAP_6 (macro, __VA_ARGS__, )
N#define MACRO_MAP_8( macro, a, ...) macro(a) MACRO_MAP_7 (macro, __VA_ARGS__, )
N#define MACRO_MAP_9( macro, a, ...) macro(a) MACRO_MAP_8 (macro, __VA_ARGS__, )
N#define MACRO_MAP_10(macro, a, ...) macro(a) MACRO_MAP_9 (macro, __VA_ARGS__, )
N#define MACRO_MAP_11(macro, a, ...) macro(a) MACRO_MAP_10(macro, __VA_ARGS__, )
N#define MACRO_MAP_12(macro, a, ...) macro(a) MACRO_MAP_11(macro, __VA_ARGS__, )
N#define MACRO_MAP_13(macro, a, ...) macro(a) MACRO_MAP_12(macro, __VA_ARGS__, )
N#define MACRO_MAP_14(macro, a, ...) macro(a) MACRO_MAP_13(macro, __VA_ARGS__, )
N#define MACRO_MAP_15(macro, a, ...) macro(a) MACRO_MAP_14(macro, __VA_ARGS__, )
N
N#define MACRO_MAP_REC_0(           ...)
N#define MACRO_MAP_REC_1( macro, a, ...) macro(a)
N#define MACRO_MAP_REC_2( macro, a, ...) macro(a) MACRO_MAP_REC_1 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_3( macro, a, ...) macro(a) MACRO_MAP_REC_2 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_4( macro, a, ...) macro(a) MACRO_MAP_REC_3 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_5( macro, a, ...) macro(a) MACRO_MAP_REC_4 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_6( macro, a, ...) macro(a) MACRO_MAP_REC_5 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_7( macro, a, ...) macro(a) MACRO_MAP_REC_6 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_8( macro, a, ...) macro(a) MACRO_MAP_REC_7 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_9( macro, a, ...) macro(a) MACRO_MAP_REC_8 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_10(macro, a, ...) macro(a) MACRO_MAP_REC_9 (macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_11(macro, a, ...) macro(a) MACRO_MAP_REC_10(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_12(macro, a, ...) macro(a) MACRO_MAP_REC_11(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_13(macro, a, ...) macro(a) MACRO_MAP_REC_12(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_14(macro, a, ...) macro(a) MACRO_MAP_REC_13(macro, __VA_ARGS__, )
N#define MACRO_MAP_REC_15(macro, a, ...) macro(a) MACRO_MAP_REC_14(macro, __VA_ARGS__, )
N
N/**
N * @brief Mapping macro with current index
N *
N * Basically macro similar to @ref MACRO_MAP, but the processing function would get an argument
N * and current argument index (beginning from 0).
N *
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument, index)
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP_FOR(...) MACRO_MAP_FOR_(__VA_ARGS__)
N#define MACRO_MAP_FOR_N_LIST 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
N#define MACRO_MAP_FOR_(...) MACRO_MAP_FOR_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), __VA_ARGS__)
N
N/**
N * @brief Mapping N arguments macro with current index
N *
N * Macro is similar to @ref MACRO_MAP_FOR but maps exact number of arguments.
N * If there is more arguments given, the rest would be ignored.
N *
N * @param N   Number of arguments to map
N * @param ... Macro name to be used for argument processing followed by arguments to process.
N *            Macro should have following form: MACRO(argument, index)
N *
N * @return Selected number of arguments processed by given macro
N */
N#define MACRO_MAP_FOR_N(N, ...) MACRO_MAP_FOR_N_(N, __VA_ARGS__)
N#define MACRO_MAP_FOR_N_(N, ...) CONCAT_2(MACRO_MAP_FOR_, N)((MACRO_MAP_FOR_N_LIST), __VA_ARGS__, )
N
N#define MACRO_MAP_FOR_0( n_list,           ...)
N#define MACRO_MAP_FOR_1( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)))
N#define MACRO_MAP_FOR_2( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_1 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_3( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_2 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_4( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_3 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_5( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_4 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_6( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_5 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_7( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_6 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_8( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_7 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_9( n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_8 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_10(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_9 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_11(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_10((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_12(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_11((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_13(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_12((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_14(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_13((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_15(n_list, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list))) MACRO_MAP_FOR_14((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), macro, __VA_ARGS__, )
N
N
N/**
N * @brief Mapping macro with current index and parameter
N *
N * Version of @ref MACRO_MAP_FOR that passes also the same parameter to all macros.
N *
N * @param param Parameter that would be passed to each macro call during mapping.
N * @param ...   Macro name to be used for argument processing followed by arguments to process.
N *              Macro should have following form: MACRO(argument, index, param)
N *
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP_FOR_PARAM(param, ...) MACRO_MAP_FOR_PARAM_(param, __VA_ARGS__)
N#define MACRO_MAP_FOR_PARAM_(param, ...) MACRO_MAP_FOR_PARAM_N(NUM_VA_ARGS_LESS_1(__VA_ARGS__), param, __VA_ARGS__)
N
N/**
N * @brief Mapping N arguments macro with with current index and parameter
N *
N * @param N     Number of arguments to map
N * @param param Parameter that would be passed to each macro call during mapping.
N * @param ...   Macro name to be used for argument processing followed by arguments to process.
N *              Macro should have following form: MACRO(argument, index, param)
N *
N * @return All arguments processed by given macro
N */
N#define MACRO_MAP_FOR_PARAM_N(N, param, ...) MACRO_MAP_FOR_PARAM_N_(N, param, __VA_ARGS__)
N#define MACRO_MAP_FOR_PARAM_N_(N, param, ...) CONCAT_2(MACRO_MAP_FOR_PARAM_, N)((MACRO_MAP_FOR_N_LIST), param, __VA_ARGS__, )
N
N
N#define MACRO_MAP_FOR_PARAM_0( n_list, param, ...)
N#define MACRO_MAP_FOR_PARAM_1( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param)
N#define MACRO_MAP_FOR_PARAM_2( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_1 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_3( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_2 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_4( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_3 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_5( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_4 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_6( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_5 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_7( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_6 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_8( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_7 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_9( n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_8 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_10(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_9 ((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_11(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_10((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_12(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_11((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_13(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_12((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_14(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_13((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N#define MACRO_MAP_FOR_PARAM_15(n_list, param, macro, a, ...) macro(a, GET_VA_ARG_1(BRACKET_EXTRACT(n_list)), param) MACRO_MAP_FOR_PARAM_14((GET_ARGS_AFTER_1(BRACKET_EXTRACT(n_list))), param, macro, __VA_ARGS__, )
N
N
N/**@brief Adding curly brace to macro parameter
N *
N * Useful in array of structures initialization.
N *
N * @param p parameter to put into the curly brace*/
N#define PARAM_CBRACE(p) { p },
N
N
N/**@brief Function for changing the value unit.
N *
N * @param[in]   value               Value to be rescaled.
N * @param[in]   old_unit_reversal   Reversal of the incoming unit.
N * @param[in]   new_unit_reversal   Reversal of the desired unit.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint64_t value_rescale(uint32_t value, uint32_t old_unit_reversal, uint16_t new_unit_reversal)
Xstatic __inline uint64_t value_rescale(uint32_t value, uint32_t old_unit_reversal, uint16_t new_unit_reversal)
N{
N    return (uint64_t)ROUNDED_DIV((uint64_t)value * new_unit_reversal, old_unit_reversal);
X    return (uint64_t)((((uint64_t)value * new_unit_reversal) + ((old_unit_reversal) / 2)) / (old_unit_reversal));
N}
N
N/**@brief Function for encoding a uint16 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
N    return sizeof(uint16_t);
N}
N
N/**@brief Function for encoding a three-byte value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint24_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint24_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    return 3;
N}
N
N/**@brief Function for encoding a uint32 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0xFF000000) >> 24);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for encoding a uint48 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint48_encode(uint64_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint48_encode(uint64_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x0000000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x00000000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x000000FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0x0000FF000000) >> 24);
N    p_encoded_data[4] = (uint8_t) ((value & 0x00FF00000000) >> 32);
N    p_encoded_data[5] = (uint8_t) ((value & 0xFF0000000000) >> 40);
N    return 6;
N}
N
N/**@brief Function for decoding a uint16 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) |
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
N}
N
N/**@brief Function for decoding a uint16 value in big-endian format.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_big_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_big_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0]) << 8 ) |
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1])) );
N}
N
N/**@brief Function for decoding a three-byte value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value (uint32_t).
N */
Nstatic __INLINE uint32_t uint24_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint24_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16));
N}
N
N/**@brief Function for decoding a uint32 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 ));
N}
N
N/**@brief Function for decoding a uint32 value in big-endian format.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_big_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_big_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 24) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 0) );
N}
N
N/**
N * @brief Function for encoding an uint16 value in big-endian format.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data will be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_big_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_big_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) (value >> 8);
N    p_encoded_data[1] = (uint8_t) (value & 0xFF);
N
N    return sizeof(uint16_t);
N}
N
N/**@brief Function for encoding a uint32 value in big-endian format.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data will be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_big_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_big_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    *(uint32_t *)p_encoded_data = __REV(value);
X    *(uint32_t *)p_encoded_data = __rev(value);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for decoding a uint48 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value. (uint64_t)
N */
Nstatic __INLINE uint64_t uint48_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint64_t uint48_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint64_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint64_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint64_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[3]) << 24) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[4]) << 32) |
N             (((uint64_t)((uint8_t *)p_encoded_data)[5]) << 40 ));
N}
N
N/** @brief Function for converting the input voltage (in milli volts) into percentage of 3.0 Volts.
N *
N *  @details The calculation is based on a linearized version of the battery's discharge
N *           curve. 3.0V returns 100% battery level. The limit for power failure is 2.1V and
N *           is considered to be the lower boundary.
N *
N *           The discharge curve for CR2032 is non-linear. In this model it is split into
N *           4 linear sections:
N *           - Section 1: 3.0V - 2.9V = 100% - 42% (58% drop on 100 mV)
N *           - Section 2: 2.9V - 2.74V = 42% - 18% (24% drop on 160 mV)
N *           - Section 3: 2.74V - 2.44V = 18% - 6% (12% drop on 300 mV)
N *           - Section 4: 2.44V - 2.1V = 6% - 0% (6% drop on 340 mV)
N *
N *           These numbers are by no means accurate. Temperature and
N *           load in the actual application is not accounted for!
N *
N *  @param[in] mvolts The voltage in mV
N *
N *  @return    Battery level in percent.
N*/
Nstatic __INLINE uint8_t battery_level_in_percent(const uint16_t mvolts)
Xstatic __inline uint8_t battery_level_in_percent(const uint16_t mvolts)
N{
N    uint8_t battery_level;
N
N    if (mvolts >= 3000)
N    {
N        battery_level = 100;
N    }
N    else if (mvolts > 2900)
N    {
N        battery_level = 100 - ((3000 - mvolts) * 58) / 100;
N    }
N    else if (mvolts > 2740)
N    {
N        battery_level = 42 - ((2900 - mvolts) * 24) / 160;
N    }
N    else if (mvolts > 2440)
N    {
N        battery_level = 18 - ((2740 - mvolts) * 12) / 300;
N    }
N    else if (mvolts > 2100)
N    {
N        battery_level = 6 - ((2440 - mvolts) * 6) / 340;
N    }
N    else
N    {
N        battery_level = 0;
N    }
N
N    return battery_level;
N}
N
N/**@brief Function for checking if a pointer value is aligned to a 4 byte boundary.
N *
N * @param[in]   p   Pointer value to be checked.
N *
N * @return      TRUE if pointer is aligned to a 4 byte boundary, FALSE otherwise.
N */
Nstatic __INLINE bool is_word_aligned(void const* p)
Xstatic __inline _Bool is_word_aligned(void const* p)
N{
N    return (((uintptr_t)p & 0x03) == 0);
N}
N
N/**
N * @brief Function for checking if provided address is located in stack space.
N *
N * @param[in]   ptr Pointer to be checked.
N *
N * @return      true if address is in stack space, false otherwise.
N */
Nstatic __INLINE bool is_address_from_stack(void * ptr)
Xstatic __inline _Bool is_address_from_stack(void * ptr)
N{
N    if (((uint32_t)ptr >= (uint32_t)STACK_BASE) &&
X    if (((uint32_t)ptr >= (uint32_t)&STACK$$Base) &&
N        ((uint32_t)ptr <  (uint32_t)STACK_TOP) )
X        ((uint32_t)ptr <  (uint32_t)((void*)((uint32_t)&STACK$$Base + (uint32_t)&STACK$$Length))) )
N    {
N        return true;
X        return 1;
N    }
N    else
N    {
N        return false;
X        return 0;
N    }
N}
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif // APP_UTIL_H__
N
N/** @} */
L 47 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.h" 2
N#include "compiler_abstraction.h"
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @file
N * @defgroup sdk_mapped_flags Mapped flags
N * @ingroup app_common
N * @{
N * @brief Module for writing and reading flags that are associated
N *        with keys.
N *
N * @details The flags are represented as bits in a bitmap called a <i>flag collection</i>. The keys
N *          are uint16_t. Each flag collection contains all flags of the same type, one flag for
N *          each key.
N *
N *          The mapped flags module does not keep the flag states, nor the list of keys. These are
N *          provided in the API calls. A key's index in the key list determines which bit in the
N *          flag collection is associated with it. This module does not ever edit the key list, and
N *          does not edit flags except in function calls that take the flag collection as a pointer.
N *
N */
N
N#define SDK_MAPPED_FLAGS_N_KEYS          8       /**< The number of keys to keep flags for. This is also the number of flags in a flag collection. If changing this value, you might also need change the width of the sdk_mapped_flags_t type. */
N#define SDK_MAPPED_FLAGS_N_KEYS_PER_BYTE 8       /**< The number of flags that fit in one byte. */
N#define SDK_MAPPED_FLAGS_INVALID_INDEX   0xFFFF  /**< A flag index guaranteed to be invalid. */
N
Ntypedef uint8_t sdk_mapped_flags_t; /**< The bitmap to hold flags. Each flag is one bit, and each bit represents the flag state associated with one key. */
N
N
N// Test whether the flag collection type is large enough to hold all the flags. If this fails,
N// reduce SDK_MAPPED_FLAGS_N_KEYS or increase the size of sdk_mapped_flags_t.
NSTATIC_ASSERT((
N    sizeof(sdk_mapped_flags_t) * SDK_MAPPED_FLAGS_N_KEYS_PER_BYTE) >= SDK_MAPPED_FLAGS_N_KEYS);
X;enum { static_assert_81 = 1 / (! !((( sizeof(sdk_mapped_flags_t) * 8) >= 8))) };
N
N
N/**@brief Type used to present a subset of the registered keys.
N */
Ntypedef struct
N{
N    uint32_t len;                                 /**< The length of the list. */
N    uint16_t flag_keys[SDK_MAPPED_FLAGS_N_KEYS];  /**< The list of keys. */
X    uint16_t flag_keys[8];   
N} sdk_mapped_flags_key_list_t;
N
N
N/**@brief Function for getting the first index at which the flag is true in the provided
N *        collection.
N *
N * @param[in]  flags   The flag collection to search for a flag set to true.
N *
N * @return  The first index that has its flag set to true. If none were found, the
N *          function returns @ref SDK_MAPPED_FLAGS_INVALID_INDEX.
N */
Nuint16_t sdk_mapped_flags_first_key_index_get(sdk_mapped_flags_t flags);
N
N
N/**@brief Function for updating the state of a flag.
N *
N * @param[in]  p_keys   The list of associated keys (assumed to have a length of
N *                      @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[out] p_flags  The flag collection to modify.
N * @param[in]  key      The key to modify the flag of.
N * @param[in]  value    The state to set the flag to.
N */
Nvoid sdk_mapped_flags_update_by_key(uint16_t           * p_keys,
N                                    sdk_mapped_flags_t * p_flags,
N                                    uint16_t             key,
N                                    bool                 value);
X                                    _Bool                 value);
N
N
N/**@brief Function for updating the state of the same flag in multiple flag collections.
N *
N * @details The key and value are the same for all flag collections in the p_flags array.
N *
N * @param[in]  p_keys              The list of associated keys (assumed to have a length of
N *                                 @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[out] p_flags             The flag collections to modify.
N * @param[out] n_flag_collections  The number of flag collections in p_flags.
N * @param[in]  key                 The key to modify the flag of.
N * @param[in]  value               The state to set the flag to.
N */
Nvoid sdk_mapped_flags_bulk_update_by_key(uint16_t           * p_keys,
N                                         sdk_mapped_flags_t * p_flags,
N                                         uint32_t             n_flag_collections,
N                                         uint16_t             key,
N                                         bool                 value);
X                                         _Bool                 value);
N
N
N/**@brief Function for getting the state of a specific flag.
N *
N * @param[in]  p_keys  The list of associated keys (assumed to have a length of
N *                     @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[in]  flags   The flag collection to read from.
N * @param[in]  key     The key to get the flag for.
N *
N * @return  The state of the flag.
N */
Nbool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key);
X_Bool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key);
N
N
N/**@brief Function for getting a list of all keys that have a specific flag set to true.
N *
N * @param[in]  p_keys  The list of associated keys (assumed to have a length of
N *                     @ref SDK_MAPPED_FLAGS_N_KEYS).
N * @param[in]  flags   The flag collection to search.
N *
N * @return  The list of keys.
N */
Nsdk_mapped_flags_key_list_t sdk_mapped_flags_key_list_get(uint16_t           * p_keys,
N                                                          sdk_mapped_flags_t   flags);
N
N
N/**@brief Function for getting the number of keys that have a specific flag set to true.
N *
N * @param[in]  flags  The flag collection to search.
N *
N * @return  The number of keys.
N */
Nuint32_t sdk_mapped_flags_n_flags_set(sdk_mapped_flags_t flags);
N
N
N/**@brief Function for querying whether any flags in the collection are set.
N *
N * @param[in]  flags  The flag collection to query.
N *
N * @retval  true If one or more flags are set to true.
N * @retval  false Otherwise.
N */
Nstatic __INLINE bool sdk_mapped_flags_any_set(sdk_mapped_flags_t flags)
Xstatic __inline _Bool sdk_mapped_flags_any_set(sdk_mapped_flags_t flags)
N{
N    return (flags != 0);
N}
N
N
N/** @} */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SDK_MAPPED_FLAGS_H__ */
L 42 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.c" 2
N#include <stdint.h>
N#include <stdbool.h>
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5050041
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 45 "..\..\..\..\..\..\components\libraries\util\sdk_mapped_flags.c" 2
N#include "compiler_abstraction.h"
N
N
N/**@brief Function for setting the state of a flag to true.
N *
N * @note This function does not check whether the index is valid.
N *
N * @param[in]  p_flags  The collection of flags to modify.
N * @param[in]  index    The index of the flag to modify.
N */
Nstatic __INLINE void sdk_mapped_flags_set_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
Xstatic __inline void sdk_mapped_flags_set_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
N{
N    *p_flags |= (1U << index);
N}
N
N
N/**@brief Function for setting the state of a flag to false.
N *
N * @note This function does not check whether the index is valid.
N *
N * @param[in]  p_flags  The collection of flags to modify.
N * @param[in]  index    The index of the flag to modify.
N */
Nstatic __INLINE void sdk_mapped_flags_clear_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
Xstatic __inline void sdk_mapped_flags_clear_by_index(sdk_mapped_flags_t * p_flags, uint16_t index)
N{
N    *p_flags &= ~(1U << index);
N}
N
N
N/**@brief Function for getting the state of a flag.
N *
N * @note This function does not check whether the index is valid.
N *
N * @param[in]  p_flags  The collection of flags to read.
N * @param[in]  index    The index of the flag to get.
N */
Nstatic __INLINE bool sdk_mapped_flags_get_by_index(sdk_mapped_flags_t flags, uint16_t index)
Xstatic __inline _Bool sdk_mapped_flags_get_by_index(sdk_mapped_flags_t flags, uint16_t index)
N{
N    return ((flags & (1 << index)) != 0);
N}
N
N
N
Nuint16_t sdk_mapped_flags_first_key_index_get(sdk_mapped_flags_t flags)
N{
N    for (uint16_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
X    for (uint16_t i = 0; i < 8; i++)
N    {
N        if (sdk_mapped_flags_get_by_index(flags, i))
N        {
N            return i;
N        }
N    }
N    return SDK_MAPPED_FLAGS_INVALID_INDEX;
X    return 0xFFFF;
N}
N
N
Nvoid sdk_mapped_flags_update_by_key(uint16_t           * p_keys,
N                                    sdk_mapped_flags_t * p_flags,
N                                    uint16_t             key,
N                                    bool                 value)
X                                    _Bool                 value)
N{
N    sdk_mapped_flags_bulk_update_by_key(p_keys, p_flags, 1, key, value);
N}
N
N
Nvoid sdk_mapped_flags_bulk_update_by_key(uint16_t           * p_keys,
N                                         sdk_mapped_flags_t * p_flags,
N                                         uint32_t             n_flag_collections,
N                                         uint16_t             key,
N                                         bool                 value)
X                                         _Bool                 value)
N{
N    if ((p_keys != NULL) && (p_flags != NULL) && (n_flag_collections > 0))
X    if ((p_keys != 0) && (p_flags != 0) && (n_flag_collections > 0))
N    {
N        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
X        for (uint32_t i = 0; i < 8; i++)
N        {
N            if (p_keys[i] == key)
N            {
N                for (uint32_t j = 0; j < n_flag_collections; j++)
N                {
N                    if (value)
N                    {
N                        sdk_mapped_flags_set_by_index(&p_flags[j], i);
N                    }
N                    else
N                    {
N                        sdk_mapped_flags_clear_by_index(&p_flags[j], i);
N                    }
N                }
N                return;
N            }
N        }
N    }
N}
N
N
Nbool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key)
X_Bool sdk_mapped_flags_get_by_key(uint16_t * p_keys, sdk_mapped_flags_t flags, uint16_t key)
N{
N    if (p_keys != NULL)
X    if (p_keys != 0)
N    {
N        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
X        for (uint32_t i = 0; i < 8; i++)
N        {
N            if (p_keys[i] == key)
N            {
N                return sdk_mapped_flags_get_by_index(flags, i);
N            }
N        }
N    }
N    return false;
X    return 0;
N}
N
N
Nsdk_mapped_flags_key_list_t sdk_mapped_flags_key_list_get(uint16_t           * p_keys,
N                                                          sdk_mapped_flags_t   flags)
N{
N    sdk_mapped_flags_key_list_t key_list;
N    key_list.len = 0;
N
N    if (p_keys != NULL)
X    if (p_keys != 0)
N    {
N        for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
X        for (uint32_t i = 0; i < 8; i++)
N        {
N            if (sdk_mapped_flags_get_by_index(flags, i))
N            {
N                key_list.flag_keys[key_list.len++] = p_keys[i];
N            }
N        }
N    }
N
N    return key_list;
N}
N
N
Nuint32_t sdk_mapped_flags_n_flags_set(sdk_mapped_flags_t flags)
N{
N    uint32_t n_flags_set = 0;
N
N    for (uint32_t i = 0; i < SDK_MAPPED_FLAGS_N_KEYS; i++)
X    for (uint32_t i = 0; i < 8; i++)
N    {
N        if (sdk_mapped_flags_get_by_index(flags, i))
N        {
N            n_flags_set += 1;
N        }
N    }
N    return n_flags_set;
N}
