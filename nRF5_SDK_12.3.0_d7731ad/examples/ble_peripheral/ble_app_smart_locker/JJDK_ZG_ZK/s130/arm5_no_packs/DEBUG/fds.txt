; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\fds.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\fds.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\fds.crf ..\..\..\..\..\..\components\libraries\fds\fds.c]
                          THUMB

                          AREA ||i.address_is_valid||, CODE, READONLY, ALIGN=2

                  address_is_valid PROC
;;;185    
;;;186    static bool address_is_valid(uint32_t const * const p_addr)
000000  b510              PUSH     {r4,lr}
;;;187    {
000002  4604              MOV      r4,r0
;;;188        return ((p_addr != NULL) &&
000004  2c00              CMP      r4,#0
000006  d00e              BEQ      |L1.38|
;;;189                (p_addr >= fs_config.p_start_addr) &&
000008  4808              LDR      r0,|L1.44|
00000a  6800              LDR      r0,[r0,#0]  ; fs_config
00000c  42a0              CMP      r0,r4
00000e  d80a              BHI      |L1.38|
;;;190                (p_addr <= fs_config.p_end_addr)   &&
000010  4806              LDR      r0,|L1.44|
000012  6840              LDR      r0,[r0,#4]  ; fs_config
000014  42a0              CMP      r0,r4
000016  d306              BCC      |L1.38|
;;;191                (is_word_aligned(p_addr)));
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       is_word_aligned
00001e  2800              CMP      r0,#0
000020  d001              BEQ      |L1.38|
000022  2001              MOVS     r0,#1
                  |L1.36|
;;;192    }
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  2000              MOVS     r0,#0                 ;191
000028  e7fc              B        |L1.36|
;;;193    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
                          DCD      fs_config

                          AREA ||i.chunk_is_aligned||, CODE, READONLY, ALIGN=1

                  chunk_is_aligned PROC
;;;194    
;;;195    static bool chunk_is_aligned(fds_record_chunk_t const * const p_chunk, uint32_t num_chunks)
000000  b570              PUSH     {r4-r6,lr}
;;;196    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;197        for (uint32_t i = 0; i < num_chunks; i++)
000006  2400              MOVS     r4,#0
000008  e007              B        |L2.26|
                  |L2.10|
;;;198        {
;;;199            if (!is_word_aligned(p_chunk[i].p_data))
00000a  00e1              LSLS     r1,r4,#3
00000c  5868              LDR      r0,[r5,r1]
00000e  f7fffffe          BL       is_word_aligned
000012  2800              CMP      r0,#0
000014  d100              BNE      |L2.24|
                  |L2.22|
;;;200            {
;;;201                return false;
;;;202            }
;;;203        }
;;;204        return true;
;;;205    }
000016  bd70              POP      {r4-r6,pc}
                  |L2.24|
000018  1c64              ADDS     r4,r4,#1              ;197
                  |L2.26|
00001a  42b4              CMP      r4,r6                 ;197
00001c  d3f5              BCC      |L2.10|
00001e  2001              MOVS     r0,#1                 ;204
000020  e7f9              B        |L2.22|
;;;206    
                          ENDP


                          AREA ||i.chunk_queue_get_and_advance||, CODE, READONLY, ALIGN=2

                  chunk_queue_get_and_advance PROC
;;;595    // Retrieve the current chunk, and advance the queue.
;;;596    static void chunk_queue_get_and_advance(fds_record_chunk_t ** pp_chunk)
000000  490a              LDR      r1,|L3.44|
;;;597    {
;;;598        if (m_chunk_queue.count != 0)
000002  6c49              LDR      r1,[r1,#0x44]  ; m_chunk_queue
000004  2900              CMP      r1,#0
000006  d00f              BEQ      |L3.40|
;;;599        {
;;;600            // Point to the current chunk and advance the queue.
;;;601            *pp_chunk = &m_chunk_queue.chunk[m_chunk_queue.rp];
000008  4908              LDR      r1,|L3.44|
00000a  6c09              LDR      r1,[r1,#0x40]  ; m_chunk_queue
00000c  00c9              LSLS     r1,r1,#3
00000e  4a07              LDR      r2,|L3.44|
000010  1889              ADDS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;602    
;;;603            m_chunk_queue.rp = (m_chunk_queue.rp + 1) % FDS_CHUNK_QUEUE_SIZE;
000014  4611              MOV      r1,r2
000016  6c09              LDR      r1,[r1,#0x40]  ; m_chunk_queue
000018  1c49              ADDS     r1,r1,#1
00001a  0749              LSLS     r1,r1,#29
00001c  0f49              LSRS     r1,r1,#29
00001e  6411              STR      r1,[r2,#0x40]  ; m_chunk_queue
;;;604            m_chunk_queue.count--;
000020  4611              MOV      r1,r2
000022  6c49              LDR      r1,[r1,#0x44]  ; m_chunk_queue
000024  1e49              SUBS     r1,r1,#1
000026  6451              STR      r1,[r2,#0x44]  ; m_chunk_queue
                  |L3.40|
;;;605        }
;;;606    }
000028  4770              BX       lr
;;;607    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      m_chunk_queue

                          AREA ||i.chunk_queue_next||, CODE, READONLY, ALIGN=2

                  chunk_queue_next PROC
;;;582    // the next element in the queue. Handles wrap around.
;;;583    void chunk_queue_next(fds_record_chunk_t ** pp_chunk)
000000  4906              LDR      r1,|L4.28|
;;;584    {
;;;585        if ((*pp_chunk) != &m_chunk_queue.chunk[FDS_CHUNK_QUEUE_SIZE - 1])
000002  6802              LDR      r2,[r0,#0]
000004  428a              CMP      r2,r1
000006  d003              BEQ      |L4.16|
;;;586        {
;;;587            (*pp_chunk)++;
000008  6801              LDR      r1,[r0,#0]
00000a  3108              ADDS     r1,r1,#8
00000c  6001              STR      r1,[r0,#0]
                  |L4.14|
;;;588            return;
;;;589        }
;;;590    
;;;591        *pp_chunk = &m_chunk_queue.chunk[0];
;;;592    }
00000e  4770              BX       lr
                  |L4.16|
000010  4902              LDR      r1,|L4.28|
000012  3938              SUBS     r1,r1,#0x38           ;591
000014  6001              STR      r1,[r0,#0]            ;591
000016  bf00              NOP      
000018  e7f9              B        |L4.14|
;;;593    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      m_chunk_queue+0x38

                          AREA ||i.chunk_queue_skip||, CODE, READONLY, ALIGN=2

                  chunk_queue_skip PROC
;;;608    
;;;609    static void chunk_queue_skip(fds_op_t const * const p_op)
000000  7801              LDRB     r1,[r0,#0]
;;;610    {
;;;611        if ((p_op->op_code == FDS_OP_WRITE) ||
000002  2902              CMP      r1,#2
000004  d002              BEQ      |L5.12|
;;;612            (p_op->op_code == FDS_OP_UPDATE))
000006  7801              LDRB     r1,[r0,#0]
000008  2903              CMP      r1,#3
00000a  d10b              BNE      |L5.36|
                  |L5.12|
;;;613        {
;;;614            m_chunk_queue.rp    += p_op->write.chunk_count;
00000c  4906              LDR      r1,|L5.40|
00000e  6c0a              LDR      r2,[r1,#0x40]  ; m_chunk_queue
000010  7d81              LDRB     r1,[r0,#0x16]
000012  1851              ADDS     r1,r2,r1
000014  4a04              LDR      r2,|L5.40|
000016  6411              STR      r1,[r2,#0x40]  ; m_chunk_queue
;;;615            m_chunk_queue.count -= p_op->write.chunk_count;
000018  4611              MOV      r1,r2
00001a  6c4a              LDR      r2,[r1,#0x44]  ; m_chunk_queue
00001c  7d81              LDRB     r1,[r0,#0x16]
00001e  1a51              SUBS     r1,r2,r1
000020  4a01              LDR      r2,|L5.40|
000022  6451              STR      r1,[r2,#0x44]  ; m_chunk_queue
                  |L5.36|
;;;616        }
;;;617    }
000024  4770              BX       lr
;;;618    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      m_chunk_queue

                          AREA ||i.delete_execute||, CODE, READONLY, ALIGN=2

                  delete_execute PROC
;;;1314   
;;;1315   static ret_code_t delete_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  b570              PUSH     {r4-r6,lr}
;;;1316   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1317       ret_code_t ret;
;;;1318   
;;;1319       if (prev_ret != FS_SUCCESS)
000006  2e00              CMP      r6,#0
000008  d001              BEQ      |L6.14|
;;;1320       {
;;;1321           return FDS_ERR_OPERATION_TIMEOUT;
00000a  2001              MOVS     r0,#1
                  |L6.12|
;;;1322       }
;;;1323   
;;;1324       switch (p_op->del.step)
;;;1325       {
;;;1326           case FDS_OP_DEL_RECORD_FLAG_DIRTY:
;;;1327               ret = record_find_and_delete(p_op);
;;;1328               p_op->del.step = FDS_OP_DEL_DONE;
;;;1329               break;
;;;1330   
;;;1331           case FDS_OP_DEL_FILE_FLAG_DIRTY:
;;;1332               ret = file_find_and_delete(p_op);
;;;1333               if (ret == FDS_ERR_NOT_FOUND)
;;;1334               {
;;;1335                   // No more records could be found.
;;;1336                   // There won't be another callback for this operation, so return now.
;;;1337                   ret = FDS_OP_COMPLETED;
;;;1338               }
;;;1339               break;
;;;1340   
;;;1341           case FDS_OP_DEL_DONE:
;;;1342               ret = FDS_OP_COMPLETED;
;;;1343               break;
;;;1344   
;;;1345           default:
;;;1346               ret = FDS_ERR_INTERNAL;
;;;1347               break;
;;;1348       }
;;;1349   
;;;1350       return ret;
;;;1351   }
00000c  bd70              POP      {r4-r6,pc}
                  |L6.14|
00000e  7928              LDRB     r0,[r5,#4]            ;1324
000010  2800              CMP      r0,#0                 ;1324
000012  d004              BEQ      |L6.30|
000014  2801              CMP      r0,#1                 ;1324
000016  d009              BEQ      |L6.44|
000018  2802              CMP      r0,#2                 ;1324
00001a  d111              BNE      |L6.64|
00001c  e00e              B        |L6.60|
                  |L6.30|
00001e  4628              MOV      r0,r5                 ;1327
000020  f7fffffe          BL       record_find_and_delete
000024  4604              MOV      r4,r0                 ;1327
000026  2002              MOVS     r0,#2                 ;1328
000028  7128              STRB     r0,[r5,#4]            ;1328
00002a  e00b              B        |L6.68|
                  |L6.44|
00002c  4628              MOV      r0,r5                 ;1332
00002e  f7fffffe          BL       file_find_and_delete
000032  4604              MOV      r4,r0                 ;1332
000034  2c0a              CMP      r4,#0xa               ;1333
000036  d100              BNE      |L6.58|
000038  4c04              LDR      r4,|L6.76|
                  |L6.58|
00003a  e003              B        |L6.68|
                  |L6.60|
00003c  4c03              LDR      r4,|L6.76|
00003e  e001              B        |L6.68|
                  |L6.64|
000040  240f              MOVS     r4,#0xf               ;1346
000042  bf00              NOP                            ;1347
                  |L6.68|
000044  bf00              NOP                            ;1329
000046  4620              MOV      r0,r4                 ;1350
000048  e7e0              B        |L6.12|
;;;1352   
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      0x00001d1d

                          AREA ||i.dirty_records_stat||, CODE, READONLY, ALIGN=2

                  dirty_records_stat PROC
;;;537    // Retrieve basic statistics about dirty records on a page.
;;;538    static void dirty_records_stat(uint16_t         page,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;539                                   uint16_t * const p_dirty_records,
;;;540                                   uint16_t * const p_word_count)
;;;541    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;542        fds_header_t const * p_header;
;;;543        uint32_t     const * p_rec;
;;;544    
;;;545        p_rec = m_pages[page].p_addr + FDS_PAGE_TAG_SIZE;
000006  0130              LSLS     r0,r6,#4
000008  4914              LDR      r1,|L7.92|
00000a  1840              ADDS     r0,r0,r1
00000c  6840              LDR      r0,[r0,#4]
00000e  4605              MOV      r5,r0
000010  3508              ADDS     r5,r5,#8
;;;546    
;;;547        while ((p_rec < (m_pages[page].p_addr + FDS_PAGE_SIZE)) &&
000012  e014              B        |L7.62|
                  |L7.20|
;;;548               (*p_rec != FDS_ERASED_WORD))
;;;549        {
;;;550            p_header = (fds_header_t*)p_rec;
000014  462c              MOV      r4,r5
;;;551    
;;;552            if (!header_is_valid(p_header))
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       header_is_valid
00001c  2800              CMP      r0,#0
00001e  d10a              BNE      |L7.54|
;;;553            {
;;;554                (*p_dirty_records) += 1;
000020  8838              LDRH     r0,[r7,#0]
000022  1c40              ADDS     r0,r0,#1
000024  8038              STRH     r0,[r7,#0]
;;;555                (*p_word_count)    += FDS_HEADER_SIZE + p_header->tl.length_words;
000026  9802              LDR      r0,[sp,#8]
000028  8801              LDRH     r1,[r0,#0]
00002a  8860              LDRH     r0,[r4,#2]
00002c  1cc0              ADDS     r0,r0,#3
00002e  1808              ADDS     r0,r1,r0
000030  b281              UXTH     r1,r0
000032  9802              LDR      r0,[sp,#8]
000034  8001              STRH     r1,[r0,#0]
                  |L7.54|
;;;556            }
;;;557    
;;;558            p_rec += (FDS_HEADER_SIZE + (p_header->tl.length_words));
000036  8860              LDRH     r0,[r4,#2]
000038  1cc0              ADDS     r0,r0,#3
00003a  0080              LSLS     r0,r0,#2
00003c  1945              ADDS     r5,r0,r5
                  |L7.62|
00003e  0130              LSLS     r0,r6,#4              ;547
000040  4906              LDR      r1,|L7.92|
000042  1840              ADDS     r0,r0,r1              ;547
000044  6840              LDR      r0,[r0,#4]            ;547
000046  2101              MOVS     r1,#1                 ;547
000048  0289              LSLS     r1,r1,#10             ;547
00004a  1840              ADDS     r0,r0,r1              ;547
00004c  42a8              CMP      r0,r5                 ;547
00004e  d903              BLS      |L7.88|
000050  6828              LDR      r0,[r5,#0]            ;548
000052  1c40              ADDS     r0,r0,#1              ;548
000054  2800              CMP      r0,#0                 ;548
000056  d1dd              BNE      |L7.20|
                  |L7.88|
;;;559        }
;;;560    }
000058  bdfe              POP      {r1-r7,pc}
;;;561    
                          ENDP

00005a  0000              DCW      0x0000
                  |L7.92|
                          DCD      m_pages

                          AREA ||i.event_prepare||, CODE, READONLY, ALIGN=1

                  event_prepare PROC
;;;131    
;;;132    static void event_prepare(fds_op_t const * const p_op, fds_evt_t * const p_evt)
000000  b500              PUSH     {lr}
;;;133    {
;;;134        switch (p_op->op_code)
000002  7802              LDRB     r2,[r0,#0]
000004  0013              MOVS     r3,r2
000006  f7fffffe          BL       __ARM_common_switch8
00000a  0734              DCB      0x07,0x34
00000c  05081121          DCB      0x05,0x08,0x11,0x21
000010  2a313400          DCB      0x2a,0x31,0x34,0x00
;;;135        {
;;;136            case FDS_OP_INIT:
;;;137                p_evt->id = FDS_EVT_INIT;
000014  2200              MOVS     r2,#0
000016  700a              STRB     r2,[r1,#0]
;;;138                break;
000018  e02c              B        |L8.116|
;;;139    
;;;140            case FDS_OP_WRITE:
;;;141                p_evt->id               = FDS_EVT_WRITE;
00001a  2201              MOVS     r2,#1
00001c  700a              STRB     r2,[r1,#0]
;;;142                p_evt->write.file_id    = p_op->write.header.ic.file_id;
00001e  8903              LDRH     r3,[r0,#8]
000020  818b              STRH     r3,[r1,#0xc]
;;;143                p_evt->write.record_key = p_op->write.header.tl.record_key;
000022  8883              LDRH     r3,[r0,#4]
000024  81cb              STRH     r3,[r1,#0xe]
;;;144                p_evt->write.record_id  = p_op->write.header.record_id;
000026  68c2              LDR      r2,[r0,#0xc]
000028  608a              STR      r2,[r1,#8]
;;;145                break;
00002a  e023              B        |L8.116|
;;;146    
;;;147            case FDS_OP_UPDATE:
;;;148                p_evt->id                      = FDS_EVT_UPDATE;
00002c  2202              MOVS     r2,#2
00002e  700a              STRB     r2,[r1,#0]
;;;149                p_evt->write.file_id           = p_op->write.header.ic.file_id;
000030  8903              LDRH     r3,[r0,#8]
000032  818b              STRH     r3,[r1,#0xc]
;;;150                p_evt->write.record_key        = p_op->write.header.tl.record_key;
000034  8883              LDRH     r3,[r0,#4]
000036  81cb              STRH     r3,[r1,#0xe]
;;;151                p_evt->write.record_id         = p_op->write.header.record_id;
000038  68c2              LDR      r2,[r0,#0xc]
00003a  608a              STR      r2,[r1,#8]
;;;152                p_evt->write.is_record_updated = (p_op->write.step == FDS_OP_WRITE_DONE);
00003c  7c02              LDRB     r2,[r0,#0x10]
00003e  2a06              CMP      r2,#6
000040  d101              BNE      |L8.70|
000042  2301              MOVS     r3,#1
000044  e000              B        |L8.72|
                  |L8.70|
000046  2300              MOVS     r3,#0
                  |L8.72|
000048  740b              STRB     r3,[r1,#0x10]
;;;153                break;
00004a  e013              B        |L8.116|
;;;154    
;;;155            case FDS_OP_DEL_RECORD:
;;;156                p_evt->id             = FDS_EVT_DEL_RECORD;
00004c  2203              MOVS     r2,#3
00004e  700a              STRB     r2,[r1,#0]
;;;157                p_evt->del.file_id    = p_op->del.file_id;
000050  88c3              LDRH     r3,[r0,#6]
000052  818b              STRH     r3,[r1,#0xc]
;;;158                p_evt->del.record_key = p_op->del.record_key;
000054  8903              LDRH     r3,[r0,#8]
000056  81cb              STRH     r3,[r1,#0xe]
;;;159                p_evt->del.record_id  = p_op->del.record_to_delete;
000058  68c2              LDR      r2,[r0,#0xc]
00005a  608a              STR      r2,[r1,#8]
;;;160                break;
00005c  e00a              B        |L8.116|
;;;161    
;;;162            case FDS_OP_DEL_FILE:
;;;163                p_evt->id             = FDS_EVT_DEL_FILE;
00005e  2204              MOVS     r2,#4
000060  700a              STRB     r2,[r1,#0]
;;;164                p_evt->del.file_id    = p_op->del.file_id;
000062  88c3              LDRH     r3,[r0,#6]
000064  818b              STRH     r3,[r1,#0xc]
;;;165                p_evt->del.record_key = FDS_RECORD_KEY_DIRTY;
000066  2300              MOVS     r3,#0
000068  81cb              STRH     r3,[r1,#0xe]
;;;166                break;
00006a  e003              B        |L8.116|
;;;167    
;;;168            case FDS_OP_GC:
;;;169                p_evt->id = FDS_EVT_GC;
00006c  2205              MOVS     r2,#5
00006e  700a              STRB     r2,[r1,#0]
;;;170                break;
000070  e000              B        |L8.116|
;;;171    
;;;172            default:
;;;173                // Should not happen.
;;;174                break;
000072  bf00              NOP      
                  |L8.116|
000074  bf00              NOP                            ;138
;;;175        }
;;;176    }
000076  bd00              POP      {pc}
;;;177    
                          ENDP


                          AREA ||i.event_send||, CODE, READONLY, ALIGN=2

                  event_send PROC
;;;119    
;;;120    static void event_send(fds_evt_t const * const p_evt)
000000  b570              PUSH     {r4-r6,lr}
;;;121    {
000002  4605              MOV      r5,r0
;;;122        for (uint32_t user = 0; user < FDS_MAX_USERS; user++)
000004  2400              MOVS     r4,#0
000006  e00a              B        |L9.30|
                  |L9.8|
;;;123        {
;;;124            if (m_cb_table[user] != NULL)
000008  00a0              LSLS     r0,r4,#2
00000a  4906              LDR      r1,|L9.36|
00000c  5808              LDR      r0,[r1,r0]
00000e  2800              CMP      r0,#0
000010  d004              BEQ      |L9.28|
;;;125            {
;;;126                m_cb_table[user](p_evt);
000012  00a0              LSLS     r0,r4,#2
000014  460a              MOV      r2,r1
000016  5811              LDR      r1,[r2,r0]
000018  4628              MOV      r0,r5
00001a  4788              BLX      r1
                  |L9.28|
00001c  1c64              ADDS     r4,r4,#1              ;122
                  |L9.30|
00001e  2c08              CMP      r4,#8                 ;122
000020  d3f2              BCC      |L9.8|
;;;127            }
;;;128        }
;;;129    }
000022  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

                  |L9.36|
                          DCD      m_cb_table

                          AREA ||i.fds_descriptor_from_rec_id||, CODE, READONLY, ALIGN=1

                  fds_descriptor_from_rec_id PROC
;;;2011   
;;;2012   ret_code_t fds_descriptor_from_rec_id(fds_record_desc_t * const p_desc,
000000  4602              MOV      r2,r0
;;;2013                                         uint32_t                  record_id)
;;;2014   {
;;;2015       if (p_desc == NULL)
000002  2a00              CMP      r2,#0
000004  d101              BNE      |L10.10|
;;;2016       {
;;;2017           return FDS_ERR_NULL_ARG;
000006  2005              MOVS     r0,#5
                  |L10.8|
;;;2018       }
;;;2019   
;;;2020       // Zero the descriptor and set the record_id field.
;;;2021       memset(p_desc, 0x00, sizeof(fds_record_desc_t));
;;;2022       p_desc->record_id = record_id;
;;;2023   
;;;2024       return FDS_SUCCESS;
;;;2025   }
000008  4770              BX       lr
                  |L10.10|
00000a  2000              MOVS     r0,#0                 ;2021
00000c  6010              STR      r0,[r2,#0]            ;2021
00000e  6050              STR      r0,[r2,#4]            ;2021
000010  6090              STR      r0,[r2,#8]            ;2021
000012  6011              STR      r1,[r2,#0]            ;2022
000014  bf00              NOP                            ;2024
000016  e7f7              B        |L10.8|
;;;2026   
                          ENDP


                          AREA ||i.fds_file_delete||, CODE, READONLY, ALIGN=2

                  fds_file_delete PROC
;;;1924   
;;;1925   ret_code_t fds_file_delete(uint16_t file_id)
000000  b510              PUSH     {r4,lr}
;;;1926   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1927       fds_op_t op;
;;;1928   
;;;1929       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  2800              CMP      r0,#0
00000e  d102              BNE      |L11.22|
;;;1930       {
;;;1931           return FDS_ERR_NOT_INITIALIZED;
000010  2002              MOVS     r0,#2
                  |L11.18|
;;;1932       }
;;;1933   
;;;1934       if (file_id == FDS_FILE_ID_INVALID)
;;;1935       {
;;;1936           return FDS_ERR_INVALID_ARG;
;;;1937       }
;;;1938   
;;;1939       op.op_code      = FDS_OP_DEL_FILE;
;;;1940       op.del.step     = FDS_OP_DEL_FILE_FLAG_DIRTY;
;;;1941       op.del.file_id  = file_id;
;;;1942   
;;;1943       if (op_enqueue(&op, 0, NULL))
;;;1944       {
;;;1945           queue_start();
;;;1946           return FDS_SUCCESS;
;;;1947       }
;;;1948   
;;;1949       return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1950   }
000012  b008              ADD      sp,sp,#0x20
000014  bd10              POP      {r4,pc}
                  |L11.22|
000016  480c              LDR      r0,|L11.72|
000018  4284              CMP      r4,r0                 ;1934
00001a  d101              BNE      |L11.32|
00001c  2004              MOVS     r0,#4                 ;1936
00001e  e7f8              B        |L11.18|
                  |L11.32|
000020  2105              MOVS     r1,#5                 ;1939
000022  4668              MOV      r0,sp                 ;1939
000024  7101              STRB     r1,[r0,#4]            ;1939
000026  2101              MOVS     r1,#1                 ;1940
000028  7201              STRB     r1,[r0,#8]            ;1940
00002a  a801              ADD      r0,sp,#4              ;1941
00002c  80c4              STRH     r4,[r0,#6]            ;1941
00002e  2200              MOVS     r2,#0                 ;1943
000030  4611              MOV      r1,r2                 ;1943
000032  f7fffffe          BL       op_enqueue
000036  2800              CMP      r0,#0                 ;1943
000038  d003              BEQ      |L11.66|
00003a  f7fffffe          BL       queue_start
00003e  2000              MOVS     r0,#0                 ;1946
000040  e7e7              B        |L11.18|
                  |L11.66|
000042  2008              MOVS     r0,#8                 ;1949
000044  e7e5              B        |L11.18|
;;;1951   
                          ENDP

000046  0000              DCW      0x0000
                  |L11.72|
                          DCD      0x0000ffff

                          AREA ||i.fds_gc||, CODE, READONLY, ALIGN=2

                  fds_gc PROC
;;;1952   
;;;1953   ret_code_t fds_gc(void)
000000  b500              PUSH     {lr}
;;;1954   {
000002  b087              SUB      sp,sp,#0x1c
;;;1955       fds_op_t op;
;;;1956   
;;;1957       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       flag_is_set
00000a  2800              CMP      r0,#0
00000c  d102              BNE      |L12.20|
;;;1958       {
;;;1959           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L12.16|
;;;1960       }
;;;1961   
;;;1962       op.op_code = FDS_OP_GC;
;;;1963   
;;;1964       if (op_enqueue(&op, 0, NULL))
;;;1965       {
;;;1966           if (m_gc.state != GC_BEGIN)
;;;1967           {
;;;1968               // Resume GC by retrying the last step.
;;;1969               m_gc.resume = true;
;;;1970           }
;;;1971   
;;;1972           queue_start();
;;;1973           return FDS_SUCCESS;
;;;1974       }
;;;1975   
;;;1976       return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1977   }
000010  b007              ADD      sp,sp,#0x1c
000012  bd00              POP      {pc}
                  |L12.20|
000014  2006              MOVS     r0,#6                 ;1962
000016  4669              MOV      r1,sp                 ;1962
000018  7008              STRB     r0,[r1,#0]            ;1962
00001a  2200              MOVS     r2,#0                 ;1964
00001c  4611              MOV      r1,r2                 ;1964
00001e  4668              MOV      r0,sp                 ;1964
000020  f7fffffe          BL       op_enqueue
000024  2800              CMP      r0,#0                 ;1964
000026  d00a              BEQ      |L12.62|
000028  4806              LDR      r0,|L12.68|
00002a  7800              LDRB     r0,[r0,#0]            ;1966  ; m_gc
00002c  2800              CMP      r0,#0                 ;1966
00002e  d002              BEQ      |L12.54|
000030  2001              MOVS     r0,#1                 ;1969
000032  4904              LDR      r1,|L12.68|
000034  7308              STRB     r0,[r1,#0xc]          ;1969
                  |L12.54|
000036  f7fffffe          BL       queue_start
00003a  2000              MOVS     r0,#0                 ;1973
00003c  e7e8              B        |L12.16|
                  |L12.62|
00003e  2008              MOVS     r0,#8                 ;1976
000040  e7e6              B        |L12.16|
;;;1978   
                          ENDP

000042  0000              DCW      0x0000
                  |L12.68|
                          DCD      m_gc

                          AREA ||i.fds_init||, CODE, READONLY, ALIGN=1

                  fds_init PROC
;;;1633   
;;;1634   ret_code_t fds_init(void)
000000  b510              PUSH     {r4,lr}
;;;1635   {
000002  b08c              SUB      sp,sp,#0x30
;;;1636       fds_evt_t const evt_success =
000004  2114              MOVS     r1,#0x14
000006  a807              ADD      r0,sp,#0x1c
000008  f7fffffe          BL       __aeabi_memclr4
;;;1637       {
;;;1638           .id     = FDS_EVT_INIT,
;;;1639           .result = FDS_SUCCESS
;;;1640       };
;;;1641   
;;;1642       // No initialization is necessary. Notify the application immediately.
;;;1643       if (flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  2800              CMP      r0,#0
000014  d005              BEQ      |L13.34|
;;;1644       {
;;;1645           event_send(&evt_success);
000016  a807              ADD      r0,sp,#0x1c
000018  f7fffffe          BL       event_send
;;;1646           return FDS_SUCCESS;
00001c  2000              MOVS     r0,#0
                  |L13.30|
;;;1647       }
;;;1648   
;;;1649       if (flag_is_set(FDS_FLAG_INITIALIZING))
;;;1650       {
;;;1651           return FDS_SUCCESS;
;;;1652       }
;;;1653   
;;;1654       flag_set(FDS_FLAG_INITIALIZING);
;;;1655   
;;;1656       (void)fs_init();
;;;1657   
;;;1658       // Initialize the page structure (m_pages), and determine which
;;;1659       // initialization steps are required given the current state of the filesystem.
;;;1660       fds_op_t op;
;;;1661       op.op_code = FDS_OP_INIT;
;;;1662   
;;;1663       fds_init_opts_t init_opts = pages_init();
;;;1664   
;;;1665       switch (init_opts)
;;;1666       {
;;;1667           case NO_PAGES:
;;;1668           case NO_SWAP:
;;;1669               return FDS_ERR_NO_PAGES;
;;;1670   
;;;1671           case ALREADY_INSTALLED:
;;;1672               // No initialization is necessary. Notify the application immediately.
;;;1673               flag_set(FDS_FLAG_INITIALIZED);
;;;1674               flag_clear(FDS_FLAG_INITIALIZING);
;;;1675               event_send(&evt_success);
;;;1676               return FDS_SUCCESS;
;;;1677   
;;;1678           case FRESH_INSTALL:
;;;1679           case TAG_SWAP:
;;;1680               op.init.step = FDS_OP_INIT_TAG_SWAP;
;;;1681               break;
;;;1682   
;;;1683           case PROMOTE_SWAP:
;;;1684           case PROMOTE_SWAP_INST:
;;;1685               op.init.step = FDS_OP_INIT_PROMOTE_SWAP;
;;;1686               break;
;;;1687   
;;;1688           case DISCARD_SWAP:
;;;1689               op.init.step = FDS_OP_INIT_ERASE_SWAP;
;;;1690               break;
;;;1691   
;;;1692           case TAG_DATA:
;;;1693           case TAG_DATA_INST:
;;;1694               op.init.step = FDS_OP_INIT_TAG_DATA;
;;;1695               break;
;;;1696   
;;;1697           default:
;;;1698               // Should not happen.
;;;1699               break;
;;;1700       }
;;;1701   
;;;1702       // This cannot fail since it will be the first operation in the queue.
;;;1703       (void)op_enqueue(&op, 0, NULL);
;;;1704   
;;;1705       queue_start();
;;;1706   
;;;1707       return FDS_SUCCESS;
;;;1708   }
00001e  b00c              ADD      sp,sp,#0x30
000020  bd10              POP      {r4,pc}
                  |L13.34|
000022  2001              MOVS     r0,#1                 ;1649
000024  f7fffffe          BL       flag_is_set
000028  2800              CMP      r0,#0                 ;1649
00002a  d001              BEQ      |L13.48|
00002c  2000              MOVS     r0,#0                 ;1651
00002e  e7f6              B        |L13.30|
                  |L13.48|
000030  2001              MOVS     r0,#1                 ;1654
000032  f7fffffe          BL       flag_set
000036  f7fffffe          BL       fs_init
00003a  2001              MOVS     r0,#1                 ;1661
00003c  4669              MOV      r1,sp                 ;1661
00003e  7008              STRB     r0,[r1,#0]            ;1661
000040  f7fffffe          BL       pages_init
000044  4604              MOV      r4,r0                 ;1663
000046  0023              MOVS     r3,r4                 ;1665
000048  f7fffffe          BL       __ARM_common_switch8
00004c  0c071508          DCB      0x0c,0x07,0x15,0x08
000050  1628230a          DCB      0x16,0x28,0x23,0x0a
000054  24281a1f          DCB      0x24,0x28,0x1a,0x1f
000058  1b28              DCB      0x1b,0x28
00005a  bf00              NOP                            ;1668
00005c  200b              MOVS     r0,#0xb               ;1669
00005e  e7de              B        |L13.30|
000060  2002              MOVS     r0,#2                 ;1673
000062  f7fffffe          BL       flag_set
000066  2001              MOVS     r0,#1                 ;1674
000068  f7fffffe          BL       flag_clear
00006c  a807              ADD      r0,sp,#0x1c           ;1675
00006e  f7fffffe          BL       event_send
000072  2000              MOVS     r0,#0                 ;1676
000074  e7d3              B        |L13.30|
000076  bf00              NOP                            ;1679
000078  2000              MOVS     r0,#0                 ;1680
00007a  4669              MOV      r1,sp                 ;1680
00007c  7108              STRB     r0,[r1,#4]            ;1680
00007e  e00e              B        |L13.158|
000080  bf00              NOP                            ;1684
000082  2003              MOVS     r0,#3                 ;1685
000084  4669              MOV      r1,sp                 ;1685
000086  7108              STRB     r0,[r1,#4]            ;1685
000088  e009              B        |L13.158|
00008a  2002              MOVS     r0,#2                 ;1689
00008c  4669              MOV      r1,sp                 ;1689
00008e  7108              STRB     r0,[r1,#4]            ;1689
000090  e005              B        |L13.158|
000092  bf00              NOP                            ;1693
000094  2001              MOVS     r0,#1                 ;1694
000096  4669              MOV      r1,sp                 ;1694
000098  7108              STRB     r0,[r1,#4]            ;1694
00009a  e000              B        |L13.158|
00009c  bf00              NOP                            ;1699
                  |L13.158|
00009e  bf00              NOP                            ;1681
0000a0  2200              MOVS     r2,#0                 ;1703
0000a2  4611              MOV      r1,r2                 ;1703
0000a4  4668              MOV      r0,sp                 ;1703
0000a6  f7fffffe          BL       op_enqueue
0000aa  f7fffffe          BL       queue_start
0000ae  2000              MOVS     r0,#0                 ;1707
0000b0  e7b5              B        |L13.30|
;;;1709   
                          ENDP


                          AREA ||i.fds_record_close||, CODE, READONLY, ALIGN=2

                  fds_record_close PROC
;;;1754   
;;;1755   ret_code_t fds_record_close(fds_record_desc_t * const p_desc)
000000  b538              PUSH     {r3-r5,lr}
;;;1756   {
000002  4604              MOV      r4,r0
;;;1757       ret_code_t ret;
;;;1758       uint16_t   page;
;;;1759   
;;;1760       if (p_desc == NULL)
000004  2c00              CMP      r4,#0
000006  d101              BNE      |L14.12|
;;;1761       {
;;;1762           return FDS_ERR_NULL_ARG;
000008  2005              MOVS     r0,#5
                  |L14.10|
;;;1763       }
;;;1764   
;;;1765       if (record_find_by_desc((fds_record_desc_t*)p_desc, &page))
;;;1766       {
;;;1767           CRITICAL_SECTION_ENTER();
;;;1768           if ((m_pages[page].records_open > 0) && (p_desc->record_is_open))
;;;1769           {
;;;1770   
;;;1771               m_pages[page].records_open--;
;;;1772               p_desc->record_is_open = false;
;;;1773   
;;;1774               ret = FDS_SUCCESS;
;;;1775           }
;;;1776           else
;;;1777           {
;;;1778               ret = FDS_ERR_NO_OPEN_RECORDS;
;;;1779           }
;;;1780           CRITICAL_SECTION_EXIT();
;;;1781       }
;;;1782       else
;;;1783       {
;;;1784           ret = FDS_ERR_NOT_FOUND;
;;;1785       }
;;;1786   
;;;1787       return ret;
;;;1788   }
00000a  bd38              POP      {r3-r5,pc}
                  |L14.12|
00000c  4669              MOV      r1,sp                 ;1765
00000e  4620              MOV      r0,r4                 ;1765
000010  f7fffffe          BL       record_find_by_desc
000014  2800              CMP      r0,#0                 ;1765
000016  d01d              BEQ      |L14.84|
000018  4668              MOV      r0,sp                 ;1768
00001a  8800              LDRH     r0,[r0,#0]            ;1768
00001c  0100              LSLS     r0,r0,#4              ;1768
00001e  490f              LDR      r1,|L14.92|
000020  1840              ADDS     r0,r0,r1              ;1768
000022  8980              LDRH     r0,[r0,#0xc]          ;1768
000024  2800              CMP      r0,#0                 ;1768
000026  dd13              BLE      |L14.80|
000028  7aa0              LDRB     r0,[r4,#0xa]          ;1768
00002a  2800              CMP      r0,#0                 ;1768
00002c  d010              BEQ      |L14.80|
00002e  4668              MOV      r0,sp                 ;1771
000030  8800              LDRH     r0,[r0,#0]            ;1771
000032  0100              LSLS     r0,r0,#4              ;1771
000034  1840              ADDS     r0,r0,r1              ;1771
000036  8980              LDRH     r0,[r0,#0xc]          ;1771
000038  1e40              SUBS     r0,r0,#1              ;1771
00003a  b281              UXTH     r1,r0                 ;1771
00003c  4668              MOV      r0,sp                 ;1771
00003e  8800              LDRH     r0,[r0,#0]            ;1771
000040  0100              LSLS     r0,r0,#4              ;1771
000042  4a06              LDR      r2,|L14.92|
000044  1880              ADDS     r0,r0,r2              ;1771
000046  8181              STRH     r1,[r0,#0xc]          ;1771
000048  2000              MOVS     r0,#0                 ;1772
00004a  72a0              STRB     r0,[r4,#0xa]          ;1772
00004c  2500              MOVS     r5,#0                 ;1774
00004e  e002              B        |L14.86|
                  |L14.80|
000050  2506              MOVS     r5,#6                 ;1778
000052  e000              B        |L14.86|
                  |L14.84|
000054  250a              MOVS     r5,#0xa               ;1784
                  |L14.86|
000056  4628              MOV      r0,r5                 ;1787
000058  e7d7              B        |L14.10|
;;;1789   
                          ENDP

00005a  0000              DCW      0x0000
                  |L14.92|
                          DCD      m_pages

                          AREA ||i.fds_record_delete||, CODE, READONLY, ALIGN=1

                  fds_record_delete PROC
;;;1896   
;;;1897   ret_code_t fds_record_delete(fds_record_desc_t * const p_desc)
000000  b510              PUSH     {r4,lr}
;;;1898   {
000002  b088              SUB      sp,sp,#0x20
000004  4604              MOV      r4,r0
;;;1899       fds_op_t op;
;;;1900   
;;;1901       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  2800              CMP      r0,#0
00000e  d102              BNE      |L15.22|
;;;1902       {
;;;1903           return FDS_ERR_NOT_INITIALIZED;
000010  2002              MOVS     r0,#2
                  |L15.18|
;;;1904       }
;;;1905   
;;;1906       if (p_desc == NULL)
;;;1907       {
;;;1908           return FDS_ERR_NULL_ARG;
;;;1909       }
;;;1910   
;;;1911       op.op_code              = FDS_OP_DEL_RECORD;
;;;1912       op.del.step             = FDS_OP_DEL_RECORD_FLAG_DIRTY;
;;;1913       op.del.record_to_delete = p_desc->record_id;
;;;1914   
;;;1915       if (op_enqueue(&op, 0, NULL))
;;;1916       {
;;;1917           queue_start();
;;;1918           return FDS_SUCCESS;
;;;1919       }
;;;1920   
;;;1921      return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1922   }
000012  b008              ADD      sp,sp,#0x20
000014  bd10              POP      {r4,pc}
                  |L15.22|
000016  2c00              CMP      r4,#0                 ;1906
000018  d101              BNE      |L15.30|
00001a  2005              MOVS     r0,#5                 ;1908
00001c  e7f9              B        |L15.18|
                  |L15.30|
00001e  2104              MOVS     r1,#4                 ;1911
000020  4668              MOV      r0,sp                 ;1911
000022  7101              STRB     r1,[r0,#4]            ;1911
000024  2100              MOVS     r1,#0                 ;1912
000026  7201              STRB     r1,[r0,#8]            ;1912
000028  6821              LDR      r1,[r4,#0]            ;1913
00002a  9104              STR      r1,[sp,#0x10]         ;1913
00002c  2200              MOVS     r2,#0                 ;1915
00002e  4611              MOV      r1,r2                 ;1915
000030  a801              ADD      r0,sp,#4              ;1915
000032  f7fffffe          BL       op_enqueue
000036  2800              CMP      r0,#0                 ;1915
000038  d003              BEQ      |L15.66|
00003a  f7fffffe          BL       queue_start
00003e  2000              MOVS     r0,#0                 ;1918
000040  e7e7              B        |L15.18|
                  |L15.66|
000042  2008              MOVS     r0,#8                 ;1921
000044  e7e5              B        |L15.18|
;;;1923   
                          ENDP


                          AREA ||i.fds_record_find||, CODE, READONLY, ALIGN=1

                  fds_record_find PROC
;;;1986   
;;;1987   ret_code_t fds_record_find(uint16_t                  file_id,
000000  b57f              PUSH     {r0-r6,lr}
;;;1988                              uint16_t                  record_key,
;;;1989                              fds_record_desc_t * const p_desc,
;;;1990                              fds_find_token_t  * const p_token)
;;;1991   {
000002  4614              MOV      r4,r2
000004  461d              MOV      r5,r3
;;;1992       return record_find(&file_id, &record_key, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  a901              ADD      r1,sp,#4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       record_find
;;;1993   }
000012  b004              ADD      sp,sp,#0x10
000014  bd70              POP      {r4-r6,pc}
;;;1994   
                          ENDP


                          AREA ||i.fds_record_find_by_key||, CODE, READONLY, ALIGN=1

                  fds_record_find_by_key PROC
;;;1995   
;;;1996   ret_code_t fds_record_find_by_key(uint16_t                  record_key,
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1997                                     fds_record_desc_t * const p_desc,
;;;1998                                     fds_find_token_t  * const p_token)
;;;1999   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2000       return record_find(NULL, &record_key, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       record_find
;;;2001   }
000012  bd3e              POP      {r1-r5,pc}
;;;2002   
                          ENDP


                          AREA ||i.fds_record_find_in_file||, CODE, READONLY, ALIGN=1

                  fds_record_find_in_file PROC
;;;2003   
;;;2004   ret_code_t fds_record_find_in_file(uint16_t                  file_id,
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;2005                                      fds_record_desc_t * const p_desc,
;;;2006                                      fds_find_token_t  * const p_token)
;;;2007   {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;2008       return record_find(&file_id, NULL, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  2100              MOVS     r1,#0
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       record_find
;;;2009   }
000012  bd3e              POP      {r1-r5,pc}
;;;2010   
                          ENDP


                          AREA ||i.fds_record_id_from_desc||, CODE, READONLY, ALIGN=1

                  fds_record_id_from_desc PROC
;;;2027   
;;;2028   ret_code_t fds_record_id_from_desc(fds_record_desc_t const * const p_desc,
000000  4602              MOV      r2,r0
;;;2029                                      uint32_t                * const p_record_id)
;;;2030   {
;;;2031       if ((p_desc == NULL) || (p_record_id == NULL))
000002  2a00              CMP      r2,#0
000004  d001              BEQ      |L19.10|
000006  2900              CMP      r1,#0
000008  d101              BNE      |L19.14|
                  |L19.10|
;;;2032       {
;;;2033           return FDS_ERR_NULL_ARG;
00000a  2005              MOVS     r0,#5
                  |L19.12|
;;;2034       }
;;;2035   
;;;2036       *p_record_id = p_desc->record_id;
;;;2037   
;;;2038       return FDS_SUCCESS;
;;;2039   }
00000c  4770              BX       lr
                  |L19.14|
00000e  6810              LDR      r0,[r2,#0]            ;2036
000010  6008              STR      r0,[r1,#0]            ;2036
000012  2000              MOVS     r0,#0                 ;2038
000014  e7fa              B        |L19.12|
;;;2040   
                          ENDP


                          AREA ||i.fds_record_iterate||, CODE, READONLY, ALIGN=1

                  fds_record_iterate PROC
;;;1979   
;;;1980   ret_code_t fds_record_iterate(fds_record_desc_t * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1981                                 fds_find_token_t  * const p_token)
;;;1982   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1983       return record_find(NULL, NULL, p_desc, p_token);
000006  462b              MOV      r3,r5
000008  4622              MOV      r2,r4
00000a  2100              MOVS     r1,#0
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       record_find
;;;1984   }
000012  bd70              POP      {r4-r6,pc}
;;;1985   
                          ENDP


                          AREA ||i.fds_record_open||, CODE, READONLY, ALIGN=2

                  fds_record_open PROC
;;;1710   
;;;1711   ret_code_t fds_record_open(fds_record_desc_t  * const p_desc,
000000  b538              PUSH     {r3-r5,lr}
;;;1712                              fds_flash_record_t * const p_flash_rec)
;;;1713   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1714       uint16_t page;
;;;1715   
;;;1716       if ((p_desc == NULL) || (p_flash_rec == NULL))
000006  2c00              CMP      r4,#0
000008  d001              BEQ      |L21.14|
00000a  2d00              CMP      r5,#0
00000c  d101              BNE      |L21.18|
                  |L21.14|
;;;1717       {
;;;1718           return FDS_ERR_NULL_ARG;
00000e  2005              MOVS     r0,#5
                  |L21.16|
;;;1719       }
;;;1720   
;;;1721       // Find the record if necessary.
;;;1722       if (record_find_by_desc(p_desc, &page))
;;;1723       {
;;;1724           fds_header_t const * const p_header = (fds_header_t*)p_desc->p_record;
;;;1725   
;;;1726   #if defined(FDS_CRC_ENABLED)
;;;1727           if (!crc_verify_success(p_header->ic.crc16,
;;;1728                                   p_header->tl.length_words,
;;;1729                                   p_desc->p_record))
;;;1730           {
;;;1731               return FDS_ERR_CRC_CHECK_FAILED;
;;;1732           }
;;;1733   #endif
;;;1734   
;;;1735           CRITICAL_SECTION_ENTER();
;;;1736           m_pages[page].records_open++;
;;;1737           CRITICAL_SECTION_EXIT();
;;;1738   
;;;1739           // Initialize p_flash_rec.
;;;1740           p_flash_rec->p_header = p_header;
;;;1741           p_flash_rec->p_data   = (p_desc->p_record + FDS_HEADER_SIZE);
;;;1742   
;;;1743           // Set the record as open in the descriptor.
;;;1744           p_desc->record_is_open = true;
;;;1745   
;;;1746           return FDS_SUCCESS;
;;;1747       }
;;;1748   
;;;1749       // The record could not be found.
;;;1750       // It either never existed or it has been deleted.
;;;1751       return FDS_ERR_NOT_FOUND;
;;;1752   }
000010  bd38              POP      {r3-r5,pc}
                  |L21.18|
000012  4669              MOV      r1,sp                 ;1722
000014  4620              MOV      r0,r4                 ;1722
000016  f7fffffe          BL       record_find_by_desc
00001a  2800              CMP      r0,#0                 ;1722
00001c  d016              BEQ      |L21.76|
00001e  6861              LDR      r1,[r4,#4]            ;1724
000020  4668              MOV      r0,sp                 ;1736
000022  8800              LDRH     r0,[r0,#0]            ;1736
000024  0100              LSLS     r0,r0,#4              ;1736
000026  4a0a              LDR      r2,|L21.80|
000028  1880              ADDS     r0,r0,r2              ;1736
00002a  8980              LDRH     r0,[r0,#0xc]          ;1736
00002c  1c40              ADDS     r0,r0,#1              ;1736
00002e  b282              UXTH     r2,r0                 ;1736
000030  4668              MOV      r0,sp                 ;1736
000032  8800              LDRH     r0,[r0,#0]            ;1736
000034  0100              LSLS     r0,r0,#4              ;1736
000036  4b06              LDR      r3,|L21.80|
000038  18c0              ADDS     r0,r0,r3              ;1736
00003a  8182              STRH     r2,[r0,#0xc]          ;1736
00003c  6029              STR      r1,[r5,#0]            ;1740
00003e  6860              LDR      r0,[r4,#4]            ;1741
000040  300c              ADDS     r0,r0,#0xc            ;1741
000042  6068              STR      r0,[r5,#4]            ;1741
000044  2001              MOVS     r0,#1                 ;1744
000046  72a0              STRB     r0,[r4,#0xa]          ;1744
000048  2000              MOVS     r0,#0                 ;1746
00004a  e7e1              B        |L21.16|
                  |L21.76|
00004c  200a              MOVS     r0,#0xa               ;1751
00004e  e7df              B        |L21.16|
;;;1753   
                          ENDP

                  |L21.80|
                          DCD      m_pages

                          AREA ||i.fds_record_update||, CODE, READONLY, ALIGN=1

                  fds_record_update PROC
;;;1883   
;;;1884   ret_code_t fds_record_update(fds_record_desc_t       * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1885                                fds_record_t      const * const p_record)
;;;1886   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1887       // A NULL descriptor is not allowed when updating a record.
;;;1888       if (p_desc == NULL)
000006  2c00              CMP      r4,#0
000008  d101              BNE      |L22.14|
;;;1889       {
;;;1890           return FDS_ERR_NULL_ARG;
00000a  2005              MOVS     r0,#5
                  |L22.12|
;;;1891       }
;;;1892   
;;;1893       return write_enqueue(p_desc, p_record, NULL, FDS_OP_UPDATE);
;;;1894   }
00000c  bd70              POP      {r4-r6,pc}
                  |L22.14|
00000e  2303              MOVS     r3,#3                 ;1893
000010  2200              MOVS     r2,#0                 ;1893
000012  4629              MOV      r1,r5                 ;1893
000014  4620              MOV      r0,r4                 ;1893
000016  f7fffffe          BL       write_enqueue
00001a  e7f7              B        |L22.12|
;;;1895   
                          ENDP


                          AREA ||i.fds_record_write||, CODE, READONLY, ALIGN=1

                  fds_record_write PROC
;;;1862   
;;;1863   ret_code_t fds_record_write(fds_record_desc_t       * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1864                               fds_record_t      const * const p_record)
;;;1865   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1866       return write_enqueue(p_desc, p_record, NULL, FDS_OP_WRITE);
000006  2302              MOVS     r3,#2
000008  2200              MOVS     r2,#0
00000a  4629              MOV      r1,r5
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       write_enqueue
;;;1867   }
000012  bd70              POP      {r4-r6,pc}
;;;1868   
                          ENDP


                          AREA ||i.fds_record_write_reserved||, CODE, READONLY, ALIGN=1

                  fds_record_write_reserved PROC
;;;1869   
;;;1870   ret_code_t fds_record_write_reserved(fds_record_desc_t         * const p_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1871                                        fds_record_t        const * const p_record,
;;;1872                                        fds_reserve_token_t const * const p_tok)
;;;1873   {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;1874       // A NULL token is not allowed when writing to a reserved space.
;;;1875       if (p_tok == NULL)
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L24.16|
;;;1876       {
;;;1877           return FDS_ERR_NULL_ARG;
00000c  2005              MOVS     r0,#5
                  |L24.14|
;;;1878       }
;;;1879   
;;;1880       return write_enqueue(p_desc, p_record, p_tok, FDS_OP_WRITE);
;;;1881   }
00000e  bd70              POP      {r4-r6,pc}
                  |L24.16|
000010  2302              MOVS     r3,#2                 ;1880
000012  4622              MOV      r2,r4                 ;1880
000014  4631              MOV      r1,r6                 ;1880
000016  4628              MOV      r0,r5                 ;1880
000018  f7fffffe          BL       write_enqueue
00001c  e7f7              B        |L24.14|
;;;1882   
                          ENDP


                          AREA ||i.fds_register||, CODE, READONLY, ALIGN=2

                  fds_register PROC
;;;1611   
;;;1612   ret_code_t fds_register(fds_cb_t cb)
000000  4601              MOV      r1,r0
;;;1613   {
;;;1614       ret_code_t ret;
;;;1615   
;;;1616       CRITICAL_SECTION_ENTER();
;;;1617       if (m_users == FDS_MAX_USERS)
000002  4a09              LDR      r2,|L25.40|
000004  7812              LDRB     r2,[r2,#0]  ; m_users
000006  2a08              CMP      r2,#8
000008  d101              BNE      |L25.14|
;;;1618       {
;;;1619           ret = FDS_ERR_USER_LIMIT_REACHED;
00000a  200c              MOVS     r0,#0xc
00000c  e00a              B        |L25.36|
                  |L25.14|
;;;1620       }
;;;1621       else
;;;1622       {
;;;1623           m_cb_table[m_users] = cb;
00000e  4a06              LDR      r2,|L25.40|
000010  7812              LDRB     r2,[r2,#0]  ; m_users
000012  0092              LSLS     r2,r2,#2
000014  4b05              LDR      r3,|L25.44|
000016  5099              STR      r1,[r3,r2]
;;;1624           m_users++;
000018  4a03              LDR      r2,|L25.40|
00001a  7812              LDRB     r2,[r2,#0]  ; m_users
00001c  1c52              ADDS     r2,r2,#1
00001e  4b02              LDR      r3,|L25.40|
000020  701a              STRB     r2,[r3,#0]
;;;1625   
;;;1626           ret = FDS_SUCCESS;
000022  2000              MOVS     r0,#0
                  |L25.36|
;;;1627       }
;;;1628       CRITICAL_SECTION_EXIT();
;;;1629   
;;;1630       return ret;
;;;1631   }
000024  4770              BX       lr
;;;1632   
                          ENDP

000026  0000              DCW      0x0000
                  |L25.40|
                          DCD      m_users
                  |L25.44|
                          DCD      m_cb_table

                          AREA ||i.fds_reserve||, CODE, READONLY, ALIGN=1

                  fds_reserve PROC
;;;1790   
;;;1791   ret_code_t fds_reserve(fds_reserve_token_t * const p_tok, uint16_t length_words)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1792   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1793       ret_code_t ret;
;;;1794       uint16_t   page;
;;;1795   
;;;1796       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       flag_is_set
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L26.20|
;;;1797       {
;;;1798           return FDS_ERR_NOT_INITIALIZED;
000010  2002              MOVS     r0,#2
                  |L26.18|
;;;1799       }
;;;1800   
;;;1801       if (p_tok == NULL)
;;;1802       {
;;;1803           return FDS_ERR_NULL_ARG;
;;;1804       }
;;;1805   
;;;1806       ret = write_space_reserve(length_words, &page);
;;;1807   
;;;1808       if (ret == FDS_SUCCESS)
;;;1809       {
;;;1810           p_tok->page         = page;
;;;1811           p_tok->length_words = length_words;
;;;1812       }
;;;1813   
;;;1814       return ret;
;;;1815   }
000012  bdf8              POP      {r3-r7,pc}
                  |L26.20|
000014  2c00              CMP      r4,#0                 ;1801
000016  d101              BNE      |L26.28|
000018  2005              MOVS     r0,#5                 ;1803
00001a  e7fa              B        |L26.18|
                  |L26.28|
00001c  4669              MOV      r1,sp                 ;1806
00001e  4628              MOV      r0,r5                 ;1806
000020  f7fffffe          BL       write_space_reserve
000024  4606              MOV      r6,r0                 ;1806
000026  2e00              CMP      r6,#0                 ;1808
000028  d103              BNE      |L26.50|
00002a  4668              MOV      r0,sp                 ;1810
00002c  8800              LDRH     r0,[r0,#0]            ;1810
00002e  8020              STRH     r0,[r4,#0]            ;1810
000030  8065              STRH     r5,[r4,#2]            ;1811
                  |L26.50|
000032  4630              MOV      r0,r6                 ;1814
000034  e7ed              B        |L26.18|
;;;1816   
                          ENDP


                          AREA ||i.fds_reserve_cancel||, CODE, READONLY, ALIGN=2

                  fds_reserve_cancel PROC
;;;1817   
;;;1818   ret_code_t fds_reserve_cancel(fds_reserve_token_t * const p_tok)
000000  b570              PUSH     {r4-r6,lr}
;;;1819   {
000002  4604              MOV      r4,r0
;;;1820       ret_code_t ret;
;;;1821   
;;;1822       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       flag_is_set
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L27.18|
;;;1823       {
;;;1824           return FDS_ERR_NOT_INITIALIZED;
00000e  2002              MOVS     r0,#2
                  |L27.16|
;;;1825       }
;;;1826   
;;;1827       if (p_tok == NULL)
;;;1828       {
;;;1829           return FDS_ERR_NULL_ARG;
;;;1830       }
;;;1831   
;;;1832       if (p_tok->page > FDS_MAX_PAGES)
;;;1833       {
;;;1834           // The page does not exist. This shouldn't happen.
;;;1835           return FDS_ERR_INVALID_ARG;
;;;1836       }
;;;1837   
;;;1838       fds_page_t const * const p_page = &m_pages[p_tok->page];
;;;1839   
;;;1840       CRITICAL_SECTION_ENTER();
;;;1841       if (p_page->words_reserved - (FDS_HEADER_SIZE + p_tok->length_words) >= 0)
;;;1842       {
;;;1843           // Free reserved space.
;;;1844           write_space_free(p_tok->length_words, p_tok->page);
;;;1845   
;;;1846           // Clean the token.
;;;1847           p_tok->page         = 0;
;;;1848           p_tok->length_words = 0;
;;;1849           ret = FDS_SUCCESS;
;;;1850       }
;;;1851       else
;;;1852       {
;;;1853           // We are trying to cancel a reservation of more words than how many are
;;;1854           // currently reserved on the page. Clearly, this shouldn't happen.
;;;1855           ret = FDS_ERR_INVALID_ARG;
;;;1856       }
;;;1857       CRITICAL_SECTION_EXIT();
;;;1858   
;;;1859       return ret;
;;;1860   }
000010  bd70              POP      {r4-r6,pc}
                  |L27.18|
000012  2c00              CMP      r4,#0                 ;1827
000014  d101              BNE      |L27.26|
000016  2005              MOVS     r0,#5                 ;1829
000018  e7fa              B        |L27.16|
                  |L27.26|
00001a  8820              LDRH     r0,[r4,#0]            ;1832
00001c  2802              CMP      r0,#2                 ;1832
00001e  dd01              BLE      |L27.36|
000020  2004              MOVS     r0,#4                 ;1835
000022  e7f5              B        |L27.16|
                  |L27.36|
000024  8820              LDRH     r0,[r4,#0]            ;1838
000026  0100              LSLS     r0,r0,#4              ;1838
000028  4909              LDR      r1,|L27.80|
00002a  1846              ADDS     r6,r0,r1              ;1838
00002c  8971              LDRH     r1,[r6,#0xa]          ;1841
00002e  8860              LDRH     r0,[r4,#2]            ;1841
000030  1cc0              ADDS     r0,r0,#3              ;1841
000032  1a08              SUBS     r0,r1,r0              ;1841
000034  d408              BMI      |L27.72|
000036  8821              LDRH     r1,[r4,#0]            ;1844
000038  8860              LDRH     r0,[r4,#2]            ;1844
00003a  f7fffffe          BL       write_space_free
00003e  2000              MOVS     r0,#0                 ;1847
000040  8020              STRH     r0,[r4,#0]            ;1847
000042  8060              STRH     r0,[r4,#2]            ;1848
000044  2500              MOVS     r5,#0                 ;1849
000046  e000              B        |L27.74|
                  |L27.72|
000048  2504              MOVS     r5,#4                 ;1855
                  |L27.74|
00004a  4628              MOV      r0,r5                 ;1859
00004c  e7e0              B        |L27.16|
;;;1861   
                          ENDP

00004e  0000              DCW      0x0000
                  |L27.80|
                          DCD      m_pages

                          AREA ||i.fds_stat||, CODE, READONLY, ALIGN=2

                  fds_stat PROC
;;;2041   
;;;2042   ret_code_t fds_stat(fds_stat_t * const p_stat)
000000  b5fe              PUSH     {r1-r7,lr}
;;;2043   {
000002  4604              MOV      r4,r0
;;;2044       uint16_t const words_in_page = FDS_PAGE_SIZE;
000004  20ff              MOVS     r0,#0xff
000006  3001              ADDS     r0,#1
000008  9001              STR      r0,[sp,#4]
;;;2045       // The largest number of free contiguous words on any page.
;;;2046       uint16_t       contig_words  = 0;
00000a  2600              MOVS     r6,#0
;;;2047   
;;;2048       if (!flag_is_set(FDS_FLAG_INITIALIZED))
00000c  2002              MOVS     r0,#2
00000e  f7fffffe          BL       flag_is_set
000012  2800              CMP      r0,#0
000014  d101              BNE      |L28.26|
;;;2049       {
;;;2050           return FDS_ERR_NOT_INITIALIZED;
000016  2002              MOVS     r0,#2
                  |L28.24|
;;;2051       }
;;;2052   
;;;2053       if (p_stat == NULL)
;;;2054       {
;;;2055           return FDS_ERR_NULL_ARG;
;;;2056       }
;;;2057   
;;;2058       memset(p_stat, 0x00, sizeof(fds_stat_t));
;;;2059   
;;;2060       for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
;;;2061       {
;;;2062           uint32_t const * p_record   = NULL;
;;;2063           uint16_t const   words_used = m_pages[i].write_offset + m_pages[i].words_reserved;
;;;2064   
;;;2065           p_stat->open_records   += m_pages[i].records_open;
;;;2066           p_stat->words_reserved += m_pages[i].words_reserved;
;;;2067           p_stat->words_used     += words_used;
;;;2068           contig_words           =  (words_in_page - words_used);
;;;2069   
;;;2070           if (contig_words > p_stat->largest_contig)
;;;2071           {
;;;2072               p_stat->largest_contig = contig_words;
;;;2073           }
;;;2074   
;;;2075           while (record_find_next(i, &p_record))
;;;2076           {
;;;2077               p_stat->valid_records++;
;;;2078           }
;;;2079   
;;;2080           dirty_records_stat(i, &p_stat->dirty_records, &p_stat->freeable_words);
;;;2081       }
;;;2082   
;;;2083       return FDS_SUCCESS;
;;;2084   }
000018  bdfe              POP      {r1-r7,pc}
                  |L28.26|
00001a  2c00              CMP      r4,#0                 ;2053
00001c  d101              BNE      |L28.34|
00001e  2005              MOVS     r0,#5                 ;2055
000020  e7fa              B        |L28.24|
                  |L28.34|
000022  210e              MOVS     r1,#0xe               ;2058
000024  4620              MOV      r0,r4                 ;2058
000026  f7fffffe          BL       __aeabi_memclr
00002a  2500              MOVS     r5,#0                 ;2060
00002c  e034              B        |L28.152|
                  |L28.46|
00002e  2000              MOVS     r0,#0                 ;2062
000030  9000              STR      r0,[sp,#0]            ;2062
000032  0128              LSLS     r0,r5,#4              ;2063
000034  491a              LDR      r1,|L28.160|
000036  1840              ADDS     r0,r0,r1              ;2063
000038  8900              LDRH     r0,[r0,#8]            ;2063
00003a  0129              LSLS     r1,r5,#4              ;2063
00003c  4a18              LDR      r2,|L28.160|
00003e  1889              ADDS     r1,r1,r2              ;2063
000040  8949              LDRH     r1,[r1,#0xa]          ;2063
000042  1840              ADDS     r0,r0,r1              ;2063
000044  b287              UXTH     r7,r0                 ;2063
000046  8820              LDRH     r0,[r4,#0]            ;2065
000048  0129              LSLS     r1,r5,#4              ;2065
00004a  1889              ADDS     r1,r1,r2              ;2065
00004c  8989              LDRH     r1,[r1,#0xc]          ;2065
00004e  1840              ADDS     r0,r0,r1              ;2065
000050  8020              STRH     r0,[r4,#0]            ;2065
000052  88e0              LDRH     r0,[r4,#6]            ;2066
000054  0129              LSLS     r1,r5,#4              ;2066
000056  1889              ADDS     r1,r1,r2              ;2066
000058  8949              LDRH     r1,[r1,#0xa]          ;2066
00005a  1840              ADDS     r0,r0,r1              ;2066
00005c  80e0              STRH     r0,[r4,#6]            ;2066
00005e  8920              LDRH     r0,[r4,#8]            ;2067
000060  19c0              ADDS     r0,r0,r7              ;2067
000062  8120              STRH     r0,[r4,#8]            ;2067
000064  20ff              MOVS     r0,#0xff              ;2068
000066  3001              ADDS     r0,#1                 ;2068
000068  1bc0              SUBS     r0,r0,r7              ;2068
00006a  b286              UXTH     r6,r0                 ;2068
00006c  8960              LDRH     r0,[r4,#0xa]          ;2070
00006e  42b0              CMP      r0,r6                 ;2070
000070  da00              BGE      |L28.116|
000072  8166              STRH     r6,[r4,#0xa]          ;2072
                  |L28.116|
000074  e002              B        |L28.124|
                  |L28.118|
000076  8860              LDRH     r0,[r4,#2]            ;2077
000078  1c40              ADDS     r0,r0,#1              ;2077
00007a  8060              STRH     r0,[r4,#2]            ;2077
                  |L28.124|
00007c  4669              MOV      r1,sp                 ;2075
00007e  4628              MOV      r0,r5                 ;2075
000080  f7fffffe          BL       record_find_next
000084  2800              CMP      r0,#0                 ;2075
000086  d1f6              BNE      |L28.118|
000088  4622              MOV      r2,r4                 ;2080
00008a  320c              ADDS     r2,r2,#0xc            ;2080
00008c  1d21              ADDS     r1,r4,#4              ;2080
00008e  4628              MOV      r0,r5                 ;2080
000090  f7fffffe          BL       dirty_records_stat
000094  1c68              ADDS     r0,r5,#1              ;2060
000096  b285              UXTH     r5,r0                 ;2060
                  |L28.152|
000098  2d02              CMP      r5,#2                 ;2060
00009a  dbc8              BLT      |L28.46|
00009c  2000              MOVS     r0,#0                 ;2083
00009e  e7bb              B        |L28.24|
;;;2085   
                          ENDP

                  |L28.160|
                          DCD      m_pages

                          AREA ||i.file_find_and_delete||, CODE, READONLY, ALIGN=2

                  file_find_and_delete PROC
;;;845    // Finds a record within a file and flags it as dirty.
;;;846    static ret_code_t file_find_and_delete(fds_op_t * const p_op)
000000  b53e              PUSH     {r1-r5,lr}
;;;847    {
000002  4604              MOV      r4,r0
;;;848        ret_code_t        ret;
;;;849        fds_record_desc_t desc;
;;;850    
;;;851        // This token must persist across calls.
;;;852        static fds_find_token_t tok = {0};
;;;853    
;;;854        // Pass NULL to ignore the record key.
;;;855        ret = record_find(&p_op->del.file_id, NULL, &desc, &tok);
000004  4b0a              LDR      r3,|L29.48|
000006  466a              MOV      r2,sp
000008  2100              MOVS     r1,#0
00000a  1da0              ADDS     r0,r4,#6
00000c  f7fffffe          BL       record_find
000010  4605              MOV      r5,r0
;;;856    
;;;857        if (ret == FDS_SUCCESS)
000012  2d00              CMP      r5,#0
000014  d106              BNE      |L29.36|
;;;858        {
;;;859             // A record was found: flag it as dirty.
;;;860            ret = record_header_flag_dirty((uint32_t*)desc.p_record, tok.page);
000016  4a06              LDR      r2,|L29.48|
000018  8891              LDRH     r1,[r2,#4]  ; tok
00001a  9801              LDR      r0,[sp,#4]
00001c  f7fffffe          BL       record_header_flag_dirty
000020  4605              MOV      r5,r0
000022  e003              B        |L29.44|
                  |L29.36|
;;;861        }
;;;862        else // FDS_ERR_NOT_FOUND
;;;863        {
;;;864            // No more records were found. Zero the token, so that it can be reused.
;;;865            memset(&tok, 0x00, sizeof(fds_find_token_t));
000024  4802              LDR      r0,|L29.48|
000026  2100              MOVS     r1,#0
000028  6001              STR      r1,[r0,#0]  ; tok
00002a  6041              STR      r1,[r0,#4]  ; tok
                  |L29.44|
;;;866        }
;;;867    
;;;868        return ret;
00002c  4628              MOV      r0,r5
;;;869    }
00002e  bd3e              POP      {r1-r5,pc}
;;;870    
                          ENDP

                  |L29.48|
                          DCD      tok

                          AREA ||i.flag_clear||, CODE, READONLY, ALIGN=2

                  flag_clear PROC
;;;105    
;;;106    static void flag_clear(fds_flags_t flag)
000000  4902              LDR      r1,|L30.12|
;;;107    {
;;;108        CRITICAL_SECTION_ENTER();
;;;109        m_flags &= ~(flag);
000002  7809              LDRB     r1,[r1,#0]  ; m_flags
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L30.12|
000008  7011              STRB     r1,[r2,#0]
;;;110        CRITICAL_SECTION_EXIT();
;;;111    }
00000a  4770              BX       lr
;;;112    
                          ENDP

                  |L30.12|
                          DCD      m_flags

                          AREA ||i.flag_is_set||, CODE, READONLY, ALIGN=2

                  flag_is_set PROC
;;;113    
;;;114    static bool flag_is_set(fds_flags_t flag)
000000  4601              MOV      r1,r0
;;;115    {
;;;116        return (m_flags & flag);
000002  4804              LDR      r0,|L31.20|
000004  7800              LDRB     r0,[r0,#0]  ; m_flags
000006  4008              ANDS     r0,r0,r1
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L31.16|
00000c  2001              MOVS     r0,#1
                  |L31.14|
;;;117    }
00000e  4770              BX       lr
                  |L31.16|
000010  2000              MOVS     r0,#0                 ;116
000012  e7fc              B        |L31.14|
;;;118    
                          ENDP

                  |L31.20|
                          DCD      m_flags

                          AREA ||i.flag_set||, CODE, READONLY, ALIGN=2

                  flag_set PROC
;;;97     
;;;98     static void flag_set(fds_flags_t flag)
000000  4902              LDR      r1,|L32.12|
;;;99     {
;;;100        CRITICAL_SECTION_ENTER();
;;;101        m_flags |= flag;
000002  7809              LDRB     r1,[r1,#0]  ; m_flags
000004  4301              ORRS     r1,r1,r0
000006  4a01              LDR      r2,|L32.12|
000008  7011              STRB     r1,[r2,#0]
;;;102        CRITICAL_SECTION_EXIT();
;;;103    }
00000a  4770              BX       lr
;;;104    
                          ENDP

                  |L32.12|
                          DCD      m_flags

                          AREA ||i.fs_event_handler||, CODE, READONLY, ALIGN=1

                  fs_event_handler PROC
;;;1484   
;;;1485   static void fs_event_handler(fs_evt_t const * const p_evt, fs_ret_t result)
000000  b570              PUSH     {r4-r6,lr}
;;;1486   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1487       queue_process(result);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       queue_process
;;;1488   }
00000c  bd70              POP      {r4-r6,pc}
;;;1489   
                          ENDP


                          AREA ||i.gc_execute||, CODE, READONLY, ALIGN=2

                  gc_execute PROC
;;;1353   
;;;1354   static ret_code_t gc_execute(uint32_t prev_ret)
000000  b570              PUSH     {r4-r6,lr}
;;;1355   {
000002  4605              MOV      r5,r0
;;;1356       ret_code_t ret;
;;;1357   
;;;1358       if (prev_ret != FS_SUCCESS)
000004  2d00              CMP      r5,#0
000006  d001              BEQ      |L34.12|
;;;1359       {
;;;1360           return FDS_ERR_OPERATION_TIMEOUT;
000008  2001              MOVS     r0,#1
                  |L34.10|
;;;1361       }
;;;1362   
;;;1363       if (m_gc.resume)
;;;1364       {
;;;1365           m_gc.resume = false;
;;;1366       }
;;;1367       else
;;;1368       {
;;;1369           gc_state_advance();
;;;1370       }
;;;1371   
;;;1372       switch (m_gc.state)
;;;1373       {
;;;1374           case GC_NEXT_PAGE:
;;;1375               ret = gc_next_page();
;;;1376               break;
;;;1377   
;;;1378           case GC_FIND_NEXT_RECORD:
;;;1379               ret = gc_record_find_next();
;;;1380               break;
;;;1381   
;;;1382           case GC_COPY_RECORD:
;;;1383               ret = gc_record_copy();
;;;1384               break;
;;;1385   
;;;1386           case GC_ERASE_PAGE:
;;;1387               ret = gc_page_erase();
;;;1388               break;
;;;1389   
;;;1390           case GC_PROMOTE_SWAP:
;;;1391               ret = gc_swap_promote();
;;;1392               break;
;;;1393   
;;;1394           case GC_TAG_NEW_SWAP:
;;;1395               ret = gc_tag_new_swap();
;;;1396               break;
;;;1397   
;;;1398           default:
;;;1399               // Should not happen.
;;;1400               ret = FDS_ERR_INTERNAL;
;;;1401               break;
;;;1402       }
;;;1403   
;;;1404       // Either FDS_OP_EXECUTING, FDS_OP_COMPLETED, FDS_ERR_BUSY or FDS_ERR_INTERNAL.
;;;1405       return ret;
;;;1406   }
00000a  bd70              POP      {r4-r6,pc}
                  |L34.12|
00000c  4818              LDR      r0,|L34.112|
00000e  7b00              LDRB     r0,[r0,#0xc]          ;1363  ; m_gc
000010  2800              CMP      r0,#0                 ;1363
000012  d003              BEQ      |L34.28|
000014  2000              MOVS     r0,#0                 ;1365
000016  4916              LDR      r1,|L34.112|
000018  7308              STRB     r0,[r1,#0xc]          ;1365
00001a  e001              B        |L34.32|
                  |L34.28|
00001c  f7fffffe          BL       gc_state_advance
                  |L34.32|
000020  4813              LDR      r0,|L34.112|
000022  7800              LDRB     r0,[r0,#0]            ;1372  ; m_gc
000024  0003              MOVS     r3,r0                 ;1372
000026  f7fffffe          BL       __ARM_common_switch8
00002a  081d              DCB      0x08,0x1d
00002c  05090d11          DCB      0x05,0x09,0x0d,0x11
000030  1d15191d          DCB      0x1d,0x15,0x19,0x1d
000034  f7fffffe          BL       gc_next_page
000038  4604              MOV      r4,r0                 ;1375
00003a  e015              B        |L34.104|
00003c  f7fffffe          BL       gc_record_find_next
000040  4604              MOV      r4,r0                 ;1379
000042  e011              B        |L34.104|
000044  f7fffffe          BL       gc_record_copy
000048  4604              MOV      r4,r0                 ;1383
00004a  e00d              B        |L34.104|
00004c  f7fffffe          BL       gc_page_erase
000050  4604              MOV      r4,r0                 ;1387
000052  e009              B        |L34.104|
000054  f7fffffe          BL       gc_swap_promote
000058  4604              MOV      r4,r0                 ;1391
00005a  e005              B        |L34.104|
00005c  f7fffffe          BL       gc_tag_new_swap
000060  4604              MOV      r4,r0                 ;1395
000062  e001              B        |L34.104|
000064  240f              MOVS     r4,#0xf               ;1400
000066  bf00              NOP                            ;1401
                  |L34.104|
000068  bf00              NOP                            ;1376
00006a  4620              MOV      r0,r4                 ;1405
00006c  e7cd              B        |L34.10|
;;;1407   
                          ENDP

00006e  0000              DCW      0x0000
                  |L34.112|
                          DCD      m_gc

                          AREA ||i.gc_init||, CODE, READONLY, ALIGN=2

                  gc_init PROC
;;;924    
;;;925    static void gc_init(void)
000000  480c              LDR      r0,|L35.52|
;;;926    {
;;;927        m_gc.run_count++;
000002  8900              LDRH     r0,[r0,#8]  ; m_gc
000004  1c40              ADDS     r0,r0,#1
000006  490b              LDR      r1,|L35.52|
000008  8108              STRH     r0,[r1,#8]
;;;928        m_gc.cur_page = 0;
00000a  2000              MOVS     r0,#0
00000c  8048              STRH     r0,[r1,#2]
;;;929        m_gc.resume   = false;
00000e  7308              STRB     r0,[r1,#0xc]
;;;930    
;;;931        // Setup which pages to GC. Defer checking for open records and the can_gc flag,
;;;932        // as other operations might change those while GC is running.
;;;933        for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
000010  bf00              NOP      
000012  e00c              B        |L35.46|
                  |L35.20|
;;;934        {
;;;935            m_gc.do_gc_page[i] = (m_pages[i].page_type == FDS_PAGE_DATA);
000014  0101              LSLS     r1,r0,#4
000016  4a08              LDR      r2,|L35.56|
000018  5c51              LDRB     r1,[r2,r1]
00001a  2900              CMP      r1,#0
00001c  d101              BNE      |L35.34|
00001e  2201              MOVS     r2,#1
000020  e000              B        |L35.36|
                  |L35.34|
000022  2200              MOVS     r2,#0
                  |L35.36|
000024  4903              LDR      r1,|L35.52|
000026  310a              ADDS     r1,r1,#0xa
000028  540a              STRB     r2,[r1,r0]
00002a  1c41              ADDS     r1,r0,#1              ;933
00002c  b288              UXTH     r0,r1                 ;933
                  |L35.46|
00002e  2802              CMP      r0,#2                 ;933
000030  dbf0              BLT      |L35.20|
;;;936        }
;;;937    }
000032  4770              BX       lr
;;;938    
                          ENDP

                  |L35.52|
                          DCD      m_gc
                  |L35.56|
                          DCD      m_pages

                          AREA ||i.gc_next_page||, CODE, READONLY, ALIGN=2

                  gc_next_page PROC
;;;1049   
;;;1050   static ret_code_t gc_next_page(void)
000000  b510              PUSH     {r4,lr}
;;;1051   {
;;;1052       if (!gc_page_next(&m_gc.cur_page))
000002  4807              LDR      r0,|L36.32|
000004  f7fffffe          BL       gc_page_next
000008  2800              CMP      r0,#0
00000a  d106              BNE      |L36.26|
;;;1053       {
;;;1054           // No pages left to GC; GC has terminated. Reset the state.
;;;1055           m_gc.state        = GC_BEGIN;
00000c  4904              LDR      r1,|L36.32|
00000e  1e89              SUBS     r1,r1,#2
000010  7008              STRB     r0,[r1,#0]
;;;1056           m_gc.cur_page     = 0;
000012  8048              STRH     r0,[r1,#2]
;;;1057           m_gc.p_record_src = NULL;
000014  6048              STR      r0,[r1,#4]  ; m_gc
;;;1058   
;;;1059           return FDS_OP_COMPLETED;
000016  4803              LDR      r0,|L36.36|
                  |L36.24|
;;;1060       }
;;;1061   
;;;1062       return gc_record_find_next();
;;;1063   }
000018  bd10              POP      {r4,pc}
                  |L36.26|
00001a  f7fffffe          BL       gc_record_find_next
00001e  e7fb              B        |L36.24|
;;;1064   
                          ENDP

                  |L36.32|
                          DCD      m_gc+0x2
                  |L36.36|
                          DCD      0x00001d1d

                          AREA ||i.gc_page_erase||, CODE, READONLY, ALIGN=2

                  gc_page_erase PROC
;;;977    // records on the page being garbage collected.
;;;978    static ret_code_t gc_page_erase(void)
000000  b570              PUSH     {r4-r6,lr}
;;;979    {
;;;980        uint32_t       ret;
;;;981        uint16_t const gc = m_gc.cur_page;
000002  480d              LDR      r0,|L37.56|
000004  8845              LDRH     r5,[r0,#2]  ; m_gc
;;;982    
;;;983        if (m_pages[gc].records_open == 0)
000006  0128              LSLS     r0,r5,#4
000008  490c              LDR      r1,|L37.60|
00000a  1840              ADDS     r0,r0,r1
00000c  8980              LDRH     r0,[r0,#0xc]
00000e  2800              CMP      r0,#0
000010  d10d              BNE      |L37.46|
;;;984        {
;;;985            ret = fs_erase(&fs_config, m_pages[gc].p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
000012  0128              LSLS     r0,r5,#4
000014  460a              MOV      r2,r1
000016  1880              ADDS     r0,r0,r2
000018  2300              MOVS     r3,#0
00001a  2201              MOVS     r2,#1
00001c  6841              LDR      r1,[r0,#4]
00001e  4808              LDR      r0,|L37.64|
000020  f7fffffe          BL       fs_erase
000024  4604              MOV      r4,r0
;;;986            m_gc.state = GC_ERASE_PAGE;
000026  2004              MOVS     r0,#4
000028  4903              LDR      r1,|L37.56|
00002a  7008              STRB     r0,[r1,#0]
00002c  e002              B        |L37.52|
                  |L37.46|
;;;987        }
;;;988        else
;;;989        {
;;;990            // If there are open records, stop garbage collection on this page.
;;;991            // Discard the swap and try to garbage collect another page.
;;;992            ret = gc_swap_erase();
00002e  f7fffffe          BL       gc_swap_erase
000032  4604              MOV      r4,r0
                  |L37.52|
;;;993        }
;;;994    
;;;995        return ret;
000034  4620              MOV      r0,r4
;;;996    }
000036  bd70              POP      {r4-r6,pc}
;;;997    
                          ENDP

                  |L37.56|
                          DCD      m_gc
                  |L37.60|
                          DCD      m_pages
                  |L37.64|
                          DCD      fs_config

                          AREA ||i.gc_page_next||, CODE, READONLY, ALIGN=2

                  gc_page_next PROC
;;;941    // Returns true if there are pages left to garbage collect, returns false otherwise.
;;;942    static bool gc_page_next(uint16_t * const p_next_page)
000000  b510              PUSH     {r4,lr}
;;;943    {
000002  4601              MOV      r1,r0
;;;944        bool ret = false;
000004  2200              MOVS     r2,#0
;;;945    
;;;946        for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
000006  2000              MOVS     r0,#0
000008  e016              B        |L38.56|
                  |L38.10|
;;;947        {
;;;948            if (m_gc.do_gc_page[i])
00000a  4b0e              LDR      r3,|L38.68|
00000c  5c1b              LDRB     r3,[r3,r0]
00000e  2b00              CMP      r3,#0
000010  d010              BEQ      |L38.52|
;;;949            {
;;;950                // Do not attempt to GC this page again.
;;;951                m_gc.do_gc_page[i] = false;
000012  2400              MOVS     r4,#0
000014  4b0b              LDR      r3,|L38.68|
000016  541c              STRB     r4,[r3,r0]
;;;952    
;;;953                // Only GC pages with no open records and with some records which have been deleted.
;;;954                if ((m_pages[i].records_open == 0) && (m_pages[i].can_gc == true))
000018  0103              LSLS     r3,r0,#4
00001a  4c0b              LDR      r4,|L38.72|
00001c  191b              ADDS     r3,r3,r4
00001e  899b              LDRH     r3,[r3,#0xc]
000020  2b00              CMP      r3,#0
000022  d107              BNE      |L38.52|
000024  0103              LSLS     r3,r0,#4
000026  191b              ADDS     r3,r3,r4
000028  7b9b              LDRB     r3,[r3,#0xe]
00002a  2b01              CMP      r3,#1
00002c  d102              BNE      |L38.52|
;;;955                {
;;;956                    *p_next_page = i;
00002e  8008              STRH     r0,[r1,#0]
;;;957                    ret = true;
000030  2201              MOVS     r2,#1
;;;958                    break;
000032  e003              B        |L38.60|
                  |L38.52|
000034  1c43              ADDS     r3,r0,#1              ;946
000036  b298              UXTH     r0,r3                 ;946
                  |L38.56|
000038  2802              CMP      r0,#2                 ;946
00003a  dbe6              BLT      |L38.10|
                  |L38.60|
00003c  bf00              NOP      
;;;959                }
;;;960            }
;;;961        }
;;;962    
;;;963        return ret;
00003e  4610              MOV      r0,r2
;;;964    }
000040  bd10              POP      {r4,pc}
;;;965    
                          ENDP

000042  0000              DCW      0x0000
                  |L38.68|
                          DCD      m_gc+0xa
                  |L38.72|
                          DCD      m_pages

                          AREA ||i.gc_record_copy||, CODE, READONLY, ALIGN=2

                  gc_record_copy PROC
;;;999    // Copy the current record to swap.
;;;1000   static ret_code_t gc_record_copy(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1001   {
;;;1002       fds_header_t const * const p_header   = (fds_header_t*)m_gc.p_record_src;
000002  480c              LDR      r0,|L39.52|
000004  6844              LDR      r4,[r0,#4]  ; m_gc
;;;1003       uint32_t     const * const p_dest     = m_swap_page.p_addr + m_swap_page.write_offset;
000006  480c              LDR      r0,|L39.56|
000008  6800              LDR      r0,[r0,#0]  ; m_swap_page
00000a  490b              LDR      r1,|L39.56|
00000c  8889              LDRH     r1,[r1,#4]  ; m_swap_page
00000e  0089              LSLS     r1,r1,#2
000010  1845              ADDS     r5,r0,r1
;;;1004       uint16_t     const         record_len = FDS_HEADER_SIZE + p_header->tl.length_words;
000012  8860              LDRH     r0,[r4,#2]
000014  1cc0              ADDS     r0,r0,#3
000016  b286              UXTH     r6,r0
;;;1005   
;;;1006       m_gc.state = GC_COPY_RECORD;
000018  2003              MOVS     r0,#3
00001a  4906              LDR      r1,|L39.52|
00001c  7008              STRB     r0,[r1,#0]
;;;1007   
;;;1008       // Copy the record to swap; it is guaranteed to fit in the destination page,
;;;1009       // so there is no need to check its size. This will either succeed or timeout.
;;;1010       return fs_store(&fs_config, p_dest, m_gc.p_record_src, record_len, NULL);
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
000022  4608              MOV      r0,r1
000024  4633              MOV      r3,r6
000026  4629              MOV      r1,r5
000028  6842              LDR      r2,[r0,#4]  ; m_gc
00002a  4804              LDR      r0,|L39.60|
00002c  f7fffffe          BL       fs_store
;;;1011   }
000030  bdf8              POP      {r3-r7,pc}
;;;1012   
                          ENDP

000032  0000              DCW      0x0000
                  |L39.52|
                          DCD      m_gc
                  |L39.56|
                          DCD      m_swap_page
                  |L39.60|
                          DCD      fs_config

                          AREA ||i.gc_record_find_next||, CODE, READONLY, ALIGN=2

                  gc_record_find_next PROC
;;;1013   
;;;1014   static ret_code_t gc_record_find_next(void)
000000  b510              PUSH     {r4,lr}
;;;1015   {
;;;1016       ret_code_t ret;
;;;1017   
;;;1018       // Find the next valid record to copy.
;;;1019       if (record_find_next(m_gc.cur_page, &m_gc.p_record_src))
000002  4908              LDR      r1,|L40.36|
000004  8848              LDRH     r0,[r1,#2]  ; m_gc
000006  1d09              ADDS     r1,r1,#4
000008  f7fffffe          BL       record_find_next
00000c  2800              CMP      r0,#0
00000e  d003              BEQ      |L40.24|
;;;1020       {
;;;1021           ret = gc_record_copy();
000010  f7fffffe          BL       gc_record_copy
000014  4604              MOV      r4,r0
000016  e002              B        |L40.30|
                  |L40.24|
;;;1022       }
;;;1023       else
;;;1024       {
;;;1025           // No more records left to copy on this page; swap pages.
;;;1026           ret = gc_page_erase();
000018  f7fffffe          BL       gc_page_erase
00001c  4604              MOV      r4,r0
                  |L40.30|
;;;1027       }
;;;1028   
;;;1029       return ret;
00001e  4620              MOV      r0,r4
;;;1030   }
000020  bd10              POP      {r4,pc}
;;;1031   
                          ENDP

000022  0000              DCW      0x0000
                  |L40.36|
                          DCD      m_gc

                          AREA ||i.gc_state_advance||, CODE, READONLY, ALIGN=2

                  gc_state_advance PROC
;;;1090   
;;;1091   static void gc_state_advance(void)
000000  b510              PUSH     {r4,lr}
;;;1092   {
;;;1093       switch (m_gc.state)
000002  4814              LDR      r0,|L41.84|
000004  7800              LDRB     r0,[r0,#0]  ; m_gc
000006  0003              MOVS     r3,r0
000008  f7fffffe          BL       __ARM_common_switch8
00000c  08052020          DCB      0x08,0x05,0x20,0x20
000010  0b111718          DCB      0x0b,0x11,0x17,0x18
000014  1c20              DCB      0x1c,0x20
;;;1094       {
;;;1095           case GC_BEGIN:
;;;1096               gc_init();
000016  f7fffffe          BL       gc_init
;;;1097               m_gc.state = GC_NEXT_PAGE;
00001a  2001              MOVS     r0,#1
00001c  490d              LDR      r1,|L41.84|
00001e  7008              STRB     r0,[r1,#0]
;;;1098               break;
000020  e015              B        |L41.78|
;;;1099   
;;;1100           // A record was successfully copied.
;;;1101           case GC_COPY_RECORD:
;;;1102               gc_update_swap_offset();
000022  f7fffffe          BL       gc_update_swap_offset
;;;1103               m_gc.state = GC_FIND_NEXT_RECORD;
000026  2002              MOVS     r0,#2
000028  490a              LDR      r1,|L41.84|
00002a  7008              STRB     r0,[r1,#0]
;;;1104               break;
00002c  e00f              B        |L41.78|
;;;1105   
;;;1106           // A page was successfully erased. Prepare to promote the swap.
;;;1107           case GC_ERASE_PAGE:
;;;1108               gc_swap_pages();
00002e  f7fffffe          BL       gc_swap_pages
;;;1109               m_gc.state = GC_PROMOTE_SWAP;
000032  2006              MOVS     r0,#6
000034  4907              LDR      r1,|L41.84|
000036  7008              STRB     r0,[r1,#0]
;;;1110               break;
000038  e009              B        |L41.78|
;;;1111   
;;;1112           // Swap was discarded because the page being GC'ed had open records.
;;;1113           case GC_DISCARD_SWAP:
;;;1114           // Swap was sucessfully promoted.
;;;1115           case GC_PROMOTE_SWAP:
00003a  bf00              NOP      
;;;1116               // Prepare to tag the page just GC'ed as swap.
;;;1117               m_gc.state = GC_TAG_NEW_SWAP;
00003c  2007              MOVS     r0,#7
00003e  4905              LDR      r1,|L41.84|
000040  7008              STRB     r0,[r1,#0]
;;;1118               break;
000042  e004              B        |L41.78|
;;;1119   
;;;1120           case GC_TAG_NEW_SWAP:
;;;1121               m_gc.state = GC_NEXT_PAGE;
000044  2001              MOVS     r0,#1
000046  4903              LDR      r1,|L41.84|
000048  7008              STRB     r0,[r1,#0]
;;;1122               break;
00004a  e000              B        |L41.78|
;;;1123   
;;;1124           default:
;;;1125               // Should not happen.
;;;1126               break;
00004c  bf00              NOP      
                  |L41.78|
00004e  bf00              NOP                            ;1098
;;;1127       }
;;;1128   }
000050  bd10              POP      {r4,pc}
;;;1129   
                          ENDP

000052  0000              DCW      0x0000
                  |L41.84|
                          DCD      m_gc

                          AREA ||i.gc_swap_erase||, CODE, READONLY, ALIGN=2

                  gc_swap_erase PROC
;;;966    
;;;967    static ret_code_t gc_swap_erase(void)
000000  b510              PUSH     {r4,lr}
;;;968    {
;;;969        m_gc.state               = GC_DISCARD_SWAP;
000002  2005              MOVS     r0,#5
000004  4906              LDR      r1,|L42.32|
000006  7008              STRB     r0,[r1,#0]
;;;970        m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
000008  2002              MOVS     r0,#2
00000a  4906              LDR      r1,|L42.36|
00000c  8088              STRH     r0,[r1,#4]
;;;971    
;;;972        return fs_erase(&fs_config, m_swap_page.p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
00000e  4608              MOV      r0,r1
000010  2300              MOVS     r3,#0
000012  2201              MOVS     r2,#1
000014  6801              LDR      r1,[r0,#0]  ; m_swap_page
000016  4804              LDR      r0,|L42.40|
000018  f7fffffe          BL       fs_erase
;;;973    }
00001c  bd10              POP      {r4,pc}
;;;974    
                          ENDP

00001e  0000              DCW      0x0000
                  |L42.32|
                          DCD      m_gc
                  |L42.36|
                          DCD      m_swap_page
                  |L42.40|
                          DCD      fs_config

                          AREA ||i.gc_swap_pages||, CODE, READONLY, ALIGN=2

                  gc_swap_pages PROC
;;;1075   
;;;1076   static void gc_swap_pages(void)
000000  490d              LDR      r1,|L43.56|
;;;1077   {
;;;1078       // The page being garbage collected will be the new swap page,
;;;1079       // and the current swap will be used as a data page (promoted).
;;;1080       uint32_t const * const p_addr = m_swap_page.p_addr;
000002  6808              LDR      r0,[r1,#0]  ; m_swap_page
;;;1081   
;;;1082       m_swap_page.p_addr            = m_pages[m_gc.cur_page].p_addr;
000004  490d              LDR      r1,|L43.60|
000006  8849              LDRH     r1,[r1,#2]  ; m_gc
000008  0109              LSLS     r1,r1,#4
00000a  4a0d              LDR      r2,|L43.64|
00000c  1889              ADDS     r1,r1,r2
00000e  6849              LDR      r1,[r1,#4]
000010  4a09              LDR      r2,|L43.56|
000012  6011              STR      r1,[r2,#0]  ; m_swap_page
;;;1083       m_pages[m_gc.cur_page].p_addr = p_addr;
000014  4909              LDR      r1,|L43.60|
000016  8849              LDRH     r1,[r1,#2]  ; m_gc
000018  0109              LSLS     r1,r1,#4
00001a  4a09              LDR      r2,|L43.64|
00001c  1889              ADDS     r1,r1,r2
00001e  6048              STR      r0,[r1,#4]
;;;1084   
;;;1085       // Keep the offset for this page, but reset it for the swap.
;;;1086       m_pages[m_gc.cur_page].write_offset = m_swap_page.write_offset;
000020  4905              LDR      r1,|L43.56|
000022  8889              LDRH     r1,[r1,#4]  ; m_swap_page
000024  4a05              LDR      r2,|L43.60|
000026  8852              LDRH     r2,[r2,#2]  ; m_gc
000028  0112              LSLS     r2,r2,#4
00002a  4b05              LDR      r3,|L43.64|
00002c  18d2              ADDS     r2,r2,r3
00002e  8111              STRH     r1,[r2,#8]
;;;1087       m_swap_page.write_offset            = FDS_PAGE_TAG_SIZE;
000030  2102              MOVS     r1,#2
000032  4a01              LDR      r2,|L43.56|
000034  8091              STRH     r1,[r2,#4]
;;;1088   }
000036  4770              BX       lr
;;;1089   
                          ENDP

                  |L43.56|
                          DCD      m_swap_page
                  |L43.60|
                          DCD      m_gc
                  |L43.64|
                          DCD      m_pages

                          AREA ||i.gc_swap_promote||, CODE, READONLY, ALIGN=2

                  gc_swap_promote PROC
;;;1033   // Promote the swap by tagging it as a data page.
;;;1034   static ret_code_t gc_swap_promote(void)
000000  b510              PUSH     {r4,lr}
;;;1035   {
;;;1036       m_gc.state = GC_PROMOTE_SWAP;
000002  2006              MOVS     r0,#6
000004  4904              LDR      r1,|L44.24|
000006  7008              STRB     r0,[r1,#0]
;;;1037       return page_tag_write_data(m_pages[m_gc.cur_page].p_addr);
000008  8849              LDRH     r1,[r1,#2]  ; m_gc
00000a  0109              LSLS     r1,r1,#4
00000c  4a03              LDR      r2,|L44.28|
00000e  1889              ADDS     r1,r1,r2
000010  6848              LDR      r0,[r1,#4]
000012  f7fffffe          BL       page_tag_write_data
;;;1038   }
000016  bd10              POP      {r4,pc}
;;;1039   
                          ENDP

                  |L44.24|
                          DCD      m_gc
                  |L44.28|
                          DCD      m_pages

                          AREA ||i.gc_tag_new_swap||, CODE, READONLY, ALIGN=2

                  gc_tag_new_swap PROC
;;;1041   // Tag the page just garbage collected as swap.
;;;1042   static ret_code_t gc_tag_new_swap(void)
000000  b510              PUSH     {r4,lr}
;;;1043   {
;;;1044       m_gc.state        = GC_TAG_NEW_SWAP;
000002  2007              MOVS     r0,#7
000004  4903              LDR      r1,|L45.20|
000006  7008              STRB     r0,[r1,#0]
;;;1045       m_gc.p_record_src = NULL;
000008  2000              MOVS     r0,#0
00000a  6048              STR      r0,[r1,#4]  ; m_gc
;;;1046       return page_tag_write_swap();
00000c  f7fffffe          BL       page_tag_write_swap
;;;1047   }
000010  bd10              POP      {r4,pc}
;;;1048   
                          ENDP

000012  0000              DCW      0x0000
                  |L45.20|
                          DCD      m_gc

                          AREA ||i.gc_update_swap_offset||, CODE, READONLY, ALIGN=2

                  gc_update_swap_offset PROC
;;;1066   // Update the swap page offeset after a record has been successfully copied to it.
;;;1067   static void gc_update_swap_offset(void)
000000  4a05              LDR      r2,|L46.24|
;;;1068   {
;;;1069       fds_header_t const * const p_header   = (fds_header_t*)m_gc.p_record_src;
000002  6850              LDR      r0,[r2,#4]  ; m_gc
;;;1070       uint16_t     const         record_len = FDS_HEADER_SIZE + p_header->tl.length_words;
000004  8842              LDRH     r2,[r0,#2]
000006  1cd2              ADDS     r2,r2,#3
000008  b291              UXTH     r1,r2
;;;1071   
;;;1072       m_swap_page.write_offset += record_len;
00000a  4a04              LDR      r2,|L46.28|
00000c  8892              LDRH     r2,[r2,#4]  ; m_swap_page
00000e  1852              ADDS     r2,r2,r1
000010  4b02              LDR      r3,|L46.28|
000012  809a              STRH     r2,[r3,#4]
;;;1073   }
000014  4770              BX       lr
;;;1074   
                          ENDP

000016  0000              DCW      0x0000
                  |L46.24|
                          DCD      m_gc
                  |L46.28|
                          DCD      m_swap_page

                          AREA ||i.header_is_valid||, CODE, READONLY, ALIGN=2

                  header_is_valid PROC
;;;178    
;;;179    static bool header_is_valid(fds_header_t const * const p_header)
000000  4601              MOV      r1,r0
;;;180    {
;;;181        return ((p_header->ic.file_id    != FDS_FILE_ID_INVALID) &&
000002  8888              LDRH     r0,[r1,#4]
000004  4a04              LDR      r2,|L47.24|
000006  4290              CMP      r0,r2
000008  d004              BEQ      |L47.20|
;;;182                (p_header->tl.record_key != FDS_RECORD_KEY_DIRTY));
00000a  8808              LDRH     r0,[r1,#0]
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L47.20|
000010  2001              MOVS     r0,#1
                  |L47.18|
;;;183    }
000012  4770              BX       lr
                  |L47.20|
000014  2000              MOVS     r0,#0                 ;182
000016  e7fc              B        |L47.18|
;;;184    
                          ENDP

                  |L47.24|
                          DCD      0x0000ffff

                          AREA ||i.init_execute||, CODE, READONLY, ALIGN=2

                  init_execute PROC
;;;1131   // Initialize the filesystem.
;;;1132   static ret_code_t init_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1133   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;1134       ret_code_t ret = FDS_ERR_INTERNAL;
000006  200f              MOVS     r0,#0xf
000008  9000              STR      r0,[sp,#0]
;;;1135   
;;;1136       if (prev_ret != FS_SUCCESS)
00000a  2e00              CMP      r6,#0
00000c  d004              BEQ      |L48.24|
;;;1137       {
;;;1138           // A previous operation has timed out.
;;;1139           flag_clear(FDS_FLAG_INITIALIZING);
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       flag_clear
;;;1140           return FDS_ERR_OPERATION_TIMEOUT;
000014  2001              MOVS     r0,#1
                  |L48.22|
;;;1141       }
;;;1142   
;;;1143       switch (p_op->init.step)
;;;1144       {
;;;1145           case FDS_OP_INIT_TAG_SWAP:
;;;1146               // The page write offset was determined previously by pages_init().
;;;1147               ret             = page_tag_write_swap();
;;;1148               p_op->init.step = FDS_OP_INIT_TAG_DATA;
;;;1149               break;
;;;1150   
;;;1151           case FDS_OP_INIT_TAG_DATA:
;;;1152           {
;;;1153               // Tag remaining erased pages as data.
;;;1154               bool write_reqd = false;
;;;1155               for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
;;;1156               {
;;;1157                   if (m_pages[i].page_type == FDS_PAGE_ERASED)
;;;1158                   {
;;;1159                       ret = page_tag_write_data(m_pages[i].p_addr);
;;;1160                       m_pages[i].page_type = FDS_PAGE_DATA;
;;;1161                       write_reqd           = true;
;;;1162                       break;
;;;1163                   }
;;;1164               }
;;;1165               if (!write_reqd)
;;;1166               {
;;;1167                   flag_set(FDS_FLAG_INITIALIZED);
;;;1168                   flag_clear(FDS_FLAG_INITIALIZING);
;;;1169                   return FDS_OP_COMPLETED;
;;;1170               }
;;;1171           }
;;;1172           break;
;;;1173   
;;;1174           case FDS_OP_INIT_ERASE_SWAP:
;;;1175               ret = fs_erase(&fs_config, m_swap_page.p_addr, FDS_PHY_PAGES_IN_VPAGE, NULL);
;;;1176               // If the swap is going to be discarded then reset its write_offset.
;;;1177               m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
;;;1178               p_op->init.step          = FDS_OP_INIT_TAG_SWAP;
;;;1179               break;
;;;1180   
;;;1181           case FDS_OP_INIT_PROMOTE_SWAP:
;;;1182           {
;;;1183               // When promoting the swap, keep the write_offset set by pages_init().
;;;1184               ret = page_tag_write_data(m_swap_page.p_addr);
;;;1185   
;;;1186               uint16_t const         gc         = m_gc.cur_page;
;;;1187               uint32_t const * const p_old_swap = m_swap_page.p_addr;
;;;1188   
;;;1189               // Execute the swap.
;;;1190               m_swap_page.p_addr = m_pages[gc].p_addr;
;;;1191               m_pages[gc].p_addr = p_old_swap;
;;;1192   
;;;1193               // Copy the offset from the swap to the new page.
;;;1194               m_pages[gc].write_offset = m_swap_page.write_offset;
;;;1195               m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
;;;1196   
;;;1197               m_pages[gc].page_type = FDS_PAGE_DATA;
;;;1198               p_op->init.step       = FDS_OP_INIT_TAG_SWAP;
;;;1199           }
;;;1200           break;
;;;1201   
;;;1202           default:
;;;1203               // Should not happen.
;;;1204               break;
;;;1205       }
;;;1206   
;;;1207       if (ret != FDS_SUCCESS)
;;;1208       {
;;;1209           // fstorage queue was full.
;;;1210           flag_clear(FDS_FLAG_INITIALIZING);
;;;1211           return FDS_ERR_BUSY;
;;;1212       }
;;;1213   
;;;1214       return FDS_OP_EXECUTING;
;;;1215   }
000016  bdf8              POP      {r3-r7,pc}
                  |L48.24|
000018  7920              LDRB     r0,[r4,#4]            ;1143
00001a  2800              CMP      r0,#0                 ;1143
00001c  d006              BEQ      |L48.44|
00001e  2801              CMP      r0,#1                 ;1143
000020  d00a              BEQ      |L48.56|
000022  2802              CMP      r0,#2                 ;1143
000024  d02d              BEQ      |L48.130|
000026  2803              CMP      r0,#3                 ;1143
000028  d15a              BNE      |L48.224|
00002a  e038              B        |L48.158|
                  |L48.44|
00002c  f7fffffe          BL       page_tag_write_swap
000030  9000              STR      r0,[sp,#0]            ;1147
000032  2001              MOVS     r0,#1                 ;1148
000034  7120              STRB     r0,[r4,#4]            ;1148
000036  e054              B        |L48.226|
                  |L48.56|
000038  2700              MOVS     r7,#0                 ;1154
00003a  2500              MOVS     r5,#0                 ;1155
00003c  e013              B        |L48.102|
                  |L48.62|
00003e  0128              LSLS     r0,r5,#4              ;1157
000040  492d              LDR      r1,|L48.248|
000042  5c08              LDRB     r0,[r1,r0]            ;1157
000044  2802              CMP      r0,#2                 ;1157
000046  d10c              BNE      |L48.98|
000048  0129              LSLS     r1,r5,#4              ;1159
00004a  4a2b              LDR      r2,|L48.248|
00004c  1889              ADDS     r1,r1,r2              ;1159
00004e  6848              LDR      r0,[r1,#4]            ;1159
000050  f7fffffe          BL       page_tag_write_data
000054  9000              STR      r0,[sp,#0]            ;1159
000056  2000              MOVS     r0,#0                 ;1160
000058  0129              LSLS     r1,r5,#4              ;1160
00005a  4a27              LDR      r2,|L48.248|
00005c  5450              STRB     r0,[r2,r1]            ;1160
00005e  2701              MOVS     r7,#1                 ;1161
000060  e003              B        |L48.106|
                  |L48.98|
000062  1c68              ADDS     r0,r5,#1              ;1155
000064  b285              UXTH     r5,r0                 ;1155
                  |L48.102|
000066  2d02              CMP      r5,#2                 ;1155
000068  dbe9              BLT      |L48.62|
                  |L48.106|
00006a  bf00              NOP                            ;1162
00006c  2f00              CMP      r7,#0                 ;1165
00006e  d107              BNE      |L48.128|
000070  2002              MOVS     r0,#2                 ;1167
000072  f7fffffe          BL       flag_set
000076  2001              MOVS     r0,#1                 ;1168
000078  f7fffffe          BL       flag_clear
00007c  481f              LDR      r0,|L48.252|
00007e  e7ca              B        |L48.22|
                  |L48.128|
000080  e02f              B        |L48.226|
                  |L48.130|
000082  481f              LDR      r0,|L48.256|
000084  2300              MOVS     r3,#0                 ;1175
000086  2201              MOVS     r2,#1                 ;1175
000088  6801              LDR      r1,[r0,#0]            ;1175  ; m_swap_page
00008a  481e              LDR      r0,|L48.260|
00008c  f7fffffe          BL       fs_erase
000090  9000              STR      r0,[sp,#0]            ;1175
000092  2002              MOVS     r0,#2                 ;1177
000094  491a              LDR      r1,|L48.256|
000096  8088              STRH     r0,[r1,#4]            ;1177
000098  2000              MOVS     r0,#0                 ;1178
00009a  7120              STRB     r0,[r4,#4]            ;1178
00009c  e021              B        |L48.226|
                  |L48.158|
00009e  4918              LDR      r1,|L48.256|
0000a0  6808              LDR      r0,[r1,#0]            ;1184  ; m_swap_page
0000a2  f7fffffe          BL       page_tag_write_data
0000a6  9000              STR      r0,[sp,#0]            ;1184
0000a8  4817              LDR      r0,|L48.264|
0000aa  8845              LDRH     r5,[r0,#2]            ;1186  ; m_gc
0000ac  4814              LDR      r0,|L48.256|
0000ae  6807              LDR      r7,[r0,#0]            ;1187  ; m_swap_page
0000b0  0128              LSLS     r0,r5,#4              ;1190
0000b2  4911              LDR      r1,|L48.248|
0000b4  1840              ADDS     r0,r0,r1              ;1190
0000b6  6840              LDR      r0,[r0,#4]            ;1190
0000b8  4911              LDR      r1,|L48.256|
0000ba  6008              STR      r0,[r1,#0]            ;1190  ; m_swap_page
0000bc  0128              LSLS     r0,r5,#4              ;1191
0000be  490e              LDR      r1,|L48.248|
0000c0  1840              ADDS     r0,r0,r1              ;1191
0000c2  6047              STR      r7,[r0,#4]            ;1191
0000c4  480e              LDR      r0,|L48.256|
0000c6  8880              LDRH     r0,[r0,#4]            ;1194  ; m_swap_page
0000c8  0129              LSLS     r1,r5,#4              ;1194
0000ca  4a0b              LDR      r2,|L48.248|
0000cc  1889              ADDS     r1,r1,r2              ;1194
0000ce  8108              STRH     r0,[r1,#8]            ;1194
0000d0  2002              MOVS     r0,#2                 ;1195
0000d2  490b              LDR      r1,|L48.256|
0000d4  8088              STRH     r0,[r1,#4]            ;1195
0000d6  2000              MOVS     r0,#0                 ;1197
0000d8  0129              LSLS     r1,r5,#4              ;1197
0000da  5450              STRB     r0,[r2,r1]            ;1197
0000dc  7120              STRB     r0,[r4,#4]            ;1198
0000de  e000              B        |L48.226|
                  |L48.224|
0000e0  bf00              NOP                            ;1204
                  |L48.226|
0000e2  bf00              NOP                            ;1149
0000e4  9800              LDR      r0,[sp,#0]            ;1207
0000e6  2800              CMP      r0,#0                 ;1207
0000e8  d004              BEQ      |L48.244|
0000ea  2001              MOVS     r0,#1                 ;1210
0000ec  f7fffffe          BL       flag_clear
0000f0  200e              MOVS     r0,#0xe               ;1211
0000f2  e790              B        |L48.22|
                  |L48.244|
0000f4  2000              MOVS     r0,#0                 ;1214
0000f6  e78e              B        |L48.22|
;;;1216   
                          ENDP

                  |L48.248|
                          DCD      m_pages
                  |L48.252|
                          DCD      0x00001d1d
                  |L48.256|
                          DCD      m_swap_page
                  |L48.260|
                          DCD      fs_config
                  |L48.264|
                          DCD      m_gc

                          AREA ||i.is_word_aligned||, CODE, READONLY, ALIGN=1

                  is_word_aligned PROC
;;;985     */
;;;986    static __INLINE bool is_word_aligned(void const* p)
000000  4601              MOV      r1,r0
;;;987    {
;;;988        return (((uintptr_t)p & 0x03) == 0);
000002  0788              LSLS     r0,r1,#30
000004  0f80              LSRS     r0,r0,#30
000006  2800              CMP      r0,#0
000008  d101              BNE      |L49.14|
00000a  2001              MOVS     r0,#1
                  |L49.12|
;;;989    }
00000c  4770              BX       lr
                  |L49.14|
00000e  2000              MOVS     r0,#0                 ;988
000010  e7fc              B        |L49.12|
;;;990    
                          ENDP


                          AREA ||i.op_enqueue||, CODE, READONLY, ALIGN=2

                  op_enqueue PROC
;;;620    // Enqueue an operation.
;;;621    static bool op_enqueue(fds_op_t           const * const p_op,
000000  b5fe              PUSH     {r1-r7,lr}
;;;622                           uint32_t                         num_chunks,
;;;623                           fds_record_chunk_t const * const p_chunk)
;;;624    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4617              MOV      r7,r2
;;;625        uint32_t idx;
;;;626        bool     ret = false;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;627    
;;;628        CRITICAL_SECTION_ENTER();
;;;629        if  ((m_op_queue.count    <= FDS_OP_QUEUE_SIZE - 1) &&
00000c  4820              LDR      r0,|L50.144|
00000e  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000010  2803              CMP      r0,#3
000012  d83b              BHI      |L50.140|
;;;630             (m_chunk_queue.count <= FDS_CHUNK_QUEUE_SIZE - num_chunks))
000014  481f              LDR      r0,|L50.148|
000016  6c40              LDR      r0,[r0,#0x44]  ; m_chunk_queue
000018  2108              MOVS     r1,#8
00001a  1b09              SUBS     r1,r1,r4
00001c  4288              CMP      r0,r1
00001e  d835              BHI      |L50.140|
;;;631        {
;;;632            idx = (m_op_queue.count + m_op_queue.rp) % FDS_OP_QUEUE_SIZE;
000020  481b              LDR      r0,|L50.144|
000022  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000024  491a              LDR      r1,|L50.144|
000026  6f09              LDR      r1,[r1,#0x70]  ; m_op_queue
000028  1840              ADDS     r0,r0,r1
00002a  0785              LSLS     r5,r0,#30
00002c  0fad              LSRS     r5,r5,#30
;;;633    
;;;634            m_op_queue.op[idx] = *p_op;
00002e  211c              MOVS     r1,#0x1c
000030  4369              MULS     r1,r5,r1
000032  4a17              LDR      r2,|L50.144|
000034  1888              ADDS     r0,r1,r2
000036  221c              MOVS     r2,#0x1c
000038  4631              MOV      r1,r6
00003a  f7fffffe          BL       __aeabi_memcpy4
;;;635            m_op_queue.count++;
00003e  4814              LDR      r0,|L50.144|
000040  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000042  1c40              ADDS     r0,r0,#1
000044  4912              LDR      r1,|L50.144|
000046  6748              STR      r0,[r1,#0x74]  ; m_op_queue
;;;636    
;;;637            if (num_chunks != 0)
000048  2c00              CMP      r4,#0
00004a  d01d              BEQ      |L50.136|
;;;638            {
;;;639                idx = (m_chunk_queue.count + m_chunk_queue.rp) % FDS_CHUNK_QUEUE_SIZE;
00004c  4811              LDR      r0,|L50.148|
00004e  6c40              LDR      r0,[r0,#0x44]  ; m_chunk_queue
000050  4910              LDR      r1,|L50.148|
000052  6c09              LDR      r1,[r1,#0x40]  ; m_chunk_queue
000054  1840              ADDS     r0,r0,r1
000056  0745              LSLS     r5,r0,#29
000058  0f6d              LSRS     r5,r5,#29
;;;640    
;;;641                fds_record_chunk_t * p_chunk_dst;
;;;642                p_chunk_dst = &m_chunk_queue.chunk[idx];
00005a  00e8              LSLS     r0,r5,#3
00005c  490d              LDR      r1,|L50.148|
00005e  1840              ADDS     r0,r0,r1
000060  9000              STR      r0,[sp,#0]
;;;643    
;;;644                for (uint32_t i = 0; i < num_chunks; i++)
000062  2300              MOVS     r3,#0
000064  e008              B        |L50.120|
                  |L50.102|
;;;645                {
;;;646                    *p_chunk_dst = p_chunk[i];
000066  00d8              LSLS     r0,r3,#3
000068  19c0              ADDS     r0,r0,r7
00006a  9900              LDR      r1,[sp,#0]
00006c  c805              LDM      r0,{r0,r2}
00006e  c105              STM      r1!,{r0,r2}
;;;647                    chunk_queue_next(&p_chunk_dst);
000070  4668              MOV      r0,sp
000072  f7fffffe          BL       chunk_queue_next
000076  1c5b              ADDS     r3,r3,#1              ;644
                  |L50.120|
000078  42a3              CMP      r3,r4                 ;644
00007a  d3f4              BCC      |L50.102|
;;;648                }
;;;649    
;;;650                m_chunk_queue.count += num_chunks;
00007c  4805              LDR      r0,|L50.148|
00007e  6c40              LDR      r0,[r0,#0x44]  ; m_chunk_queue
000080  1900              ADDS     r0,r0,r4
000082  4904              LDR      r1,|L50.148|
000084  6448              STR      r0,[r1,#0x44]  ; m_chunk_queue
;;;651            }
000086  bf00              NOP      
                  |L50.136|
;;;652    
;;;653            ret = true;
000088  2001              MOVS     r0,#1
00008a  9001              STR      r0,[sp,#4]
                  |L50.140|
;;;654        }
;;;655        CRITICAL_SECTION_EXIT();
;;;656    
;;;657        return ret;
00008c  9801              LDR      r0,[sp,#4]
;;;658    }
00008e  bdfe              POP      {r1-r7,pc}
;;;659    
                          ENDP

                  |L50.144|
                          DCD      m_op_queue
                  |L50.148|
                          DCD      m_chunk_queue

                          AREA ||i.page_from_record||, CODE, READONLY, ALIGN=2

                  page_from_record PROC
;;;254    // Returns FDS_SUCCESS if the page is found, FDS_ERR_NOT_FOUND otherwise.
;;;255    static ret_code_t page_from_record(uint16_t * const p_page, uint32_t const * const p_rec)
000000  b530              PUSH     {r4,r5,lr}
;;;256    {
000002  4602              MOV      r2,r0
;;;257        ret_code_t ret = FDS_ERR_NOT_FOUND;
000004  230a              MOVS     r3,#0xa
;;;258    
;;;259        CRITICAL_SECTION_ENTER();
;;;260        for (uint16_t i = 0; i < FDS_MAX_PAGES; i++)
000006  2000              MOVS     r0,#0
000008  e012              B        |L51.48|
                  |L51.10|
;;;261        {
;;;262            if ((p_rec > m_pages[i].p_addr) &&
00000a  0104              LSLS     r4,r0,#4
00000c  4d0b              LDR      r5,|L51.60|
00000e  1964              ADDS     r4,r4,r5
000010  6864              LDR      r4,[r4,#4]
000012  428c              CMP      r4,r1
000014  d20a              BCS      |L51.44|
;;;263                (p_rec < m_pages[i].p_addr + FDS_PAGE_SIZE))
000016  0104              LSLS     r4,r0,#4
000018  1964              ADDS     r4,r4,r5
00001a  6864              LDR      r4,[r4,#4]
00001c  2501              MOVS     r5,#1
00001e  02ad              LSLS     r5,r5,#10
000020  1964              ADDS     r4,r4,r5
000022  428c              CMP      r4,r1
000024  d902              BLS      |L51.44|
;;;264            {
;;;265                ret     = FDS_SUCCESS;
000026  2300              MOVS     r3,#0
;;;266                *p_page = i;
000028  8010              STRH     r0,[r2,#0]
;;;267                break;
00002a  e003              B        |L51.52|
                  |L51.44|
00002c  1c44              ADDS     r4,r0,#1              ;260
00002e  b2a0              UXTH     r0,r4                 ;260
                  |L51.48|
000030  2802              CMP      r0,#2                 ;260
000032  dbea              BLT      |L51.10|
                  |L51.52|
000034  bf00              NOP      
;;;268            }
;;;269        }
;;;270        CRITICAL_SECTION_EXIT();
;;;271    
;;;272        return ret;
000036  4618              MOV      r0,r3
;;;273    }
000038  bd30              POP      {r4,r5,pc}
;;;274    
                          ENDP

00003a  0000              DCW      0x0000
                  |L51.60|
                          DCD      m_pages

                          AREA ||i.page_has_space||, CODE, READONLY, ALIGN=2

                  page_has_space PROC
;;;244    // NOTE: Must be called from within a critical section.
;;;245    static bool page_has_space(uint16_t page, uint16_t length_words)
000000  4602              MOV      r2,r0
;;;246    {
;;;247        length_words += m_pages[page].write_offset;
000002  0110              LSLS     r0,r2,#4
000004  4b07              LDR      r3,|L52.36|
000006  18c0              ADDS     r0,r0,r3
000008  8900              LDRH     r0,[r0,#8]
00000a  1840              ADDS     r0,r0,r1
00000c  b281              UXTH     r1,r0
;;;248        length_words += m_pages[page].words_reserved;
00000e  0110              LSLS     r0,r2,#4
000010  18c0              ADDS     r0,r0,r3
000012  8940              LDRH     r0,[r0,#0xa]
000014  1840              ADDS     r0,r0,r1
000016  b281              UXTH     r1,r0
;;;249        return (length_words < FDS_PAGE_SIZE);
000018  29ff              CMP      r1,#0xff
00001a  dc01              BGT      |L52.32|
00001c  2001              MOVS     r0,#1
                  |L52.30|
;;;250    }
00001e  4770              BX       lr
                  |L52.32|
000020  2000              MOVS     r0,#0                 ;249
000022  e7fc              B        |L52.30|
;;;251    
                          ENDP

                  |L52.36|
                          DCD      m_pages

                          AREA ||i.page_identify||, CODE, READONLY, ALIGN=2

                  page_identify PROC
;;;208    // Reads a page tag, and determines if the page is used to store data or as swap.
;;;209    static fds_page_type_t page_identify(uint32_t const * const p_page_addr)
000000  4601              MOV      r1,r0
;;;210    {
;;;211        if (p_page_addr[FDS_PAGE_TAG_WORD_0] != FDS_PAGE_TAG_MAGIC)
000002  4a09              LDR      r2,|L53.40|
000004  6808              LDR      r0,[r1,#0]
000006  4290              CMP      r0,r2
000008  d001              BEQ      |L53.14|
;;;212        {
;;;213            return FDS_PAGE_UNDEFINED;
00000a  2003              MOVS     r0,#3
                  |L53.12|
;;;214        }
;;;215    
;;;216        switch (p_page_addr[FDS_PAGE_TAG_WORD_1])
;;;217        {
;;;218            case FDS_PAGE_TAG_SWAP:
;;;219                return FDS_PAGE_SWAP;
;;;220    
;;;221            case FDS_PAGE_TAG_DATA:
;;;222                return FDS_PAGE_DATA;
;;;223    
;;;224            default:
;;;225                return FDS_PAGE_UNDEFINED;
;;;226        }
;;;227    }
00000c  4770              BX       lr
                  |L53.14|
00000e  4a07              LDR      r2,|L53.44|
000010  6848              LDR      r0,[r1,#4]            ;216
000012  1880              ADDS     r0,r0,r2              ;216
000014  2800              CMP      r0,#0                 ;216
000016  d002              BEQ      |L53.30|
000018  2801              CMP      r0,#1                 ;216
00001a  d102              BNE      |L53.34|
00001c  e7f6              B        |L53.12|
                  |L53.30|
00001e  2000              MOVS     r0,#0                 ;222
000020  e7f4              B        |L53.12|
                  |L53.34|
000022  2003              MOVS     r0,#3                 ;225
000024  e7f2              B        |L53.12|
;;;228    
                          ENDP

000026  0000              DCW      0x0000
                  |L53.40|
                          DCD      0xdeadc0de
                  |L53.44|
                          DCD      0x0ee1fe02

                          AREA ||i.page_is_erased||, CODE, READONLY, ALIGN=1

                  page_is_erased PROC
;;;229    
;;;230    static bool page_is_erased(uint32_t const * const p_page_addr)
000000  4602              MOV      r2,r0
;;;231    {
;;;232        for (uint32_t i = 0; i < FDS_PAGE_SIZE; i++)
000002  2100              MOVS     r1,#0
000004  e007              B        |L54.22|
                  |L54.6|
;;;233        {
;;;234            if (*(p_page_addr + i) != FDS_ERASED_WORD)
000006  0088              LSLS     r0,r1,#2
000008  5810              LDR      r0,[r2,r0]
00000a  1c40              ADDS     r0,r0,#1
00000c  2800              CMP      r0,#0
00000e  d001              BEQ      |L54.20|
;;;235            {
;;;236                return false;
000010  2000              MOVS     r0,#0
                  |L54.18|
;;;237            }
;;;238        }
;;;239    
;;;240        return true;
;;;241    }
000012  4770              BX       lr
                  |L54.20|
000014  1c49              ADDS     r1,r1,#1              ;232
                  |L54.22|
000016  29ff              CMP      r1,#0xff              ;232
000018  d9f5              BLS      |L54.6|
00001a  2001              MOVS     r0,#1                 ;240
00001c  e7f9              B        |L54.18|
;;;242    
                          ENDP


                          AREA ||i.page_offsets_update||, CODE, READONLY, ALIGN=1

                  page_offsets_update PROC
;;;319    
;;;320    static void page_offsets_update(fds_page_t * const p_page, uint16_t length_words)
000000  8903              LDRH     r3,[r0,#8]
;;;321    {
;;;322        p_page->write_offset   += (FDS_HEADER_SIZE + length_words);
000002  1cca              ADDS     r2,r1,#3
000004  189a              ADDS     r2,r3,r2
000006  8102              STRH     r2,[r0,#8]
;;;323        p_page->words_reserved -= (FDS_HEADER_SIZE + length_words);
000008  8943              LDRH     r3,[r0,#0xa]
00000a  1cca              ADDS     r2,r1,#3
00000c  1a9a              SUBS     r2,r3,r2
00000e  8142              STRH     r2,[r0,#0xa]
;;;324    }
000010  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.page_scan||, CODE, READONLY, ALIGN=2

                  page_scan PROC
;;;279    // If an invalid record header is found, the can_gc argument is set to true.
;;;280    static void page_scan(uint32_t const *       p_addr,
000000  b5fe              PUSH     {r1-r7,lr}
;;;281                          uint16_t       * const words_written,
;;;282                          bool           * const can_gc)
;;;283    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;284        uint32_t const * const p_end_addr          = p_addr + FDS_PAGE_SIZE;
000008  2001              MOVS     r0,#1
00000a  0280              LSLS     r0,r0,#10
00000c  1820              ADDS     r0,r4,r0
00000e  9001              STR      r0,[sp,#4]
;;;285        bool                   dirty_record_found  = false;
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;286    
;;;287        p_addr         += FDS_PAGE_TAG_SIZE;
000014  3408              ADDS     r4,r4,#8
;;;288        *words_written  = FDS_PAGE_TAG_SIZE;
000016  2002              MOVS     r0,#2
000018  8030              STRH     r0,[r6,#0]
;;;289    
;;;290        while ((p_addr < p_end_addr) && (*p_addr != FDS_ERASED_WORD))
00001a  e01a              B        |L56.82|
                  |L56.28|
;;;291        {
;;;292            // NOTE: Skip records with a dirty key or with a missing file ID.
;;;293            fds_header_t const * const p_header = (fds_header_t*)p_addr;
00001c  4625              MOV      r5,r4
;;;294    
;;;295            if (!header_is_valid(p_header))
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       header_is_valid
000024  2800              CMP      r0,#0
000026  d102              BNE      |L56.46|
;;;296            {
;;;297                dirty_record_found = true;
000028  2001              MOVS     r0,#1
00002a  9000              STR      r0,[sp,#0]
00002c  e007              B        |L56.62|
                  |L56.46|
;;;298            }
;;;299            else
;;;300            {
;;;301                // Update the latest (largest) record ID.
;;;302                if (p_header->record_id > m_latest_rec_id)
00002e  490f              LDR      r1,|L56.108|
000030  68a8              LDR      r0,[r5,#8]
000032  6809              LDR      r1,[r1,#0]  ; m_latest_rec_id
000034  4288              CMP      r0,r1
000036  d902              BLS      |L56.62|
;;;303                {
;;;304                   m_latest_rec_id = p_header->record_id;
000038  490c              LDR      r1,|L56.108|
00003a  68a8              LDR      r0,[r5,#8]
00003c  6008              STR      r0,[r1,#0]  ; m_latest_rec_id
                  |L56.62|
;;;305                }
;;;306            }
;;;307    
;;;308            // Jump to the next record.
;;;309            p_addr         += (FDS_HEADER_SIZE + p_header->tl.length_words);
00003e  8868              LDRH     r0,[r5,#2]
000040  1cc0              ADDS     r0,r0,#3
000042  0080              LSLS     r0,r0,#2
000044  1904              ADDS     r4,r0,r4
;;;310            *words_written += (FDS_HEADER_SIZE + p_header->tl.length_words);
000046  8831              LDRH     r1,[r6,#0]
000048  8868              LDRH     r0,[r5,#2]
00004a  1cc0              ADDS     r0,r0,#3
00004c  1808              ADDS     r0,r1,r0
00004e  8030              STRH     r0,[r6,#0]
;;;311        }
000050  bf00              NOP      
                  |L56.82|
000052  9801              LDR      r0,[sp,#4]            ;290
000054  4284              CMP      r4,r0                 ;290
000056  d203              BCS      |L56.96|
000058  6820              LDR      r0,[r4,#0]            ;290
00005a  1c40              ADDS     r0,r0,#1              ;290
00005c  2800              CMP      r0,#0                 ;290
00005e  d1dd              BNE      |L56.28|
                  |L56.96|
;;;312    
;;;313        if (can_gc != NULL)
000060  2f00              CMP      r7,#0
000062  d001              BEQ      |L56.104|
;;;314        {
;;;315            *can_gc = dirty_record_found;
000064  9800              LDR      r0,[sp,#0]
000066  7038              STRB     r0,[r7,#0]
                  |L56.104|
;;;316        }
;;;317    }
000068  bdfe              POP      {r1-r7,pc}
;;;318    
                          ENDP

00006a  0000              DCW      0x0000
                  |L56.108|
                          DCD      m_latest_rec_id

                          AREA ||i.page_tag_write_data||, CODE, READONLY, ALIGN=2

                  page_tag_write_data PROC
;;;336    // Tags a page as data, i.e, ready for storage.
;;;337    static ret_code_t page_tag_write_data(uint32_t const * const p_page_addr)
000000  b538              PUSH     {r3-r5,lr}
;;;338    {
000002  4604              MOV      r4,r0
;;;339        // Needs to be statically allocated since it will be written to flash.
;;;340        static uint32_t const page_tag_data[] = {FDS_PAGE_TAG_MAGIC, FDS_PAGE_TAG_DATA};
;;;341        return fs_store(&fs_config, p_page_addr, page_tag_data, FDS_PAGE_TAG_SIZE, NULL);
000004  2000              MOVS     r0,#0
000006  2302              MOVS     r3,#2
000008  4a03              LDR      r2,|L57.24|
00000a  4621              MOV      r1,r4
00000c  9000              STR      r0,[sp,#0]
00000e  4803              LDR      r0,|L57.28|
000010  f7fffffe          BL       fs_store
;;;342    }
000014  bd38              POP      {r3-r5,pc}
;;;343    
                          ENDP

000016  0000              DCW      0x0000
                  |L57.24|
                          DCD      page_tag_data
                  |L57.28|
                          DCD      fs_config

                          AREA ||i.page_tag_write_swap||, CODE, READONLY, ALIGN=2

                  page_tag_write_swap PROC
;;;327    // Tags a page as swap, i.e., reserved for GC.
;;;328    static ret_code_t page_tag_write_swap()
000000  b508              PUSH     {r3,lr}
;;;329    {
;;;330        // Needs to be statically allocated since it will be written to flash.
;;;331        static uint32_t const page_tag_swap[] = {FDS_PAGE_TAG_MAGIC, FDS_PAGE_TAG_SWAP};
;;;332        return fs_store(&fs_config, m_swap_page.p_addr, page_tag_swap, FDS_PAGE_TAG_SIZE, NULL);
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
000006  4804              LDR      r0,|L58.24|
000008  2302              MOVS     r3,#2
00000a  4a04              LDR      r2,|L58.28|
00000c  6801              LDR      r1,[r0,#0]  ; m_swap_page
00000e  4804              LDR      r0,|L58.32|
000010  f7fffffe          BL       fs_store
;;;333    }
000014  bd08              POP      {r3,pc}
;;;334    
                          ENDP

000016  0000              DCW      0x0000
                  |L58.24|
                          DCD      m_swap_page
                  |L58.28|
                          DCD      page_tag_swap
                  |L58.32|
                          DCD      fs_config

                          AREA ||i.pages_init||, CODE, READONLY, ALIGN=2

                  pages_init PROC
;;;662    // provide additional information regarding eventual further initialization steps.
;;;663    static fds_init_opts_t pages_init()
000000  b5fe              PUSH     {r1-r7,lr}
;;;664    {
;;;665        uint32_t ret = NO_PAGES;
000002  2600              MOVS     r6,#0
;;;666        // The index of the page being initialized in m_pages[].
;;;667        uint16_t page = 0;
000004  2400              MOVS     r4,#0
;;;668        bool     swap_set_but_not_found  = false;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;669    
;;;670        for (uint16_t i = 0; i < FDS_VIRTUAL_PAGES; i++)
00000a  2700              MOVS     r7,#0
00000c  e079              B        |L59.258|
                  |L59.14|
;;;671        {
;;;672            uint32_t        const * const p_page_addr = fs_config.p_start_addr + (i * FDS_PAGE_SIZE);
00000e  483f              LDR      r0,|L59.268|
000010  6800              LDR      r0,[r0,#0]  ; fs_config
000012  02b9              LSLS     r1,r7,#10
000014  1845              ADDS     r5,r0,r1
;;;673            fds_page_type_t const         page_type   = page_identify(p_page_addr);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       page_identify
00001c  9000              STR      r0,[sp,#0]
;;;674    
;;;675            switch (page_type)
00001e  9800              LDR      r0,[sp,#0]
000020  2800              CMP      r0,#0
000022  d02f              BEQ      |L59.132|
000024  2801              CMP      r0,#1
000026  d046              BEQ      |L59.182|
000028  2803              CMP      r0,#3
00002a  d166              BNE      |L59.250|
;;;676            {
;;;677                case FDS_PAGE_UNDEFINED:
;;;678                    if (page_is_erased(p_page_addr))
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       page_is_erased
000032  2800              CMP      r0,#0
000034  d01e              BEQ      |L59.116|
;;;679                    {
;;;680                        if (m_swap_page.p_addr != NULL)
000036  4836              LDR      r0,|L59.272|
000038  6800              LDR      r0,[r0,#0]  ; m_swap_page
00003a  2800              CMP      r0,#0
00003c  d010              BEQ      |L59.96|
;;;681                        {
;;;682                            // If a swap page is already set, flag the page as erased (in m_pages)
;;;683                            // and try to tag it as data (in flash) later on during initialization.
;;;684                            m_pages[page].page_type    = FDS_PAGE_ERASED;
00003e  2002              MOVS     r0,#2
000040  0121              LSLS     r1,r4,#4
000042  4a34              LDR      r2,|L59.276|
000044  5450              STRB     r0,[r2,r1]
;;;685                            m_pages[page].p_addr       = p_page_addr;
000046  0120              LSLS     r0,r4,#4
000048  4611              MOV      r1,r2
00004a  1840              ADDS     r0,r0,r1
00004c  6045              STR      r5,[r0,#4]
;;;686                            m_pages[page].write_offset = FDS_PAGE_TAG_SIZE;
00004e  2002              MOVS     r0,#2
000050  0121              LSLS     r1,r4,#4
000052  1889              ADDS     r1,r1,r2
000054  8108              STRH     r0,[r1,#8]
;;;687    
;;;688                            // This is a candidate for a potential new swap page, in case the
;;;689                            // current swap is going to be promoted to complete a GC instance.
;;;690                            m_gc.cur_page = page;
000056  4830              LDR      r0,|L59.280|
000058  8044              STRH     r4,[r0,#2]
;;;691                            page++;
00005a  1c60              ADDS     r0,r4,#1
00005c  b284              UXTH     r4,r0
00005e  e006              B        |L59.110|
                  |L59.96|
;;;692                        }
;;;693                        else
;;;694                        {
;;;695                            // If there is no swap page yet, use this one.
;;;696                            m_swap_page.p_addr       = p_page_addr;
000060  482b              LDR      r0,|L59.272|
000062  6005              STR      r5,[r0,#0]  ; m_swap_page
;;;697                            m_swap_page.write_offset = FDS_PAGE_TAG_SIZE;
000064  2002              MOVS     r0,#2
000066  492a              LDR      r1,|L59.272|
000068  8088              STRH     r0,[r1,#4]
;;;698                            swap_set_but_not_found   = true;
00006a  2001              MOVS     r0,#1
00006c  9001              STR      r0,[sp,#4]
                  |L59.110|
;;;699                        }
;;;700    
;;;701                        ret |= PAGE_ERASED;
00006e  2001              MOVS     r0,#1
000070  4306              ORRS     r6,r6,r0
000072  e006              B        |L59.130|
                  |L59.116|
;;;702                    }
;;;703                    else
;;;704                    {
;;;705                        // Do not initialize or use this page.
;;;706                        m_pages[page++].page_type = FDS_PAGE_UNDEFINED;
000074  2203              MOVS     r2,#3
000076  4620              MOV      r0,r4
000078  1c61              ADDS     r1,r4,#1
00007a  b28c              UXTH     r4,r1
00007c  0100              LSLS     r0,r0,#4
00007e  4925              LDR      r1,|L59.276|
000080  540a              STRB     r2,[r1,r0]
                  |L59.130|
;;;707                    }
;;;708                    break;
000082  e03b              B        |L59.252|
                  |L59.132|
;;;709    
;;;710                case FDS_PAGE_DATA:
;;;711                    m_pages[page].page_type = FDS_PAGE_DATA;
000084  2000              MOVS     r0,#0
000086  0121              LSLS     r1,r4,#4
000088  4a22              LDR      r2,|L59.276|
00008a  5450              STRB     r0,[r2,r1]
;;;712                    m_pages[page].p_addr    = p_page_addr;
00008c  0120              LSLS     r0,r4,#4
00008e  4611              MOV      r1,r2
000090  1840              ADDS     r0,r0,r1
000092  6045              STR      r5,[r0,#4]
;;;713                    // Scan the page to compute its write offset and determine whether or not the page
;;;714                    // can be garbage collected. Additionally, update the latest kwown record ID.
;;;715                    page_scan(p_page_addr, &m_pages[page].write_offset, &m_pages[page].can_gc);
000094  0120              LSLS     r0,r4,#4
000096  460b              MOV      r3,r1
000098  18c0              ADDS     r0,r0,r3
00009a  4602              MOV      r2,r0
00009c  320e              ADDS     r2,r2,#0xe
00009e  0120              LSLS     r0,r4,#4
0000a0  18c0              ADDS     r0,r0,r3
0000a2  4601              MOV      r1,r0
0000a4  3108              ADDS     r1,r1,#8
0000a6  4628              MOV      r0,r5
0000a8  f7fffffe          BL       page_scan
;;;716    
;;;717                    ret |= PAGE_DATA;
0000ac  2002              MOVS     r0,#2
0000ae  4306              ORRS     r6,r6,r0
;;;718                    page++;
0000b0  1c60              ADDS     r0,r4,#1
0000b2  b284              UXTH     r4,r0
;;;719    
;;;720                    break;
0000b4  e022              B        |L59.252|
                  |L59.182|
;;;721    
;;;722                case FDS_PAGE_SWAP:
;;;723                    if (swap_set_but_not_found)
0000b6  9801              LDR      r0,[sp,#4]
0000b8  2800              CMP      r0,#0
0000ba  d00e              BEQ      |L59.218|
;;;724                    {
;;;725                        m_pages[page].page_type    = FDS_PAGE_ERASED;
0000bc  2002              MOVS     r0,#2
0000be  0121              LSLS     r1,r4,#4
0000c0  4a14              LDR      r2,|L59.276|
0000c2  5450              STRB     r0,[r2,r1]
;;;726                        m_pages[page].p_addr       = m_swap_page.p_addr;
0000c4  4812              LDR      r0,|L59.272|
0000c6  6800              LDR      r0,[r0,#0]  ; m_swap_page
0000c8  0121              LSLS     r1,r4,#4
0000ca  1889              ADDS     r1,r1,r2
0000cc  6048              STR      r0,[r1,#4]
;;;727                        m_pages[page].write_offset = FDS_PAGE_TAG_SIZE;
0000ce  2002              MOVS     r0,#2
0000d0  0121              LSLS     r1,r4,#4
0000d2  1889              ADDS     r1,r1,r2
0000d4  8108              STRH     r0,[r1,#8]
;;;728    
;;;729                        page++;
0000d6  1c60              ADDS     r0,r4,#1
0000d8  b284              UXTH     r4,r0
                  |L59.218|
;;;730                    }
;;;731    
;;;732                    m_swap_page.p_addr = p_page_addr;
0000da  480d              LDR      r0,|L59.272|
0000dc  6005              STR      r5,[r0,#0]  ; m_swap_page
;;;733                    // If the swap is promoted, this offset should be kept, otherwise,
;;;734                    // it should be set to FDS_PAGE_TAG_SIZE.
;;;735                    page_scan(p_page_addr, &m_swap_page.write_offset, NULL);
0000de  2200              MOVS     r2,#0
0000e0  1d01              ADDS     r1,r0,#4
0000e2  4628              MOV      r0,r5
0000e4  f7fffffe          BL       page_scan
;;;736    
;;;737                    ret |= (m_swap_page.write_offset == FDS_PAGE_TAG_SIZE) ?
0000e8  4809              LDR      r0,|L59.272|
0000ea  8880              LDRH     r0,[r0,#4]  ; m_swap_page
0000ec  2802              CMP      r0,#2
0000ee  d101              BNE      |L59.244|
;;;738                            PAGE_SWAP_CLEAN : PAGE_SWAP_DIRTY;
0000f0  2004              MOVS     r0,#4
0000f2  e000              B        |L59.246|
                  |L59.244|
0000f4  2008              MOVS     r0,#8
                  |L59.246|
0000f6  4306              ORRS     r6,r6,r0
;;;739                    break;
0000f8  e000              B        |L59.252|
                  |L59.250|
;;;740    
;;;741                default:
;;;742                    // Shouldn't happen.
;;;743                    break;
0000fa  bf00              NOP      
                  |L59.252|
0000fc  bf00              NOP                            ;708
0000fe  1c78              ADDS     r0,r7,#1              ;670
000100  b287              UXTH     r7,r0                 ;670
                  |L59.258|
000102  2f03              CMP      r7,#3                 ;670
000104  db83              BLT      |L59.14|
;;;744            }
;;;745        }
;;;746    
;;;747        return (fds_init_opts_t)ret;
000106  b2f0              UXTB     r0,r6
;;;748    }
000108  bdfe              POP      {r1-r7,pc}
;;;749    
                          ENDP

00010a  0000              DCW      0x0000
                  |L59.268|
                          DCD      fs_config
                  |L59.272|
                          DCD      m_swap_page
                  |L59.276|
                          DCD      m_pages
                  |L59.280|
                          DCD      m_gc

                          AREA ||i.queue_advance||, CODE, READONLY, ALIGN=2

                  queue_advance PROC
;;;564    // Returns true if the queue is not empty.
;;;565    static bool queue_advance(void)
000000  b510              PUSH     {r4,lr}
;;;566    {
;;;567        // Reset the current element.
;;;568        memset(&m_op_queue.op[m_op_queue.rp], 0x00, sizeof(fds_op_t));
000002  4910              LDR      r1,|L60.68|
000004  6f09              LDR      r1,[r1,#0x70]  ; m_op_queue
000006  221c              MOVS     r2,#0x1c
000008  4351              MULS     r1,r2,r1
00000a  4a0e              LDR      r2,|L60.68|
00000c  1888              ADDS     r0,r1,r2
00000e  211c              MOVS     r1,#0x1c
000010  f7fffffe          BL       __aeabi_memclr4
;;;569    
;;;570        if (m_op_queue.count != 0)
000014  480b              LDR      r0,|L60.68|
000016  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000018  2800              CMP      r0,#0
00001a  d00a              BEQ      |L60.50|
;;;571        {
;;;572            // Advance in the queue, wrapping around if necessary.
;;;573            m_op_queue.rp = (m_op_queue.rp + 1) % FDS_OP_QUEUE_SIZE;
00001c  4809              LDR      r0,|L60.68|
00001e  6f00              LDR      r0,[r0,#0x70]  ; m_op_queue
000020  1c40              ADDS     r0,r0,#1
000022  0780              LSLS     r0,r0,#30
000024  0f80              LSRS     r0,r0,#30
000026  4907              LDR      r1,|L60.68|
000028  6708              STR      r0,[r1,#0x70]  ; m_op_queue
;;;574            m_op_queue.count--;
00002a  4608              MOV      r0,r1
00002c  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
00002e  1e40              SUBS     r0,r0,#1
000030  6748              STR      r0,[r1,#0x74]  ; m_op_queue
                  |L60.50|
;;;575        }
;;;576    
;;;577        return (m_op_queue.count != 0);
000032  4804              LDR      r0,|L60.68|
000034  6f40              LDR      r0,[r0,#0x74]  ; m_op_queue
000036  2800              CMP      r0,#0
000038  d001              BEQ      |L60.62|
00003a  2001              MOVS     r0,#1
                  |L60.60|
;;;578    }
00003c  bd10              POP      {r4,pc}
                  |L60.62|
00003e  2000              MOVS     r0,#0                 ;577
000040  e7fc              B        |L60.60|
;;;579    
                          ENDP

000042  0000              DCW      0x0000
                  |L60.68|
                          DCD      m_op_queue

                          AREA ||i.queue_process||, CODE, READONLY, ALIGN=2

                  queue_process PROC
;;;1408   
;;;1409   static void queue_process(fs_ret_t result)
000000  b570              PUSH     {r4-r6,lr}
;;;1410   {
000002  b086              SUB      sp,sp,#0x18
000004  4606              MOV      r6,r0
;;;1411       ret_code_t         ret;
;;;1412       fds_op_t   * const p_op = &m_op_queue.op[m_op_queue.rp];
000006  4826              LDR      r0,|L61.160|
000008  6f00              LDR      r0,[r0,#0x70]  ; m_op_queue
00000a  211c              MOVS     r1,#0x1c
00000c  4348              MULS     r0,r1,r0
00000e  4924              LDR      r1,|L61.160|
000010  1845              ADDS     r5,r0,r1
;;;1413   
;;;1414       switch (p_op->op_code)
000012  7828              LDRB     r0,[r5,#0]
000014  0003              MOVS     r3,r0
000016  f7fffffe          BL       __ARM_common_switch8
00001a  071e              DCB      0x07,0x1e
00001c  050b0c12          DCB      0x05,0x0b,0x0c,0x12
000020  13191e00          DCB      0x13,0x19,0x1e,0x00
;;;1415       {
;;;1416           case FDS_OP_INIT:
;;;1417               ret = init_execute(result, p_op);
000024  4629              MOV      r1,r5
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       init_execute
00002c  4604              MOV      r4,r0
;;;1418               break;
00002e  e014              B        |L61.90|
;;;1419   
;;;1420           case FDS_OP_WRITE:
;;;1421           case FDS_OP_UPDATE:
000030  bf00              NOP      
;;;1422               ret = write_execute(result, p_op);
000032  4629              MOV      r1,r5
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       write_execute
00003a  4604              MOV      r4,r0
;;;1423               break;
00003c  e00d              B        |L61.90|
;;;1424   
;;;1425           case FDS_OP_DEL_RECORD:
;;;1426           case FDS_OP_DEL_FILE:
00003e  bf00              NOP      
;;;1427               ret = delete_execute(result, p_op);
000040  4629              MOV      r1,r5
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       delete_execute
000048  4604              MOV      r4,r0
;;;1428               break;
00004a  e006              B        |L61.90|
;;;1429   
;;;1430           case FDS_OP_GC:
;;;1431               ret = gc_execute(result);
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       gc_execute
000052  4604              MOV      r4,r0
;;;1432               break;
000054  e001              B        |L61.90|
;;;1433   
;;;1434           default:
;;;1435               ret = FDS_ERR_INTERNAL;
000056  240f              MOVS     r4,#0xf
;;;1436               break;
000058  bf00              NOP      
                  |L61.90|
00005a  bf00              NOP                            ;1418
;;;1437       }
;;;1438   
;;;1439       if (ret != FDS_OP_EXECUTING)
00005c  2c00              CMP      r4,#0
00005e  d01c              BEQ      |L61.154|
;;;1440       {
;;;1441           fds_evt_t evt;
;;;1442   
;;;1443           if (ret == FDS_OP_COMPLETED)
000060  4810              LDR      r0,|L61.164|
000062  4284              CMP      r4,r0
000064  d102              BNE      |L61.108|
;;;1444           {
;;;1445               evt.result = FDS_SUCCESS;
000066  2000              MOVS     r0,#0
000068  9002              STR      r0,[sp,#8]
00006a  e003              B        |L61.116|
                  |L61.108|
;;;1446           }
;;;1447           else
;;;1448           {
;;;1449               // Either FDS_ERR_BUSY, FDS_ERR_OPERATION_TIMEOUT,
;;;1450               // FDS_ERR_CRC_CHECK_FAILED or FDS_ERR_NOT_FOUND.
;;;1451               evt.result = ret;
00006c  9402              STR      r4,[sp,#8]
;;;1452   
;;;1453               // If this operation had any chunks in the queue, skip them.
;;;1454               chunk_queue_skip(p_op);
00006e  4628              MOV      r0,r5
000070  f7fffffe          BL       chunk_queue_skip
                  |L61.116|
;;;1455           }
;;;1456   
;;;1457           event_prepare(p_op, &evt);
000074  a901              ADD      r1,sp,#4
000076  4628              MOV      r0,r5
000078  f7fffffe          BL       event_prepare
;;;1458           event_send(&evt);
00007c  a801              ADD      r0,sp,#4
00007e  f7fffffe          BL       event_send
;;;1459   
;;;1460           // Advance the queue, and if there are any queued operations, process them.
;;;1461           if (queue_advance())
000082  f7fffffe          BL       queue_advance
000086  2800              CMP      r0,#0
000088  d003              BEQ      |L61.146|
;;;1462           {
;;;1463               queue_process(FS_SUCCESS);
00008a  2000              MOVS     r0,#0
00008c  f7fffffe          BL       queue_process
000090  e002              B        |L61.152|
                  |L61.146|
;;;1464           }
;;;1465           else
;;;1466           {
;;;1467               // No more elements in the queue. Clear the FDS_FLAG_PROCESSING flag,
;;;1468               // so that new operation can start processing the queue.
;;;1469               flag_clear(FDS_FLAG_PROCESSING);
000092  2004              MOVS     r0,#4
000094  f7fffffe          BL       flag_clear
                  |L61.152|
;;;1470           }
;;;1471       }
000098  bf00              NOP      
                  |L61.154|
;;;1472   }
00009a  b006              ADD      sp,sp,#0x18
00009c  bd70              POP      {r4-r6,pc}
;;;1473   
                          ENDP

00009e  0000              DCW      0x0000
                  |L61.160|
                          DCD      m_op_queue
                  |L61.164|
                          DCD      0x00001d1d

                          AREA ||i.queue_start||, CODE, READONLY, ALIGN=1

                  queue_start PROC
;;;1474   
;;;1475   static void queue_start(void)
000000  b510              PUSH     {r4,lr}
;;;1476   {
;;;1477       if (!flag_is_set(FDS_FLAG_PROCESSING))
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       flag_is_set
000008  2800              CMP      r0,#0
00000a  d105              BNE      |L62.24|
;;;1478       {
;;;1479           flag_set(FDS_FLAG_PROCESSING);
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       flag_set
;;;1480           queue_process(FS_SUCCESS);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       queue_process
                  |L62.24|
;;;1481       }
;;;1482   }
000018  bd10              POP      {r4,pc}
;;;1483   
                          ENDP


                          AREA ||i.record_find||, CODE, READONLY, ALIGN=2

                  record_find PROC
;;;478    // If both are NULL, it will iterate through all records.
;;;479    static ret_code_t record_find(uint16_t          const * const p_file_id,
000000  b5f8              PUSH     {r3-r7,lr}
;;;480                                  uint16_t          const * const p_record_key,
;;;481                                  fds_record_desc_t       * const p_desc,
;;;482                                  fds_find_token_t        * const p_token)
;;;483    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461c              MOV      r4,r3
;;;484        if (!flag_is_set(FDS_FLAG_INITIALIZED))
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       flag_is_set
000010  2800              CMP      r0,#0
000012  d101              BNE      |L63.24|
;;;485        {
;;;486            return FDS_ERR_NOT_INITIALIZED;
000014  2002              MOVS     r0,#2
                  |L63.22|
;;;487        }
;;;488    
;;;489        if (p_desc == NULL || p_token == NULL)
;;;490        {
;;;491            return FDS_ERR_NULL_ARG;
;;;492        }
;;;493    
;;;494        // Begin (or resume) searching for a record.
;;;495        for (; p_token->page < FDS_MAX_PAGES; p_token->page++)
;;;496        {
;;;497            if (m_pages[p_token->page].page_type != FDS_PAGE_DATA)
;;;498            {
;;;499                // Skip this page.
;;;500                continue;
;;;501            }
;;;502    
;;;503            while (record_find_next(p_token->page, &p_token->p_addr))
;;;504            {
;;;505                fds_header_t const * const p_header = (fds_header_t*)p_token->p_addr;
;;;506    
;;;507                // A valid record was found, check its header for a match.
;;;508                if ((p_file_id != NULL) &&
;;;509                    (p_header->ic.file_id != *p_file_id))
;;;510                {
;;;511                    continue;
;;;512                }
;;;513    
;;;514                if ((p_record_key != NULL) &&
;;;515                    (p_header->tl.record_key != *p_record_key))
;;;516                {
;;;517                    continue;
;;;518                }
;;;519    
;;;520                // Record found; update the descriptor.
;;;521                p_desc->record_id    = p_header->record_id;
;;;522                p_desc->p_record     = p_token->p_addr;
;;;523                p_desc->gc_run_count = m_gc.run_count;
;;;524    
;;;525                return FDS_SUCCESS;
;;;526            }
;;;527    
;;;528            // We have scanned an entire page. Set the address in the token to NULL
;;;529            // so that it will be updated in the next iteration.
;;;530            p_token->p_addr = NULL;
;;;531        }
;;;532    
;;;533        return FDS_ERR_NOT_FOUND;
;;;534    }
000016  bdf8              POP      {r3-r7,pc}
                  |L63.24|
000018  2d00              CMP      r5,#0                 ;489
00001a  d001              BEQ      |L63.32|
00001c  2c00              CMP      r4,#0                 ;489
00001e  d101              BNE      |L63.36|
                  |L63.32|
000020  2005              MOVS     r0,#5                 ;491
000022  e7f8              B        |L63.22|
                  |L63.36|
000024  e02a              B        |L63.124|
                  |L63.38|
000026  88a0              LDRH     r0,[r4,#4]            ;497
000028  0100              LSLS     r0,r0,#4              ;497
00002a  4917              LDR      r1,|L63.136|
00002c  5c08              LDRB     r0,[r1,r0]            ;497
00002e  2800              CMP      r0,#0                 ;497
000030  d000              BEQ      |L63.52|
000032  e020              B        |L63.118|
                  |L63.52|
000034  e017              B        |L63.102|
                  |L63.54|
000036  6821              LDR      r1,[r4,#0]            ;505
000038  2e00              CMP      r6,#0                 ;508
00003a  d004              BEQ      |L63.70|
00003c  8888              LDRH     r0,[r1,#4]            ;509
00003e  8832              LDRH     r2,[r6,#0]            ;509
000040  4290              CMP      r0,r2                 ;509
000042  d000              BEQ      |L63.70|
000044  e00f              B        |L63.102|
                  |L63.70|
000046  2f00              CMP      r7,#0                 ;514
000048  d004              BEQ      |L63.84|
00004a  8808              LDRH     r0,[r1,#0]            ;515
00004c  883a              LDRH     r2,[r7,#0]            ;515
00004e  4290              CMP      r0,r2                 ;515
000050  d000              BEQ      |L63.84|
000052  e008              B        |L63.102|
                  |L63.84|
000054  6888              LDR      r0,[r1,#8]            ;521
000056  6028              STR      r0,[r5,#0]            ;521
000058  6820              LDR      r0,[r4,#0]            ;522
00005a  6068              STR      r0,[r5,#4]            ;522
00005c  480b              LDR      r0,|L63.140|
00005e  8900              LDRH     r0,[r0,#8]            ;523  ; m_gc
000060  8128              STRH     r0,[r5,#8]            ;523
000062  2000              MOVS     r0,#0                 ;525
000064  e7d7              B        |L63.22|
                  |L63.102|
000066  88a0              LDRH     r0,[r4,#4]            ;503
000068  4621              MOV      r1,r4                 ;503
00006a  f7fffffe          BL       record_find_next
00006e  2800              CMP      r0,#0                 ;503
000070  d1e1              BNE      |L63.54|
000072  6020              STR      r0,[r4,#0]            ;530
000074  bf00              NOP                            ;500
                  |L63.118|
000076  88a0              LDRH     r0,[r4,#4]            ;495
000078  1c40              ADDS     r0,r0,#1              ;495
00007a  80a0              STRH     r0,[r4,#4]            ;495
                  |L63.124|
00007c  88a0              LDRH     r0,[r4,#4]            ;495
00007e  2802              CMP      r0,#2                 ;495
000080  dbd1              BLT      |L63.38|
000082  200a              MOVS     r0,#0xa               ;533
000084  e7c7              B        |L63.22|
;;;535    
                          ENDP

000086  0000              DCW      0x0000
                  |L63.136|
                          DCD      m_pages
                  |L63.140|
                          DCD      m_gc

                          AREA ||i.record_find_and_delete||, CODE, READONLY, ALIGN=1

                  record_find_and_delete PROC
;;;811    
;;;812    static ret_code_t record_find_and_delete(fds_op_t * const p_op)
000000  b57f              PUSH     {r0-r6,lr}
;;;813    {
000002  4604              MOV      r4,r0
;;;814        ret_code_t        ret;
;;;815        uint16_t          page;
;;;816        fds_record_desc_t desc = {0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
;;;817    
;;;818        desc.record_id = p_op->del.record_to_delete;
00000c  68e0              LDR      r0,[r4,#0xc]
00000e  9000              STR      r0,[sp,#0]
;;;819    
;;;820        if (record_find_by_desc(&desc, &page))
000010  a903              ADD      r1,sp,#0xc
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       record_find_by_desc
000018  2800              CMP      r0,#0
00001a  d00b              BEQ      |L64.52|
;;;821        {
;;;822            fds_header_t const * const p_header = (fds_header_t const *)desc.p_record;
00001c  9e01              LDR      r6,[sp,#4]
;;;823    
;;;824            // Copy the record key and file ID, so that they can be returned in the event.
;;;825            // In case this function is run as part of an update, there is no need to copy
;;;826            // the file ID and record key since they are present in the header stored
;;;827            // in the queue element.
;;;828    
;;;829            p_op->del.file_id    = p_header->ic.file_id;
00001e  88b1              LDRH     r1,[r6,#4]
000020  80e1              STRH     r1,[r4,#6]
;;;830            p_op->del.record_key = p_header->tl.record_key;
000022  8831              LDRH     r1,[r6,#0]
000024  8121              STRH     r1,[r4,#8]
;;;831    
;;;832            // Flag the record as dirty.
;;;833            ret = record_header_flag_dirty((uint32_t*)desc.p_record, page);
000026  4669              MOV      r1,sp
000028  8989              LDRH     r1,[r1,#0xc]
00002a  9801              LDR      r0,[sp,#4]
00002c  f7fffffe          BL       record_header_flag_dirty
000030  4605              MOV      r5,r0
;;;834        }
000032  e000              B        |L64.54|
                  |L64.52|
;;;835        else
;;;836        {
;;;837            // The record never existed, or it has already been deleted.
;;;838            ret = FDS_ERR_NOT_FOUND;
000034  250a              MOVS     r5,#0xa
                  |L64.54|
;;;839        }
;;;840    
;;;841        return ret;
000036  4628              MOV      r0,r5
;;;842    }
000038  b004              ADD      sp,sp,#0x10
00003a  bd70              POP      {r4-r6,pc}
;;;843    
                          ENDP


                          AREA ||i.record_find_by_desc||, CODE, READONLY, ALIGN=2

                  record_find_by_desc PROC
;;;439    // NOTE: Do not pass NULL as an argument for p_page.
;;;440    static bool record_find_by_desc(fds_record_desc_t * const p_desc, uint16_t * const p_page)
000000  b538              PUSH     {r3-r5,lr}
;;;441    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;442        // If the gc_run_count field in the descriptor matches our counter, then the record has
;;;443        // not been moved. If the address is valid, and the record ID matches, there is no need
;;;444        // to find the record again. Only lookup the page in which the record is stored.
;;;445    
;;;446        if ((address_is_valid(p_desc->p_record))     &&
000006  6860              LDR      r0,[r4,#4]
000008  f7fffffe          BL       address_is_valid
00000c  2800              CMP      r0,#0
00000e  d013              BEQ      |L65.56|
;;;447            (p_desc->gc_run_count == m_gc.run_count) &&
000010  8920              LDRH     r0,[r4,#8]
000012  491a              LDR      r1,|L65.124|
000014  8909              LDRH     r1,[r1,#8]  ; m_gc
000016  4288              CMP      r0,r1
000018  d10e              BNE      |L65.56|
;;;448            (p_desc->record_id    == ((fds_header_t*)p_desc->p_record)->record_id))
00001a  6861              LDR      r1,[r4,#4]
00001c  6820              LDR      r0,[r4,#0]
00001e  6889              LDR      r1,[r1,#8]
000020  4288              CMP      r0,r1
000022  d109              BNE      |L65.56|
;;;449        {
;;;450            return (page_from_record(p_page, p_desc->p_record) == FDS_SUCCESS);
000024  4628              MOV      r0,r5
000026  6861              LDR      r1,[r4,#4]
000028  f7fffffe          BL       page_from_record
00002c  2800              CMP      r0,#0
00002e  d101              BNE      |L65.52|
000030  2001              MOVS     r0,#1
                  |L65.50|
;;;451        }
;;;452    
;;;453        // Otherwise, find the record in flash.
;;;454        for (*p_page = 0; *p_page < FDS_MAX_PAGES; (*p_page)++)
;;;455        {
;;;456            // Set p_record to NULL to make record_find_next() search from the beginning of the page.
;;;457            uint32_t const * p_record = NULL;
;;;458    
;;;459            while (record_find_next(*p_page, &p_record))
;;;460            {
;;;461                fds_header_t const * const p_header = (fds_header_t*)p_record;
;;;462                if (p_header->record_id == p_desc->record_id)
;;;463                {
;;;464                    p_desc->p_record     = p_record;
;;;465                    p_desc->gc_run_count = m_gc.run_count;
;;;466                    return true;
;;;467                }
;;;468            }
;;;469        }
;;;470    
;;;471        return false;
;;;472    }
000032  bd38              POP      {r3-r5,pc}
                  |L65.52|
000034  2000              MOVS     r0,#0                 ;450
000036  e7fc              B        |L65.50|
                  |L65.56|
000038  2000              MOVS     r0,#0                 ;454
00003a  8028              STRH     r0,[r5,#0]            ;454
00003c  e018              B        |L65.112|
                  |L65.62|
00003e  2000              MOVS     r0,#0                 ;457
000040  9000              STR      r0,[sp,#0]            ;457
000042  e00c              B        |L65.94|
                  |L65.68|
000044  9900              LDR      r1,[sp,#0]            ;461
000046  6888              LDR      r0,[r1,#8]            ;462
000048  6822              LDR      r2,[r4,#0]            ;462
00004a  4290              CMP      r0,r2                 ;462
00004c  d106              BNE      |L65.92|
00004e  9800              LDR      r0,[sp,#0]            ;464
000050  6060              STR      r0,[r4,#4]            ;464
000052  480a              LDR      r0,|L65.124|
000054  8900              LDRH     r0,[r0,#8]            ;465  ; m_gc
000056  8120              STRH     r0,[r4,#8]            ;465
000058  2001              MOVS     r0,#1                 ;466
00005a  e7ea              B        |L65.50|
                  |L65.92|
00005c  bf00              NOP                            ;468
                  |L65.94|
00005e  8828              LDRH     r0,[r5,#0]            ;459
000060  4669              MOV      r1,sp                 ;459
000062  f7fffffe          BL       record_find_next
000066  2800              CMP      r0,#0                 ;459
000068  d1ec              BNE      |L65.68|
00006a  8828              LDRH     r0,[r5,#0]            ;454
00006c  1c40              ADDS     r0,r0,#1              ;454
00006e  8028              STRH     r0,[r5,#0]            ;454
                  |L65.112|
000070  8828              LDRH     r0,[r5,#0]            ;454
000072  2802              CMP      r0,#2                 ;454
000074  dbe3              BLT      |L65.62|
000076  2000              MOVS     r0,#0                 ;471
000078  e7db              B        |L65.50|
;;;473    
                          ENDP

00007a  0000              DCW      0x0000
                  |L65.124|
                          DCD      m_gc

                          AREA ||i.record_find_next||, CODE, READONLY, ALIGN=2

                  record_find_next PROC
;;;396    // If no record is found, p_record is unchanged.
;;;397    static bool record_find_next(uint16_t page, uint32_t const ** p_record)
000000  b5f8              PUSH     {r3-r7,lr}
;;;398    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;399        fds_header_t const * p_header;
;;;400        uint32_t     const * p_next_rec = (*p_record);
000006  683c              LDR      r4,[r7,#0]
;;;401    
;;;402        // If this is not the first invocation on this page, then jump to the next record.
;;;403        // Otherwise, start searching from the beginning of the page.
;;;404        if (p_next_rec != NULL)
000008  2c00              CMP      r4,#0
00000a  d005              BEQ      |L66.24|
;;;405        {
;;;406            p_header    = ((fds_header_t*)p_next_rec);
00000c  4625              MOV      r5,r4
;;;407            p_next_rec += (FDS_HEADER_SIZE + p_header->tl.length_words);
00000e  8868              LDRH     r0,[r5,#2]
000010  1cc0              ADDS     r0,r0,#3
000012  0080              LSLS     r0,r0,#2
000014  1904              ADDS     r4,r0,r4
000016  e005              B        |L66.36|
                  |L66.24|
;;;408        }
;;;409        else
;;;410        {
;;;411            p_next_rec = m_pages[page].p_addr + FDS_PAGE_TAG_SIZE;
000018  0130              LSLS     r0,r6,#4
00001a  4911              LDR      r1,|L66.96|
00001c  1840              ADDS     r0,r0,r1
00001e  6840              LDR      r0,[r0,#4]
000020  4604              MOV      r4,r0
000022  3408              ADDS     r4,r4,#8
                  |L66.36|
;;;412        }
;;;413    
;;;414        // Read records from the page, until a valid record is found or the end of the page is
;;;415        // reached. The argument p_record is only updated if a valid record is found.
;;;416        while ((p_next_rec < (m_pages[page].p_addr + FDS_PAGE_SIZE) &&
000024  e00c              B        |L66.64|
                  |L66.38|
;;;417               *p_next_rec != FDS_ERASED_WORD))
;;;418        {
;;;419            p_header = (fds_header_t*)p_next_rec;
000026  4625              MOV      r5,r4
;;;420    
;;;421            if (header_is_valid(p_header))
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       header_is_valid
00002e  2800              CMP      r0,#0
000030  d002              BEQ      |L66.56|
;;;422            {
;;;423                *p_record = p_next_rec;
000032  603c              STR      r4,[r7,#0]
;;;424                return true;
000034  2001              MOVS     r0,#1
                  |L66.54|
;;;425            }
;;;426            else
;;;427            {
;;;428                // The record is not valid, jump to the next.
;;;429                p_next_rec += (FDS_HEADER_SIZE + (p_header->tl.length_words));
;;;430            }
;;;431        }
;;;432    
;;;433        // No more valid records on this page.
;;;434        return false;
;;;435    }
000036  bdf8              POP      {r3-r7,pc}
                  |L66.56|
000038  8868              LDRH     r0,[r5,#2]            ;429
00003a  1cc0              ADDS     r0,r0,#3              ;429
00003c  0080              LSLS     r0,r0,#2              ;429
00003e  1904              ADDS     r4,r0,r4              ;429
                  |L66.64|
000040  0130              LSLS     r0,r6,#4              ;416
000042  4907              LDR      r1,|L66.96|
000044  1840              ADDS     r0,r0,r1              ;416
000046  6840              LDR      r0,[r0,#4]            ;416
000048  2101              MOVS     r1,#1                 ;416
00004a  0289              LSLS     r1,r1,#10             ;416
00004c  1840              ADDS     r0,r0,r1              ;416
00004e  42a0              CMP      r0,r4                 ;416
000050  d903              BLS      |L66.90|
000052  6820              LDR      r0,[r4,#0]            ;417
000054  1c40              ADDS     r0,r0,#1              ;417
000056  2800              CMP      r0,#0                 ;417
000058  d1e5              BNE      |L66.38|
                  |L66.90|
00005a  2000              MOVS     r0,#0                 ;434
00005c  e7eb              B        |L66.54|
;;;436    
                          ENDP

00005e  0000              DCW      0x0000
                  |L66.96|
                          DCD      m_pages

                          AREA ||i.record_header_flag_dirty||, CODE, READONLY, ALIGN=2

                  record_header_flag_dirty PROC
;;;794    
;;;795    static ret_code_t record_header_flag_dirty(uint32_t * const p_record, uint16_t page_to_gc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;796    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;797        // Flag the record as dirty.
;;;798        fs_ret_t ret = fs_store(&fs_config, p_record,
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  4a09              LDR      r2,|L67.48|
00000c  4621              MOV      r1,r4
00000e  9000              STR      r0,[sp,#0]
000010  4808              LDR      r0,|L67.52|
000012  f7fffffe          BL       fs_store
000016  4606              MOV      r6,r0
;;;799                                (uint32_t*)&m_fds_tl_dirty, FDS_HEADER_SIZE_TL, NULL);
;;;800    
;;;801        if (ret != FS_SUCCESS)
000018  2e00              CMP      r6,#0
00001a  d001              BEQ      |L67.32|
;;;802        {
;;;803            return FDS_ERR_BUSY;
00001c  200e              MOVS     r0,#0xe
                  |L67.30|
;;;804        }
;;;805    
;;;806        m_pages[page_to_gc].can_gc = true;
;;;807    
;;;808        return FDS_SUCCESS;
;;;809    }
00001e  bdf8              POP      {r3-r7,pc}
                  |L67.32|
000020  2001              MOVS     r0,#1                 ;806
000022  0129              LSLS     r1,r5,#4              ;806
000024  4a04              LDR      r2,|L67.56|
000026  1889              ADDS     r1,r1,r2              ;806
000028  7388              STRB     r0,[r1,#0xe]          ;806
00002a  2000              MOVS     r0,#0                 ;808
00002c  e7f7              B        |L67.30|
;;;810    
                          ENDP

00002e  0000              DCW      0x0000
                  |L67.48|
                          DCD      m_fds_tl_dirty
                  |L67.52|
                          DCD      fs_config
                  |L67.56|
                          DCD      m_pages

                          AREA ||i.record_header_write_begin||, CODE, READONLY, ALIGN=2

                  record_header_write_begin PROC
;;;751    // Write the first part of a record header (the key and length).
;;;752    static ret_code_t record_header_write_begin(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;753    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;754        ret_code_t ret;
;;;755        ret = fs_store(&fs_config, p_addr + FDS_OFFSET_TL,
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  1d22              ADDS     r2,r4,#4
00000c  4629              MOV      r1,r5
00000e  9000              STR      r0,[sp,#0]
000010  4805              LDR      r0,|L68.40|
000012  f7fffffe          BL       fs_store
000016  4606              MOV      r6,r0
;;;756                      (uint32_t*)&p_op->write.header.tl, FDS_HEADER_SIZE_TL, NULL);
;;;757    
;;;758        // Write the record ID next.
;;;759        p_op->write.step = FDS_OP_WRITE_RECORD_ID;
000018  2102              MOVS     r1,#2
00001a  7421              STRB     r1,[r4,#0x10]
;;;760    
;;;761        return (ret == FS_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
00001c  2e00              CMP      r6,#0
00001e  d100              BNE      |L68.34|
                  |L68.32|
;;;762    }
000020  bdf8              POP      {r3-r7,pc}
                  |L68.34|
000022  200e              MOVS     r0,#0xe               ;761
000024  e7fc              B        |L68.32|
;;;763    
                          ENDP

000026  0000              DCW      0x0000
                  |L68.40|
                          DCD      fs_config

                          AREA ||i.record_header_write_finalize||, CODE, READONLY, ALIGN=2

                  record_header_write_finalize PROC
;;;779    
;;;780    static ret_code_t record_header_write_finalize(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;781    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;782        ret_code_t ret;
;;;783        ret = fs_store(&fs_config, p_addr + FDS_OFFSET_IC,
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  4622              MOV      r2,r4
00000c  3208              ADDS     r2,r2,#8
00000e  1d29              ADDS     r1,r5,#4
000010  9000              STR      r0,[sp,#0]
000012  4808              LDR      r0,|L69.52|
000014  f7fffffe          BL       fs_store
000018  4606              MOV      r6,r0
;;;784                       (uint32_t*)&p_op->write.header.ic, FDS_HEADER_SIZE_IC, NULL);
;;;785    
;;;786        // If this is a simple write operation, then this is the last step.
;;;787        // If this is an update instead, delete the old record next.
;;;788        p_op->write.step = (p_op->op_code == FDS_OP_UPDATE) ? FDS_OP_WRITE_FLAG_DIRTY :
00001a  7820              LDRB     r0,[r4,#0]
00001c  2803              CMP      r0,#3
00001e  d101              BNE      |L69.36|
000020  2105              MOVS     r1,#5
000022  e000              B        |L69.38|
                  |L69.36|
;;;789                                                              FDS_OP_WRITE_DONE;
000024  2106              MOVS     r1,#6
                  |L69.38|
000026  7421              STRB     r1,[r4,#0x10]
;;;790    
;;;791        return (ret == FS_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000028  2e00              CMP      r6,#0
00002a  d101              BNE      |L69.48|
00002c  2000              MOVS     r0,#0
                  |L69.46|
;;;792    }
00002e  bdf8              POP      {r3-r7,pc}
                  |L69.48|
000030  200e              MOVS     r0,#0xe               ;791
000032  e7fc              B        |L69.46|
;;;793    
                          ENDP

                  |L69.52|
                          DCD      fs_config

                          AREA ||i.record_header_write_id||, CODE, READONLY, ALIGN=2

                  record_header_write_id PROC
;;;764    
;;;765    static ret_code_t record_header_write_id(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;766    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;767        ret_code_t ret;
;;;768        ret = fs_store(&fs_config, p_addr + FDS_OFFSET_ID,
000006  2000              MOVS     r0,#0
000008  2301              MOVS     r3,#1
00000a  4622              MOV      r2,r4
00000c  320c              ADDS     r2,r2,#0xc
00000e  4629              MOV      r1,r5
000010  3108              ADDS     r1,r1,#8
000012  9000              STR      r0,[sp,#0]
000014  4808              LDR      r0,|L70.56|
000016  f7fffffe          BL       fs_store
00001a  4606              MOV      r6,r0
;;;769                       (uint32_t*)&p_op->write.header.record_id, FDS_HEADER_SIZE_ID, NULL);
;;;770    
;;;771        // If this record has zero chunk, write the last part of the header directly.
;;;772        // Otherwise, write the record chunks next.
;;;773        p_op->write.step = (p_op->write.chunk_count != 0) ? FDS_OP_WRITE_CHUNKS :
00001c  7da0              LDRB     r0,[r4,#0x16]
00001e  2800              CMP      r0,#0
000020  d001              BEQ      |L70.38|
000022  2103              MOVS     r1,#3
000024  e000              B        |L70.40|
                  |L70.38|
;;;774                                                            FDS_OP_WRITE_HEADER_FINALIZE;
000026  2101              MOVS     r1,#1
                  |L70.40|
000028  7421              STRB     r1,[r4,#0x10]
;;;775    
;;;776        return (ret == FS_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
00002a  2e00              CMP      r6,#0
00002c  d101              BNE      |L70.50|
00002e  2000              MOVS     r0,#0
                  |L70.48|
;;;777    }
000030  bdf8              POP      {r3-r7,pc}
                  |L70.50|
000032  200e              MOVS     r0,#0xe               ;776
000034  e7fc              B        |L70.48|
;;;778    
                          ENDP

000036  0000              DCW      0x0000
                  |L70.56|
                          DCD      fs_config

                          AREA ||i.record_id_new||, CODE, READONLY, ALIGN=2

                  record_id_new PROC
;;;383    
;;;384    static uint32_t record_id_new(void)
000000  4803              LDR      r0,|L71.16|
;;;385    {
;;;386        CRITICAL_SECTION_ENTER();
;;;387        m_latest_rec_id++;
000002  6800              LDR      r0,[r0,#0]  ; m_latest_rec_id
000004  1c40              ADDS     r0,r0,#1
000006  4902              LDR      r1,|L71.16|
000008  6008              STR      r0,[r1,#0]  ; m_latest_rec_id
;;;388        CRITICAL_SECTION_EXIT();
;;;389        return m_latest_rec_id;
00000a  4608              MOV      r0,r1
00000c  6800              LDR      r0,[r0,#0]  ; m_latest_rec_id
;;;390    }
00000e  4770              BX       lr
;;;391    
                          ENDP

                  |L71.16|
                          DCD      m_latest_rec_id

                          AREA ||i.record_write_chunk||, CODE, READONLY, ALIGN=2

                  record_write_chunk PROC
;;;873    // the number of chunks left to write for this operation and accumulates the offset.
;;;874    static ret_code_t record_write_chunk(fds_op_t * const p_op, uint32_t * const p_addr)
000000  b57c              PUSH     {r2-r6,lr}
;;;875    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;876        ret_code_t           ret;
;;;877        fds_record_chunk_t * p_chunk = NULL;
000006  2000              MOVS     r0,#0
000008  9001              STR      r0,[sp,#4]
;;;878    
;;;879        // Retrieve the next chunk to be written.
;;;880        chunk_queue_get_and_advance(&p_chunk);
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       chunk_queue_get_and_advance
;;;881    
;;;882        ret = fs_store(&fs_config, p_addr + p_op->write.chunk_offset,
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
000014  9801              LDR      r0,[sp,#4]
000016  8883              LDRH     r3,[r0,#4]
000018  6802              LDR      r2,[r0,#0]
00001a  8aa0              LDRH     r0,[r4,#0x14]
00001c  0080              LSLS     r0,r0,#2
00001e  1941              ADDS     r1,r0,r5
000020  480b              LDR      r0,|L72.80|
000022  f7fffffe          BL       fs_store
000026  4606              MOV      r6,r0
;;;883                       p_chunk->p_data, p_chunk->length_words, NULL);
;;;884    
;;;885        // Accumulate the offset.
;;;886        p_op->write.chunk_offset += p_chunk->length_words;
000028  8aa0              LDRH     r0,[r4,#0x14]
00002a  9901              LDR      r1,[sp,#4]
00002c  8889              LDRH     r1,[r1,#4]
00002e  1840              ADDS     r0,r0,r1
000030  82a0              STRH     r0,[r4,#0x14]
;;;887    
;;;888        // Decrement the number of chunks left to write.
;;;889        // NOTE: If chunk_count is initially zero, this function is not called
;;;890        // because this step is skipped entirely. See record_header_write_id().
;;;891        p_op->write.chunk_count--;
000032  7da0              LDRB     r0,[r4,#0x16]
000034  1e40              SUBS     r0,r0,#1
000036  75a0              STRB     r0,[r4,#0x16]
;;;892    
;;;893        if (p_op->write.chunk_count == 0)
000038  7da0              LDRB     r0,[r4,#0x16]
00003a  2800              CMP      r0,#0
00003c  d101              BNE      |L72.66|
;;;894        {
;;;895            // All record chunks have been written; write the last part of
;;;896            // the record header to finalize the write operation.
;;;897            p_op->write.step = FDS_OP_WRITE_HEADER_FINALIZE;
00003e  2101              MOVS     r1,#1
000040  7421              STRB     r1,[r4,#0x10]
                  |L72.66|
;;;898        }
;;;899    
;;;900        return (ret == NRF_SUCCESS) ? FDS_SUCCESS : FDS_ERR_BUSY;
000042  2e00              CMP      r6,#0
000044  d101              BNE      |L72.74|
000046  2000              MOVS     r0,#0
                  |L72.72|
;;;901    }
000048  bd7c              POP      {r2-r6,pc}
                  |L72.74|
00004a  200e              MOVS     r0,#0xe               ;900
00004c  e7fc              B        |L72.72|
;;;902    
                          ENDP

00004e  0000              DCW      0x0000
                  |L72.80|
                          DCD      fs_config

                          AREA ||i.write_enqueue||, CODE, READONLY, ALIGN=2

                  write_enqueue PROC
;;;1491   // Enqueues write and update operations.
;;;1492   static ret_code_t write_enqueue(fds_record_desc_t         * const p_desc,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1493                                   fds_record_t        const * const p_record,
;;;1494                                   fds_reserve_token_t const * const p_tok,
;;;1495                                   fds_op_code_t                     op_code)
;;;1496   {
000002  b08b              SUB      sp,sp,#0x2c
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1497       ret_code_t ret;
;;;1498       fds_op_t   op;
;;;1499       uint16_t   page;
;;;1500       uint16_t   crc          = 0;
00000c  2000              MOVS     r0,#0
00000e  9001              STR      r0,[sp,#4]
;;;1501       uint16_t   length_words = 0;
000010  9000              STR      r0,[sp,#0]
;;;1502   
;;;1503       if (!flag_is_set(FDS_FLAG_INITIALIZED))
000012  2002              MOVS     r0,#2
000014  f7fffffe          BL       flag_is_set
000018  2800              CMP      r0,#0
00001a  d102              BNE      |L73.34|
;;;1504       {
;;;1505           return FDS_ERR_NOT_INITIALIZED;
00001c  2002              MOVS     r0,#2
                  |L73.30|
;;;1506       }
;;;1507   
;;;1508       if (p_record == NULL)
;;;1509       {
;;;1510           return FDS_ERR_NULL_ARG;
;;;1511       }
;;;1512   
;;;1513       if ((p_record->file_id == FDS_FILE_ID_INVALID) ||
;;;1514           (p_record->key     == FDS_RECORD_KEY_DIRTY))
;;;1515       {
;;;1516           return FDS_ERR_INVALID_ARG;
;;;1517       }
;;;1518   
;;;1519       if (!chunk_is_aligned(p_record->data.p_chunks,
;;;1520                             p_record->data.num_chunks))
;;;1521       {
;;;1522           return FDS_ERR_UNALIGNED_ADDR;
;;;1523       }
;;;1524   
;;;1525       // No space was previously reserved for this operation.
;;;1526       if (p_tok == NULL)
;;;1527       {
;;;1528           // Compute the total length of the record.
;;;1529           for (uint32_t i = 0; i < p_record->data.num_chunks; i++)
;;;1530           {
;;;1531               length_words += p_record->data.p_chunks[i].length_words;
;;;1532           }
;;;1533   
;;;1534           // Find a page where to write data.
;;;1535           ret = write_space_reserve(length_words, &page);
;;;1536   
;;;1537           if (ret != FDS_SUCCESS)
;;;1538           {
;;;1539               // There is either not enough flash space available (FDS_ERR_NO_SPACE_IN_FLASH) or
;;;1540               // the record exceeds the virtual page size (FDS_ERR_RECORD_TOO_LARGE).
;;;1541               return ret;
;;;1542           }
;;;1543       }
;;;1544       else
;;;1545       {
;;;1546           page         = p_tok->page;
;;;1547           length_words = p_tok->length_words;
;;;1548       }
;;;1549   
;;;1550       // Initialize the operation.
;;;1551       op.op_code                      = op_code;
;;;1552       op.write.step                   = FDS_OP_WRITE_HEADER_BEGIN;
;;;1553       op.write.page                   = page;
;;;1554       op.write.chunk_count            = p_record->data.num_chunks;
;;;1555       op.write.chunk_offset           = FDS_OFFSET_DATA;
;;;1556       op.write.header.record_id       = record_id_new();
;;;1557       op.write.header.ic.file_id      = p_record->file_id;
;;;1558       op.write.header.tl.record_key   = p_record->key;
;;;1559       op.write.header.tl.length_words = length_words;
;;;1560   
;;;1561       if (op_code == FDS_OP_UPDATE)
;;;1562       {
;;;1563           op.write.step             = FDS_OP_WRITE_FIND_RECORD;
;;;1564           // Save the record ID of the record to be updated.
;;;1565           op.write.record_to_delete = p_desc->record_id;
;;;1566       }
;;;1567   
;;;1568   #if defined (FDS_CRC_ENABLED)
;;;1569       // First, compute the CRC for the first 6 bytes of the header which contain the
;;;1570       // record key, length and file ID, then, compute the CRC of the record ID (4 bytes).
;;;1571       crc = crc16_compute((uint8_t*)&op.write.header,           6, NULL);
;;;1572       crc = crc16_compute((uint8_t*)&op.write.header.record_id, 4, &crc);
;;;1573   
;;;1574       for (uint32_t i = 0; i < p_record->data.num_chunks; i++)
;;;1575       {
;;;1576           // Compute the CRC for the record data.
;;;1577           crc = crc16_compute((uint8_t*)p_record->data.p_chunks[i].p_data,
;;;1578                               p_record->data.p_chunks[i].length_words * sizeof(uint32_t), &crc);
;;;1579       }
;;;1580   #endif
;;;1581   
;;;1582       op.write.header.ic.crc16 = crc;
;;;1583   
;;;1584       // Attempt to enqueue the operation.
;;;1585       if (!op_enqueue(&op, p_record->data.num_chunks, p_record->data.p_chunks))
;;;1586       {
;;;1587           // No space availble in the queues. Cancel the reservation of flash space.
;;;1588           CRITICAL_SECTION_ENTER();
;;;1589           write_space_free(length_words, page);
;;;1590           CRITICAL_SECTION_EXIT();
;;;1591   
;;;1592           return FDS_ERR_NO_SPACE_IN_QUEUES;
;;;1593       }
;;;1594   
;;;1595        // Initialize the record descriptor, if provided.
;;;1596       if (p_desc != NULL)
;;;1597       {
;;;1598           p_desc->p_record       = NULL;
;;;1599           // Don't invoke record_id_new() again !
;;;1600           p_desc->record_id      = op.write.header.record_id;
;;;1601           p_desc->record_is_open = false;
;;;1602           p_desc->gc_run_count   = m_gc.run_count;
;;;1603       }
;;;1604   
;;;1605       // Start processing the queue, if necessary.
;;;1606       queue_start();
;;;1607   
;;;1608       return FDS_SUCCESS;
;;;1609   }
00001e  b00b              ADD      sp,sp,#0x2c
000020  bdf0              POP      {r4-r7,pc}
                  |L73.34|
000022  2c00              CMP      r4,#0                 ;1508
000024  d101              BNE      |L73.42|
000026  2005              MOVS     r0,#5                 ;1510
000028  e7f9              B        |L73.30|
                  |L73.42|
00002a  8820              LDRH     r0,[r4,#0]            ;1513
00002c  4936              LDR      r1,|L73.264|
00002e  4288              CMP      r0,r1                 ;1513
000030  d002              BEQ      |L73.56|
000032  8860              LDRH     r0,[r4,#2]            ;1514
000034  2800              CMP      r0,#0                 ;1514
000036  d101              BNE      |L73.60|
                  |L73.56|
000038  2004              MOVS     r0,#4                 ;1516
00003a  e7f0              B        |L73.30|
                  |L73.60|
00003c  8921              LDRH     r1,[r4,#8]            ;1519
00003e  6860              LDR      r0,[r4,#4]            ;1519
000040  f7fffffe          BL       chunk_is_aligned
000044  2800              CMP      r0,#0                 ;1519
000046  d101              BNE      |L73.76|
000048  2003              MOVS     r0,#3                 ;1522
00004a  e7e8              B        |L73.30|
                  |L73.76|
00004c  2e00              CMP      r6,#0                 ;1526
00004e  d117              BNE      |L73.128|
000050  2000              MOVS     r0,#0                 ;1529
000052  e008              B        |L73.102|
                  |L73.84|
000054  00c2              LSLS     r2,r0,#3              ;1531
000056  6861              LDR      r1,[r4,#4]            ;1531
000058  1889              ADDS     r1,r1,r2              ;1531
00005a  888a              LDRH     r2,[r1,#4]            ;1531
00005c  9900              LDR      r1,[sp,#0]            ;1531
00005e  1851              ADDS     r1,r2,r1              ;1531
000060  b289              UXTH     r1,r1                 ;1531
000062  9100              STR      r1,[sp,#0]            ;1531
000064  1c40              ADDS     r0,r0,#1              ;1529
                  |L73.102|
000066  8921              LDRH     r1,[r4,#8]            ;1529
000068  4281              CMP      r1,r0                 ;1529
00006a  d8f3              BHI      |L73.84|
00006c  a902              ADD      r1,sp,#8              ;1535
00006e  9800              LDR      r0,[sp,#0]            ;1535
000070  f7fffffe          BL       write_space_reserve
000074  900a              STR      r0,[sp,#0x28]         ;1535
000076  980a              LDR      r0,[sp,#0x28]         ;1537
000078  2800              CMP      r0,#0                 ;1537
00007a  d005              BEQ      |L73.136|
00007c  980a              LDR      r0,[sp,#0x28]         ;1541
00007e  e7ce              B        |L73.30|
                  |L73.128|
000080  8830              LDRH     r0,[r6,#0]            ;1546
000082  9002              STR      r0,[sp,#8]            ;1546
000084  8870              LDRH     r0,[r6,#2]            ;1547
000086  9000              STR      r0,[sp,#0]            ;1547
                  |L73.136|
000088  4668              MOV      r0,sp                 ;1551
00008a  7307              STRB     r7,[r0,#0xc]          ;1551
00008c  2100              MOVS     r1,#0                 ;1552
00008e  a803              ADD      r0,sp,#0xc            ;1552
000090  7401              STRB     r1,[r0,#0x10]         ;1552
000092  4668              MOV      r0,sp                 ;1553
000094  8901              LDRH     r1,[r0,#8]            ;1553
000096  a803              ADD      r0,sp,#0xc            ;1553
000098  8241              STRH     r1,[r0,#0x12]         ;1553
00009a  7a21              LDRB     r1,[r4,#8]            ;1554
00009c  7581              STRB     r1,[r0,#0x16]         ;1554
00009e  2103              MOVS     r1,#3                 ;1555
0000a0  8281              STRH     r1,[r0,#0x14]         ;1555
0000a2  f7fffffe          BL       record_id_new
0000a6  9006              STR      r0,[sp,#0x18]         ;1556
0000a8  8821              LDRH     r1,[r4,#0]            ;1557
0000aa  a803              ADD      r0,sp,#0xc            ;1557
0000ac  8101              STRH     r1,[r0,#8]            ;1557
0000ae  8861              LDRH     r1,[r4,#2]            ;1558
0000b0  4668              MOV      r0,sp                 ;1558
0000b2  8201              STRH     r1,[r0,#0x10]         ;1558
0000b4  a903              ADD      r1,sp,#0xc            ;1559
0000b6  9800              LDR      r0,[sp,#0]            ;1559
0000b8  80c8              STRH     r0,[r1,#6]            ;1559
0000ba  2f03              CMP      r7,#3                 ;1561
0000bc  d104              BNE      |L73.200|
0000be  2104              MOVS     r1,#4                 ;1563
0000c0  a803              ADD      r0,sp,#0xc            ;1563
0000c2  7401              STRB     r1,[r0,#0x10]         ;1563
0000c4  6829              LDR      r1,[r5,#0]            ;1565
0000c6  9109              STR      r1,[sp,#0x24]         ;1565
                  |L73.200|
0000c8  a803              ADD      r0,sp,#0xc            ;1582
0000ca  9901              LDR      r1,[sp,#4]            ;1582
0000cc  8141              STRH     r1,[r0,#0xa]          ;1582
0000ce  8921              LDRH     r1,[r4,#8]            ;1585
0000d0  6862              LDR      r2,[r4,#4]            ;1585
0000d2  f7fffffe          BL       op_enqueue
0000d6  2800              CMP      r0,#0                 ;1585
0000d8  d106              BNE      |L73.232|
0000da  4668              MOV      r0,sp                 ;1589
0000dc  8901              LDRH     r1,[r0,#8]            ;1589
0000de  9800              LDR      r0,[sp,#0]            ;1589
0000e0  f7fffffe          BL       write_space_free
0000e4  2008              MOVS     r0,#8                 ;1592
0000e6  e79a              B        |L73.30|
                  |L73.232|
0000e8  2d00              CMP      r5,#0                 ;1596
0000ea  d008              BEQ      |L73.254|
0000ec  2000              MOVS     r0,#0                 ;1598
0000ee  6068              STR      r0,[r5,#4]            ;1598
0000f0  9806              LDR      r0,[sp,#0x18]         ;1600
0000f2  6028              STR      r0,[r5,#0]            ;1600
0000f4  2000              MOVS     r0,#0                 ;1601
0000f6  72a8              STRB     r0,[r5,#0xa]          ;1601
0000f8  4804              LDR      r0,|L73.268|
0000fa  8900              LDRH     r0,[r0,#8]            ;1602  ; m_gc
0000fc  8128              STRH     r0,[r5,#8]            ;1602
                  |L73.254|
0000fe  f7fffffe          BL       queue_start
000102  2000              MOVS     r0,#0                 ;1608
000104  e78b              B        |L73.30|
;;;1610   
                          ENDP

000106  0000              DCW      0x0000
                  |L73.264|
                          DCD      0x0000ffff
                  |L73.268|
                          DCD      m_gc

                          AREA ||i.write_execute||, CODE, READONLY, ALIGN=2

                  write_execute PROC
;;;1218   // Executes write and update operations.
;;;1219   static ret_code_t write_execute(uint32_t prev_ret, fds_op_t * const p_op)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1220   {
000002  4607              MOV      r7,r0
000004  460d              MOV      r5,r1
;;;1221       ret_code_t         ret;
;;;1222       uint32_t   *       p_write_addr;
;;;1223       fds_page_t * const p_page = &m_pages[p_op->write.page];
000006  8a68              LDRH     r0,[r5,#0x12]
000008  0100              LSLS     r0,r0,#4
00000a  492a              LDR      r1,|L74.180|
00000c  1846              ADDS     r6,r0,r1
;;;1224   
;;;1225       // This must persist across calls.
;;;1226       static fds_record_desc_t desc = {0};
;;;1227       // When a record is updated, this variable will hold the page where the old
;;;1228       // copy was stored. This will be used to set the can_gc flag when the header is
;;;1229       // invalidated (FDS_OP_WRITE_FLAG_DIRTY).
;;;1230       static uint16_t page;
;;;1231   
;;;1232       if (prev_ret != FS_SUCCESS)
00000e  2f00              CMP      r7,#0
000010  d005              BEQ      |L74.30|
;;;1233       {
;;;1234           // The previous operation has timed out, update offsets.
;;;1235           page_offsets_update(p_page, p_op->write.header.tl.length_words);
000012  88e9              LDRH     r1,[r5,#6]
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       page_offsets_update
;;;1236           return FDS_ERR_OPERATION_TIMEOUT;
00001a  2001              MOVS     r0,#1
                  |L74.28|
;;;1237       }
;;;1238   
;;;1239       // Compute the address where to write data.
;;;1240       p_write_addr = (uint32_t*)(p_page->p_addr + p_page->write_offset);
;;;1241   
;;;1242       // Execute the current step of the operation, and set one to be executed next.
;;;1243       switch (p_op->write.step)
;;;1244       {
;;;1245           case FDS_OP_WRITE_FIND_RECORD:
;;;1246           {
;;;1247               // The first step of updating a record constists of locating the copy to be deleted.
;;;1248               // If the old copy couldn't be found for any reason then the update should fail.
;;;1249               // This prevents duplicates when queuing multiple updates of the same record.
;;;1250               desc.p_record  = NULL;
;;;1251               desc.record_id = p_op->write.record_to_delete;
;;;1252   
;;;1253               if (!record_find_by_desc(&desc, &page))
;;;1254               {
;;;1255                   return FDS_ERR_NOT_FOUND;
;;;1256               }
;;;1257               // Setting the step is redundant since we are falling through.
;;;1258           }
;;;1259           // Fallthrough to FDS_OP_WRITE_HEADER_BEGIN.
;;;1260   
;;;1261           case FDS_OP_WRITE_HEADER_BEGIN:
;;;1262               ret = record_header_write_begin(p_op, p_write_addr);
;;;1263               break;
;;;1264   
;;;1265           case FDS_OP_WRITE_RECORD_ID:
;;;1266               ret = record_header_write_id(p_op, p_write_addr);
;;;1267               break;
;;;1268   
;;;1269           case FDS_OP_WRITE_CHUNKS:
;;;1270               ret = record_write_chunk(p_op, p_write_addr);
;;;1271               break;
;;;1272   
;;;1273           case FDS_OP_WRITE_HEADER_FINALIZE:
;;;1274               ret = record_header_write_finalize(p_op, p_write_addr);
;;;1275               break;
;;;1276   
;;;1277           case FDS_OP_WRITE_FLAG_DIRTY:
;;;1278               ret = record_header_flag_dirty((uint32_t*)desc.p_record, page);
;;;1279               p_op->write.step = FDS_OP_WRITE_DONE;
;;;1280               break;
;;;1281   
;;;1282           case FDS_OP_WRITE_DONE:
;;;1283               ret = FDS_OP_COMPLETED;
;;;1284   
;;;1285   #if defined(FDS_CRC_ENABLED)
;;;1286               if (flag_is_set(FDS_FLAG_VERIFY_CRC))
;;;1287               {
;;;1288                   if (!crc_verify_success(p_op->write.header.ic.crc16,
;;;1289                                           p_op->write.header.tl.length_words,
;;;1290                                           p_write_addr))
;;;1291                   {
;;;1292                       ret = FDS_ERR_CRC_CHECK_FAILED;
;;;1293                   }
;;;1294               }
;;;1295   #endif
;;;1296               break;
;;;1297   
;;;1298           default:
;;;1299               ret = FDS_ERR_INTERNAL;
;;;1300               break;
;;;1301       }
;;;1302   
;;;1303       // An operation has either completed or failed. It may have failed because fstorage
;;;1304       // ran out of memory, or because the user tried to delete a record which did not exist.
;;;1305       if (ret != FDS_OP_EXECUTING)
;;;1306       {
;;;1307           // There won't be another callback for this operation, so update the page offset now.
;;;1308           page_offsets_update(p_page, p_op->write.header.tl.length_words);
;;;1309       }
;;;1310   
;;;1311       return ret;
;;;1312   }
00001c  bdf8              POP      {r3-r7,pc}
                  |L74.30|
00001e  8931              LDRH     r1,[r6,#8]            ;1240
000020  0089              LSLS     r1,r1,#2              ;1240
000022  6870              LDR      r0,[r6,#4]            ;1240
000024  1840              ADDS     r0,r0,r1              ;1240
000026  9000              STR      r0,[sp,#0]            ;1240
000028  7c28              LDRB     r0,[r5,#0x10]         ;1243
00002a  0003              MOVS     r3,r0                 ;1243
00002c  f7fffffe          BL       __ARM_common_switch8
000030  07132519          DCB      0x07,0x13,0x25,0x19
000034  1f052b35          DCB      0x1f,0x05,0x2b,0x35
000038  3700              DCB      0x37,0x00
00003a  2000              MOVS     r0,#0                 ;1250
00003c  491e              LDR      r1,|L74.184|
00003e  6048              STR      r0,[r1,#4]            ;1250  ; desc
000040  69a8              LDR      r0,[r5,#0x18]         ;1251
000042  6008              STR      r0,[r1,#0]            ;1251  ; desc
000044  491d              LDR      r1,|L74.188|
000046  481c              LDR      r0,|L74.184|
000048  f7fffffe          BL       record_find_by_desc
00004c  2800              CMP      r0,#0                 ;1253
00004e  d101              BNE      |L74.84|
000050  200a              MOVS     r0,#0xa               ;1255
000052  e7e3              B        |L74.28|
                  |L74.84|
000054  bf00              NOP                            ;1261
000056  4628              MOV      r0,r5                 ;1262
000058  9900              LDR      r1,[sp,#0]            ;1262
00005a  f7fffffe          BL       record_header_write_begin
00005e  4604              MOV      r4,r0                 ;1262
000060  e01f              B        |L74.162|
000062  4628              MOV      r0,r5                 ;1266
000064  9900              LDR      r1,[sp,#0]            ;1266
000066  f7fffffe          BL       record_header_write_id
00006a  4604              MOV      r4,r0                 ;1266
00006c  e019              B        |L74.162|
00006e  4628              MOV      r0,r5                 ;1270
000070  9900              LDR      r1,[sp,#0]            ;1270
000072  f7fffffe          BL       record_write_chunk
000076  4604              MOV      r4,r0                 ;1270
000078  e013              B        |L74.162|
00007a  4628              MOV      r0,r5                 ;1274
00007c  9900              LDR      r1,[sp,#0]            ;1274
00007e  f7fffffe          BL       record_header_write_finalize
000082  4604              MOV      r4,r0                 ;1274
000084  e00d              B        |L74.162|
000086  490c              LDR      r1,|L74.184|
000088  6848              LDR      r0,[r1,#4]            ;1278  ; desc
00008a  490c              LDR      r1,|L74.188|
00008c  8809              LDRH     r1,[r1,#0]            ;1278  ; page
00008e  f7fffffe          BL       record_header_flag_dirty
000092  4604              MOV      r4,r0                 ;1278
000094  2106              MOVS     r1,#6                 ;1279
000096  7429              STRB     r1,[r5,#0x10]         ;1279
000098  e003              B        |L74.162|
00009a  4c09              LDR      r4,|L74.192|
00009c  e001              B        |L74.162|
00009e  240f              MOVS     r4,#0xf               ;1299
0000a0  bf00              NOP                            ;1300
                  |L74.162|
0000a2  bf00              NOP                            ;1263
0000a4  2c00              CMP      r4,#0                 ;1305
0000a6  d003              BEQ      |L74.176|
0000a8  88e9              LDRH     r1,[r5,#6]            ;1308
0000aa  4630              MOV      r0,r6                 ;1308
0000ac  f7fffffe          BL       page_offsets_update
                  |L74.176|
0000b0  4620              MOV      r0,r4                 ;1311
0000b2  e7b3              B        |L74.28|
;;;1313   
                          ENDP

                  |L74.180|
                          DCD      m_pages
                  |L74.184|
                          DCD      desc
                  |L74.188|
                          DCD      page
                  |L74.192|
                          DCD      0x00001d1d

                          AREA ||i.write_space_free||, CODE, READONLY, ALIGN=2

                  write_space_free PROC
;;;377    // NOTE: Must be called within a critical section.
;;;378    static void write_space_free(uint16_t length_words, uint16_t page)
000000  b510              PUSH     {r4,lr}
;;;379    {
;;;380        m_pages[page].words_reserved -= (length_words + FDS_HEADER_SIZE);
000002  010a              LSLS     r2,r1,#4
000004  4b04              LDR      r3,|L75.24|
000006  18d2              ADDS     r2,r2,r3
000008  8953              LDRH     r3,[r2,#0xa]
00000a  1cc2              ADDS     r2,r0,#3
00000c  1a9a              SUBS     r2,r3,r2
00000e  010b              LSLS     r3,r1,#4
000010  4c01              LDR      r4,|L75.24|
000012  191b              ADDS     r3,r3,r4
000014  815a              STRH     r2,[r3,#0xa]
;;;381    }
000016  bd10              POP      {r4,pc}
;;;382    
                          ENDP

                  |L75.24|
                          DCD      m_pages

                          AREA ||i.write_space_reserve||, CODE, READONLY, ALIGN=2

                  write_space_reserve PROC
;;;346    // NOTE: this function takes into the account the space required for the record header.
;;;347    static ret_code_t write_space_reserve(uint16_t length_words, uint16_t * p_page)
000000  b5f8              PUSH     {r3-r7,lr}
;;;348    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;349        bool           space_reserved  = false;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;350        uint16_t const total_len_words = length_words + FDS_HEADER_SIZE;
00000a  1cf0              ADDS     r0,r6,#3
00000c  b285              UXTH     r5,r0
;;;351    
;;;352        if (total_len_words >= FDS_PAGE_SIZE - FDS_PAGE_TAG_SIZE)
00000e  2dfe              CMP      r5,#0xfe
000010  db01              BLT      |L76.22|
;;;353        {
;;;354            return FDS_ERR_RECORD_TOO_LARGE;
000012  2009              MOVS     r0,#9
                  |L76.20|
;;;355        }
;;;356    
;;;357        CRITICAL_SECTION_ENTER();
;;;358        for (uint16_t page = 0; page < FDS_MAX_PAGES; page++)
;;;359        {
;;;360            if ((m_pages[page].page_type == FDS_PAGE_DATA) &&
;;;361                (page_has_space(page, total_len_words)))
;;;362            {
;;;363                space_reserved = true;
;;;364                *p_page        = page;
;;;365    
;;;366                m_pages[page].words_reserved += total_len_words;
;;;367                break;
;;;368            }
;;;369        }
;;;370        CRITICAL_SECTION_EXIT();
;;;371    
;;;372        return (space_reserved) ? FDS_SUCCESS : FDS_ERR_NO_SPACE_IN_FLASH;
;;;373    }
000014  bdf8              POP      {r3-r7,pc}
                  |L76.22|
000016  2400              MOVS     r4,#0                 ;358
000018  e019              B        |L76.78|
                  |L76.26|
00001a  0120              LSLS     r0,r4,#4              ;360
00001c  4911              LDR      r1,|L76.100|
00001e  5c08              LDRB     r0,[r1,r0]            ;360
000020  2800              CMP      r0,#0                 ;360
000022  d112              BNE      |L76.74|
000024  4629              MOV      r1,r5                 ;361
000026  4620              MOV      r0,r4                 ;361
000028  f7fffffe          BL       page_has_space
00002c  2800              CMP      r0,#0                 ;361
00002e  d00c              BEQ      |L76.74|
000030  2001              MOVS     r0,#1                 ;363
000032  9000              STR      r0,[sp,#0]            ;363
000034  803c              STRH     r4,[r7,#0]            ;364
000036  0120              LSLS     r0,r4,#4              ;366
000038  490a              LDR      r1,|L76.100|
00003a  1840              ADDS     r0,r0,r1              ;366
00003c  8940              LDRH     r0,[r0,#0xa]          ;366
00003e  1940              ADDS     r0,r0,r5              ;366
000040  0121              LSLS     r1,r4,#4              ;366
000042  4a08              LDR      r2,|L76.100|
000044  1889              ADDS     r1,r1,r2              ;366
000046  8148              STRH     r0,[r1,#0xa]          ;366
000048  e003              B        |L76.82|
                  |L76.74|
00004a  1c60              ADDS     r0,r4,#1              ;358
00004c  b284              UXTH     r4,r0                 ;358
                  |L76.78|
00004e  2c02              CMP      r4,#2                 ;358
000050  dbe3              BLT      |L76.26|
                  |L76.82|
000052  bf00              NOP                            ;367
000054  9800              LDR      r0,[sp,#0]            ;372
000056  2800              CMP      r0,#0                 ;372
000058  d001              BEQ      |L76.94|
00005a  2000              MOVS     r0,#0                 ;372
00005c  e7da              B        |L76.20|
                  |L76.94|
00005e  2007              MOVS     r0,#7                 ;372
000060  e7d8              B        |L76.20|
;;;374    
                          ENDP

000062  0000              DCW      0x0000
                  |L76.100|
                          DCD      m_pages

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  m_cb_table
                          %        32
                  m_op_queue
                          %        120
                  m_chunk_queue
                          %        72
                  m_pages
                          %        32
                  m_gc
                          %        16
                  desc
                          %        12

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  m_fds_tl_dirty
000000  0000ffff          DCW      0x0000,0xffff
                  page_tag_swap
                          DCD      0xdeadc0de
                          DCD      0xf11e01ff
                  page_tag_data
                          DCD      0xdeadc0de
                          DCD      0xf11e01fe

                          AREA ||.data||, DATA, ALIGN=2

                  m_flags
000000  00                DCB      0x00
                  m_users
000001  000000            DCB      0x00,0x00,0x00
                  m_latest_rec_id
                          DCD      0x00000000
                  m_swap_page
                          %        8
                  tok
                          DCD      0x00000000
000014  0000              DCW      0x0000
000016  0000              DCB      0x00,0x00
                  page
000018  0000              DCB      0x00,0x00

                          AREA fs_data, DATA, ALIGN=2

                  fs_config
                  ||__tagsym$$used||
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      fs_event_handler
00000c  03ff0000          DCB      0x03,0xff,0x00,0x00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L412.24|
                  |L412.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L412.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L412.14|
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\components\\libraries\\fds\\fds.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_1b2f21da____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_fds_c_1b2f21da____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_fds_c_1b2f21da____REVSH|
#line 144
|__asm___5_fds_c_1b2f21da____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
