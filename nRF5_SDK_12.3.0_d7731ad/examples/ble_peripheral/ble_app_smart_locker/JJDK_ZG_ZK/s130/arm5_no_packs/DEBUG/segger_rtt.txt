; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\debug\segger_rtt.o --asm_dir=.\DEBUG\ --list_dir=.\DEBUG\ --depend=.\debug\segger_rtt.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\config -I..\..\..\..\..\..\components -I..\..\..\..\..\..\components\ble\ble_advertising -I..\..\..\..\..\..\components\ble\ble_dtm -I..\..\..\..\..\..\components\ble\ble_racp -I..\..\..\..\..\..\components\ble\ble_services\ble_ancs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_ans_c -I..\..\..\..\..\..\components\ble\ble_services\ble_bas -I..\..\..\..\..\..\components\ble\ble_services\ble_bas_c -I..\..\..\..\..\..\components\ble\ble_services\ble_cscs -I..\..\..\..\..\..\components\ble\ble_services\ble_cts_c -I..\..\..\..\..\..\components\ble\ble_services\ble_dfu -I..\..\..\..\..\..\components\ble\ble_services\ble_dis -I..\..\..\..\..\..\components\ble\ble_services\ble_gls -I..\..\..\..\..\..\components\ble\ble_services\ble_hids -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs -I..\..\..\..\..\..\components\ble\ble_services\ble_hrs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_hts -I..\..\..\..\..\..\components\ble\ble_services\ble_ias -I..\..\..\..\..\..\components\ble\ble_services\ble_ias_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs -I..\..\..\..\..\..\components\ble\ble_services\ble_lbs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_lls -I..\..\..\..\..\..\components\ble\ble_services\ble_nus -I..\..\..\..\..\..\components\ble\ble_services\ble_nus_c -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs -I..\..\..\..\..\..\components\ble\ble_services\ble_rscs_c -I..\..\..\..\..\..\components\ble\ble_services\ble_tps -I..\..\..\..\..\..\components\ble\common -I..\..\..\..\..\..\components\ble\nrf_ble_qwr -I..\..\..\..\..\..\components\ble\peer_manager -I..\..\..\..\..\..\components\boards -I..\..\..\..\..\..\components\drivers_nrf\adc -I..\..\..\..\..\..\components\drivers_nrf\clock -I..\..\..\..\..\..\components\drivers_nrf\common -I..\..\..\..\..\..\components\drivers_nrf\comp -I..\..\..\..\..\..\components\drivers_nrf\delay -I..\..\..\..\..\..\components\drivers_nrf\gpiote -I..\..\..\..\..\..\components\drivers_nrf\hal -I..\..\..\..\..\..\components\drivers_nrf\i2s -I..\..\..\..\..\..\components\drivers_nrf\lpcomp -I..\..\..\..\..\..\components\drivers_nrf\pdm -I..\..\..\..\..\..\components\drivers_nrf\power -I..\..\..\..\..\..\components\drivers_nrf\ppi -I..\..\..\..\..\..\components\drivers_nrf\pwm -I..\..\..\..\..\..\components\drivers_nrf\qdec -I..\..\..\..\..\..\components\drivers_nrf\rng -I..\..\..\..\..\..\components\drivers_nrf\rtc -I..\..\..\..\..\..\components\drivers_nrf\saadc -I..\..\..\..\..\..\components\drivers_nrf\spi_master -I..\..\..\..\..\..\components\drivers_nrf\spi_slave -I..\..\..\..\..\..\components\drivers_nrf\swi -I..\..\..\..\..\..\components\drivers_nrf\timer -I..\..\..\..\..\..\components\drivers_nrf\twi_master -I..\..\..\..\..\..\components\drivers_nrf\twis_slave -I..\..\..\..\..\..\components\drivers_nrf\uart -I..\..\..\..\..\..\components\drivers_nrf\usbd -I..\..\..\..\..\..\components\drivers_nrf\wdt -I..\..\..\..\..\..\components\libraries\bsp -I..\..\..\..\..\..\components\libraries\button -I..\..\..\..\..\..\components\libraries\crc16 -I..\..\..\..\..\..\components\libraries\crc32 -I..\..\..\..\..\..\components\libraries\csense -I..\..\..\..\..\..\components\libraries\csense_drv -I..\..\..\..\..\..\components\libraries\experimental_section_vars -I..\..\..\..\..\..\components\libraries\fds -I..\..\..\..\..\..\components\libraries\fstorage -I..\..\..\..\..\..\components\libraries\gpiote -I..\..\..\..\..\..\components\libraries\hardfault -I..\..\..\..\..\..\components\libraries\hci -I..\..\..\..\..\..\components\libraries\led_softblink -I..\..\..\..\..\..\components\libraries\log -I..\..\..\..\..\..\components\libraries\log\src -I..\..\..\..\..\..\components\libraries\low_power_pwm -I..\..\..\..\..\..\components\libraries\mem_manager -I..\..\..\..\..\..\components\libraries\pwm -I..\..\..\..\..\..\components\libraries\queue -I..\..\..\..\..\..\components\libraries\scheduler -I..\..\..\..\..\..\components\libraries\sensorsim -I..\..\..\..\..\..\components\libraries\slip -I..\..\..\..\..\..\components\libraries\timer -I..\..\..\..\..\..\components\libraries\twi -I..\..\..\..\..\..\components\libraries\uart -I..\..\..\..\..\..\components\libraries\usbd -I..\..\..\..\..\..\components\libraries\usbd\class\audio -I..\..\..\..\..\..\components\libraries\usbd\class\cdc -I..\..\..\..\..\..\components\libraries\usbd\class\cdc\acm -I..\..\..\..\..\..\components\libraries\usbd\class\hid -I..\..\..\..\..\..\components\libraries\usbd\class\hid\generic -I..\..\..\..\..\..\components\libraries\usbd\class\hid\kbd -I..\..\..\..\..\..\components\libraries\usbd\class\hid\mouse -I..\..\..\..\..\..\components\libraries\usbd\class\msc -I..\..\..\..\..\..\components\libraries\usbd\config -I..\..\..\..\..\..\components\libraries\util -I..\..\..\..\..\..\components\softdevice\common\softdevice_handler -I..\..\..\..\..\..\components\softdevice\s130\headers -I..\..\..\..\..\..\components\softdevice\s130\headers\nrf51 -I..\..\..\..\..\..\components\toolchain -I..\..\..\..\..\..\external\segger_rtt -I..\config -I..\..\..\..\..\..\components\ble\ble_services\ble_sls -ID:\development\nordic_ble\src_code\nrf51_sdk_v12_3_0\nRF5_SDK_12.3.0_d7731ad\examples\ble_peripheral\ble_app_smart_locker\JJDK_ZG_ZK\s130\arm5_no_packs\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\NordicSemiconductor\nRF_DeviceFamilyPack\8.11.1\Device\Include -D__MICROLIB -D_RTE_ -DNRF51 -DBLE_STACK_SUPPORT_REQD -DNRF51822 -DBOARD_JJDK_ZG_ZK -DNRF_SD_BLE_API_VERSION=2 -DS130 -DNRF51 -DSOFTDEVICE_PRESENT -DSWI_DISABLE0 --omf_browse=.\debug\segger_rtt.crf ..\..\..\..\..\..\external\segger_rtt\SEGGER_RTT.c]
                          THUMB

                          AREA ||i.SEGGER_RTT_ConfigDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigDownBuffer PROC
;;;859    */
;;;860    int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;861      int r;
;;;862      volatile unsigned SavedState;
;;;863    
;;;864      INIT();
00000a  bf00              NOP      
00000c  4820              LDR      r0,|L1.144|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  2800              CMP      r0,#0
000012  d101              BNE      |L1.24|
000014  f7fffffe          BL       _DoInit
                  |L1.24|
000018  bf00              NOP      
;;;865      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
00001a  481d              LDR      r0,|L1.144|
00001c  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
00001e  42a0              CMP      r0,r4
000020  d930              BLS      |L1.132|
;;;866        SEGGER_RTT_LOCK(SavedState);
000022  2000              MOVS     r0,#0
000024  9002              STR      r0,[sp,#8]
000026  9001              STR      r0,[sp,#4]
000028  a801              ADD      r0,sp,#4
00002a  f7fffffe          BL       app_util_critical_region_enter
;;;867        if (BufferIndex > 0u) {
00002e  2c00              CMP      r4,#0
000030  d01a              BEQ      |L1.104|
;;;868          _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
000032  2018              MOVS     r0,#0x18
000034  4360              MULS     r0,r4,r0
000036  4916              LDR      r1,|L1.144|
000038  3148              ADDS     r1,r1,#0x48
00003a  500e              STR      r6,[r1,r0]
;;;869          _SEGGER_RTT.aDown[BufferIndex].pBuffer      = pBuffer;
00003c  2018              MOVS     r0,#0x18
00003e  4360              MULS     r0,r4,r0
000040  1840              ADDS     r0,r0,r1
000042  6047              STR      r7,[r0,#4]
;;;870          _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
000044  2118              MOVS     r1,#0x18
000046  4361              MULS     r1,r4,r1
000048  4a11              LDR      r2,|L1.144|
00004a  3248              ADDS     r2,r2,#0x48
00004c  1889              ADDS     r1,r1,r2
00004e  9806              LDR      r0,[sp,#0x18]
000050  6088              STR      r0,[r1,#8]
;;;871          _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
000052  2200              MOVS     r2,#0
000054  2018              MOVS     r0,#0x18
000056  4360              MULS     r0,r4,r0
000058  490d              LDR      r1,|L1.144|
00005a  3148              ADDS     r1,r1,#0x48
00005c  1840              ADDS     r0,r0,r1
00005e  6102              STR      r2,[r0,#0x10]
;;;872          _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
000060  2018              MOVS     r0,#0x18
000062  4360              MULS     r0,r4,r0
000064  1840              ADDS     r0,r0,r1
000066  60c2              STR      r2,[r0,#0xc]
                  |L1.104|
;;;873        }
;;;874        _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
000068  2018              MOVS     r0,#0x18
00006a  4360              MULS     r0,r4,r0
00006c  4a08              LDR      r2,|L1.144|
00006e  3248              ADDS     r2,r2,#0x48
000070  1880              ADDS     r0,r0,r2
000072  990c              LDR      r1,[sp,#0x30]
000074  6141              STR      r1,[r0,#0x14]
;;;875        SEGGER_RTT_UNLOCK(SavedState);
000076  bf00              NOP      
000078  4668              MOV      r0,sp
00007a  7900              LDRB     r0,[r0,#4]
00007c  f7fffffe          BL       app_util_critical_region_exit
;;;876        r =  0;
000080  2500              MOVS     r5,#0
000082  e001              B        |L1.136|
                  |L1.132|
;;;877      } else {
;;;878        r = -1;
000084  2500              MOVS     r5,#0
000086  43ed              MVNS     r5,r5
                  |L1.136|
;;;879      }
;;;880      return r;
000088  4628              MOV      r0,r5
;;;881    }
00008a  b007              ADD      sp,sp,#0x1c
00008c  bdf0              POP      {r4-r7,pc}
;;;882    
                          ENDP

00008e  0000              DCW      0x0000
                  |L1.144|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_ConfigUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ConfigUpBuffer PROC
;;;816    */
;;;817    int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
000000  b5ff              PUSH     {r0-r7,lr}
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;818      int r;
;;;819      volatile unsigned SavedState;
;;;820    
;;;821      INIT();
00000a  bf00              NOP      
00000c  4820              LDR      r0,|L2.144|
00000e  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000010  2800              CMP      r0,#0
000012  d101              BNE      |L2.24|
000014  f7fffffe          BL       _DoInit
                  |L2.24|
000018  bf00              NOP      
;;;822      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
00001a  481d              LDR      r0,|L2.144|
00001c  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
00001e  42a0              CMP      r0,r4
000020  d930              BLS      |L2.132|
;;;823        SEGGER_RTT_LOCK(SavedState);
000022  2000              MOVS     r0,#0
000024  9002              STR      r0,[sp,#8]
000026  9001              STR      r0,[sp,#4]
000028  a801              ADD      r0,sp,#4
00002a  f7fffffe          BL       app_util_critical_region_enter
;;;824        if (BufferIndex > 0u) {
00002e  2c00              CMP      r4,#0
000030  d01a              BEQ      |L2.104|
;;;825          _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
000032  2018              MOVS     r0,#0x18
000034  4360              MULS     r0,r4,r0
000036  4916              LDR      r1,|L2.144|
000038  3118              ADDS     r1,r1,#0x18
00003a  500e              STR      r6,[r1,r0]
;;;826          _SEGGER_RTT.aUp[BufferIndex].pBuffer      = pBuffer;
00003c  2018              MOVS     r0,#0x18
00003e  4360              MULS     r0,r4,r0
000040  1840              ADDS     r0,r0,r1
000042  6047              STR      r7,[r0,#4]
;;;827          _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
000044  2118              MOVS     r1,#0x18
000046  4361              MULS     r1,r4,r1
000048  4a11              LDR      r2,|L2.144|
00004a  3218              ADDS     r2,r2,#0x18
00004c  1889              ADDS     r1,r1,r2
00004e  9806              LDR      r0,[sp,#0x18]
000050  6088              STR      r0,[r1,#8]
;;;828          _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
000052  2200              MOVS     r2,#0
000054  2018              MOVS     r0,#0x18
000056  4360              MULS     r0,r4,r0
000058  490d              LDR      r1,|L2.144|
00005a  3118              ADDS     r1,r1,#0x18
00005c  1840              ADDS     r0,r0,r1
00005e  6102              STR      r2,[r0,#0x10]
;;;829          _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
000060  2018              MOVS     r0,#0x18
000062  4360              MULS     r0,r4,r0
000064  1840              ADDS     r0,r0,r1
000066  60c2              STR      r2,[r0,#0xc]
                  |L2.104|
;;;830        }
;;;831        _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
000068  2018              MOVS     r0,#0x18
00006a  4360              MULS     r0,r4,r0
00006c  4a08              LDR      r2,|L2.144|
00006e  3218              ADDS     r2,r2,#0x18
000070  1880              ADDS     r0,r0,r2
000072  990c              LDR      r1,[sp,#0x30]
000074  6141              STR      r1,[r0,#0x14]
;;;832        SEGGER_RTT_UNLOCK(SavedState);
000076  bf00              NOP      
000078  4668              MOV      r0,sp
00007a  7900              LDRB     r0,[r0,#4]
00007c  f7fffffe          BL       app_util_critical_region_exit
;;;833        r =  0;
000080  2500              MOVS     r5,#0
000082  e001              B        |L2.136|
                  |L2.132|
;;;834      } else {
;;;835        r = -1;
000084  2500              MOVS     r5,#0
000086  43ed              MVNS     r5,r5
                  |L2.136|
;;;836      }
;;;837      return r;
000088  4628              MOV      r0,r5
;;;838    }
00008a  b007              ADD      sp,sp,#0x1c
00008c  bdf0              POP      {r4-r7,pc}
;;;839    
                          ENDP

00008e  0000              DCW      0x0000
                  |L2.144|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_GetKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_GetKey PROC
;;;709    */
;;;710    int SEGGER_RTT_GetKey(void) {
000000  b538              PUSH     {r3-r5,lr}
;;;711      char c;
;;;712      int r;
;;;713    
;;;714      r = (int)SEGGER_RTT_Read(0u, &c, 1u);
000002  2201              MOVS     r2,#1
000004  4669              MOV      r1,sp
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       SEGGER_RTT_Read
00000c  4604              MOV      r4,r0
;;;715      if (r == 1) {
00000e  2c01              CMP      r4,#1
000010  d102              BNE      |L3.24|
;;;716        r = (int)(unsigned char)c;
000012  4668              MOV      r0,sp
000014  7804              LDRB     r4,[r0,#0]
000016  e001              B        |L3.28|
                  |L3.24|
;;;717      } else {
;;;718        r = -1;
000018  2400              MOVS     r4,#0
00001a  43e4              MVNS     r4,r4
                  |L3.28|
;;;719      }
;;;720      return r;
00001c  4620              MOV      r0,r4
;;;721    }
00001e  bd38              POP      {r3-r5,pc}
;;;722    
                          ENDP


                          AREA ||i.SEGGER_RTT_HasData||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasData PROC
;;;786    */
;;;787    unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;788      SEGGER_RTT_RING_BUFFER *pRing;
;;;789      unsigned v;
;;;790    
;;;791      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000004  2018              MOVS     r0,#0x18
000006  4348              MULS     r0,r1,r0
000008  4c02              LDR      r4,|L4.20|
00000a  1902              ADDS     r2,r0,r4
;;;792      v = pRing->WrOff;
00000c  68d3              LDR      r3,[r2,#0xc]
;;;793      return v - pRing->RdOff;
00000e  6910              LDR      r0,[r2,#0x10]
000010  1a18              SUBS     r0,r3,r0
;;;794    }
000012  bd10              POP      {r4,pc}
;;;795    
                          ENDP

                  |L4.20|
                          DCD      _SEGGER_RTT+0x48

                          AREA ||i.SEGGER_RTT_HasKey||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_HasKey PROC
;;;760    */
;;;761    int SEGGER_RTT_HasKey(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;762      unsigned RdOff;
;;;763      int r;
;;;764    
;;;765      INIT();
000002  bf00              NOP      
000004  4808              LDR      r0,|L5.40|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L5.16|
00000c  f7fffffe          BL       _DoInit
                  |L5.16|
000010  bf00              NOP      
;;;766      RdOff = _SEGGER_RTT.aDown[0].RdOff;
000012  4805              LDR      r0,|L5.40|
000014  6d85              LDR      r5,[r0,#0x58]
;;;767      if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
000016  6d40              LDR      r0,[r0,#0x54]
000018  42a8              CMP      r0,r5
00001a  d001              BEQ      |L5.32|
;;;768        r = 1;
00001c  2401              MOVS     r4,#1
00001e  e000              B        |L5.34|
                  |L5.32|
;;;769      } else {
;;;770        r = 0;
000020  2400              MOVS     r4,#0
                  |L5.34|
;;;771      }
;;;772      return r;
000022  4620              MOV      r0,r4
;;;773    }
000024  bd70              POP      {r4-r6,pc}
;;;774    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Init||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Init PROC
;;;955    */
;;;956    void SEGGER_RTT_Init (void) {
000000  b510              PUSH     {r4,lr}
;;;957      INIT();
000002  bf00              NOP      
000004  4803              LDR      r0,|L6.20|
000006  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L6.16|
00000c  f7fffffe          BL       _DoInit
                  |L6.16|
000010  bf00              NOP      
;;;958    }
000012  bd10              POP      {r4,pc}
;;;959    
                          ENDP

                  |L6.20|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_Read||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_Read PROC
;;;436    */
;;;437    unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;438      unsigned NumBytesRead;
;;;439      volatile unsigned SavedState;
;;;440      //
;;;441      SEGGER_RTT_LOCK(SavedState);
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
00000c  2100              MOVS     r1,#0
00000e  9100              STR      r1,[sp,#0]
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       app_util_critical_region_enter
;;;442      //
;;;443      // Call the non-locking read function
;;;444      //
;;;445      NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
000016  4632              MOV      r2,r6
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SEGGER_RTT_ReadNoLock
000020  4607              MOV      r7,r0
;;;446      //
;;;447      // Finish up.
;;;448      //
;;;449      SEGGER_RTT_UNLOCK(SavedState);
000022  bf00              NOP      
000024  4668              MOV      r0,sp
000026  7800              LDRB     r0,[r0,#0]
000028  f7fffffe          BL       app_util_critical_region_exit
;;;450      //
;;;451      return NumBytesRead;
00002c  4638              MOV      r0,r7
;;;452    }
00002e  bdfe              POP      {r1-r7,pc}
;;;453    
                          ENDP


                          AREA ||i.SEGGER_RTT_ReadNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_ReadNoLock PROC
;;;369    */
;;;370    unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b084              SUB      sp,sp,#0x10
000004  4617              MOV      r7,r2
;;;371      unsigned NumBytesRem;
;;;372      unsigned NumBytesRead;
;;;373      unsigned RdOff;
;;;374      unsigned WrOff;
;;;375      unsigned char* pBuffer;
;;;376      SEGGER_RTT_RING_BUFFER* pRing;
;;;377      //
;;;378      INIT();
000006  bf00              NOP      
000008  4827              LDR      r0,|L8.168|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L8.20|
000010  f7fffffe          BL       _DoInit
                  |L8.20|
000014  bf00              NOP      
;;;379      pRing = &_SEGGER_RTT.aDown[BufferIndex];
000016  2118              MOVS     r1,#0x18
000018  9804              LDR      r0,[sp,#0x10]
00001a  4348              MULS     r0,r1,r0
00001c  4922              LDR      r1,|L8.168|
00001e  3148              ADDS     r1,r1,#0x48
000020  1846              ADDS     r6,r0,r1
;;;380      pBuffer = (unsigned char*)pData;
000022  9805              LDR      r0,[sp,#0x14]
000024  9001              STR      r0,[sp,#4]
;;;381      RdOff = pRing->RdOff;
000026  6935              LDR      r5,[r6,#0x10]
;;;382      WrOff = pRing->WrOff;
000028  68f0              LDR      r0,[r6,#0xc]
00002a  9002              STR      r0,[sp,#8]
;;;383      NumBytesRead = 0u;
00002c  2000              MOVS     r0,#0
00002e  9003              STR      r0,[sp,#0xc]
;;;384      //
;;;385      // Read from current read position to wrap-around of buffer, first
;;;386      //
;;;387      if (RdOff > WrOff) {
000030  9802              LDR      r0,[sp,#8]
000032  4285              CMP      r5,r0
000034  d919              BLS      |L8.106|
;;;388        NumBytesRem = pRing->SizeOfBuffer - RdOff;
000036  68b0              LDR      r0,[r6,#8]
000038  1b44              SUBS     r4,r0,r5
;;;389        NumBytesRem = MIN(NumBytesRem, BufferSize);
00003a  42bc              CMP      r4,r7
00003c  d201              BCS      |L8.66|
00003e  4620              MOV      r0,r4
000040  e000              B        |L8.68|
                  |L8.66|
000042  4638              MOV      r0,r7
                  |L8.68|
000044  4604              MOV      r4,r0
;;;390        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
000046  6870              LDR      r0,[r6,#4]
000048  1941              ADDS     r1,r0,r5
00004a  4622              MOV      r2,r4
00004c  9801              LDR      r0,[sp,#4]
00004e  f7fffffe          BL       __aeabi_memcpy
;;;391        NumBytesRead += NumBytesRem;
000052  9803              LDR      r0,[sp,#0xc]
000054  1900              ADDS     r0,r0,r4
000056  9003              STR      r0,[sp,#0xc]
;;;392        pBuffer      += NumBytesRem;
000058  9801              LDR      r0,[sp,#4]
00005a  1900              ADDS     r0,r0,r4
00005c  9001              STR      r0,[sp,#4]
;;;393        BufferSize   -= NumBytesRem;
00005e  1b3f              SUBS     r7,r7,r4
;;;394        RdOff        += NumBytesRem;
000060  192d              ADDS     r5,r5,r4
;;;395        //
;;;396        // Handle wrap-around of buffer
;;;397        //
;;;398        if (RdOff == pRing->SizeOfBuffer) {
000062  68b0              LDR      r0,[r6,#8]
000064  42a8              CMP      r0,r5
000066  d100              BNE      |L8.106|
;;;399          RdOff = 0u;
000068  2500              MOVS     r5,#0
                  |L8.106|
;;;400        }
;;;401      }
;;;402      //
;;;403      // Read remaining items of buffer
;;;404      //
;;;405      NumBytesRem = WrOff - RdOff;
00006a  9802              LDR      r0,[sp,#8]
00006c  1b44              SUBS     r4,r0,r5
;;;406      NumBytesRem = MIN(NumBytesRem, BufferSize);
00006e  42bc              CMP      r4,r7
000070  d201              BCS      |L8.118|
000072  4620              MOV      r0,r4
000074  e000              B        |L8.120|
                  |L8.118|
000076  4638              MOV      r0,r7
                  |L8.120|
000078  4604              MOV      r4,r0
;;;407      if (NumBytesRem > 0u) {
00007a  2c00              CMP      r4,#0
00007c  d00d              BEQ      |L8.154|
;;;408        memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
00007e  6870              LDR      r0,[r6,#4]
000080  1941              ADDS     r1,r0,r5
000082  4622              MOV      r2,r4
000084  9801              LDR      r0,[sp,#4]
000086  f7fffffe          BL       __aeabi_memcpy
;;;409        NumBytesRead += NumBytesRem;
00008a  9803              LDR      r0,[sp,#0xc]
00008c  1900              ADDS     r0,r0,r4
00008e  9003              STR      r0,[sp,#0xc]
;;;410        pBuffer      += NumBytesRem;
000090  9801              LDR      r0,[sp,#4]
000092  1900              ADDS     r0,r0,r4
000094  9001              STR      r0,[sp,#4]
;;;411        BufferSize   -= NumBytesRem;
000096  1b3f              SUBS     r7,r7,r4
;;;412        RdOff        += NumBytesRem;
000098  192d              ADDS     r5,r5,r4
                  |L8.154|
;;;413      }
;;;414      if (NumBytesRead) {
00009a  9803              LDR      r0,[sp,#0xc]
00009c  2800              CMP      r0,#0
00009e  d000              BEQ      |L8.162|
;;;415        pRing->RdOff = RdOff;
0000a0  6135              STR      r5,[r6,#0x10]
                  |L8.162|
;;;416      }
;;;417      //
;;;418      return NumBytesRead;
0000a2  9803              LDR      r0,[sp,#0xc]
;;;419    }
0000a4  b007              ADD      sp,sp,#0x1c
0000a6  bdf0              POP      {r4-r7,pc}
;;;420    
                          ENDP

                  |L8.168|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameDownBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameDownBuffer PROC
;;;930    */
;;;931    int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;932      int r;
;;;933      volatile unsigned SavedState;
;;;934    
;;;935      INIT();
000006  bf00              NOP      
000008  4810              LDR      r0,|L9.76|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L9.20|
000010  f7fffffe          BL       _DoInit
                  |L9.20|
000014  bf00              NOP      
;;;936      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
000016  480d              LDR      r0,|L9.76|
000018  6940              LDR      r0,[r0,#0x14]  ; _SEGGER_RTT
00001a  42a0              CMP      r0,r4
00001c  d912              BLS      |L9.68|
;;;937        SEGGER_RTT_LOCK(SavedState);
00001e  2000              MOVS     r0,#0
000020  9001              STR      r0,[sp,#4]
000022  2100              MOVS     r1,#0
000024  9100              STR      r1,[sp,#0]
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       app_util_critical_region_enter
;;;938        _SEGGER_RTT.aDown[BufferIndex].sName = sName;
00002c  2018              MOVS     r0,#0x18
00002e  4360              MULS     r0,r4,r0
000030  4906              LDR      r1,|L9.76|
000032  3148              ADDS     r1,r1,#0x48
000034  500e              STR      r6,[r1,r0]
;;;939        SEGGER_RTT_UNLOCK(SavedState);
000036  bf00              NOP      
000038  4668              MOV      r0,sp
00003a  7800              LDRB     r0,[r0,#0]
00003c  f7fffffe          BL       app_util_critical_region_exit
;;;940        r =  0;
000040  2500              MOVS     r5,#0
000042  e001              B        |L9.72|
                  |L9.68|
;;;941      } else {
;;;942        r = -1;
000044  2500              MOVS     r5,#0
000046  43ed              MVNS     r5,r5
                  |L9.72|
;;;943      }
;;;944      return r;
000048  4628              MOV      r0,r5
;;;945    }
00004a  bd7c              POP      {r2-r6,pc}
;;;946    
                          ENDP

                  |L9.76|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetNameUpBuffer||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetNameUpBuffer PROC
;;;898    */
;;;899    int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;900      int r;
;;;901      volatile unsigned SavedState;
;;;902    
;;;903      INIT();
000006  bf00              NOP      
000008  4810              LDR      r0,|L10.76|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L10.20|
000010  f7fffffe          BL       _DoInit
                  |L10.20|
000014  bf00              NOP      
;;;904      if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
000016  480d              LDR      r0,|L10.76|
000018  6900              LDR      r0,[r0,#0x10]  ; _SEGGER_RTT
00001a  42a0              CMP      r0,r4
00001c  d912              BLS      |L10.68|
;;;905        SEGGER_RTT_LOCK(SavedState);
00001e  2000              MOVS     r0,#0
000020  9001              STR      r0,[sp,#4]
000022  2100              MOVS     r1,#0
000024  9100              STR      r1,[sp,#0]
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       app_util_critical_region_enter
;;;906        _SEGGER_RTT.aUp[BufferIndex].sName = sName;
00002c  2018              MOVS     r0,#0x18
00002e  4360              MULS     r0,r4,r0
000030  4906              LDR      r1,|L10.76|
000032  3118              ADDS     r1,r1,#0x18
000034  500e              STR      r6,[r1,r0]
;;;907        SEGGER_RTT_UNLOCK(SavedState);
000036  bf00              NOP      
000038  4668              MOV      r0,sp
00003a  7800              LDRB     r0,[r0,#0]
00003c  f7fffffe          BL       app_util_critical_region_exit
;;;908        r =  0;
000040  2500              MOVS     r5,#0
000042  e001              B        |L10.72|
                  |L10.68|
;;;909      } else {
;;;910        r = -1;
000044  2500              MOVS     r5,#0
000046  43ed              MVNS     r5,r5
                  |L10.72|
;;;911      }
;;;912      return r;
000048  4628              MOV      r0,r5
;;;913    }
00004a  bd7c              POP      {r2-r6,pc}
;;;914    
                          ENDP

                  |L10.76|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_SetTerminal||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_SetTerminal PROC
;;;973    */
;;;974    int SEGGER_RTT_SetTerminal (char TerminalId) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
;;;975      char ac[2];
;;;976      SEGGER_RTT_RING_BUFFER *pRing;
;;;977      volatile unsigned SavedState;
;;;978      unsigned Avail;
;;;979      int r;
;;;980      //
;;;981      INIT();
000004  bf00              NOP      
000006  4820              LDR      r0,|L11.136|
000008  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000a  2800              CMP      r0,#0
00000c  d101              BNE      |L11.18|
00000e  f7fffffe          BL       _DoInit
                  |L11.18|
000012  bf00              NOP      
;;;982      //
;;;983      r = 0;
000014  2700              MOVS     r7,#0
;;;984      ac[0] = 0xFFU;
000016  20ff              MOVS     r0,#0xff
000018  4669              MOV      r1,sp
00001a  7208              STRB     r0,[r1,#8]
;;;985      if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
00001c  2c10              CMP      r4,#0x10
00001e  da2f              BGE      |L11.128|
;;;986        ac[1] = _aTerminalId[(unsigned char)TerminalId];
000020  481a              LDR      r0,|L11.140|
000022  5d01              LDRB     r1,[r0,r4]
000024  4668              MOV      r0,sp
000026  7241              STRB     r1,[r0,#9]
;;;987        pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
000028  4d17              LDR      r5,|L11.136|
00002a  3518              ADDS     r5,r5,#0x18
;;;988        SEGGER_RTT_LOCK(SavedState);    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
00002c  2000              MOVS     r0,#0
00002e  9001              STR      r0,[sp,#4]
000030  2100              MOVS     r1,#0
000032  9100              STR      r1,[sp,#0]
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       app_util_critical_region_enter
;;;989        if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
00003a  7d28              LDRB     r0,[r5,#0x14]
00003c  0780              LSLS     r0,r0,#30
00003e  0f80              LSRS     r0,r0,#30
000040  2802              CMP      r0,#2
000042  d107              BNE      |L11.84|
;;;990          _ActiveTerminal = TerminalId;
000044  4812              LDR      r0,|L11.144|
000046  7004              STRB     r4,[r0,#0]
;;;991          _WriteBlocking(pRing, ac, 2u);
000048  2202              MOVS     r2,#2
00004a  a902              ADD      r1,sp,#8
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       _WriteBlocking
000052  e00f              B        |L11.116|
                  |L11.84|
;;;992        } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
;;;993          Avail = _GetAvailWriteSpace(pRing);
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       _GetAvailWriteSpace
00005a  4606              MOV      r6,r0
;;;994          if (Avail >= 2) {
00005c  2e02              CMP      r6,#2
00005e  d307              BCC      |L11.112|
;;;995            _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
000060  480b              LDR      r0,|L11.144|
000062  7004              STRB     r4,[r0,#0]
;;;996            _WriteNoCheck(pRing, ac, 2u);
000064  2202              MOVS     r2,#2
000066  a902              ADD      r1,sp,#8
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       _WriteNoCheck
00006e  e001              B        |L11.116|
                  |L11.112|
;;;997          } else {
;;;998            r = -1;
000070  2700              MOVS     r7,#0
000072  43ff              MVNS     r7,r7
                  |L11.116|
;;;999          }
;;;1000       }
;;;1001       SEGGER_RTT_UNLOCK(SavedState);
000074  bf00              NOP      
000076  4668              MOV      r0,sp
000078  7800              LDRB     r0,[r0,#0]
00007a  f7fffffe          BL       app_util_critical_region_exit
00007e  e001              B        |L11.132|
                  |L11.128|
;;;1002     } else {
;;;1003       r = -1;
000080  2700              MOVS     r7,#0
000082  43ff              MVNS     r7,r7
                  |L11.132|
;;;1004     }
;;;1005     return r;
000084  4638              MOV      r0,r7
;;;1006   }
000086  bdfe              POP      {r1-r7,pc}
;;;1007   
                          ENDP

                  |L11.136|
                          DCD      _SEGGER_RTT
                  |L11.140|
                          DCD      _aTerminalId
                  |L11.144|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_TerminalOut||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_TerminalOut PROC
;;;1024   */
;;;1025   int SEGGER_RTT_TerminalOut (char TerminalId, const char* s) {
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
000002  b083              SUB      sp,sp,#0xc
000004  4607              MOV      r7,r0
;;;1026     int  Status;
;;;1027     unsigned  FragLen;
;;;1028     unsigned  Avail;
;;;1029     SEGGER_RTT_RING_BUFFER *pRing;
;;;1030     volatile unsigned SavedState;
;;;1031     //
;;;1032     INIT();
000006  bf00              NOP      
000008  4839              LDR      r0,|L12.240|
00000a  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000c  2800              CMP      r0,#0
00000e  d101              BNE      |L12.20|
000010  f7fffffe          BL       _DoInit
                  |L12.20|
000014  bf00              NOP      
;;;1033     //
;;;1034     // Validate terminal ID.
;;;1035     //
;;;1036     if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
000016  2f10              CMP      r7,#0x10
000018  da65              BGE      |L12.230|
;;;1037       //
;;;1038       // Get "to-host" ring buffer.
;;;1039       //
;;;1040       pRing = &_SEGGER_RTT.aUp[0];
00001a  4835              LDR      r0,|L12.240|
00001c  3018              ADDS     r0,r0,#0x18
00001e  9002              STR      r0,[sp,#8]
;;;1041       //
;;;1042       // Need to be able to change terminal, write data, change back.
;;;1043       // Compute the fixed and variable sizes.
;;;1044       //
;;;1045       FragLen = strlen(s);
000020  9804              LDR      r0,[sp,#0x10]
000022  f7fffffe          BL       strlen
000026  4606              MOV      r6,r0
;;;1046       //
;;;1047       // How we output depends upon the mode...
;;;1048       //
;;;1049       SEGGER_RTT_LOCK(SavedState);
000028  2000              MOVS     r0,#0
00002a  9001              STR      r0,[sp,#4]
00002c  9000              STR      r0,[sp,#0]
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       app_util_critical_region_enter
;;;1050       Avail = _GetAvailWriteSpace(pRing);
000034  9802              LDR      r0,[sp,#8]
000036  f7fffffe          BL       _GetAvailWriteSpace
00003a  4605              MOV      r5,r0
;;;1051       switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
00003c  9802              LDR      r0,[sp,#8]
00003e  7d00              LDRB     r0,[r0,#0x14]
000040  0780              LSLS     r0,r0,#30
000042  0f80              LSRS     r0,r0,#30
000044  2800              CMP      r0,#0
000046  d004              BEQ      |L12.82|
000048  2801              CMP      r0,#1
00004a  d017              BEQ      |L12.124|
00004c  2802              CMP      r0,#2
00004e  d140              BNE      |L12.210|
000050  e02f              B        |L12.178|
                  |L12.82|
;;;1052       case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;1053         //
;;;1054         // If we are in skip mode and there is no space for the whole
;;;1055         // of this output, don't bother switching terminals at all.
;;;1056         //
;;;1057         if (Avail < (FragLen + 4u)) {
000052  1d30              ADDS     r0,r6,#4
000054  4285              CMP      r5,r0
000056  d201              BCS      |L12.92|
;;;1058           Status = 0;
000058  2400              MOVS     r4,#0
00005a  e00e              B        |L12.122|
                  |L12.92|
;;;1059         } else {
;;;1060           _PostTerminalSwitch(pRing, TerminalId);
00005c  4639              MOV      r1,r7
00005e  9802              LDR      r0,[sp,#8]
000060  f7fffffe          BL       _PostTerminalSwitch
;;;1061           Status = (int)_WriteBlocking(pRing, s, FragLen);
000064  4632              MOV      r2,r6
000066  9904              LDR      r1,[sp,#0x10]
000068  9802              LDR      r0,[sp,#8]
00006a  f7fffffe          BL       _WriteBlocking
00006e  4604              MOV      r4,r0
;;;1062           _PostTerminalSwitch(pRing, _ActiveTerminal);
000070  4820              LDR      r0,|L12.244|
000072  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
000074  9802              LDR      r0,[sp,#8]
000076  f7fffffe          BL       _PostTerminalSwitch
                  |L12.122|
;;;1063         }
;;;1064         break;
00007a  e02d              B        |L12.216|
                  |L12.124|
;;;1065       case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;1066         //
;;;1067         // If we are in trim mode and there is not enough space for everything,
;;;1068         // trim the output but always include the terminal switch.  If no room
;;;1069         // for terminal switch, skip that totally.
;;;1070         //
;;;1071         if (Avail < 4u) {
00007c  2d04              CMP      r5,#4
00007e  d202              BCS      |L12.134|
;;;1072           Status = -1;
000080  2400              MOVS     r4,#0
000082  43e4              MVNS     r4,r4
000084  e014              B        |L12.176|
                  |L12.134|
;;;1073         } else {
;;;1074           _PostTerminalSwitch(pRing, TerminalId);
000086  4639              MOV      r1,r7
000088  9802              LDR      r0,[sp,#8]
00008a  f7fffffe          BL       _PostTerminalSwitch
;;;1075           Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
00008e  1f28              SUBS     r0,r5,#4
000090  42b0              CMP      r0,r6
000092  d901              BLS      |L12.152|
000094  4630              MOV      r0,r6
000096  e000              B        |L12.154|
                  |L12.152|
000098  1f28              SUBS     r0,r5,#4
                  |L12.154|
00009a  4602              MOV      r2,r0
00009c  9904              LDR      r1,[sp,#0x10]
00009e  9802              LDR      r0,[sp,#8]
0000a0  f7fffffe          BL       _WriteBlocking
0000a4  4604              MOV      r4,r0
;;;1076           _PostTerminalSwitch(pRing, _ActiveTerminal);
0000a6  4813              LDR      r0,|L12.244|
0000a8  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000aa  9802              LDR      r0,[sp,#8]
0000ac  f7fffffe          BL       _PostTerminalSwitch
                  |L12.176|
;;;1077         }
;;;1078         break;
0000b0  e012              B        |L12.216|
                  |L12.178|
;;;1079       case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;1080         //
;;;1081         // If we are in blocking mode, output everything.
;;;1082         //
;;;1083         _PostTerminalSwitch(pRing, TerminalId);
0000b2  4639              MOV      r1,r7
0000b4  9802              LDR      r0,[sp,#8]
0000b6  f7fffffe          BL       _PostTerminalSwitch
;;;1084         Status = (int)_WriteBlocking(pRing, s, FragLen);
0000ba  4632              MOV      r2,r6
0000bc  9904              LDR      r1,[sp,#0x10]
0000be  9802              LDR      r0,[sp,#8]
0000c0  f7fffffe          BL       _WriteBlocking
0000c4  4604              MOV      r4,r0
;;;1085         _PostTerminalSwitch(pRing, _ActiveTerminal);
0000c6  480b              LDR      r0,|L12.244|
0000c8  7801              LDRB     r1,[r0,#0]  ; _ActiveTerminal
0000ca  9802              LDR      r0,[sp,#8]
0000cc  f7fffffe          BL       _PostTerminalSwitch
;;;1086         break;
0000d0  e002              B        |L12.216|
                  |L12.210|
;;;1087       default:
;;;1088         Status = -1;
0000d2  2400              MOVS     r4,#0
0000d4  43e4              MVNS     r4,r4
;;;1089         break;
0000d6  bf00              NOP      
                  |L12.216|
0000d8  bf00              NOP                            ;1064
;;;1090       }
;;;1091       //
;;;1092       // Finish up.
;;;1093       //
;;;1094       SEGGER_RTT_UNLOCK(SavedState);
0000da  bf00              NOP      
0000dc  4668              MOV      r0,sp
0000de  7800              LDRB     r0,[r0,#0]
0000e0  f7fffffe          BL       app_util_critical_region_exit
0000e4  e001              B        |L12.234|
                  |L12.230|
;;;1095     } else {
;;;1096       Status = -1;
0000e6  2400              MOVS     r4,#0
0000e8  43e4              MVNS     r4,r4
                  |L12.234|
;;;1097     }
;;;1098     return Status;
0000ea  4620              MOV      r0,r4
;;;1099   }
0000ec  b005              ADD      sp,sp,#0x14
0000ee  bdf0              POP      {r4-r7,pc}
;;;1100   
                          ENDP

                  |L12.240|
                          DCD      _SEGGER_RTT
                  |L12.244|
                          DCD      _ActiveTerminal

                          AREA ||i.SEGGER_RTT_WaitKey||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WaitKey PROC
;;;737    */
;;;738    int SEGGER_RTT_WaitKey(void) {
000000  b510              PUSH     {r4,lr}
;;;739      int r;
;;;740    
;;;741      do {
000002  bf00              NOP      
                  |L13.4|
;;;742        r = SEGGER_RTT_GetKey();
000004  f7fffffe          BL       SEGGER_RTT_GetKey
;;;743      } while (r < 0);
000008  2800              CMP      r0,#0
00000a  dbfb              BLT      |L13.4|
;;;744      return r;
;;;745    }
00000c  bd10              POP      {r4,pc}
;;;746    
                          ENDP


                          AREA ||i.SEGGER_RTT_Write||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_Write PROC
;;;648    */
;;;649    unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;650      unsigned Status;
;;;651      volatile unsigned SavedState;
;;;652      //
;;;653      INIT();
000008  bf00              NOP      
00000a  480d              LDR      r0,|L14.64|
00000c  7800              LDRB     r0,[r0,#0]  ; _SEGGER_RTT
00000e  2800              CMP      r0,#0
000010  d101              BNE      |L14.22|
000012  f7fffffe          BL       _DoInit
                  |L14.22|
000016  bf00              NOP      
;;;654      SEGGER_RTT_LOCK(SavedState);
000018  2000              MOVS     r0,#0
00001a  9001              STR      r0,[sp,#4]
00001c  2100              MOVS     r1,#0
00001e  9100              STR      r1,[sp,#0]
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       app_util_critical_region_enter
;;;655      //
;;;656      // Call the non-locking write function
;;;657      //
;;;658      Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
000026  4632              MOV      r2,r6
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       SEGGER_RTT_WriteNoLock
000030  4607              MOV      r7,r0
;;;659      //
;;;660      // Finish up.
;;;661      //
;;;662      SEGGER_RTT_UNLOCK(SavedState);
000032  bf00              NOP      
000034  4668              MOV      r0,sp
000036  7800              LDRB     r0,[r0,#0]
000038  f7fffffe          BL       app_util_critical_region_exit
;;;663      //
;;;664      return Status;
00003c  4638              MOV      r0,r7
;;;665    }
00003e  bdfe              POP      {r1-r7,pc}
;;;666    
                          ENDP

                  |L14.64|
                          DCD      _SEGGER_RTT

                          AREA ||i.SEGGER_RTT_WriteNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteNoLock PROC
;;;577    */
;;;578    unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4607              MOV      r7,r0
000006  4616              MOV      r6,r2
;;;579      unsigned Status;
;;;580      unsigned Avail;
;;;581      const char*  pData;
;;;582      SEGGER_RTT_RING_BUFFER *pRing;
;;;583    
;;;584      pData = (const char *)pBuffer;
000008  9803              LDR      r0,[sp,#0xc]
00000a  9001              STR      r0,[sp,#4]
;;;585      //
;;;586      // Get "to-host" ring buffer.
;;;587      //
;;;588      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000c  2018              MOVS     r0,#0x18
00000e  4378              MULS     r0,r7,r0
000010  491b              LDR      r1,|L15.128|
000012  1840              ADDS     r0,r0,r1
000014  9000              STR      r0,[sp,#0]
;;;589      //
;;;590      // How we output depends upon the mode...
;;;591      //
;;;592      switch (pRing->Flags) {
000016  9800              LDR      r0,[sp,#0]
000018  6940              LDR      r0,[r0,#0x14]
00001a  2800              CMP      r0,#0
00001c  d004              BEQ      |L15.40|
00001e  2801              CMP      r0,#1
000020  d011              BEQ      |L15.70|
000022  2802              CMP      r0,#2
000024  d126              BNE      |L15.116|
000026  e01e              B        |L15.102|
                  |L15.40|
;;;593      case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
;;;594        //
;;;595        // If we are in skip mode and there is no space for the whole
;;;596        // of this output, don't bother.
;;;597        //
;;;598        Avail = _GetAvailWriteSpace(pRing);
000028  9800              LDR      r0,[sp,#0]
00002a  f7fffffe          BL       _GetAvailWriteSpace
00002e  4605              MOV      r5,r0
;;;599        if (Avail < NumBytes) {
000030  42b5              CMP      r5,r6
000032  d201              BCS      |L15.56|
;;;600          Status = 0u;
000034  2400              MOVS     r4,#0
000036  e005              B        |L15.68|
                  |L15.56|
;;;601        } else {
;;;602          Status = NumBytes;
000038  4634              MOV      r4,r6
;;;603          _WriteNoCheck(pRing, pData, NumBytes);
00003a  4632              MOV      r2,r6
00003c  9901              LDR      r1,[sp,#4]
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       _WriteNoCheck
                  |L15.68|
;;;604        }
;;;605        break;
000044  e018              B        |L15.120|
                  |L15.70|
;;;606      case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
;;;607        //
;;;608        // If we are in trim mode, trim to what we can output without blocking.
;;;609        //
;;;610        Avail = _GetAvailWriteSpace(pRing);
000046  9800              LDR      r0,[sp,#0]
000048  f7fffffe          BL       _GetAvailWriteSpace
00004c  4605              MOV      r5,r0
;;;611        Status = Avail < NumBytes ? Avail : NumBytes;
00004e  42b5              CMP      r5,r6
000050  d201              BCS      |L15.86|
000052  4628              MOV      r0,r5
000054  e000              B        |L15.88|
                  |L15.86|
000056  4630              MOV      r0,r6
                  |L15.88|
000058  4604              MOV      r4,r0
;;;612        _WriteNoCheck(pRing, pData, Status);
00005a  4622              MOV      r2,r4
00005c  9901              LDR      r1,[sp,#4]
00005e  9800              LDR      r0,[sp,#0]
000060  f7fffffe          BL       _WriteNoCheck
;;;613        break;
000064  e008              B        |L15.120|
                  |L15.102|
;;;614      case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
;;;615        //
;;;616        // If we are in blocking mode, output everything.
;;;617        //
;;;618        Status = _WriteBlocking(pRing, pData, NumBytes);
000066  4632              MOV      r2,r6
000068  9901              LDR      r1,[sp,#4]
00006a  9800              LDR      r0,[sp,#0]
00006c  f7fffffe          BL       _WriteBlocking
000070  4604              MOV      r4,r0
;;;619        break;
000072  e001              B        |L15.120|
                  |L15.116|
;;;620      default:
;;;621        Status = 0u;
000074  2400              MOVS     r4,#0
;;;622        break;
000076  bf00              NOP      
                  |L15.120|
000078  bf00              NOP                            ;605
;;;623      }
;;;624      //
;;;625      // Finish up.
;;;626      //
;;;627      return Status;
00007a  4620              MOV      r0,r4
;;;628    }
00007c  b005              ADD      sp,sp,#0x14
00007e  bdf0              POP      {r4-r7,pc}
;;;629    
                          ENDP

                  |L15.128|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteSkipNoLock||, CODE, READONLY, ALIGN=2

                  SEGGER_RTT_WriteSkipNoLock PROC
;;;477    */
;;;478    unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b084              SUB      sp,sp,#0x10
000004  4616              MOV      r6,r2
;;;479      const char*  pData;
;;;480      SEGGER_RTT_RING_BUFFER* pRing;
;;;481      unsigned     Avail;
;;;482      unsigned     RdOff;
;;;483      unsigned     WrOff;
;;;484      unsigned     Rem;
;;;485    
;;;486      pData = (const char *)pBuffer;
000006  9805              LDR      r0,[sp,#0x14]
000008  9003              STR      r0,[sp,#0xc]
;;;487      //
;;;488      // Get "to-host" ring buffer and copy some elements into local variables.
;;;489      //
;;;490      pRing = &_SEGGER_RTT.aUp[BufferIndex];
00000a  2118              MOVS     r1,#0x18
00000c  9804              LDR      r0,[sp,#0x10]
00000e  4348              MULS     r0,r1,r0
000010  4927              LDR      r1,|L16.176|
000012  1844              ADDS     r4,r0,r1
;;;491      RdOff = pRing->RdOff;
000014  6920              LDR      r0,[r4,#0x10]
000016  9002              STR      r0,[sp,#8]
;;;492      WrOff = pRing->WrOff;
000018  68e5              LDR      r5,[r4,#0xc]
;;;493      //
;;;494      // Handle the most common cases fastest.
;;;495      // Which is:
;;;496      //    RdOff <= WrOff -> Space until wrap around is free.
;;;497      //  AND
;;;498      //    WrOff + NumBytes < SizeOfBuffer -> No Wrap around necessary.
;;;499      //
;;;500      //  OR
;;;501      //
;;;502      //    RdOff > WrOff -> Space until RdOff - 1 is free.
;;;503      //  AND
;;;504      //    WrOff + NumBytes < RdOff -> Data fits into buffer
;;;505      //
;;;506      if (RdOff <= WrOff) {
00001a  9802              LDR      r0,[sp,#8]
00001c  42a8              CMP      r0,r5
00001e  d836              BHI      |L16.142|
;;;507        //
;;;508        // Get space until WrOff will be at wrap around.
;;;509        //
;;;510        Avail = pRing->SizeOfBuffer - 1u - WrOff ;
000020  68a0              LDR      r0,[r4,#8]
000022  1e40              SUBS     r0,r0,#1
000024  1b47              SUBS     r7,r0,r5
;;;511        if (Avail >= NumBytes) {
000026  42b7              CMP      r7,r6
000028  d30a              BCC      |L16.64|
;;;512          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
00002a  6861              LDR      r1,[r4,#4]
00002c  1948              ADDS     r0,r1,r5
00002e  4632              MOV      r2,r6
000030  9903              LDR      r1,[sp,#0xc]
000032  f7fffffe          BL       __aeabi_memcpy
;;;513          pRing->WrOff = WrOff + NumBytes;
000036  19a8              ADDS     r0,r5,r6
000038  60e0              STR      r0,[r4,#0xc]
;;;514          return 1;
00003a  2001              MOVS     r0,#1
                  |L16.60|
;;;515        }
;;;516        //
;;;517        // If data did not fit into space until wrap around calculate complete space in buffer.
;;;518        //
;;;519        Avail += RdOff;
;;;520        //
;;;521        // If there is still no space for the whole of this output, don't bother.
;;;522        //
;;;523        if (Avail >= NumBytes) {
;;;524          //
;;;525          //  OK, we have enough space in buffer. Copy in one or 2 chunks
;;;526          //
;;;527          Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
;;;528          if (Rem > NumBytes) {
;;;529            memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;530            pRing->WrOff = WrOff + NumBytes;
;;;531          } else {
;;;532            //
;;;533            // We reach the end of the buffer, so need to wrap around
;;;534            //
;;;535            memcpy(pRing->pBuffer + WrOff, pData, Rem);
;;;536            memcpy(pRing->pBuffer, pData + Rem, NumBytes - Rem);
;;;537            pRing->WrOff = NumBytes - Rem;
;;;538          }
;;;539          return 1;
;;;540        }
;;;541      } else {
;;;542        Avail = RdOff - WrOff - 1u;
;;;543        if (Avail >= NumBytes) {
;;;544          memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
;;;545          pRing->WrOff = WrOff + NumBytes;
;;;546          return 1;
;;;547        }
;;;548      }
;;;549      //
;;;550      // If we reach this point no data has been written
;;;551      //
;;;552      return 0;
;;;553    }
00003c  b007              ADD      sp,sp,#0x1c
00003e  bdf0              POP      {r4-r7,pc}
                  |L16.64|
000040  9802              LDR      r0,[sp,#8]            ;519
000042  183f              ADDS     r7,r7,r0              ;519
000044  42b7              CMP      r7,r6                 ;523
000046  d331              BCC      |L16.172|
000048  68a0              LDR      r0,[r4,#8]            ;527
00004a  1b40              SUBS     r0,r0,r5              ;527
00004c  9001              STR      r0,[sp,#4]            ;527
00004e  9801              LDR      r0,[sp,#4]            ;528
000050  42b0              CMP      r0,r6                 ;528
000052  d908              BLS      |L16.102|
000054  6861              LDR      r1,[r4,#4]            ;529
000056  1948              ADDS     r0,r1,r5              ;529
000058  4632              MOV      r2,r6                 ;529
00005a  9903              LDR      r1,[sp,#0xc]          ;529
00005c  f7fffffe          BL       __aeabi_memcpy
000060  19a8              ADDS     r0,r5,r6              ;530
000062  60e0              STR      r0,[r4,#0xc]          ;530
000064  e011              B        |L16.138|
                  |L16.102|
000066  6861              LDR      r1,[r4,#4]            ;535
000068  1948              ADDS     r0,r1,r5              ;535
00006a  9a01              LDR      r2,[sp,#4]            ;535
00006c  9903              LDR      r1,[sp,#0xc]          ;535
00006e  f7fffffe          BL       __aeabi_memcpy
000072  9801              LDR      r0,[sp,#4]            ;536
000074  1a32              SUBS     r2,r6,r0              ;536
000076  9b01              LDR      r3,[sp,#4]            ;536
000078  9803              LDR      r0,[sp,#0xc]          ;536
00007a  18c1              ADDS     r1,r0,r3              ;536
00007c  6860              LDR      r0,[r4,#4]            ;536
00007e  9000              STR      r0,[sp,#0]            ;536
000080  f7fffffe          BL       __aeabi_memcpy
000084  9801              LDR      r0,[sp,#4]            ;537
000086  1a30              SUBS     r0,r6,r0              ;537
000088  60e0              STR      r0,[r4,#0xc]          ;537
                  |L16.138|
00008a  2001              MOVS     r0,#1                 ;539
00008c  e7d6              B        |L16.60|
                  |L16.142|
00008e  9802              LDR      r0,[sp,#8]            ;542
000090  1b40              SUBS     r0,r0,r5              ;542
000092  1e47              SUBS     r7,r0,#1              ;542
000094  42b7              CMP      r7,r6                 ;543
000096  d309              BCC      |L16.172|
000098  6861              LDR      r1,[r4,#4]            ;544
00009a  1948              ADDS     r0,r1,r5              ;544
00009c  4632              MOV      r2,r6                 ;544
00009e  9903              LDR      r1,[sp,#0xc]          ;544
0000a0  f7fffffe          BL       __aeabi_memcpy
0000a4  19a8              ADDS     r0,r5,r6              ;545
0000a6  60e0              STR      r0,[r4,#0xc]          ;545
0000a8  2001              MOVS     r0,#1                 ;546
0000aa  e7c7              B        |L16.60|
                  |L16.172|
0000ac  2000              MOVS     r0,#0                 ;552
0000ae  e7c5              B        |L16.60|
;;;554    
                          ENDP

                  |L16.176|
                          DCD      _SEGGER_RTT+0x18

                          AREA ||i.SEGGER_RTT_WriteString||, CODE, READONLY, ALIGN=1

                  SEGGER_RTT_WriteString PROC
;;;687    */
;;;688    unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;689      unsigned Len;
;;;690    
;;;691      Len = STRLEN(s);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       strlen
00000c  4606              MOV      r6,r0
;;;692      return SEGGER_RTT_Write(BufferIndex, s, Len);
00000e  4632              MOV      r2,r6
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SEGGER_RTT_Write
;;;693    }
000018  bd70              POP      {r4-r6,pc}
;;;694    
                          ENDP


                          AREA ||i._DoInit||, CODE, READONLY, ALIGN=2

                  _DoInit PROC
;;;162                    } while (0)
;;;163    static void _DoInit(void) {
000000  b510              PUSH     {r4,lr}
;;;164      SEGGER_RTT_CB* p;
;;;165      //
;;;166      // Initialize control block
;;;167      //
;;;168      p = &_SEGGER_RTT;
000002  4c11              LDR      r4,|L18.72|
;;;169      p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
000004  2002              MOVS     r0,#2
000006  6120              STR      r0,[r4,#0x10]
;;;170      p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
000008  6160              STR      r0,[r4,#0x14]
;;;171      //
;;;172      // Initialize up buffer 0
;;;173      //
;;;174      p->aUp[0].sName         = "Terminal";
00000a  a010              ADR      r0,|L18.76|
00000c  61a0              STR      r0,[r4,#0x18]
;;;175      p->aUp[0].pBuffer       = _acUpBuffer;
00000e  4912              LDR      r1,|L18.88|
000010  61e1              STR      r1,[r4,#0x1c]
;;;176      p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
000012  2140              MOVS     r1,#0x40
000014  6221              STR      r1,[r4,#0x20]
;;;177      p->aUp[0].RdOff         = 0u;
000016  2100              MOVS     r1,#0
000018  62a1              STR      r1,[r4,#0x28]
;;;178      p->aUp[0].WrOff         = 0u;
00001a  6261              STR      r1,[r4,#0x24]
;;;179      p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
00001c  62e1              STR      r1,[r4,#0x2c]
;;;180      //
;;;181      // Initialize down buffer 0
;;;182      //
;;;183      p->aDown[0].sName         = "Terminal";
00001e  a00b              ADR      r0,|L18.76|
000020  64a0              STR      r0,[r4,#0x48]
;;;184      p->aDown[0].pBuffer       = _acDownBuffer;
000022  490e              LDR      r1,|L18.92|
000024  64e1              STR      r1,[r4,#0x4c]
;;;185      p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
000026  2110              MOVS     r1,#0x10
000028  6521              STR      r1,[r4,#0x50]
;;;186      p->aDown[0].RdOff         = 0u;
00002a  2100              MOVS     r1,#0
00002c  65a1              STR      r1,[r4,#0x58]
;;;187      p->aDown[0].WrOff         = 0u;
00002e  6561              STR      r1,[r4,#0x54]
;;;188      p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
000030  65e1              STR      r1,[r4,#0x5c]
;;;189      //
;;;190      // Finish initialization of the control block.
;;;191      // Copy Id string in three steps to make sure "SEGGER RTT" is not found
;;;192      // in initializer memory (usually flash) by J-Link
;;;193      //
;;;194      strcpy(&p->acID[7], "RTT");
000032  a10b              ADR      r1,|L18.96|
000034  1de0              ADDS     r0,r4,#7
000036  f7fffffe          BL       strcpy
;;;195      strcpy(&p->acID[0], "SEGGER");
00003a  a10a              ADR      r1,|L18.100|
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       strcpy
;;;196      p->acID[6] = ' ';
000042  2020              MOVS     r0,#0x20
000044  71a0              STRB     r0,[r4,#6]
;;;197    }
000046  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L18.72|
                          DCD      _SEGGER_RTT
                  |L18.76|
00004c  5465726d          DCB      "Terminal",0
000050  696e616c
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L18.88|
                          DCD      _acUpBuffer
                  |L18.92|
                          DCD      _acDownBuffer
                  |L18.96|
000060  52545400          DCB      "RTT",0
                  |L18.100|
000064  53454747          DCB      "SEGGER",0
000068  455200  
00006b  00                DCB      0

                          AREA ||i._GetAvailWriteSpace||, CODE, READONLY, ALIGN=1

                  _GetAvailWriteSpace PROC
;;;328    */
;;;329    static unsigned _GetAvailWriteSpace(SEGGER_RTT_RING_BUFFER *pRing) {
000000  b510              PUSH     {r4,lr}
000002  4601              MOV      r1,r0
;;;330      unsigned RdOff;
;;;331      unsigned WrOff;
;;;332      unsigned r;
;;;333      //
;;;334      // Avoid warnings regarding volatile access order.  It's not a problem
;;;335      // in this case, but dampen compiler enthusiasm.
;;;336      //
;;;337      RdOff = pRing->RdOff;
000004  690a              LDR      r2,[r1,#0x10]
;;;338      WrOff = pRing->WrOff;
000006  68cb              LDR      r3,[r1,#0xc]
;;;339      if (RdOff <= WrOff) {
000008  429a              CMP      r2,r3
00000a  d804              BHI      |L19.22|
;;;340        r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
00000c  688c              LDR      r4,[r1,#8]
00000e  1e64              SUBS     r4,r4,#1
000010  1ae4              SUBS     r4,r4,r3
000012  18a0              ADDS     r0,r4,r2
000014  e001              B        |L19.26|
                  |L19.22|
;;;341      } else {
;;;342        r = RdOff - WrOff - 1u;
000016  1ad4              SUBS     r4,r2,r3
000018  1e60              SUBS     r0,r4,#1
                  |L19.26|
;;;343      }
;;;344      return r;
;;;345    }
00001a  bd10              POP      {r4,pc}
;;;346    
                          ENDP


                          AREA ||i._PostTerminalSwitch||, CODE, READONLY, ALIGN=2

                  _PostTerminalSwitch PROC
;;;306    */
;;;307    static void _PostTerminalSwitch(SEGGER_RTT_RING_BUFFER *pRing, char TerminalId) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;308      char ac[2];
;;;309    
;;;310      ac[0] = 0xFFu;
000006  21ff              MOVS     r1,#0xff
000008  4668              MOV      r0,sp
00000a  7001              STRB     r1,[r0,#0]
;;;311      ac[1] = _aTerminalId[(unsigned char)TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
00000c  4804              LDR      r0,|L20.32|
00000e  5d01              LDRB     r1,[r0,r4]
000010  4668              MOV      r0,sp
000012  7041              STRB     r1,[r0,#1]
;;;312      _WriteBlocking(pRing, ac, 2u);
000014  2202              MOVS     r2,#2
000016  4669              MOV      r1,sp
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       _WriteBlocking
;;;313    }
00001e  bd38              POP      {r3-r5,pc}
;;;314    
                          ENDP

                  |L20.32|
                          DCD      _aTerminalId

                          AREA ||i._WriteBlocking||, CODE, READONLY, ALIGN=1

                  _WriteBlocking PROC
;;;217    */
;;;218    static unsigned _WriteBlocking(SEGGER_RTT_RING_BUFFER *pRing, const char* pBuffer, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4617              MOV      r7,r2
;;;219      unsigned NumBytesToWrite;
;;;220      unsigned NumBytesWritten;
;;;221      unsigned RdOff;
;;;222      unsigned WrOff;
;;;223      //
;;;224      // Write data to buffer and handle wrap-around if necessary
;;;225      //
;;;226      NumBytesWritten = 0u;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;227      WrOff = pRing->WrOff;
00000c  68e5              LDR      r5,[r4,#0xc]
;;;228      do {
00000e  bf00              NOP      
                  |L21.16|
;;;229        RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
000010  6920              LDR      r0,[r4,#0x10]
000012  9000              STR      r0,[sp,#0]
;;;230        if (RdOff > WrOff) {
000014  9800              LDR      r0,[sp,#0]
000016  42a8              CMP      r0,r5
000018  d903              BLS      |L21.34|
;;;231          NumBytesToWrite = RdOff - WrOff - 1u;
00001a  9800              LDR      r0,[sp,#0]
00001c  1b40              SUBS     r0,r0,r5
00001e  1e46              SUBS     r6,r0,#1
000020  e004              B        |L21.44|
                  |L21.34|
;;;232        } else {
;;;233          NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
000022  68a1              LDR      r1,[r4,#8]
000024  9800              LDR      r0,[sp,#0]
000026  1a28              SUBS     r0,r5,r0
000028  1c40              ADDS     r0,r0,#1
00002a  1a0e              SUBS     r6,r1,r0
                  |L21.44|
;;;234        }
;;;235        NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
00002c  68a0              LDR      r0,[r4,#8]
00002e  1b40              SUBS     r0,r0,r5
000030  42b0              CMP      r0,r6
000032  d901              BLS      |L21.56|
000034  4630              MOV      r0,r6
000036  e001              B        |L21.60|
                  |L21.56|
000038  68a0              LDR      r0,[r4,#8]
00003a  1b40              SUBS     r0,r0,r5
                  |L21.60|
00003c  4606              MOV      r6,r0
;;;236        NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
00003e  42be              CMP      r6,r7
000040  d201              BCS      |L21.70|
000042  4630              MOV      r0,r6
000044  e000              B        |L21.72|
                  |L21.70|
000046  4638              MOV      r0,r7
                  |L21.72|
000048  4606              MOV      r6,r0
;;;237        memcpy(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
00004a  6861              LDR      r1,[r4,#4]
00004c  1948              ADDS     r0,r1,r5
00004e  4632              MOV      r2,r6
000050  9903              LDR      r1,[sp,#0xc]
000052  f7fffffe          BL       __aeabi_memcpy
;;;238        NumBytesWritten += NumBytesToWrite;
000056  9801              LDR      r0,[sp,#4]
000058  1980              ADDS     r0,r0,r6
00005a  9001              STR      r0,[sp,#4]
;;;239        pBuffer         += NumBytesToWrite;
00005c  9803              LDR      r0,[sp,#0xc]
00005e  1980              ADDS     r0,r0,r6
000060  9003              STR      r0,[sp,#0xc]
;;;240        NumBytes        -= NumBytesToWrite;
000062  1bbf              SUBS     r7,r7,r6
;;;241        WrOff           += NumBytesToWrite;
000064  19ad              ADDS     r5,r5,r6
;;;242        if (WrOff == pRing->SizeOfBuffer) {
000066  68a0              LDR      r0,[r4,#8]
000068  42a8              CMP      r0,r5
00006a  d100              BNE      |L21.110|
;;;243          WrOff = 0u;
00006c  2500              MOVS     r5,#0
                  |L21.110|
;;;244        }
;;;245        pRing->WrOff = WrOff;
00006e  60e5              STR      r5,[r4,#0xc]
;;;246      } while (NumBytes);
000070  2f00              CMP      r7,#0
000072  d1cd              BNE      |L21.16|
;;;247      //
;;;248      return NumBytesWritten;
000074  9801              LDR      r0,[sp,#4]
;;;249    }
000076  b005              ADD      sp,sp,#0x14
000078  bdf0              POP      {r4-r7,pc}
;;;250    
                          ENDP


                          AREA ||i._WriteNoCheck||, CODE, READONLY, ALIGN=1

                  _WriteNoCheck PROC
;;;268    */
;;;269    static void _WriteNoCheck(SEGGER_RTT_RING_BUFFER *pRing, const char* pData, unsigned NumBytes) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;270      unsigned NumBytesAtOnce;
;;;271      unsigned WrOff;
;;;272      unsigned Rem;
;;;273    
;;;274      WrOff = pRing->WrOff;
000008  68e6              LDR      r6,[r4,#0xc]
;;;275      Rem = pRing->SizeOfBuffer - WrOff;
00000a  68a0              LDR      r0,[r4,#8]
00000c  1b87              SUBS     r7,r0,r6
;;;276      if (Rem > NumBytes) {
00000e  42af              CMP      r7,r5
000010  d908              BLS      |L22.36|
;;;277        //
;;;278        // All data fits before wrap around
;;;279        //
;;;280        memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
000012  6861              LDR      r1,[r4,#4]
000014  1988              ADDS     r0,r1,r6
000016  462a              MOV      r2,r5
000018  9903              LDR      r1,[sp,#0xc]
00001a  f7fffffe          BL       __aeabi_memcpy
;;;281        pRing->WrOff = WrOff + NumBytes;
00001e  1970              ADDS     r0,r6,r5
000020  60e0              STR      r0,[r4,#0xc]
000022  e010              B        |L22.70|
                  |L22.36|
;;;282      } else {
;;;283        //
;;;284        // We reach the end of the buffer, so need to wrap around
;;;285        //
;;;286        NumBytesAtOnce = Rem;
000024  9701              STR      r7,[sp,#4]
;;;287        memcpy(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
000026  6861              LDR      r1,[r4,#4]
000028  1988              ADDS     r0,r1,r6
00002a  9a01              LDR      r2,[sp,#4]
00002c  9903              LDR      r1,[sp,#0xc]
00002e  f7fffffe          BL       __aeabi_memcpy
;;;288        NumBytesAtOnce = NumBytes - Rem;
000032  1be8              SUBS     r0,r5,r7
000034  9001              STR      r0,[sp,#4]
;;;289        memcpy(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
000036  9a03              LDR      r2,[sp,#0xc]
000038  19d1              ADDS     r1,r2,r7
00003a  6860              LDR      r0,[r4,#4]
00003c  9a01              LDR      r2,[sp,#4]
00003e  f7fffffe          BL       __aeabi_memcpy
;;;290        pRing->WrOff = NumBytesAtOnce;
000042  9801              LDR      r0,[sp,#4]
000044  60e0              STR      r0,[r4,#0xc]
                  |L22.70|
;;;291      }
;;;292    }
000046  b005              ADD      sp,sp,#0x14
000048  bdf0              POP      {r4-r7,pc}
;;;293    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  _acUpBuffer
                          %        64
                  _acDownBuffer
                          %        16
                  _SEGGER_RTT
                          %        120

                          AREA ||.data||, DATA, ALIGN=0

                  _aTerminalId
000000  30313233          DCB      0x30,0x31,0x32,0x33
000004  34353637          DCB      0x34,0x35,0x36,0x37
000008  38394142          DCB      0x38,0x39,0x41,0x42
00000c  43444546          DCB      0x43,0x44,0x45,0x46
                  _ActiveTerminal
000010  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\..\\..\\external\\segger_rtt\\SEGGER_RTT.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_SEGGER_RTT_c_c0f1166c____REV16|
#line 129 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\4.2.0\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_SEGGER_RTT_c_c0f1166c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_SEGGER_RTT_c_c0f1166c____REVSH|
#line 144
|__asm___12_SEGGER_RTT_c_c0f1166c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
